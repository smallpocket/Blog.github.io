<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    search: {
      root: '/',
      path: 'search.xml'
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="RabbitMQRabbitMQ是一个消息代理。它的核心思想非常简单：接收并转发消息。你可以把它想象成一个邮局：当你把邮件丢进邮箱时，你非常确定邮递员先生会把它送到收件人手中。在这个比喻中，RabbitMQ就是邮箱、邮局和邮递员。 概述是什么RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、">
<meta name="keywords" content="消息队列">
<meta property="og:type" content="article">
<meta property="og:title" content="消息队列：RabbitMQ概述">
<meta property="og:url" content="http://yoursite.com/2018/10/02/系统架构/消息队列：RabbitMQ概述/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="RabbitMQRabbitMQ是一个消息代理。它的核心思想非常简单：接收并转发消息。你可以把它想象成一个邮局：当你把邮件丢进邮箱时，你非常确定邮递员先生会把它送到收件人手中。在这个比喻中，RabbitMQ就是邮箱、邮局和邮递员。 概述是什么RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/assets/bd2e7e5edbadb274871b5891ee5a786d">
<meta property="og:image" content="http://yoursite.com/assets/rabbitMq_direct.png">
<meta property="og:image" content="http://yoursite.com/assets/1567950699481.png">
<meta property="og:image" content="http://yoursite.com/assets/1567944190719.png">
<meta property="og:image" content="http://yoursite.com/assets/1567956900902.png">
<meta property="og:image" content="http://yoursite.com/assets/1567957371388.png">
<meta property="og:updated_time" content="2019-09-24T03:34:56.345Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="消息队列：RabbitMQ概述">
<meta name="twitter:description" content="RabbitMQRabbitMQ是一个消息代理。它的核心思想非常简单：接收并转发消息。你可以把它想象成一个邮局：当你把邮件丢进邮箱时，你非常确定邮递员先生会把它送到收件人手中。在这个比喻中，RabbitMQ就是邮箱、邮局和邮递员。 概述是什么RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、">
<meta name="twitter:image" content="http://yoursite.com/assets/bd2e7e5edbadb274871b5891ee5a786d">
  <link rel="canonical" href="http://yoursite.com/2018/10/02/系统架构/消息队列：RabbitMQ概述/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>消息队列：RabbitMQ概述 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-top">
      
    

    <a href="/top/" rel="section"><i class="menu-item-icon fa fa-fw fa-signal"></i> <br>阅读排行</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>

</div>
    </header>

    

  <a href="https://github.com/smallpocket" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/02/系统架构/消息队列：RabbitMQ概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">消息队列：RabbitMQ概述

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-02 23:19:03" itemprop="dateCreated datePublished" datetime="2018-10-02T23:19:03+08:00">2018-10-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-24 11:34:56" itemprop="dateModified" datetime="2019-09-24T11:34:56+08:00">2019-09-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">11k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">20 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>RabbitMQ是一个消息代理。它的核心思想非常简单：接收并转发消息。你可以把它想象成一个邮局：当你把邮件丢进邮箱时，你非常确定邮递员先生会把它送到收件人手中。在这个比喻中，RabbitMQ就是邮箱、邮局和邮递员。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量还在其次。</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/assets/bd2e7e5edbadb274871b5891ee5a786d" alt="img"></p>
<p>通常我们谈到队列服务, 会有三个概念：发消息者、队列、收消息者，RabbitMQ在这个基本概念之上，多做了一层抽象，在发消息者和队列之间，加入了交换器 (Exchange)。这样发消息者和队列就没有直接联系，转而变成发消息者把消息给交换器，交换器根据调度策略再把消息再给队列。</p>
<p>上图中有几个重要概念：</p>
<ul>
<li>Broker：简单来说就是消息队列服务器实体。</li>
<li><strong>Producer</strong>：消息生产者，就是投递消息的程序。</li>
<li><strong>Consumer</strong>：消息消费者，就是接受消息的程序。</li>
<li><strong>Exchange</strong>：消息交换机，它指定消息按什么规则，路由到哪个队列。<ul>
<li><em>Exchange用于转发消息，但是它不会做存储</em> ，如果没有Queue bind到Exchange的话，它会直接丢弃掉Producer发送过来的消息。 </li>
</ul>
</li>
<li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li>
<li>Binding：绑定，它的作用就是把Exchange和Queue按照路由规则绑定起来。<ul>
<li>也就是交换机需要和队列相绑定，这其中如上图所示，是多对多的关系。</li>
</ul>
</li>
<li>Routing Key：路由关键字，Exchange根据这个关键字进行消息投递。<ul>
<li>消息到交换机的时候，交互机会转发到对应的队列中，那么究竟转发到哪个队列，就要根据该路由键。</li>
</ul>
</li>
<li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。<ul>
<li>一个虚拟主机持有一组交换机、队列和绑定。为什么需要多个虚拟主机呢？很简单， RabbitMQ 当中，<em>用户只能在虚拟主机的粒度进行权限控制。</em> 因此，如果需要禁止A组访问B组的交换机/队列/绑定，必须为A和B分别创建一个虚拟主机。每一个 RabbitMQ 服务器都有一个默认的虚拟主机“/”。</li>
</ul>
</li>
<li>channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</li>
</ul>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>消息中间件的服务节点。一个Broker可以简单看作一个RabbitMQ服务节点或RabbitMQ服务实例。</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>消息的生产者。生产者创建消息，然后发布到RabbitMQ当中，消息一般可以包含2个部分：消息体(payload)和标签(label)。</p>
<ul>
<li>payload。一般是一个带有业务逻辑结构的数据，例如一个JSON字符串。</li>
<li>label。用于表述这条消息，例如一个交换器名称和一个路由键，RabbitMQ根据标签将消息发送到感兴趣的Consumer。</li>
</ul>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消费者即接收消息的一方，消费者连接到RabbitMQ服务器，并订阅到队列上，当消费者消费一条消息时，只是消费消息的消息体。</p>
<p>在消息路由的过程中，消息的标签被丢弃，存入到队列中的消息只有消息体，消费者也只会消费消息体，即不知道消息的生产者是谁。</p>
<h3 id="Exchange、Routing-Key、Binding"><a href="#Exchange、Routing-Key、Binding" class="headerlink" title="Exchange、Routing Key、Binding"></a>Exchange、Routing Key、Binding</h3><p><strong><em>Exchange</em></strong>：当生产者期望将消息投递到队列中，消息首先会被发送到Exchange当中，由交换器将消息路由到一个或多个队列中，如果路由不到，则可能返回给生产者或丢弃。</p>
<p>交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，在启用ack模式后，交换机找不到队列会返回错误。</p>
<p><strong><em>Exchange 参数</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">	String type,<span class="keyword">boolean</span> durable,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> autoDelete,<span class="keyword">boolean</span> internal,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String,Object&gt; arguments)</span><span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>exchange：交换器名称。</li>
<li>type：Exchange Type。</li>
<li>durable：是否持久化，持久化可将交换器存盘，在服务器重启时也不会丢失相关信息。</li>
<li>autoDelete：是否自动删除的，自动删除的前提是至少有应该队列或者交换器与该交换器绑定，之后所有与这个交换器绑定的都与该交换器解绑。</li>
<li>internal：是否内置的，对于内置的交换器，客户端无法直接发送消息到这个交换器中。</li>
<li>argument：其他的一些结构化的参数。</li>
</ul>
<p>有其他重载的方法例如<code>exchangeDeclareNoWait()</code>方法多设置了一个nowait参数，指不需要服务器返回。而常规方法在声明交换器后需要等待服务器返回Exchange.Declare-Ok。</p>
<p><strong><em>Routing Key</em></strong>：路由键，生产者将消息发送到Exchange时，一般会指定一个Routing Key，用于指定消息的路由规则。Routing Key需要与Exchange Type和Binding联合使用才有效。</p>
<p><strong><em>Binding</em></strong>：绑定，RabbitMQ通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ就知道如何正确地将消息路由到队列中。</p>
<p><strong><em>Exchange Bind参数</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">BindOk <span class="title">exchangeBind</span><span class="params">(String destination, String source, String routingKey)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>Exchange Type</em></strong></p>
<p>交换机有四种类型：Direct，Topic，Headers and Fanout：</p>
<ul>
<li>Direct：direct类型的行为是”先匹配，再投送”。即在绑定时设定一个<strong>routing key</strong>， 消息的<strong>routing key</strong>匹配时, 才会被交换器投送到绑定的队列中去。</li>
<li>Topic：按规则转发消息（最灵活）。</li>
<li>Headers：设置header attribute参数类型的交换机。</li>
<li>Fanout：转发消息到所有绑定队列。</li>
</ul>
<p><strong>Direct Exchange</strong></p>
<p>Direct Exchange是RabbitMQ默认的交换机模式，也是最简单的模式，根据key全文匹配去寻找队列。</p>
<p><img src="/assets/rabbitMq_direct.png" alt="img"></p>
<p>第一个X - Q1就有一个binding key，名字为orange；X - Q2就有2个binding key，名字为black和green。<em>当消息中的routing Key和这个binding key对应上的时候，那么就知道了该消息去到哪一个队列中。</em></p>
<p>Ps：为什么X到Q2要有black，green2个binding key呢，一个不就行了吗？</p>
<p>这个主要是因为可能又有Q3，而Q3只接受black的信息，而Q2不仅接受black的信息，还接受green的信息。</p>
<p><strong>Topic Exchange</strong></p>
<p><em>Topic Exchange 转发消息主要是根据通配符。</em>在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。</p>
<p>在这种交换机模式下：</p>
<ul>
<li>路由键必须是一串字符，用句号（<code>.</code>） 隔开，比如说agreements.us，或者 agreements.eu.stockholm等。</li>
<li>路由模式必须包含一个星号（<code>*</code>），主要用于匹配路由键指定位置的一个单词<ul>
<li>一个路由模式是这样子：agreements..b.*，那么就只能匹配路由键是这样子的：第一个单词是 agreements，第四个单词是 b。 </li>
</ul>
</li>
<li>井号（#）就表示相当于一个或者多个单词，例如一个匹配模式是 agreements.eu.berlin.#，那么，以agreements.eu.berlin开头的路由键都是可以的。</li>
</ul>
<p>具体代码发送的时候还是一样，第一个参数表示交换机，第二个参数表示routing key，第三个参数即消息。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(<span class="string">"testTopicExchange"</span>,<span class="string">"key1.a.c.key2"</span>, <span class="string">" this is  RabbitMQ!"</span>);</span><br></pre></td></tr></table></figure>

<p>topic和direct类似, 只是匹配上支持了”模式”, 在”点分”的routing key形式中，可以使用两个通配符：</p>
<ul>
<li><code>*</code>表示一个词。</li>
<li><code>#</code>表示零个或多个词。</li>
</ul>
<p><strong>Headers Exchange</strong></p>
<p>headers也是根据规则匹配，相较于direct和topic固定地使用routing key，headers则是一个自定义匹配规则的类型，在队列与交换器绑定时，会设定一组键值对规则，消息中也包括一组键值对(headers属性)，当这些键值对有一对，或全部匹配时，消息被投送到对应队列。</p>
<p><strong>Fanout Exchange</strong></p>
<p>Fanout Exchange消息广播的模式，不管路由键或者是路由模式，<em>会把消息发给绑定给它的全部队列</em>，如果配置了routing key会被忽略。</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue是RabbitMQ的内部对象，用于存储消息。RabbitMQ中<strong>消息都只能存储在队列中</strong>。</p>
<p>多个Consumer可以订阅同一个队列，这时队列中的消息会被平均分摊(轮询)给多个消费者处理，而不是每个消费者都收到所有的消息并处理。</p>
<p>RabbitMQ不支持队列层面的广播消费，如果需要则需要二次开发，并且处理逻辑会更加复杂。</p>
<p><strong><em>queueDeclare 参数</em></strong></p>
<ul>
<li>quque：队列的名称。</li>
<li>durable：是否持久化，持久化的队列会存盘。</li>
<li>exclusive：是否排他，若是则<strong>只对首次声明它的Connection可见</strong>，注意不是Channel，并在连接断开时自动删除。<ul>
<li>适用于一个客户端同时发送和读取消息的场景。</li>
</ul>
</li>
<li>autoDelete：是否自动删除的。</li>
<li>arguments：设置其他的一些参数。</li>
</ul>
<p><strong><em>queueBind 参数</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">BindOk <span class="title">queueBind</span><span class="params">(String queue,String exchange,String routingKey,Map&lt;String,Object&gt; arguments)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>queue。队列名称。</li>
<li>exchange。交换器名称</li>
<li>routingKey。用来绑定队列和交换器的路由键。</li>
<li>argument。定义绑定的一些参数。</li>
</ul>
<h3 id="Connection、Channel"><a href="#Connection、Channel" class="headerlink" title="Connection、Channel"></a>Connection、Channel</h3><p>Producer与Consumer都需要与Broker建立连接，即一个TCP连接，即Connection。</p>
<p>当TCP连接建立后，客户端紧接着可以创建一个AMQP Channel，每个Channel会被指派一个唯一ID，Channel是建立在Connection上的虚拟连接，RabbitMQ处理的每条AMQP指令都是通过Channel完成的。</p>
<p><img src="/assets/1567950699481.png" alt="1567950699481"></p>
<p><strong><em>Channel特点</em></strong></p>
<ul>
<li>Channel使用了NIO，对于单点，只需要建立一个TCP连接即可，减少了性能开销，便于管理。</li>
<li>Channel保证了每个线程的私密性，如同独立的连接一样，当Channel的流量不是很大时，可以有效节省TCP连接资源。</li>
<li>当Channel本身流量很大，此时使用一个Connection可能导致性能瓶颈，此时应该开辟多个Connection。</li>
<li>如果公用Channel，则可能导致网络上出现错误的通信帧交错，也会影响发送方Confirm机制的运行。即Channel非线程安全。</li>
</ul>
<p><strong><em>Channel模式</em></strong></p>
<p>一个Channel只能承接一个会话任务，因此一个Channel不能既负责消费又负责生产。</p>
<ul>
<li>传输模式：</li>
<li>订阅模式：</li>
</ul>
<h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>Producer将消息存入Broker，Consumer从Broker中消费数据的整个流程：</p>
<p><img src="/assets/1567944190719.png" alt="1567944190719"></p>
<ul>
<li>Producer将业务方数据进行包装，封装为消息，发送（在AMQP中是Basic.Publish）到Broker中。</li>
<li>Consumer订阅并接收消息(Basic.Consume或Basic.Get)，经过解包得到原始数据。</li>
<li>Consumer进行业务处理逻辑。</li>
</ul>
<h3 id="RabbitMQ运转流程"><a href="#RabbitMQ运转流程" class="headerlink" title="RabbitMQ运转流程"></a>RabbitMQ运转流程</h3><p>生产者发送消息：</p>
<ul>
<li>Producer连接到Broker，建立一个Connection，开启一个信道Channel。</li>
<li>Producer声明一个Exchange，并设置相关的属性，例如交换机类型、释放持久化等。</li>
<li>Producer声明一个Queue并设置相关属性，比如是否排他、是否持久化、是否自动删除等。</li>
<li>Producer通过路由键将交换器和队列绑定起来。</li>
<li>Producer发送消息至Broker，其中包含Routing Key、Exchange等信息。</li>
<li>相应的Exchange根据接收到的Routing Key查找相匹配的Queue。<ul>
<li>如果找到，则将从Producer发送过来的消息存入相应的Queue。</li>
<li>如果没有找到，则根据Producer配置的属性选择丢弃还是回退给Producer。</li>
</ul>
</li>
<li>关闭Channel。</li>
<li>关闭Connection。</li>
</ul>
<p>Consumer接收消息：</p>
<ul>
<li>Consumer连接到Broker，建立一个Connection，开启一个Channel。</li>
<li>Consumer向Broker请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作。</li>
<li>等待Broker回应并投递相应队列中的消息，Consumer接收消息。</li>
<li>Consumer ack接收到的消息。</li>
<li>RabbitMQ从队列中删除相应已经被确认的消息。</li>
<li>关闭Channel。</li>
<li>关闭Connection。</li>
</ul>
<h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可靠性：RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</li>
<li>灵活的路由：在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。</li>
<li>扩展性：多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>
<li>高可用性：队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li>
<li>多种协议：RabbitMQ除了原生支持AMQP协议，还支持STOMP，MQTT等多种消息中间件协议。</li>
<li>多语言客户端：RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript 等。</li>
<li>管理界面：RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。</li>
<li>插件机制: RabbitMQ提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。</li>
</ul>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="何时创建队列"><a href="#何时创建队列" class="headerlink" title="何时创建队列"></a>何时创建队列</h3><p>RabbitMQ当中队列是真正耗费服务器性能的地方，因此衡量RabbitMQ的QPS只需要看队列即可。实际应用中，需要对创建的队列的流量、内存占用、网卡占用有一个清晰的认知，预估其均值与峰值，以便在固定硬件资源的情况下能够进行合理的分配。</p>
<ul>
<li>生产者与消费者创建。即在使用队列时，生产者与消费者都应该尝试创建(声明操作)队列。</li>
<li>预创建队列。如果设计初已经充分预估了队列的使用情况，则完全可以在业务上线前预先在服务器上创建好。<ul>
<li>预创建资源可以确保交换器与队列间正确地绑定匹配。</li>
<li>预先创建可以对业务代码无干扰，方便迁移。</li>
</ul>
</li>
</ul>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange,String routingKey,<span class="keyword">boolean</span> mandatory,<span class="keyword">boolean</span> immediate,BasicProperties props,<span class="keyword">byte</span>[] body)</span><span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<ul>
<li>exchange：交换器的名称，指明消息需要发送到哪个交换器中。<ul>
<li>如果设置为空则消息会发送到RabbitMQ默认的交换器中。</li>
</ul>
</li>
<li>routingKey：路由键，交换器根据routingKey将消息存储到相应的队列中。</li>
<li>props：消息的基本属性集。<ul>
<li>contentType。</li>
<li>contentEncoding。</li>
<li>headers(Map&lt;String,Object&gt;)。</li>
<li>deliveryMode。</li>
<li>priority。</li>
<li>correlationId。</li>
<li>replyTo。</li>
<li>expiration。</li>
<li>messageId。</li>
<li>timestamp。</li>
<li>type。</li>
<li>userId。</li>
<li>appId。</li>
<li>clusterId。</li>
</ul>
</li>
<li>byte[] body：消息体。</li>
</ul>
<h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><p>消费消息有两种模式：</p>
<ul>
<li>推模式。Basic.Consume。<ul>
<li>适用于批量消费，数量限制于Basic.Qos。</li>
</ul>
</li>
<li>拉模式。Basic.Get。<ul>
<li>适用于单条消费。</li>
</ul>
</li>
</ul>
<p><strong><em>推模式</em></strong>，当调用与Consumer相关的API方法时，不同的订阅采用不同的consumerTag来区分彼此，同一个Channel中的消费者也需要通过唯一的consumerTag以作区分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">basicConsume</span><span class="params">(String queue,<span class="keyword">boolean</span> autoAck,String consumerTag,<span class="keyword">boolean</span> noLocal,<span class="keyword">boolean</span> exclusive,Map&lt;String,Object&gt; arguments,Consumer callback)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>queue：队列名称。</li>
<li>autoAck：设置是否自动确认。</li>
<li>consumerTag：消费者标签，用于区分多个消费者。</li>
<li>noLocal：设置为true则表示不能将同一个Connection中Producer发送的消息传送给这个Connection中的Consumer。</li>
<li>exclusive：设置是否排他。</li>
<li>arguments：设置消费者的其他参数。</li>
<li>callback：设置消费者的回调函数，用来处理RabbitMQ推送过来的消息。</li>
</ul>
<p>basic.Consume将Channel置为接收模式，直到取消队列的订阅为止，在接收模式中，MQ会不断推送消息给消费者，但是数量收到Basic.Qos限制。</p>
<p><strong><em>拉模式</em></strong>，通过channel.basicGet可以单条地获取消息，返回值是GetReponse。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GetReponse <span class="title">basicGet</span><span class="params">(String queue,<span class="keyword">boolean</span> autoAck)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<ul>
<li>queue：队列名称。</li>
<li>autoAck：是否自动确认。</li>
</ul>
<h1 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h1><p>AMQP解决了什么问题，或者说它的应用场景是什么？</p>
<p>对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如：</p>
<ol>
<li>信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何方式丢失？</li>
<li>如何降低发送者和接收者的耦合度？</li>
<li>如何让Priority高的接收者先接到数据？</li>
<li>如何做到load balance？有效均衡接收者的负载？</li>
<li>如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。</li>
<li>如何做到可扩展，甚至将这个通信模块发到cluster上？</li>
<li>如何保证接收者接收到了完整，正确的数据？</li>
</ol>
<p>AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>AMQP协议本身包括三层：</p>
<ul>
<li>Module Layer：位于协议最高层，主要定义了一些供客户端调用的命令，客户端可以利用这些命令实现自己的业务逻辑。<ul>
<li>例如Basic.Consume，Queue.Declare。</li>
</ul>
</li>
<li>Session Layer：位于中间层，主要负责将客户端的命令发送给服务器，再将服务器的应答返回给客户端，主要为客户端与服务器间的通信提供可靠性同步机制和错误处理。</li>
<li>Transport Layer：位于最底层，主要传输二进制数据流，提供帧的处理、信道复用、错误监测和数据表示等。</li>
</ul>
<p>从计算机网络方面，AMQP是应用层协议，其填充TCP协议的数据部分。</p>
<p>AMQP通过协议命令进行交互的，AMQP协议可以看作一系列结构化命令的集合。可类比HTTP方法，如GET、POST。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table>
<thead>
<tr>
<th>名称</th>
<th>内容体</th>
<th>客户端方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Connection.Start</td>
<td>无</td>
<td>factory.newConnection</td>
<td>建立连接相关</td>
</tr>
<tr>
<td>Connection.Close</td>
<td>无</td>
<td>connection.close</td>
<td>关闭连接</td>
</tr>
<tr>
<td>Channel.Open</td>
<td>无</td>
<td>connection.openChannel</td>
<td>开启信道</td>
</tr>
<tr>
<td>Channel.Close</td>
<td>无</td>
<td>channel.close</td>
<td>关闭信道</td>
</tr>
<tr>
<td>Exchange.Declare</td>
<td>无</td>
<td>channel.exchangeDeclare</td>
<td>声明交换器</td>
</tr>
<tr>
<td>Exchange.Delete</td>
<td>无</td>
<td></td>
<td>删除交换器</td>
</tr>
<tr>
<td>Exchange.Bind</td>
<td>无</td>
<td></td>
<td>交换器与交换器绑定</td>
</tr>
<tr>
<td>Exchange.UnBind</td>
<td>无</td>
<td></td>
<td>交换器与交换器解绑</td>
</tr>
<tr>
<td>Queue.Declare</td>
<td>无</td>
<td></td>
<td>声明队列</td>
</tr>
<tr>
<td>Queue.Bind</td>
<td>无</td>
<td></td>
<td>队列与交换器绑定</td>
</tr>
<tr>
<td>Queue.Purge</td>
<td>无</td>
<td></td>
<td>清除队列中的内容</td>
</tr>
<tr>
<td>Queue.Delete</td>
<td>无</td>
<td></td>
<td>删除队列</td>
</tr>
<tr>
<td>Queue.Unbind</td>
<td>无</td>
<td></td>
<td>队列与交换器解绑</td>
</tr>
<tr>
<td>Basic.Qos</td>
<td>无</td>
<td></td>
<td>设置未被确认消费的个数</td>
</tr>
<tr>
<td>Basic.Consume</td>
<td>无</td>
<td></td>
<td>消费消息，推模式</td>
</tr>
<tr>
<td>Basic.Cancel</td>
<td>无</td>
<td></td>
<td>取消</td>
</tr>
<tr>
<td>Basic.Publish</td>
<td>有</td>
<td></td>
<td>发送消息</td>
</tr>
<tr>
<td>Basic.Return</td>
<td>是</td>
<td></td>
<td>未能成功路由的消息返回</td>
</tr>
<tr>
<td>Basic.Deliver</td>
<td>是</td>
<td></td>
<td>Broker推送消息模式</td>
</tr>
<tr>
<td>Basic.Get</td>
<td>无</td>
<td></td>
<td>消费消息，拉模式</td>
</tr>
<tr>
<td>Basic.Ack</td>
<td>无</td>
<td></td>
<td>确认</td>
</tr>
<tr>
<td>Basic.Reject</td>
<td>无</td>
<td></td>
<td>单条拒绝</td>
</tr>
<tr>
<td>Basic.Recover</td>
<td>无</td>
<td></td>
<td>请求Broker重新发送未被确认的消息</td>
</tr>
<tr>
<td>Basic.Nack</td>
<td>无</td>
<td></td>
<td>拒绝，可批量化</td>
</tr>
<tr>
<td>Tx.Select</td>
<td>无</td>
<td></td>
<td>事务开启</td>
</tr>
<tr>
<td>Tx.Commit</td>
<td>无</td>
<td></td>
<td>事务提交</td>
</tr>
<tr>
<td>Tx.Rollback</td>
<td>无</td>
<td></td>
<td>事务回滚</td>
</tr>
<tr>
<td>Confirm.Select</td>
<td>无</td>
<td></td>
<td>开启发送端确认模式</td>
</tr>
</tbody></table>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><h3 id="AMQP-Producer流转过程"><a href="#AMQP-Producer流转过程" class="headerlink" title="AMQP Producer流转过程"></a>AMQP Producer流转过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = factory .newConnection() ; <span class="comment">//创建连接 </span></span><br><span class="line">Channel channel = connection.createChannel() ; <span class="comment">//创建信道 </span></span><br><span class="line">String message = <span class="string">"Hello World! "</span>; </span><br><span class="line">channel.basicPublish(EXCHANGE NAME , ROUTING KEY , 			</span><br><span class="line">		MessageProperties.PERSISTENT_TEXT_PLAIN, </span><br><span class="line">                     message.getBytes());</span><br><span class="line">        <span class="comment">//关闭资源 </span></span><br><span class="line">channel.close() ; </span><br><span class="line">connection .close();</span><br></pre></td></tr></table></figure>

<ul>
<li>当客户端希望与Broker建立连接时，会调用<code>factory .newConnection()</code>，方法会进一步封装未Protocol Header 0-9-1的报文头发送给Broker，以通知Broker本次交互采用的时AMQP 0-9-1协议。</li>
<li>客户端调用<code>connection.createChannel()</code>，其包装<code>Channel.Open</code>命令发送给Broker，等待<code>Channel.Open-Ok</code>。</li>
<li>客户端发送消息需要调用<code>channel.basicPublish()</code>，对应<code>Basic.Pubilsh</code>，命令内部包含Content Header和Content Body。<ul>
<li>Content Header包含消息体的属性，例如投递模式、优先级等。</li>
</ul>
</li>
<li>客户端关闭资源。</li>
</ul>
<p><img src="/assets/1567956900902.png" alt="1567956900902"></p>
<h3 id="AMQP-Consumer流转过程"><a href="#AMQP-Consumer流转过程" class="headerlink" title="AMQP Consumer流转过程"></a>AMQP Consumer流转过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = factory.newConnection(addresses);<span class="comment">//创建连接 </span></span><br><span class="line"><span class="keyword">final</span> Channel channel = connection.createChannel() ; <span class="comment">//创建信道 </span></span><br><span class="line">Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) ();<span class="comment">//_省略实现 </span></span><br><span class="line">channel .basicQos(<span class="number">64</span>) ; </span><br><span class="line">channel.basicConsume(QUEUE NAME , consumer) ; <span class="comment">//等待回调函数执行完毕之后，关闭资源 </span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>) ;</span><br><span class="line">channel.close(); </span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>

<ul>
<li>如果在消费前调用了<code>channel.basicQos(int prefetchCount)</code>设置消费者客户端最大能<strong>保持</strong>的未确认消息数，则会涉及<code>Basic.Qos</code>等命令。</li>
<li>当真正消费前，客户端需要向Broker发送<code>Basic.Consume</code>将Channel设置未接收模式。</li>
<li>Broker回执<code>Basic.Consume-Ok</code>告诉Consumer准备好消费消息。</li>
<li>Broker向Consumer Push消息，即<code>Basic.Deliver</code>，该消息会携带Content Header与Content Body。</li>
<li>消费者接收到消息并正确消费后，向Broker发送确认，即<code>Basic.Ack</code>。</li>
<li>停止消费，关闭连接。</li>
</ul>
<p><img src="/assets/1567957371388.png" alt="1567957371388"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">RabbitMQ教程</a></li>
<li><a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">消费者致谢和生产者确认</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/消息队列/" rel="tag"># 消息队列</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2018/09/30/Java/框架/安全框架：shiro-登录认证和权限管理/" rel="next" title="安全框架：整合shiro-登录认证和权限管理">
                <i class="fa fa-chevron-left"></i> 安全框架：整合shiro-登录认证和权限管理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2018/10/02/系统架构/消息队列：概述/" rel="prev" title="消息队列：概述">
                消息队列：概述 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">209</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RabbitMQ"><span class="nav-number">1.</span> <span class="nav-text">RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#是什么"><span class="nav-number">1.1.1.</span> <span class="nav-text">是什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用"><span class="nav-number">1.2.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#适用性"><span class="nav-number">1.2.1.</span> <span class="nav-text">适用性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">1.3.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Broker"><span class="nav-number">1.3.1.</span> <span class="nav-text">Broker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Producer"><span class="nav-number">1.3.2.</span> <span class="nav-text">Producer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumer"><span class="nav-number">1.3.3.</span> <span class="nav-text">Consumer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchange、Routing-Key、Binding"><span class="nav-number">1.3.4.</span> <span class="nav-text">Exchange、Routing Key、Binding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue"><span class="nav-number">1.3.5.</span> <span class="nav-text">Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Connection、Channel"><span class="nav-number">1.3.6.</span> <span class="nav-text">Connection、Channel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协作"><span class="nav-number">1.4.</span> <span class="nav-text">协作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RabbitMQ运转流程"><span class="nav-number">1.4.1.</span> <span class="nav-text">RabbitMQ运转流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#权衡"><span class="nav-number">1.5.</span> <span class="nav-text">权衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优点"><span class="nav-number">1.5.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺陷"><span class="nav-number">1.5.2.</span> <span class="nav-text">缺陷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现"><span class="nav-number">1.6.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#何时创建队列"><span class="nav-number">1.6.1.</span> <span class="nav-text">何时创建队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送消息"><span class="nav-number">1.6.2.</span> <span class="nav-text">发送消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消费消息"><span class="nav-number">1.6.3.</span> <span class="nav-text">消费消息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AMQP"><span class="nav-number">2.</span> <span class="nav-text">AMQP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-1"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命令"><span class="nav-number">2.1.1.</span> <span class="nav-text">命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现-1"><span class="nav-number">2.2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AMQP-Producer流转过程"><span class="nav-number">2.2.1.</span> <span class="nav-text">AMQP Producer流转过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AMQP-Consumer流转过程"><span class="nav-number">2.2.2.</span> <span class="nav-text">AMQP Consumer流转过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">3.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">1.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">40:45</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        




  <script>
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=66458302";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  























  <script src="/js/local-search.js?v=7.2.0"></script>














</body>
</html>
