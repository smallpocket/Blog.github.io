<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    search: {
      root: '/',
      path: 'search.xml'
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="线程安全概念 线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。  即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这">
<meta name="keywords" content="并发编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发：线程安全-理论">
<meta property="og:url" content="http://yoursite.com/2019/03/01/Java/base/Java并发：线程安全-理论/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="线程安全概念 线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。  即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/assets/1565054929055.png">
<meta property="og:updated_time" content="2019-08-06T01:30:59.167Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发：线程安全-理论">
<meta name="twitter:description" content="线程安全概念 线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。  即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这">
<meta name="twitter:image" content="http://yoursite.com/assets/1565054929055.png">
  <link rel="canonical" href="http://yoursite.com/2019/03/01/Java/base/Java并发：线程安全-理论/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java并发：线程安全-理论 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-top">
      
    

    <a href="/top/" rel="section"><i class="menu-item-icon fa fa-fw fa-signal"></i> <br>阅读排行</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>

</div>
    </header>

    

  <a href="https://github.com/smallpocket" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Java/base/Java并发：线程安全-理论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">Java并发：线程安全-理论

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-01 15:42:55" itemprop="dateCreated datePublished" datetime="2019-03-01T15:42:55+08:00">2019-03-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-06 09:30:59" itemprop="dateModified" datetime="2019-08-06T09:30:59+08:00">2019-08-06</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">20k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">58 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="线程安全概念"><a href="#线程安全概念" class="headerlink" title="线程安全概念"></a>线程安全概念</h1><blockquote>
<p>线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作， <strong>调用这个对象的行为</strong>都可以获得正确的结果，那这个对象是线程安全的。</p>
</blockquote>
<p>即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这个并不容易做到。</p>
<p>因此一般将定义弱化一些,即将调用这个对象的行为限定为<strong>单次调用</strong>，若其他描述成立，则称它线程安全。</p>
<p>在一项工作进行前，会被不停中断与切换，对象的属性可能会在中断期间被修改和变脏。如何保证程序在计算机中准确无误地运行。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>编写线程安全的代码，本质上就是管理对<strong>状态</strong>的访问，而且通常都是<strong>共享、可变</strong>的状态。</p>
<p>一个对象的状态就是它的数据，存储在状态变量中，如静态域、实例域。共享即一个变量可以被多个线程访问。可变即变量的值在其生命周期内都可以改变。真正要做到的线程安全是在不可控制的并发访问当中保护数据。</p>
<p>无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。</p>
<p>java的锁机制：synchronized(独占锁)，volatile、显示锁和原子变量的使用</p>
<p>修复同步隐患</p>
<ul>
<li>不跨线程的共享变量</li>
<li>使用状态变量为不可变的</li>
<li>在任何访问状态变量的时候使用同步</li>
</ul>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>当我们在一个无状态对象中增加一个状态时，例如增加一个命中计数器count++来统计所处理的请求数量。</p>
<p>但是在多线程下，这种自增操作可能会丢失一些更新操作，该语句会转换为多个字节码指令，包含3个独立的操作：读取、修改、写入。其结果状态依赖于之前的状态，即这三个操作并不能作为一个原子操作。</p>
<p>而多线程在没有同步的情况下对一个count进行操作，如果初始值为0，则可能会出现每个线程读取得到的指都时0，之后进行递增操作，并将计数器的值设为1，之后写入。在这个过程中丢失了一次更改。</p>
<p>在Web服务中，命中计数器的少量偏差是我们可以接受的， 但是如果我们是在生成唯一的对象标识符，那么将导致严重的问题。</p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><blockquote>
<p>竞态条件：由于不恰当的执行时序而出现不正确的结果，即结果的出现依赖于线程的执行顺序</p>
</blockquote>
<p>当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件。即正确的结果依赖于运气</p>
<p><strong><em>常见场景</em></strong></p>
<ul>
<li>先检查后执行，即检查-修改。然鹅在检查-修改的中间时间，观察结果可能会失效，从而导致各种问题<ul>
<li>延迟初始化，确保只初始化一次。在多线程下可能会初始多次。</li>
</ul>
</li>
</ul>
<p>竞态条件并不总是产生错误，需要某种不恰当的执行时序。</p>
<h3 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h3><blockquote>
<p>数据竞争：如果在访问共享的非final类型的域时没有采用同步来进行协同，那么就会出现数据竞争。当一个线程写入一个变量而另一个线程接下来读取这个变量，或者读取一个之前由另一个线程写入的变量时，并且在这两个线程间没有使用同步，就可能会出现数据竞争。</p>
<p>如果代码存在数据竞争，那么这段代码就没有确定的语义</p>
</blockquote>
<p>并非所有的竞态条件都是数据竞争，也并非所有的数据竞争都是竞态条件，但二者都可能导致并非程序失败。</p>
<h3 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h3><p>要避免竞态条件，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。</p>
<blockquote>
<p><strong>原子操作</strong>：假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说就是原子的。</p>
<p>原子操作是指，对于访问同一个状态的所有操作(包括操作本身)来说，这个操作是一个以原子方式执行的操作。</p>
</blockquote>
<h2 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h2><p>当在Servlet中添加了一个状态变量，可以通过线程安全的对象来管理Servlet的状态来维护其线程安全性，但是当想在Servlet添加更多的状态，是否只需要增加更多的线程安全状态变量就可以了。</p>
<p>然而尽管两个状态变量都是安全的，但是对两个安全的状态变量进行操作并不一定是安全的，即它们独立的操作都是原子的，而对它们两个的操作是两个原子操作，在两次操作间存在空隙，因此不是一个原子操作，而存在竞态条件。</p>
<blockquote>
<p>要保证状态的一致性，就需要在单个原子操作中更新所有相关的状态变量</p>
</blockquote>
<h3 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h3><p>Java提供了一种内置的锁机制来支持原子性，即同步代码块<code>synchronized</code>，同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。之所以内置锁只是为了免去显式创建锁对象，</p>
<p>以synchronized修饰的方法是一种横跨整个方法体的同步代码块，锁就是方法调用所在的对象。静态的synchronized以Class对象为锁。</p>
<p>每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁或监视器锁(Monitor)。获得内置锁的唯一途径就是进入由整个锁保护的同步代码块或方法。</p>
<p>而内置锁的存在使得线程安全变得简单，但是却过于极端，导致服务的响应性会很低，即一个性能问题。</p>
<h3 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h3><p>当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞，然而由于内置锁可重入，即当某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。</p>
<p>重入意味着锁的操作粒度是线程，而不是调用。重入的一种实现是为每个锁关联一个获取计数值和一个所有者线程，当计数值为0时，这个锁被认为是没有被任何线程持有，当线程请求一个未被持有的锁时，JVM记录锁的持有者，并将计数器+1。</p>
<p>重入使得子类如果重写了父类的<code>synchronized</code>方法，之后调用父类的方法不会产生死锁。</p>
<p><strong><em>理解</em></strong>：父类的方法与子类本身的方法都是在子类的方法表当中，即这些方法归属于同一个类，同一个对象，而不是说有两个对象。因此在调用子类的synchronized方法时首先获得了该对象的锁，此时调用父类的方法，如果不是可重入的，则因为该对象的锁已经被获取而发生死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">log</span> <span class="keyword">extends</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">do</span>();</span><br><span class="line">    &#125;	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为两个do都时<code>synchronized</code>的，因此每个方法都会在执行前获取Widget的锁，如果不可重入，则当调用<code>super.do</code>时会阻塞。而重入避免了该情况</p>
<h2 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h2><p>锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问，只要始终遵循这些协议就能保持状态的一致性。</p>
<p>访问共享状态的复合操作都必须是原子操作以避免产生竞态条件，如果在复合操作中持有一个锁，则会使得复合操作称为原子操作。仅仅将复合操作封装到一个同步代码块中是不够的，如果使用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。</p>
<p>常见的<strong>错误</strong>是只有在写入共享变量时才需要使用同步。</p>
<blockquote>
<p>对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，这种情况下我们称状态变量是由这个锁保护的。</p>
</blockquote>
<blockquote>
<p>每个共享的和可变的变量都应该只有一个锁来保护，从而使维护人员知道是哪一个锁</p>
</blockquote>
<p>一种常见的加锁约定是将所有的可变状态都封装在对象内部，帮通过对象的内置锁对所有访问可边状态的代码路径进行同步，使得在该对象上不会发生并发访问。但是这种模式不会得到强制，即如果在添加新的方法时忘记使用了同步，则加锁协议就被破坏了。</p>
<blockquote>
<p>对于包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护</p>
</blockquote>
<h2 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h2><p>对于Servlet，如果通过Servlet对象的内置锁保护每一个状态变量，即对整个service方法进行同步，这种简单且粗粒度的方法能确保线程安全性，但是代价很高。service如果同步了，则每次只能有应该线程可以执行，背离了Servlet的初衷，即需要能同时处理多个请求，在负载过高的情况下将给用户带来糟糕的体验。</p>
<p><strong>不良并发应用程序</strong>：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。</p>
<p>通过缩小同步代码块的作用范围可以很容易做到既确保Servlet的并发性，同时又维护线程安全性。要确保同步代码块不要过小，并且不要将本应时原子的操作拆分到多个同步代码块中，<strong>应</strong>尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。</p>
<p>应当在程序中使用一种同步机制，两种不同的同步机制会带来混乱，并且不会在性能或安全性上带来任何好处，例如在<code>synchronized</code>中使用<code>Atomic</code>。</p>
<p><strong><em>判断同步代码块的合理大小</em></strong>。需要权衡安全性、简单性、性能。</p>
<blockquote>
<p>通常，在简单性和性能间存在相互制约因素。当实现某个同步策略时，一定不要盲目地未了性能而牺牲简单性(可能会破坏安全性)</p>
</blockquote>
<p>当使用锁时，应当清楚代码块中实现地功能，以及在执行该代码块时是否需要很长时间。如果需要，则都会带来活跃性或性能问题。</p>
<blockquote>
<p>当执行时间较长地计算或者可能无法快速完成地操作时，例如网络IO或IO，一定不要持有锁。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>编写线程安全的代码，本质上就是管理对<strong>状态</strong>的访问，而且通常都是<strong>共享、可变</strong>的状态。<ul>
<li><strong>动机</strong>：无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。<ul>
<li>要保证状态的一致性，就需要在单个原子操作中更新所有相关的状态变量</li>
<li>并不仅仅是只需要在写入的时候需要同步</li>
<li>每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁(封装在对象中)</li>
</ul>
</li>
</ul>
</li>
<li>同步将使得性能降低。判断同步代码块地合理大小<ul>
<li>当执行时间较长地计算或者可能无法快速完成地操作时，例如网络IO或IO，一定不要持有锁。</li>
</ul>
</li>
<li>加锁的机制不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</li>
</ul>
<h1 id="实现线程安全"><a href="#实现线程安全" class="headerlink" title="实现线程安全"></a>实现线程安全</h1><p>实现线程安全有两种方式：</p>
<ul>
<li>对象的共享。需要自己去设计线程安全的类</li>
<li>对象的组合。通过将对象的线程安全委托给其他类</li>
</ul>
<h1 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h1><p>如何共享和发布对象，从而使它们能够安全地由多个线程同时访问。并且实现内存可见性。</p>
<blockquote>
<p>内存可见性：希望确保当一个线程修改了对象状态后，其他线程能够看到发生地状态变化。</p>
</blockquote>
<h2 id="线程安全级别"><a href="#线程安全级别" class="headerlink" title="线程安全级别"></a>线程安全级别</h2><p>线程安全限定于多个线程间存在共享数据访问这个前提，如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度看，程序是串行执行还是多线程执行对它没有区别</p>
<p>依照线程安全的<strong>安全程度</strong>排序来看，Java中各种操作共享的数据分为以下5类：</p>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>final对象，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要采用任何的线程安全保障措施。</p>
<p>只要一个不可变的对象被正确地构建出来(this引用没有逃逸)，那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程中处于不一致的状态。</p>
<ul>
<li>对于一个<strong>数据类型</strong>，只需要在定义时使用final即可</li>
<li>对于一个<strong>对象</strong>，则需要保证对象的行为不会对其状态产生任何影响才行。例如String，subString会返回一个新的字符串，对其本身没有影响。</li>
</ul>
<h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>指完全满足定义。而即使一个类的所有方法都时被synchronized修饰的，也不意味着调用它永远都不需要同步手段了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread removeThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)&#123;</span><br><span class="line">            vector.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread printThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)&#123;</span><br><span class="line">            System.out.println(vector.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    removeThread.start();</span><br><span class="line">    printThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例当中，依然时线程不安全的，当remove刚好删除一个元素，导致序号<code>i</code>已经不可用，此时去访问数组会抛出<code>ArrayIndexOutOfBoundsException</code></p>
<p>而要改为绝对安全则需要将<code>synchronized(vector)</code></p>
<h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>保证单次调用下，线程是安全的，对于特定顺序的连续调用，则可能需要使用额外的同步手段。Java中的大多数线程安全类都属于该类型</p>
<h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>对象本身并不是线程安全，但可以在调用端正确使用同步手段来保证对象在并发环境可以安全使用。一般常说类不是线程安全的绝大部分是指该情况。</p>
<h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>无论调用端是否采用了同步措施，都无法在多线程环境并发使用的代码。</p>
<p>例如Thread的<code>suspend()</code>与<code>resume()</code>，如果两个线程同时持有一个线程对象，一个尝试中断线程，另一个尝试恢复线程。当并发进行时，无论调用是否同步，目标线程都存在死锁风险。</p>
<h2 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h2><p>导致共享变量在线程间不可见的原因</p>
<ul>
<li>线程交叉执行</li>
<li>重排序结合线程交叉执行</li>
<li>共享变量更新后的值没有在工作内存与主内存间及时更新</li>
</ul>
<p>因为我认为这块属于JMM方面，因此详情查看<strong>Java并发：JMM</strong></p>
<h2 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h2><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>发布对象：发布一个对象指它能够被当前作用域以外的代码所使用。发布一个对象，同时将发布该对象所有的非私有域引用的对象。</p>
<p>发布对象的场景：例如将应该指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。</p>
<p>很多情况下，我们确保对象及其内部状态不被发布。而某些情况下，我们又需要发布某个对象，如果在发布时要确保线程安全，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。不安全发布的<strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafePublish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] states = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接获得了私有对象states的引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String[] getStates()&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UnsafePublish unsafePublish = <span class="keyword">new</span> UnsafePublish();</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">        <span class="comment">//发布states对象,无法确定其他线程是否会修改该对象的数据</span></span><br><span class="line">        <span class="comment">//因此在使用这个对象的数据的时候,无法完全确定对象里面的数据</span></span><br><span class="line">        <span class="comment">//即线程不安全的</span></span><br><span class="line">        unsafePublish.getStates()[<span class="number">0</span>] = <span class="string">"d"</span>;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逸出"><a href="#逸出" class="headerlink" title="逸出"></a>逸出</h3><p>对象逸出：一个对象在尚未准备好的时候就发布，使得它被其他线程可见。</p>
<p>逸出会破坏线程安全性，当应该对象逸出后，你必须假设有某个类或线程可能会误用对象，这正是使用封装的最主要原因。封装能够使得对程序的正确性进行分析变得可能，使得无意中破坏涉及约束条件变得更难。</p>
<p>逸出：</p>
<ul>
<li>this引用在构造期间逸出，即对象在没有通过构造函数构造完毕（执行到了构造函数的某一句）时候逸出。<ul>
<li>当对象在构造函数当中创建一个线程，this引用总是被新线程共享</li>
<li>当发布一个内部的类的实例，也会隐式发布了实例本身，因为内部类的实例中包含了对其原类的实例的隐含引用</li>
</ul>
</li>
</ul>
<p>如果要在构造函数中创建线程</p>
<ul>
<li>使用<strong>工厂方法</strong>或者<strong>私有构造函数</strong>来完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//在这里启动了一个线程,新线程已经可以看到escape类的对象		</span></span><br><span class="line">        listener = <span class="keyword">new</span> EventListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>&#123;</span><br><span class="line">                <span class="keyword">do</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">       SafeListener safe = <span class="keyword">new</span> SafeListener();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>访问共享的、可变的数据要求使用同步。一个可以避免同步的方法就是<strong>不共享数据</strong>。当对象封装在一个线程当中，则自动成为线程安全的。即使被封闭的对象本身不是线程安全的。</p>
<blockquote>
<p>线程封闭：如果数据仅仅在单线程当中访问，则不需要任何同步</p>
</blockquote>
<p>Java中并没有强制规定某个变量必须由锁来保护，同样在Java语言中也无法强制将对象封闭在某个线程中，Java通过使用局部变量和ThreadLocal实现。</p>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p><strong><em>示例</em></strong></p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<ul>
<li>Swing将事件分发到线程当中</li>
<li>JDBC从池中分配一个对象给线程。</li>
</ul>
<h3 id="线程封闭方法："><a href="#线程封闭方法：" class="headerlink" title="线程封闭方法："></a>线程封闭方法：</h3><blockquote>
<p>Ad-hoc线程封闭：维护线程封闭性完全由程序实现来承担。</p>
</blockquote>
<p>程序控制实现，最糟糕。因为没有任何一种语言特性能够将对象封闭到目标线程上。</p>
<p>volatile存在一种特殊的线程访问，确保只通过单一线程写入共享的volatile变量，则操作便是共享</p>
<blockquote>
<p>堆栈封闭：局部变量，无并发问题。</p>
</blockquote>
<p>是线程限制的特例，只能通过局部变量才可以触及对象。本地变量使得对象更容易被限制在线程本地中<strong>，本地变量本身就被限制在执行线程</strong>中，它们存在于执行线程栈。其他线程无法访问这个栈</p>
<p>堆栈封闭比Ad-hoc更易于维护，也更健壮。JVM保证了基本类型的局部变量始终封闭在堆栈中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>例如下面方法当中的numPairs。在该方法当中，实例化的animals只有一个引用指向它，因此它保存在线程的栈当中，确保了不会破坏栈封闭性。倘若发布了animals或其内部对象的引用，则破坏了限制，并导致了对象逸出。</p>
<p>如果在线程内部上下文使用非线程安全的对象，那么该对象仍然时线程安全的，但是只有开发代码的人员才知道那些对象需要被封闭到执行线程中，以及被封闭的对象是否线程安全，如果没有明确说明，则后续维护很容易使得对象逸出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span></span>&#123;</span><br><span class="line">	SortedSet&lt;Animal&gt; animals;</span><br><span class="line">    <span class="keyword">int</span> numPairs = <span class="number">0</span>;</span><br><span class="line">    Animal candidate = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    animals = <span class="keyword">new</span> TreeSet&lt;Animal&gt;(<span class="keyword">new</span> SpeciesGenderComparator());</span><br><span class="line">    animals.addAll(candidates);</span><br><span class="line">    <span class="keyword">for</span>(Animal a : animals)&#123;</span><br><span class="line">        <span class="keyword">if</span>(candidate == <span class="keyword">null</span> || !candidate.isPotentialMate(a))&#123;</span><br><span class="line">            candidate = a;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ark.load(<span class="keyword">new</span> AnimalPair(candidate, a));</span><br><span class="line">            ++numPairs;</span><br><span class="line">            candidate = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numPairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ThreadLocal：使得线程中的某个值与保存值的对象关联起来。</p>
</blockquote>
<ul>
<li>ThreadLocal线程封闭：特别好的封闭方法。<ul>
<li>内部维护了一个map，key是线程名称，值是对象</li>
<li>更规范的方式，允许将每个线程与持有数值的对象关联在一起。ThradLocal提供了get和set，为每个使用它的线程维护一份单独的拷贝，所以get总是返回当前执行线程通过set设置的最新值。</li>
</ul>
</li>
<li>通常用于防止对可变的单实例变量或者全局变量进行共享。</li>
</ul>
<p>ThreadLocal提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的<strong>实例副本</strong>。ThreadLocal 变量通常被<code>private static</code>修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
<p>总的来说，<strong>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</strong>。可以使用 <code>java.lang.ThreadLocal</code> 类来实现线程本地存储功能。</p>
<p><strong><em>应用</em></strong></p>
<ul>
<li>当某个频繁执行的操作需要一个临时对象，例如缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用该技术。</li>
<li>如果将单线程的应用程序移植到多线程中，通过将共享的全局变量转换为Th’readLoacl对象(如果全局变量的语义允许)，可以维持线程安全性。</li>
<li>例如JDBC的全局连接不是线程安全的，因此将其保存到ThreadLocal当中，每个线程拥有属于自己的副本。</li>
</ul>
<p><strong><em>缺陷</em></strong></p>
<p>ThreadLocal会降低代码的可重用性，并在类间引入隐含的耦合性。</p>
<p><strong><em>示例</em></strong></p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>
<p>在不可变对象的内部仍可以使用可变对象来管理它们的状态。但这些可变对象对外而言是不可变的。</p>
<blockquote>
<p>除非需要更高的可见性，否则应将所有的域都声明为私有域</p>
<p>除非需要某个域是可变的，否则应将其声明为final域</p>
</blockquote>
<p>不可变的<strong>类型</strong>：</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
<p>不可变对象需要满足的<strong>条件</strong></p>
<ul>
<li>对象创建以后状态就不能修改<ul>
<li>将类声明为final</li>
</ul>
</li>
<li>对象所有域都是final类型<ul>
<li>所有域声明为私有</li>
<li>不设置set方法</li>
<li>将所有可变数据声明为final</li>
</ul>
</li>
<li>对象是正确创建的，this引用没有逸出<ul>
<li>通过构造器初始化所有成员</li>
<li>在get方法不直接返回对象本身，而是返回一个clone</li>
</ul>
</li>
</ul>
<p><strong>final关键字</strong>：类、方法、变量</p>
<p>final确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。</p>
<ul>
<li>修饰类：<ul>
<li>不能被继承</li>
<li>所有成员方法会隐式选择为final</li>
</ul>
</li>
<li>修饰方法<ul>
<li>锁定方法不能被继承修改</li>
</ul>
</li>
<li>修饰变量<ul>
<li>基本数据类型变量</li>
<li>引用类型变量（初始化后，不能指向另一个对象）</li>
</ul>
</li>
</ul>
<p>其他创建不可变对象方法</p>
<ul>
<li>对于集合类型，Collections.unmodifiableXXX：Collection、List、Set、Map…</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//创建final的map</span></span><br><span class="line">        map = Collections.unmodifiableMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//会抛出异常, map无法被修改</span></span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>,map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将返回一个新的map，将数据拷贝过去，然后将所有更改数据转换为了抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Guava：ImmutableXXX：Collection、List、Set、Map…</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableList&lt;Integer&gt; list = ImmutableList.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableSet set = ImmutableSet.copyOf(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer,Integer&gt; map = ImmutableMap.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer,Integer&gt; map2 = ImmutableMap.&lt;Integer,Integer&gt;builder()</span><br><span class="line">            .put(<span class="number">1</span>,<span class="number">2</span>).put(<span class="number">3</span>,<span class="number">4</span>).put(<span class="number">5</span>,<span class="number">6</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        set.add(4);</span></span><br><span class="line"><span class="comment">//        map2.put(1,4);</span></span><br><span class="line">        System.out.println(map2.get(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h2><p>当某些情况下希望在多个线程间共享对象，此时必须确保安全地进行共享。</p>
<h3 id="不正确的发布"><a href="#不正确的发布" class="headerlink" title="不正确的发布"></a>不正确的发布</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Holder holder</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initHolder</span><span class="params">()</span></span>&#123;</span><br><span class="line">	holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码会存在可见性问题，其他线程看到地Holder对象将处于不一致地状态，即使在该对象地构造函数中已经正确地构建了不变性条件，这种不正确的发布会使得其他线程看到尚未创建完成的对象。未被正确发布的对象存在两个问题：</p>
<ul>
<li>除了发布对象的线程外，其他线程可以看到的Holder域是一个失效值，因此将看到一个空引用或之前的旧值</li>
<li>线程看到Holder引用的值是最新的，但Holder状态的值是失效的，即可能线程第一次读取域时得到失效值，再次读取这个域会得到一个更新值。</li>
</ul>
<h3 id="不可变对象与初始化安全性"><a href="#不可变对象与初始化安全性" class="headerlink" title="不可变对象与初始化安全性"></a>不可变对象与初始化安全性</h3><p>JMM为不可对象的共享提供了一种特殊的初始化安全性保证。</p>
<p>即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的，因此为了确保对象状态能呈现一致性，则必须使用同步。而即使在发布不可变对象的引用时没有使用同步，也仍然可以安全地访问该对象。</p>
<blockquote>
<p>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。</p>
</blockquote>
<h3 id="安全发布的常用模式"><a href="#安全发布的常用模式" class="headerlink" title="安全发布的常用模式"></a>安全发布的常用模式</h3><p>可变对象必须通过安全地方式来发布，意味着在发布和使用该对象的线程时都必须使用同步。要安全地发布一个对象，对象地引用以及对象地状态必须同时对其他线程可见，一个正确构造地对象可以通过以下方式来安全发布</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象地引用保存到volatile类型的域或者AtomicReferance对象中</li>
<li>将对象的引用保存保存到某个正确构造对象的final类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中。</li>
</ul>
<p>在线程安全容器内部的同步意味着，在对象放入到例如Vector当中将满足最后一条要求。线程安全库中的容器类提供了以下的安全发布保证</p>
<ul>
<li>通过将一个键或值放入HashTable等可以安全地将它发布给任何从这些容器中访问它的线程</li>
<li>通过将某个元素放入Vector等，可以将该元素安全地发布到任何从这些容器中访问该元素的线程</li>
<li>通过将某个元素放入BlockingQueue等，可以将元素安全地发布到任何从这些队列中访问该元素地线程。</li>
</ul>
<p>对于静态发布，静态的初始化器由JVM在类的初始化阶段执行，由于JVM内部存在同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Holder holder = <span class="keyword">new</span> Holder(<span class="number">42</span>)</span><br></pre></td></tr></table></figure>

<h3 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h3><p>如果对象在发布后不会被修改，那么对于其他在没有额外同步地情况下安全地访问这些对象的线程来说，安全发布是足够的。所有安全发布机制都能保证，当对象的引用对所有访问该对象的线程可见时，对象发布时的状态对于所有线程也将时可见的，并且如果对象的状态不会再改变，则足以确保任何访问都是安全的。</p>
<blockquote>
<p>事实不可变对象：如果对象从技术上来看是可变的，但其状态再发布后不会再改变。</p>
</blockquote>
<h3 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h3><p>如果对象再构造后可以修改，那么安全发布只能保证发布当时状态的可见性，对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。</p>
<p>要安全地共享可变对象，这些对象就必须被安全地发布，并且必须是线程安全地或者由某个锁保护起来的。对象的发布需求取决于它的可变性</p>
<ul>
<li>不可变对象可以通过任意机制来发布</li>
<li>事实不可变对象必须通过安全方式来发布</li>
<li>可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。</li>
</ul>
<h3 id="安全地共享对象"><a href="#安全地共享对象" class="headerlink" title="安全地共享对象"></a>安全地共享对象</h3><p>当获得对象的一个引用时，需要知道在这个引用上可以执行哪些操作。在使用它之前是否需要获得一个锁，是否可以修改它的状态，或者只能读取它。当发布一个对象时，必须明确地说明对象地访问方式。</p>
<h4 id="发布策略"><a href="#发布策略" class="headerlink" title="发布策略"></a>发布策略</h4><blockquote>
<p>线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改</p>
</blockquote>
<blockquote>
<p>只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。</p>
</blockquote>
<blockquote>
<p>线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口进行访问而不需要进一步的同步</p>
</blockquote>
<blockquote>
<p>保护对象。被保护的对象只能通过持有特定的锁来访问，保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</p>
</blockquote>
<h2 id="线程安全策略"><a href="#线程安全策略" class="headerlink" title="线程安全策略"></a>线程安全策略</h2><h3 id="首先安全发布对象"><a href="#首先安全发布对象" class="headerlink" title="首先安全发布对象"></a>首先安全发布对象</h3><ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象地引用保存到volatile类型的域或者AtomicReferance对象中</li>
<li>将对象的引用保存保存到某个正确构造对象的final类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中。<ul>
<li>并发容器</li>
</ul>
</li>
</ul>
<h3 id="不可变-1"><a href="#不可变-1" class="headerlink" title="不可变"></a>不可变</h3><p>final</p>
<h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>对于一些方法本身不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此由一些代码天生就是线程安全的。</p>
<ul>
<li><p>可重入代码。</p>
<ul>
<li>即纯代码。不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。如果一个方法，它的返回结果时可以预测的，即只要输入了相同的数据，就能返回相同的结果。那么就满足可重入的要求。</li>
</ul>
</li>
<li><p>线程封闭。包括堆栈封闭、ThreadLocal</p>
</li>
</ul>
<h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>锁等操作</p>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>由于硬件指令集的发展而出现。基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，则采用其他补偿措施（例如不断重试，直到成功）。</p>
<p>由于该方法大多实现不需要将线程挂起，即称为非阻塞同步。</p>
<ul>
<li>测试并设置 Test and Set</li>
<li>获取并增加 Fetch and Increment</li>
<li>交换 Swap</li>
<li>比较并交换 Compare and Swap     CAS<ul>
<li>ABA问题，如果要解决ABA问题可以使用Atomic，但是可能互斥同步更高效一些。</li>
</ul>
</li>
<li>加载链接/条件存储 Load-Linked/Store-Conditional     LL/SC</li>
</ul>
<h3 id="无同步方案-1"><a href="#无同步方案-1" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>对于一些方法本身不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此由一些代码天生就是线程安全的。</p>
<p>即纯代码。不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<p>如果一个方法，它的返回结果时可以预测的，即只要输入了相同的数据，就能返回相同的结果。那么就满足可重入的要求。</p>
<h1 id="设计线程安全的类"><a href="#设计线程安全的类" class="headerlink" title="设计线程安全的类"></a>设计线程安全的类</h1><p>在线程安全的程序中，虽然可以将程序的所有状态都保存在公有的静态域中，但与那些将状态封装起来的程序相比，这些程序的线程安全性更难以得到验证，并且在修改时也更难以始终保持其线程安全性。</p>
<p>通过使用封装，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全的。</p>
<p>在设计线程安全类的过程中，需要包含以下三个基本要素：</p>
<ul>
<li>找出构成对象状态的所有变量<ul>
<li>从对象的域开始，如果对象中所有的域都是基本类型的变量，那么这些域将构成对象的全部状态。</li>
<li>如果在对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域</li>
</ul>
</li>
<li>找出约束状态变量的不变性条件</li>
<li>建立对象状态的并发访问管理策略</li>
</ul>
<blockquote>
<p>同步策略定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。</p>
</blockquote>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h3 id="收集同步需求"><a href="#收集同步需求" class="headerlink" title="收集同步需求"></a>收集同步需求</h3><p>要确保类的安全性，就需要确保它的不变性条件不会在并发访问的情况下被破坏，这就需要对其状态进行推断。</p>
<p>对象与变量都有一个状态空间，即所有可能的取值。状态空间越小，就越容易判断对象的状态。final类型的域使用越多，就越能简化对象可能状态的分析过程。</p>
<p><strong><em>状态迁移</em></strong></p>
<ul>
<li>不可变条件</li>
<li>后验条件</li>
</ul>
<p>在许多类中定义了一些<strong>不可变条件</strong>，用于判断状态是有效的还是无效的。即一些对象的一些值不能为负数等限定条件。</p>
<p>在某些操作中还会包含一些<strong>后验条件</strong>来判断<strong>状态迁移</strong>是否有效，对于计数器Counter，如果当前状态为17，那么下一个有效状态只能为18。当下一个状态依赖当前状态时，整个操作必须是一个复合操作。而并非所有的操作都会在状态转换上增加限制，例如更新温度这个状态，其之前的值并不影响结果。</p>
<p><strong>后验条件</strong>：对状态的值进行检验，如果不符合，则异常</p>
<p><strong>状态迁移</strong>：一个对象的下一个状态源于当前状态。如果某些状态是非法的，则必须封装该状态下的状态变量，否则客户代码会将对象置于非法状态。如果一个操作的过程当中出现非法状态，则该操作必须是原子的</p>
<blockquote>
<p>如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性于封装性。</p>
</blockquote>
<p>由于不变性条件以及后验条件在状态及状态转换上施加了各种约束，因此就需要额外的同步与封装。</p>
<ul>
<li>如果某些状态是无效的，那么必须对底层的状态变量进行封装，否则客户代码可能使对象处于无效状态</li>
<li>如果某个操作中存在无效的状态转换，那么该操作必须是原子的。</li>
</ul>
<p>在类中也可能包含同时约束多个状态变量的不变性条件，而此时在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。</p>
<h3 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h3><p>类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换时有效的。在某些对象的方法中含包含一些基于状态的<strong>先验条件</strong>，例如不能从空队列中删除一个元素。</p>
<p>如果在某个操作中包含有基于状态的先验条件，那么这个操作就称为<strong>依赖状态的操作</strong></p>
<p>在单线程中，如果某个操作无法满足先验条件，那么只能失败。但是在并非程序中，先验条件可能会由于其他线程执行的操作而为真，在并发程序中要一直等到先验条件为真，然后再执行操作。</p>
<p>实现某个等待先验条件为真时才执行的操作的简单实现是通过现有的库的类。</p>
<h3 id="状态的所有权"><a href="#状态的所有权" class="headerlink" title="状态的所有权"></a>状态的所有权</h3><p>如果以某个对象为根节点构造一张对象图，那么该对象的状态将是对象图中所有对象包含的域的一个子集。为什么是一个子集？在凑够对象可以到达的所有域中，需要满足哪些条件才不属于对象状态的一部分。</p>
<p>在定义哪些变量将构成对象的状态时，只考虑对象拥有的数据。所有权在Java中并没有得到充分的体现，而是类设计的一个要素。在许多情况下，所有权与封装性总是相互关联的：对象封装它拥有的状态，反之也成立，即对它封装的状态拥有所有权。</p>
<p>状态变量的所有者将决定采用何种加锁协议来维持变量状态的完整性。所<strong>有权意味着控制权</strong>，如果发布了某个可变对象的引用，那么就不再拥有独占的控制权，最多是”共享控制权“。</p>
<p>对于从构造函数或者从方法中传递过来的对象，类通常并不拥有这些对象，除非这些方法是被专门设计为转移传递进来的对象的所有权（同步容器封装器的工厂方法）。</p>
<p>容器类通常表现出一种”<strong>所有权分离</strong>“的形式。容器类拥有其自身的状态，而客户代码则拥有容器中的各个对象的状态。例如SynchronizedList当中，List对象是线程安全的，即当使用get或add时是不需要使用同步的。但是使用保存在List当中的对象时，可能需要使用同步，这些对象由应用程序拥有，而List只是替应用程序保管它们。与所有共享对象一样，它们必须安全地被共享。因此为了线程安全，这些对象应该要么是线程安全的对象，要么是事实不可变的对象，或者是由锁来保护的对象。</p>
<h2 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h2><p>如果某对象不是线程安全的，那么可以通过多种技术使其在多线程中安全地使用。可以确保该对象只能由单个线程访问，或者通过一个锁来保护对该对象的所有访问。</p>
<p>封装简化了线程安全类的实现过程，它提供了一种实例封闭机制，当一个对象被封装到另一个对象中时，能够访问被封装对象的所有的代码路径都是已知的。因此更易于对代码进行分析，通过将封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。</p>
<blockquote>
<p>将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的</p>
</blockquote>
<ul>
<li>封闭在类的一个实例中，例如作为类的一个私有成员</li>
<li>封闭在某个作用域中，例如作为一个局部变量</li>
<li>封闭在一个线程中，例如通过ThreadLocal</li>
</ul>
<blockquote>
<p>封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。</p>
</blockquote>
<h1 id="线程安全实现方式（委托）"><a href="#线程安全实现方式（委托）" class="headerlink" title="线程安全实现方式（委托）"></a>线程安全实现方式（委托）</h1><p>基于对象的组合实现线程安全。</p>
<blockquote>
<p>当类中各个组件都已经是线程安全的，那么需要视情况而定是否需要额外增加一个线程安全层。</p>
</blockquote>
<h2 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h2><h3 id="单状态"><a href="#单状态" class="headerlink" title="单状态"></a>单状态</h3><p>当类中只有一个状态变量，则可以将该变量设置为Atomic，即该类的状态就是Atomic的状态，而Atomic是线程安全的，因此类是安全的，即将线程安全委托给了Atomic。</p>
<h3 id="多状态"><a href="#多状态" class="headerlink" title="多状态"></a>多状态</h3><p>而当存在多个状态变量，只要这些变量是彼此独立的，即组合的类不会在其包含的多个状态变量上增加任何不变性条件。此时依然可以使用Atomic。</p>
<h3 id="发布底层的状态变量"><a href="#发布底层的状态变量" class="headerlink" title="发布底层的状态变量"></a>发布底层的状态变量</h3><blockquote>
<p>如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都<strong>不包含无效状态转换</strong>，那么可以将线程安全性委托给底层的状态变量。</p>
<p>如果一个状态变量是线程安全的，并且没有任何不变性条件约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量</p>
</blockquote>
<h2 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h2><p>Java类库中包含很多基础模块类，我们应该进行重用，但是大部分时候现有的类只能支持大部分的操作，此时就需要在不破坏线程安全性的情况下添加应该新的操作。</p>
<ul>
<li>修改原始类，但通常无法做到</li>
<li>扩展类，扩展方法比直接添加代码到类中更加脆弱，因为同步策略实现被分布到多个单独维护的代码中。</li>
</ul>
<h3 id="客户端加锁机制"><a href="#客户端加锁机制" class="headerlink" title="客户端加锁机制"></a>客户端加锁机制</h3><p>将扩展代码放入应该辅助类当中，并且需要确保整个对象使用的是同一个锁，如果在类内部使用了Vector与synchronized，则会有两个锁的存在。</p>
<p>通过添加一个原子操作来扩展类是脆弱的，因为将类的加锁代码分布到了多个类中。然而客户端加锁更脆弱。客户端加锁将类C的加锁代码放入了与C完全无关的其他类中，</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>创建一个新类A，持有一个List的引用，将它们组合起来。A通过将List对象的操作委托给底层的List实例来实现List的操作，同时添加一个原子操作，即使将List传递给客户端，也只能通过类A进行访问。</p>
<p><img src="/assets/1565054929055.png" alt="1565054929055"></p>
<p>只要确保了List的唯一外部引用，则可以保证线程安全性。</p>
<h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><p>类别</p>
<ul>
<li>ArrayList-&gt;Vector、Stack</li>
<li>HashMap-&gt;HashTable</li>
<li>Collections.synchronizedXXX(List、Set、Map)<ul>
<li>collection的静态工厂创建</li>
</ul>
</li>
</ul>
<p>同步容器也未必线程安全</p>
<p>同步容器虽然保证了同一时刻只有一个线程可以访问，但是线程交替进行访问依然会出现问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">            vector.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//在size=10,i=9时刻,上面的线程将其删除,而此时读取则会出现异常</span></span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size()</span></span>; i++) &#123;</span><br><span class="line">            vector.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>

<h1 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h1><h3 id="监视器模式"><a href="#监视器模式" class="headerlink" title="监视器模式"></a>监视器模式</h3><p>遵循Java监视器模式的对象会将堆详细的所有可变状态都封装起来，并由对象自己的内置锁来保护。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value == Long.MAX_VALUE)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即对类内所有的状态变量都需要通过Counter的方法执行，而且这些方法都是同步的。例如Vector等都使用了监视器模式。</p>
<p>Java监视器模式仅仅是一种编写代码的约定，对于任何一种锁现象，只要自始至终都使用该锁对象，都可以用来保护对象的状态。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
    </div>

    
    
    

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/并发编程/" rel="tag"># 并发编程</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2019/03/01/Java/base/JVM：类文件与类加载/" rel="next" title="JVM：类文件与类加载">
                <i class="fa fa-chevron-left"></i> JVM：类文件与类加载
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2019/03/02/OS/计算机操作系统：虚拟内存/" rel="prev" title="计算机操作系统（三）：虚拟内存">
                计算机操作系统（三）：虚拟内存 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">197</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#线程安全概念"><span class="nav-number">1.</span> <span class="nav-text">线程安全概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子性"><span class="nav-number">1.2.</span> <span class="nav-text">原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#竞态条件"><span class="nav-number">1.2.1.</span> <span class="nav-text">竞态条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据竞争"><span class="nav-number">1.2.2.</span> <span class="nav-text">数据竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复合操作"><span class="nav-number">1.2.3.</span> <span class="nav-text">复合操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加锁机制"><span class="nav-number">1.3.</span> <span class="nav-text">加锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内置锁"><span class="nav-number">1.3.1.</span> <span class="nav-text">内置锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重入"><span class="nav-number">1.3.2.</span> <span class="nav-text">重入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用锁来保护状态"><span class="nav-number">1.4.</span> <span class="nav-text">用锁来保护状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#活跃性与性能"><span class="nav-number">1.5.</span> <span class="nav-text">活跃性与性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现线程安全"><span class="nav-number">2.</span> <span class="nav-text">实现线程安全</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象的共享"><span class="nav-number">3.</span> <span class="nav-text">对象的共享</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全级别"><span class="nav-number">3.1.</span> <span class="nav-text">线程安全级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变"><span class="nav-number">3.1.1.</span> <span class="nav-text">不可变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绝对线程安全"><span class="nav-number">3.1.2.</span> <span class="nav-text">绝对线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相对线程安全"><span class="nav-number">3.1.3.</span> <span class="nav-text">相对线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程兼容"><span class="nav-number">3.1.4.</span> <span class="nav-text">线程兼容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程对立"><span class="nav-number">3.1.5.</span> <span class="nav-text">线程对立</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存可见性"><span class="nav-number">3.2.</span> <span class="nav-text">内存可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发布与逸出"><span class="nav-number">3.3.</span> <span class="nav-text">发布与逸出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发布"><span class="nav-number">3.3.1.</span> <span class="nav-text">发布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逸出"><span class="nav-number">3.3.2.</span> <span class="nav-text">逸出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程封闭"><span class="nav-number">3.4.</span> <span class="nav-text">线程封闭</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程封闭方法："><span class="nav-number">3.4.1.</span> <span class="nav-text">线程封闭方法：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不变性"><span class="nav-number">3.5.</span> <span class="nav-text">不变性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安全发布"><span class="nav-number">3.6.</span> <span class="nav-text">安全发布</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不正确的发布"><span class="nav-number">3.6.1.</span> <span class="nav-text">不正确的发布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变对象与初始化安全性"><span class="nav-number">3.6.2.</span> <span class="nav-text">不可变对象与初始化安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全发布的常用模式"><span class="nav-number">3.6.3.</span> <span class="nav-text">安全发布的常用模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事实不可变对象"><span class="nav-number">3.6.4.</span> <span class="nav-text">事实不可变对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变对象"><span class="nav-number">3.6.5.</span> <span class="nav-text">可变对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全地共享对象"><span class="nav-number">3.6.6.</span> <span class="nav-text">安全地共享对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发布策略"><span class="nav-number">3.6.6.1.</span> <span class="nav-text">发布策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全策略"><span class="nav-number">3.7.</span> <span class="nav-text">线程安全策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#首先安全发布对象"><span class="nav-number">3.7.1.</span> <span class="nav-text">首先安全发布对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变-1"><span class="nav-number">3.7.2.</span> <span class="nav-text">不可变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无同步方案"><span class="nav-number">3.7.3.</span> <span class="nav-text">无同步方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥同步"><span class="nav-number">3.7.4.</span> <span class="nav-text">互斥同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非阻塞同步"><span class="nav-number">3.7.5.</span> <span class="nav-text">非阻塞同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无同步方案-1"><span class="nav-number">3.7.6.</span> <span class="nav-text">无同步方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计线程安全的类"><span class="nav-number">4.</span> <span class="nav-text">设计线程安全的类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#思想"><span class="nav-number">4.1.</span> <span class="nav-text">思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#收集同步需求"><span class="nav-number">4.1.1.</span> <span class="nav-text">收集同步需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖状态的操作"><span class="nav-number">4.1.2.</span> <span class="nav-text">依赖状态的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态的所有权"><span class="nav-number">4.1.3.</span> <span class="nav-text">状态的所有权</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例封闭"><span class="nav-number">4.2.</span> <span class="nav-text">实例封闭</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程安全实现方式（委托）"><span class="nav-number">5.</span> <span class="nav-text">线程安全实现方式（委托）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#状态变量"><span class="nav-number">5.1.</span> <span class="nav-text">状态变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单状态"><span class="nav-number">5.1.1.</span> <span class="nav-text">单状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多状态"><span class="nav-number">5.1.2.</span> <span class="nav-text">多状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发布底层的状态变量"><span class="nav-number">5.1.3.</span> <span class="nav-text">发布底层的状态变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展类"><span class="nav-number">5.2.</span> <span class="nav-text">扩展类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端加锁机制"><span class="nav-number">5.2.1.</span> <span class="nav-text">客户端加锁机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合"><span class="nav-number">5.2.2.</span> <span class="nav-text">组合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步容器"><span class="nav-number">5.3.</span> <span class="nav-text">同步容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java实现"><span class="nav-number">6.</span> <span class="nav-text">Java实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#监视器模式"><span class="nav-number">6.0.1.</span> <span class="nav-text">监视器模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结-1"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">1.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">57:26</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        




  <script>
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=66458302";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  























  <script src="/js/local-search.js?v=7.2.0"></script>














</body>
</html>
