<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: 'OZTK1BY156',
      apiKey: '',
      indexName: 'BlogIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Kopieren',
      copy_success: 'Kopiert',
      copy_failure: 'Kopieren fehlgeschlagen'
    }
  };
</script>

  <meta name="description" content="线程安全 线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用放进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。  即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这个并">
<meta name="keywords" content="并发编程">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发：线程安全">
<meta property="og:url" content="http://yoursite.com/2019/03/01/Java/base/java并发：线程安全/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="线程安全 线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用放进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。  即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这个并">
<meta property="og:locale" content="default">
<meta property="og:image" content="c:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550563393365.png">
<meta property="og:image" content="http://yoursite.com/2019/03/01/Java/base/java并发：线程安全/assets/1551425245832.png">
<meta property="og:image" content="http://yoursite.com/2019/03/01/Java/base/java并发：线程安全/assets/1551425259624.png">
<meta property="og:image" content="c:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550587826303.png">
<meta property="og:image" content="http://yoursite.com/2019/03/01/Java/base/java并发：线程安全/assets/6782674c-1bfe-4879-af39-e9d722a95d39.png">
<meta property="og:updated_time" content="2019-07-31T07:46:43.265Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java并发：线程安全">
<meta name="twitter:description" content="线程安全 线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用放进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。  即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这个并">
<meta name="twitter:image" content="c:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550563393365.png">
  <link rel="canonical" href="http://yoursite.com/2019/03/01/Java/base/java并发：线程安全/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>java并发：线程安全 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>Über</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Schlagwörter</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Kategorien</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>Zeitplan</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Suche</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="algolia-popup popup search-popup">
  <div class="algolia-search">
    <div class="algolia-search-input-icon">
      <i class="fa fa-search"></i>
    </div>
    <div class="algolia-search-input" id="algolia-search-input"></div>
  </div>

  <div class="algolia-results">
    <div id="algolia-stats"></div>
    <div id="algolia-hits"></div>
    <div id="algolia-pagination" class="algolia-pagination"></div>
  </div>

  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>



    </div>
</nav>

</div>
    </header>

    

  <a href="https://github.com/smallpocket" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Java/base/java并发：线程安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">java并发：线程安全

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-01 15:42:55" itemprop="dateCreated datePublished" datetime="2019-03-01T15:42:55+08:00">2019-03-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-07-31 15:46:43" itemprop="dateModified" datetime="2019-07-31T15:46:43+08:00">2019-07-31</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/01/Java/base/java并发：线程安全/" class="post-meta-item leancloud_visitors" data-flag-title="java并发：线程安全">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/01/Java/base/java并发：线程安全/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/01/Java/base/java并发：线程安全/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><blockquote>
<p>线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用放进行任何其他的协调操作， <strong>调用这个对象的行为</strong>都可以获得正确的结果，那这个对象是线程安全的。</p>
</blockquote>
<p>即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这个并不容易做到</p>
<p>因此一般将定义弱化一些,即将调用这个对象的行为限定为<strong>单次调用</strong>，若其他描述成立，则称它线程安全。</p>
<p>在一项工作进行前，会被不停中断与切换，对象的属性可能会在中断期间被修改和变脏。如何保证程序在计算机中正确无误地运行</p>
<h2 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h2><p>线程安全限定于多个线程间存在共享数据访问这个前提，如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度看，程序是串行执行还是多线程执行对它没有区别</p>
<p>依照线程安全的<strong>安全程度</strong>排序来看，Java中各种操作共享的数据分为以下5类：</p>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>final对象，不可边的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要采用任何的线程安全保障措施。</p>
<p>只要一个不可变的对象被正确地构建出来(this引用没有逃逸)，那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程中处于不一致的状态。</p>
<ul>
<li>对于一个<strong>数据类型</strong>，只需要在定义时使用final即可</li>
<li>对于一个<strong>对象</strong>，则需要保证对象的行为不糊对其状态产生任何影响才行。例如String，subString会返回一个新的字符串，对其本身没有影响。</li>
</ul>
<h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>指完全满足定义。即使一个类的所有方法都时被synchronized修饰的，也不意味着调用它永远都不需要同步手段了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread removeThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)&#123;</span><br><span class="line">            vector.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread printThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)&#123;</span><br><span class="line">            System.out.println(vector.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    removeThread.start();</span><br><span class="line">    printThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例当中，依然时线程不安全的，当remove刚好删除一个元素，导致序号i已经不可用，此时去访问数组会抛出ArrayIndexOutOfBoundsException</p>
<p>而要改为绝对安全则需要将<code>synchronized(vector)</code></p>
<h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>保证单次调用下，线程是安全的，对于特定顺序的连续调用，则可能需要使用额外的同步手段。Java中的大多数线程安全类都属于该类型</p>
<h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>对象本身并不是线程安全，但可以在调用端正确使用同步手段来保证对象在并发环境可以安全使用。一般常说类不是线程安全的绝大部分是指该情况。</p>
<h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>无论调用端是否采用了同步措施，都无法在多线程环境并发使用的代码。</p>
<p>例如Thread的<code>suspend()</code>与<code>resume()</code>，如果两个线程同时持有一个线程对象，一个尝试中断线程，另一个尝试恢复线程。当并发进行时，无论调用是否同步，目标线程都存在死锁风险。</p>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><blockquote>
<p>同步指多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个(或一些)线程使用。</p>
<p>互斥是实现同步的一种手段。</p>
</blockquote>
<p>互斥同步最主要的问题是进行线程阻塞与唤醒带来的性能问题。悲观的并发策略。</p>
<ul>
<li>临界区、互斥量、信号量都是主要互斥实现方法。</li>
<li>synchronized关键字：需要系统帮助完成</li>
<li>J.U.C包下的重入锁，例如ReentrantLock</li>
</ul>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>由于硬件指令集的发展而出现。基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，则采用其他补偿措施（例如不断重试，直到成功）。</p>
<p>由于该方法大多实现不需要将线程挂起，即称为非阻塞同步。</p>
<ul>
<li>测试并设置 Test and Set</li>
<li>获取并增加 Fetch and Increment</li>
<li>交换 Swap</li>
<li>比较并交换 Compare and Swap     CAS<ul>
<li>ABA问题，如果要解决ABA问题可以使用Atomic，但是可能互斥同步更高效一些。</li>
</ul>
</li>
<li>加载链接/条件存储 Load-Linked/Store-Conditional     LL/SC</li>
</ul>
<h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>对于一些方法本身不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此由一些代码天生就是线程安全的。</p>
<h4 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h4><p>即纯代码。不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<p>如果一个方法，它的返回结果时可以预测的，即只要输入了相同的数据，就能返回相同的结果。那么就满足可重入的要求。</p>
<h4 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h4><p>如果一段代码中所需要的数据必须与其他代码共享，那就看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，就可以将共享数据的可见范围限制在同一个线程内，这样无须同步也能保证线程间不会出现数据争用的问题。</p>
<p>例如大部分消费队列的架构模式都会将产品的消费过程尽量在一个线程中消费完，例如一个请求对应一个服务器线程的处理方式。</p>
<p>通过ThreadLocal实现。</p>
<h1 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h1><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>编写线程安全的代码，本质上就是管理对<strong>状态</strong>的访问，而且通常都是<strong>共享、可变</strong>的状态。</p>
<p>一个对象的状态就是它的数据，存储在状态变量中，如静态域、实例域。共享即一个变量可以被多个线程访问。可变即变量的值在其生命周期内都可以改变。真正要做到的线程安全是在不可控制的并发访问当中保护数据。</p>
<p>无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。</p>
<p>java的同步机制：synchronized(独占锁)，volatile(显示锁和原子变量的使用)</p>
<p>修复同步隐患</p>
<ul>
<li>不跨线程的共享变量</li>
<li>使用状态变量为不可变的</li>
<li>在任何访问状态变量的时候使用同步</li>
</ul>
<h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p>当多个线程访问某个类时，不管运行时环境采用<strong>何种调度方式</strong>或者这些进程将如何交替执行，并且在主调代码中不需要<strong>任何额外的同步或协同</strong>，这个类都能表现出<strong>正确的行为</strong>。</p>
<p>无状态的对象永远是安全的。即指这个对象没有状态域，也没有引用其他对象的域，是一次特定计算的瞬时状态，会唯一存放在一个本地变量当中，即线程的栈当中。而两个线程并不共享状态。</p>
<p><strong>三个方面</strong></p>
<ul>
<li>原子性：提供了互斥访问，同一时刻只能有一个线程对它进行操作</li>
<li>可见性：一个线程对主内存的修改可以及时被其他线程观察到</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般无序</li>
</ul>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性：能作为一个单独的、不可分割的操作去执行</p>
<p>当向一个无状态的对象添加一个域，并进行long++操作（读+改+写），则不是线程安全</p>
<p>将long换作一个atomic包下的AtomicLong变量，则由于该变量是一个原子变量类，该计数器是线程安全的，该对象的状态即该计数器的对象，即该对象线程安全。（利用已有的线程安全类进行管理，如果只有一个，则线程安全，如果多个，则未必线程安全）</p>
<p>当变量之间相互关联，则在一个原子操作当中，要将几个相互关联的变量同时更新</p>
<p><strong>竞争条件</strong></p>
<p>​    想得到正确的答案，依赖时序。</p>
<h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><p>JDK的Atomic包，通过CAS完成原子性</p>
<p>int类型变为AtomicInteger，自增的方法为incrementAndGet</p>
<h4 id="CAS核心"><a href="#CAS核心" class="headerlink" title="CAS核心"></a>CAS核心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//计数方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count.incrementAndGet();<span class="comment">//先执行增加操作，再获取值</span></span><br><span class="line"><span class="comment">//        count.getAndIncrement(); //先获取当前的值，再执行增加操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>源码实现，基于一个unsafe类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以dowhile语句为核心实现,CompareAndSwap是C.A.S的核心.</p>
<p>因为使用循环，如果修改很频繁，会不断循环尝试修改，使得性能受到影响</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * var1:当前的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//通过调用底层方法,获得var1对象底层当前的值</span></span><br><span class="line">            <span class="comment">//如果没有其他线程更改,则var5就会等于var2</span></span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">            <span class="comment">//比较底层的值var5与传入的值var2</span></span><br><span class="line">            <span class="comment">//如果底层的值与传入值相同,那么更新为var5+增量var4</span></span><br><span class="line">            <span class="comment">//如果值不相同,则将var2的值更改为底层当前的值,然后重新do,获得var5的值,进行比较</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以native标识，即java底层的实现，不是java的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p><strong>AtomicLong</strong></p>
<p>对于很精确的数值需要使用</p>
<p><strong>LongAdder</strong></p>
<p>原理：JVM对于普通的long与double，允许将64位的读操作与写操作拆分为两个32位的操作。</p>
<p>核心：将热点数据分离，将一个value分割为一个数组，每个线程针对一个数值，最后的value由数组的值合成，将单点的更新压力分散为多点的更新压力。在低并行的时候，对value直接更新。</p>
<p>优点：在高并发下，效率很高</p>
<p>缺点：如果有并行更新，可能导致统计数据有一些误差</p>
<p><strong>AtomicReference</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; count = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出4</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        count.compareAndSet(<span class="number">0</span>,<span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line">        count.compareAndSet(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// no</span></span><br><span class="line">        count.compareAndSet(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// no</span></span><br><span class="line">        count.compareAndSet(<span class="number">2</span>,<span class="number">4</span>); <span class="comment">// 4</span></span><br><span class="line">        count.compareAndSet(<span class="number">3</span>,<span class="number">5</span>); <span class="comment">// no</span></span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>,count.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>AtomicReferenceFieldUpdater</strong></p>
<p>以<strong>原子性更新</strong>某个类的一个实例的一个字段，字段必须volatile，并且非static</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater = AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class,<span class="string">"count"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicExample5 atomicExample5 = <span class="keyword">new</span> AtomicExample5();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (updater.compareAndSet(atomicExample5,<span class="number">100</span>,<span class="number">120</span>))&#123;</span><br><span class="line">        log.info(<span class="string">"update success,&#123;&#125;"</span>,atomicExample5.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (updater.compareAndSet(atomicExample5,<span class="number">100</span>,<span class="number">120</span>))&#123;</span><br><span class="line">        log.info(<span class="string">"update success,&#123;&#125;"</span>,atomicExample5.getCount());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">"update error&#123;&#125;"</span>,atomicExample5.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AtomicLongArray</strong></p>
<p>更新一个long的数组</p>
<p><strong>AtomicBoolean</strong></p>
<p>实现代码只执行一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean isHappend = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (isHappend.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line"></span><br><span class="line">         log.info(<span class="string">"execute"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CAS的ABA问题"><a href="#CAS的ABA问题" class="headerlink" title="CAS的ABA问题"></a>CAS的ABA问题</h4><p>ABA问题：在CAS操作中，其他线程将数据A改为B，又改为A。</p>
<p>解决：在每次更新的时候，记录一个版本号，每次更新+1</p>
<p>通过AtomicStampReference实现，核心方法为CompareAndSet</p>
<h3 id="原子性：锁"><a href="#原子性：锁" class="headerlink" title="原子性：锁"></a>原子性：锁</h3><p>synchronized：依赖JVM，在该关键字作用对象的作用范围内，只有一个线程可以操作</p>
<p>Lock：依赖特殊的CPU指令，由代码实现。ReentrantLock</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>同步锁，修饰的对象：</p>
<ul>
<li>修饰代码块：大括号括起来的代码，作用于<strong>调用的对象</strong></li>
<li>修饰方法：整个方法，作用于<strong>调用的对象</strong></li>
<li>修饰静态方法：整个静态方法，作用于<strong>所有对象</strong></li>
<li>修饰类：括号括起来部分，作用于<strong>所有对象</strong></li>
</ul>
<p>作用于所有的对象。则如果两个对象调用一个修饰的方法，他们会并行执行。而如果调用一个静态方法，则他们无法并行执行。</p>
<p>对于修饰代码块与修饰方法，不同的调用对象互相不影响</p>
<p><strong><em>继承</em></strong></p>
<p>如果子类调用继承于父类的synchronize方法（synchronize不属于一个类），是没有synchronize效果的，必须显式声明</p>
<p><strong><em>特性</em></strong></p>
<ul>
<li><p>重进入：内部锁是重进入的，当线程试图获得它自己所占有的锁时候，请求会成功，即重进入是基于每<strong>线程</strong>的，而不是调用。</p>
<p>实现是通过为每个锁关联一个请求计数与一个占有它的线程，当同一线程访问，则计数++，线程退出该锁，则计数–，直到计数为0，释放该锁（父类与子类的使用）</p>
</li>
</ul>
<p><strong><em>用锁来保持状态</em></strong></p>
<ul>
<li>如果每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行状态当中占有同一个锁，则称该变量是由这个锁保护的</li>
<li>每个共享的可变变量都需要唯一一个确定的锁保护</li>
</ul>
<p><strong><em>设计</em></strong></p>
<ul>
<li>决定synchronize块大小需要权衡安全性（不能妥协）、简单性、性能。通常简单性与性能相互牵制，实现一个同步策略时候，不要过早地为了性能而牺牲简单性（是对安全性潜在的妥协）</li>
<li>有些耗时的计算或操作，如网络或者控制台IO，难以快速完成，执行它们的时候不要占有锁</li>
</ul>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><h3 id="原子性对比："><a href="#原子性对比：" class="headerlink" title="原子性对比："></a>原子性对比：</h3><ul>
<li>synchronize；不可中断锁，适合竞争不激烈，可读性好</li>
<li>Lock：可中断锁，多样化同步，竞争激烈能维持常态</li>
<li>Atomic：竞争激烈能维持常态，比lock性能好，但是只能同步一个值</li>
</ul>
<h3 id="活跃度与性能"><a href="#活跃度与性能" class="headerlink" title="活跃度与性能"></a>活跃度与性能</h3><p>​    不能武断地将整个方法设置为synchronize的，通过缩小synchronize的范围来提高并发性</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550563393365.png" alt="1550563393365"></p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>一个线程对主内存的修改可以及时被其他线程观察到。</p>
<p>导致共享变量在线程间不可见的原因</p>
<ul>
<li>线程交叉执行</li>
<li>重排序结合线程交叉执行</li>
<li>共享变量更新后的值没有在工作内存与主内存间及时更新</li>
</ul>
<h3 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h3><p>JVM对synchronize的规定</p>
<ul>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存</li>
<li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享内存是需要从主内存中重新读取最新的值</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>通过加入内存屏障与禁止重排序优化来实现。</p>
<ul>
<li>对volatile变量<strong>写操作</strong>时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存。（每次写之后都刷新），CPU指令级别进行操作。</li>
</ul>
<p><img src="assets/1551425245832.png" alt="1551425245832"></p>
<ul>
<li>对volatile变量<strong>读操作</strong>时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量。（每次读从主内存读）</li>
</ul>
<p><img src="assets/1551425259624.png" alt="1551425259624"></p>
<p>但是volatile<strong>无法保证</strong>线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count++;</span><br><span class="line"><span class="comment">// 1、count//获得的是最新值</span></span><br><span class="line"><span class="comment">// 2、+1   //两个进程同时++</span></span><br><span class="line"><span class="comment">// 3、count//同时写回,即丢掉了一次.</span></span><br></pre></td></tr></table></figure>

<p>volatile<strong>使用</strong></p>
<ul>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ul>
<p>可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>使用场景</p>
<ul>
<li>很适合作为状态标示量</li>
<li>检查两次</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般无序</p>
<p>方式：volatile、synchronized、lock、java内存模型的先天有序性（happens before原则）</p>
<h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens before原则"></a>happens before原则</h3><ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定操作：一个unlock操作先行发生于后面对同一个锁的lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对于这个变量的读操作</li>
<li>传递规则；如果操作A先行发生于操作B，而操作B又先行发生于操作C，则操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start（）方法先行发生于此线程的每一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测</li>
<li>对象终结规则：一个对象的初始化完成先行发生于它的finalize（）方法的开始</li>
</ul>
<p>如果两个操作的执行次序无法从happens before推导出来，则JVM可以对它进行随意的重排序。</p>
<h1 id="线程安全策略"><a href="#线程安全策略" class="headerlink" title="线程安全策略"></a>线程安全策略</h1><p>进行共享和发布对象，使得多个线程可以安全地访问他们。</p>
<ul>
<li>线程限制<ul>
<li>一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改</li>
<li>线程封闭：把对象封装到一个线程当中，只有一个线程可以看到它</li>
</ul>
</li>
<li>共享只读<ul>
<li>一个共享只读的对象，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它</li>
<li>不可变对象：一种对象只要发布了就是安全的，即不可变对象，是一种躲避并发的方法</li>
</ul>
</li>
<li>线程安全对象<ul>
<li>一个线程安全的对象或者容器，在内部通过同步机制来保证线程安全，所有其他线程无需额外同步就可以通过公共接口随意访问它</li>
</ul>
</li>
<li>被守护对象<ul>
<li>只能通过获取特定的锁来访问</li>
</ul>
</li>
</ul>
<h2 id="线程安全的困难"><a href="#线程安全的困难" class="headerlink" title="线程安全的困难"></a>线程安全的困难</h2><h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><p>​    重排序现象：在单个线程当中，只要重排序不会对结果产生影响，则不能保证操作一定按照程序写定的顺序执行（java虚拟机的高性能）</p>
<p>​    如果数据需要跨线程共享，就要进行恰当的同步。</p>
<p><strong>过期数据</strong></p>
<p>​    当读线程检查一个变量时，可能看到一个过期的数据。并且过期不会发生在全部变量上，也不会完全不出现。</p>
<p>​    对于get与set方法，同样需要同步化，进行synchronize</p>
<p><strong>锁与可见性</strong></p>
<p>​    锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能看到共享的、可变变量的最新值，读取和写入线程必须使用公共的锁进行同步</p>
<p>​    volatile：弱同步，确保对一个变量的更新以可预见的方式告知其他线程</p>
<h3 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h3><p>​    发布：发布一个对象指它能够被当前范围以外的代码所使用。发布一个对象，同时将发布该对象所有的非私有域引用的对象。</p>
<p>​    逸出：一个对象在尚未准备好的时候就发布</p>
<p>发布方式：</p>
<ul>
<li>将对象存放到公共静态域</li>
</ul>
<p>逸出：</p>
<ul>
<li><p>this引用在构造期间逸出，即对象在没有通过构造函数构造完毕（执行到了构造函数的某一句）时候逸出。</p>
<p>当对象在构造函数当中创建一个线程，this引用总是被新线程共享，</p>
</li>
</ul>
<h2 id="线程不安全类与写法"><a href="#线程不安全类与写法" class="headerlink" title="线程不安全类与写法"></a>线程不安全类与写法</h2><p>线程不安全类：</p>
<ul>
<li>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</li>
<li>如果一个类的对象可以同时被多个线程访问，如果没有做并发处理，则会出现异常</li>
</ul>
<p>StringBuilder是线程不安全的。</p>
<p>StringBuffer是线程安全的，它内部方法添加了synchronized，但也因此它的性能有损耗。</p>
<p><strong>ArrayList、hashMap、hashSet等collection</strong></p>
<p>线程不安全</p>
<p><strong><em>示例</em></strong></p>
<p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    ThreadUnsafeExample example = <span class="keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h2><p>​    如果希望跨线程共享对象，则必须安全地共享它</p>
<p>​    对象的引用对其他线程可见，但它的状态可能是过期的，即对象的状态不一定对消费线程可见。</p>
<p><strong>安全发布的模式</strong></p>
<ul>
<li>通过静态初始化器初始化对象的引用（JVM内部的同步机制）</li>
<li>将它的引用存储到volatile域或者atomicReference</li>
<li>将它的引用存储到正确创建的对象的final域</li>
<li>或者将它的引用存储到由锁正确保护的域中</li>
</ul>
<p><strong>线程安全容器</strong></p>
<p>​    线程安全容器的内部同步，即将对象置入这些容器的操作符合最后一条要求</p>
<ul>
<li>HashTable、synchronizedMap、concurrentMap</li>
<li>Vector、CopyOnWriteArrayList、synchronizedList</li>
<li>BlockingQueue、concurrentLinkedQueue</li>
</ul>
<p><strong>高效不可变对象</strong></p>
<p>​    一个对象在技术上不是不可变得，但是它的状态在发布后不会再更改，即有效不可变对象。</p>
<blockquote>
<p>任何线程都可以在没有额外同步的情况下安全使用一个<strong>安全发布</strong>的高效不可变对象</p>
</blockquote>
<p><strong>可变对象</strong></p>
<p>​    安全发布仅仅保证发布当时的可见性，对于可变性，还需要线程安全或锁</p>
<ul>
<li><p>可变对象必须要安全发布，同时必须要线程安全或者是锁保护的</p>
<blockquote>
<ul>
<li>线程限制：一个线程限制的对象，通过限制在线程中，而被线程独占，且只能被占有它的线程修改</li>
<li>共享只读：在没有额外同步的情况下可以被多个对象并发访问，但是任何线程都不可以修改它，包括可变对象和高效不可变对象</li>
<li>共享线程安全：一个线程安全的对象在内部同步，所以其他线程无须额外同步，就可以通过公共接口访问</li>
<li>被守护的：一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布对象</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="线程安全实现方式："><a href="#线程安全实现方式：" class="headerlink" title="线程安全实现方式："></a>线程安全实现方式：</h2><h3 id="不可变-1"><a href="#不可变-1" class="headerlink" title="不可变"></a>不可变</h3><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>
<p>不可变的<strong>类型</strong>：</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
<p>不可变对象需要满足的<strong>条件</strong></p>
<ul>
<li>对象创建以后状态就不能修改<ul>
<li>将类声明为final</li>
</ul>
</li>
<li>对象所有域都是final类型<ul>
<li>所有域声明为私有</li>
<li>不通过set方法</li>
<li>将所有可变数据声明为final</li>
</ul>
</li>
<li>对象是正确创建的，this引用没有逸出<ul>
<li>通过构造器初始化所有成员</li>
<li>在get方法不直接返回对象本身，而是返回一个clone</li>
</ul>
</li>
</ul>
<p><strong>final关键字</strong>：类、方法、变量</p>
<ul>
<li>修饰类：<ul>
<li>不能被继承</li>
<li>所有成员方法会隐式选择为final</li>
</ul>
</li>
<li>修饰方法<ul>
<li>锁定方法不能被继承修改</li>
</ul>
</li>
<li>修饰变量<ul>
<li>基本数据类型变量</li>
<li>引用类型变量（初始化后，不能指向另一个对象）</li>
</ul>
</li>
</ul>
<p>其他创建不可变对象方法</p>
<ul>
<li>对于集合类型，Collections.unmodifiableXXX：Collection、List、Set、Map…</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//创建final的map</span></span><br><span class="line">        map = Collections.unmodifiableMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//会抛出异常, map无法被修改</span></span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>,map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将返回一个新的map，将数据拷贝过去，然后将所有更改数据转换为了抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Guava：ImmutableXXX：Collection、List、Set、Map…</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableList&lt;Integer&gt; list = ImmutableList.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableSet set = ImmutableSet.copyOf(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer,Integer&gt; map = ImmutableMap.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer,Integer&gt; map2 = ImmutableMap.&lt;Integer,Integer&gt;builder()</span><br><span class="line">            .put(<span class="number">1</span>,<span class="number">2</span>).put(<span class="number">3</span>,<span class="number">4</span>).put(<span class="number">5</span>,<span class="number">6</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        set.add(4);</span></span><br><span class="line"><span class="comment">//        map2.put(1,4);</span></span><br><span class="line">        System.out.println(map2.get(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥同步-1"><a href="#互斥同步-1" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>synchronized 和 ReentrantLock。</p>
<h3 id="非阻塞同步-1"><a href="#非阻塞同步-1" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<h4 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h4><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<h4 id="2-AtomicInteger"><a href="#2-AtomicInteger" class="headerlink" title="2. AtomicInteger"></a>2. AtomicInteger</h4><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p>
<p>以下代码使用了 AtomicInteger 执行了自增的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private AtomicInteger cnt = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">public void add() &#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p>
<p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ABA"><a href="#3-ABA" class="headerlink" title="3. ABA"></a>3. ABA</h4><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p>
<p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h3 id="无同步方案-1"><a href="#无同步方案-1" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><p>访问共享的、可变的数据要求使用同步。一个可以避免同步的方法就是不共享数据，如果数据仅仅在单线程当中访问，则不需要任何同步。当对象封装在一个线程当中，则自动成为线程安全的。</p>
<ul>
<li>Swing将事件分发到线程当中</li>
<li>JDBC从池中分配一个对象给线程。</li>
</ul>
<p><strong>线程封闭方法：</strong></p>
<ul>
<li><p>Ad-hoc线程封闭：程序控制实现，最糟糕。</p>
<ul>
<li>指维护线程限制性的任务全部落在实现上的情况</li>
<li>确保只通过单一线程写入共享的volatile变量，则操作便是共享</li>
</ul>
</li>
<li><p>堆栈封闭：局部变量，无并发问题。</p>
<ul>
<li><p>是线程限制的特例，只能通过本地变量才可以触及对象。本地变量使得对象更容易被限制在线程本地中<strong>，本地变量本身就被限制在执行线程</strong>中，它们存在于执行线程栈。其他线程无法访问这个栈</p>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>例如方法当中的numPairs。在该方法当中，实例化的animals只有一个引用指向它，因此它保存在线程的栈当中，倘若发布了animals或其内部对象的引用，则破坏了限制，并导致了对象逸出</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550587826303.png" alt="1550587826303"></p>
</li>
</ul>
</li>
</ul>
<h4 id="线程本地存储（Thread-Local-Storage）"><a href="#线程本地存储（Thread-Local-Storage）" class="headerlink" title="线程本地存储（Thread Local Storage）"></a>线程本地存储（Thread Local Storage）</h4><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<ul>
<li>ThreadLocal线程封闭：特别好的封闭方法。<ul>
<li>内部维护了一个map，key是线程名称，值是对象</li>
<li>更规范的方式，允许将每个线程与持有数值的对象关联在一起。ThradLocal提供了get和set，为每个使用它的线程维护一份单独的拷贝，所以get总是返回当前执行线程通过set设置的最新值。</li>
</ul>
</li>
</ul>
<blockquote>
<p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被<code>private static</code>修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
</blockquote>
<p>总的来说，<strong>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</strong></p>
<p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>为了理解 ThreadLocal，先看以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal1 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h5><p>它所对应的底层结构图为：</p>
<p><img src="assets/6782674c-1bfe-4879-af39-e9d722a95d39.png" alt="img"></p>
<p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get() 方法类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<h4 id="可重入代码（Reentrant-Code）"><a href="#可重入代码（Reentrant-Code）" class="headerlink" title="可重入代码（Reentrant Code）"></a>可重入代码（Reentrant Code）</h4><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h3 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h3><p>类别</p>
<ul>
<li>ArrayList-&gt;Vector、Stack</li>
<li>HashMap-&gt;HashTable</li>
<li>Collections.synchronizedXXX(List、Set、Map)<ul>
<li>collection的静态工厂创建</li>
</ul>
</li>
</ul>
<p>同步容器也未必线程安全</p>
<p>同步容器虽然保证了同一时刻只有一个线程可以访问，但是线程交替进行访问依然会出现问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">            vector.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//在size=10,i=9时刻,上面的线程将其删除,而此时读取则会出现异常</span></span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size()</span></span>; i++) &#123;</span><br><span class="line">            vector.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>原子性：Atomic包、CAS算法、synchronized、Lock</p>
<p>可见性：synchronized、volatile</p>
<p>有序性：happens-before</p>
<h1 id="待迁移"><a href="#待迁移" class="headerlink" title="待迁移"></a>待迁移</h1><h1 id="发布对象与逸出"><a href="#发布对象与逸出" class="headerlink" title="发布对象与逸出"></a>发布对象与逸出</h1><p>发布对象：发布一个对象指它能够被当前范围以外的代码所使用。发布一个对象，同时将发布该对象所有的非私有域引用的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafePublish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] states = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接获得了私有对象states的引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String[] getStates()&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UnsafePublish unsafePublish = <span class="keyword">new</span> UnsafePublish();</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">        <span class="comment">//发布states对象,无法确定其他线程是否会修改该对象的数据</span></span><br><span class="line">        <span class="comment">//因此在使用这个对象的数据的时候,无法完全确定对象里面的数据</span></span><br><span class="line">        <span class="comment">//即线程不安全的</span></span><br><span class="line">        unsafePublish.getStates()[<span class="number">0</span>] = <span class="string">"d"</span>;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象逸出：一个对象在尚未准备好的时候就发布，使得它被其他线程可见</p>
<p>逸出：</p>
<ul>
<li>this引用在构造期间逸出，即对象在没有通过构造函数构造完毕（执行到了构造函数的某一句）时候逸出。</li>
<li>当对象在构造函数当中创建一个线程，this引用总是被新线程共享.</li>
</ul>
<p>如果要在构造函数中创建线程</p>
<ul>
<li>使用工厂方法或者私有构造函数来完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Escape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> thisCanBeEscape = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Escape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//在这里启动了一个线程,新线程已经可以看到escape类的对象</span></span><br><span class="line">        <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//包含了对封装实例隐含的引用,在对象未构造完全就被发布</span></span><br><span class="line">            </span><br><span class="line">            log.info(<span class="string">"&#123;&#125;"</span>,Escape.<span class="keyword">this</span>.thisCanBeEscape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Escape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="安全发布对象的四种方法"><a href="#安全发布对象的四种方法" class="headerlink" title="安全发布对象的四种方法"></a>安全发布对象的四种方法</h1><ul>
<li>通过静态初始化器初始化对象的引用（JVM内部的同步机制）</li>
<li>将它的引用存储到volatile域或者atomicReference对象中</li>
<li>将它的引用存储到正确创建的对象的final域</li>
<li>或者将它的引用存储到由锁正确保护的域中</li>
</ul>
<h2 id="单例发布对象"><a href="#单例发布对象" class="headerlink" title="单例发布对象"></a>单例发布对象</h2><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><h4 id="线程不安全法"><a href="#线程不安全法" class="headerlink" title="线程不安全法"></a>线程不安全法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时候进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotRecommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="comment">//即其他途径无法创建这个类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//包含对资源的处理等等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingletonExample1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//多线程环境很容易出现问题</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双重检测机制</strong>(线程不安全)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式 --&gt; 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时候进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotRecommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2.ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3. instance = memory 设置instance 指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//JVM和CPU优化，发生了指令重排</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 3. instance = memory 设置instance 指向刚分配的内存</span></span><br><span class="line">    <span class="comment">// 2.ctorInstance() 初始化对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在第三步的时候,instance!=null</span></span><br><span class="line">    <span class="comment">//而此时在指令重排下,另一个线程就会获得一个没有初始化对象的引用,并将其返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123; <span class="comment">//双重检测机制          //B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4.class)&#123; <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4(); <span class="comment">//A - 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程安全法"><a href="#线程安全法" class="headerlink" title="线程安全法"></a><strong>线程安全法</strong></h4><p>不推荐法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="comment">//synchronized限制,而存在性能开销</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonExample3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双重同步锁</strong></p>
<p>基于volatile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式 --&gt; 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时候进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample5</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2.ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3. instance = memory 设置instance 指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象 volatitle+ 双重检测机制 -&gt; 禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonExample5 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingletonExample5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123; <span class="comment">//双重检测机制          //B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample5.class)&#123; <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample5(); <span class="comment">//A - 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>通过静态域实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在装载使用时候进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果构造方法中存在过多的功能,则在加载时会过慢,存在性能问题</span></span><br><span class="line">        <span class="comment">//只进行资源加载而没有实际调用,则会导致资源浪费</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过静态块实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class SingletonExample6 &#123;</span><br><span class="line"></span><br><span class="line">    //私有的构造函数</span><br><span class="line">    private SingletonExample6()&#123;&#125;</span><br><span class="line">	//静态资源是顺序执行的</span><br><span class="line">    //单例对象</span><br><span class="line">    private static SingletonExample6 instance = null;</span><br><span class="line">	//必须写在后面,如果写在前面,则会被上一句赋值为null</span><br><span class="line">    static &#123;</span><br><span class="line">        instance = new SingletonExample6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //静态的工厂方法</span><br><span class="line">    private static SingletonExample6 getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举模式：最安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Recommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//在实际使用的时候才会初始化</span></span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JVM保证这个方法绝对只调用一次</span></span><br><span class="line">        Singleton()&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/youzhidakeai/concurrency" target="_blank" rel="noopener">慕课网《Java并发编程入门与高并发面试 》课程学习</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/并发编程/" rel="tag"># 并发编程</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2019/03/01/Java/base/JVM：程序优化/" rel="next" title="JVM（5）：程序优化">
                <i class="fa fa-chevron-left"></i> JVM（5）：程序优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2019/03/02/OS/计算机操作系统：虚拟内存/" rel="prev" title="计算机操作系统（三）：虚拟内存">
                计算机操作系统（三）：虚拟内存 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">219</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">Kategorien</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">schlagwörter</span>
        
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#线程安全"><span class="nav-number">1.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java语言中的线程安全"><span class="nav-number">1.1.</span> <span class="nav-text">Java语言中的线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变"><span class="nav-number">1.1.1.</span> <span class="nav-text">不可变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绝对线程安全"><span class="nav-number">1.1.2.</span> <span class="nav-text">绝对线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相对线程安全"><span class="nav-number">1.1.3.</span> <span class="nav-text">相对线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程兼容"><span class="nav-number">1.1.4.</span> <span class="nav-text">线程兼容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程对立"><span class="nav-number">1.1.5.</span> <span class="nav-text">线程对立</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全的实现方法"><span class="nav-number">1.2.</span> <span class="nav-text">线程安全的实现方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥同步"><span class="nav-number">1.2.1.</span> <span class="nav-text">互斥同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非阻塞同步"><span class="nav-number">1.2.2.</span> <span class="nav-text">非阻塞同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无同步方案"><span class="nav-number">1.2.3.</span> <span class="nav-text">无同步方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可重入代码"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">可重入代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程本地存储"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">线程本地存储</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程安全-1"><span class="nav-number">2.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">2.1.</span> <span class="nav-text">概念</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程安全性"><span class="nav-number">3.</span> <span class="nav-text">线程安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原子性"><span class="nav-number">3.1.</span> <span class="nav-text">原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Atomic"><span class="nav-number">3.1.1.</span> <span class="nav-text">Atomic</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS核心"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">CAS核心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源码解析"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">源码解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS的ABA问题"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">CAS的ABA问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性：锁"><span class="nav-number">3.1.2.</span> <span class="nav-text">原子性：锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">Lock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性对比："><span class="nav-number">3.1.3.</span> <span class="nav-text">原子性对比：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#活跃度与性能"><span class="nav-number">3.1.4.</span> <span class="nav-text">活跃度与性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可见性"><span class="nav-number">3.2.</span> <span class="nav-text">可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number">3.2.2.</span> <span class="nav-text">volatile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序性"><span class="nav-number">3.3.</span> <span class="nav-text">有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#happens-before原则"><span class="nav-number">3.3.1.</span> <span class="nav-text">happens before原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程安全策略"><span class="nav-number">4.</span> <span class="nav-text">线程安全策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全的困难"><span class="nav-number">4.1.</span> <span class="nav-text">线程安全的困难</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可见性-1"><span class="nav-number">4.1.1.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发布和逸出"><span class="nav-number">4.1.2.</span> <span class="nav-text">发布和逸出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程不安全类与写法"><span class="nav-number">4.2.</span> <span class="nav-text">线程不安全类与写法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安全发布"><span class="nav-number">4.3.</span> <span class="nav-text">安全发布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全实现方式："><span class="nav-number">4.4.</span> <span class="nav-text">线程安全实现方式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变-1"><span class="nav-number">4.4.1.</span> <span class="nav-text">不可变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥同步-1"><span class="nav-number">4.4.2.</span> <span class="nav-text">互斥同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非阻塞同步-1"><span class="nav-number">4.4.3.</span> <span class="nav-text">非阻塞同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-CAS"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">1. CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-AtomicInteger"><span class="nav-number">4.4.3.2.</span> <span class="nav-text">2. AtomicInteger</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-ABA"><span class="nav-number">4.4.3.3.</span> <span class="nav-text">3. ABA</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无同步方案-1"><span class="nav-number">4.4.4.</span> <span class="nav-text">无同步方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程封闭"><span class="nav-number">4.4.4.1.</span> <span class="nav-text">线程封闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程本地存储（Thread-Local-Storage）"><span class="nav-number">4.4.4.2.</span> <span class="nav-text">线程本地存储（Thread Local Storage）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#底层原理"><span class="nav-number">4.4.4.2.1.</span> <span class="nav-text">底层原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可重入代码（Reentrant-Code）"><span class="nav-number">4.4.4.3.</span> <span class="nav-text">可重入代码（Reentrant Code）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步容器"><span class="nav-number">4.4.5.</span> <span class="nav-text">同步容器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#待迁移"><span class="nav-number">6.</span> <span class="nav-text">待迁移</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#发布对象与逸出"><span class="nav-number">7.</span> <span class="nav-text">发布对象与逸出</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安全发布对象的四种方法"><span class="nav-number">8.</span> <span class="nav-text">安全发布对象的四种方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单例发布对象"><span class="nav-number">8.1.</span> <span class="nav-text">单例发布对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#懒汉式"><span class="nav-number">8.1.1.</span> <span class="nav-text">懒汉式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程不安全法"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">线程不安全法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全法"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">线程安全法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#饿汉模式"><span class="nav-number">8.1.2.</span> <span class="nav-text">饿汉模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举模式"><span class="nav-number">8.1.3.</span> <span class="nav-text">枚举模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">9.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  











  
  <script>
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log(`Failed to save Visitor num, with error message: ${responseJSON.error}`);
              })
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! More info at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log(`LeanCloud Counter Error: ${responseJSON.code} ${responseJSON.error}`);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
                'X-LC-Key': 'uTVcNIWdMCGpicrhTKygpKXi',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
            const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
            if (localhost.test(document.URL)) return;
            addCount(Counter);
          
        });
    });
  </script>












  
<link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">
<script src="/lib/algolia-instant-search/instantsearch.min.js"></script>


<script src="/js/algolia-search.js?v=7.2.0"></script>














    
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
    appKey: 'uTVcNIWdMCGpicrhTKygpKXi',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn'
  });
</script>


</body>
</html>
