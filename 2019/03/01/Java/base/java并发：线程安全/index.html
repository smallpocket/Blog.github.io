<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    search: {
      root: '/',
      path: 'search.xml'
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="线程安全概念 线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。  即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这">
<meta name="keywords" content="并发编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发：线程安全">
<meta property="og:url" content="http://yoursite.com/2019/03/01/Java/base/Java并发：线程安全/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="线程安全概念 线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。  即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-08-05T00:54:27.720Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发：线程安全">
<meta name="twitter:description" content="线程安全概念 线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作， 调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。  即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这">
  <link rel="canonical" href="http://yoursite.com/2019/03/01/Java/base/Java并发：线程安全/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java并发：线程安全 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-top">
      
    

    <a href="/top/" rel="section"><i class="menu-item-icon fa fa-fw fa-signal"></i> <br>阅读排行</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>

</div>
    </header>

    

  <a href="https://github.com/smallpocket" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Java/base/Java并发：线程安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">Java并发：线程安全

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-01 15:42:55" itemprop="dateCreated datePublished" datetime="2019-03-01T15:42:55+08:00">2019-03-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-05 08:54:27" itemprop="dateModified" datetime="2019-08-05T08:54:27+08:00">2019-08-05</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">15k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">18 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="线程安全概念"><a href="#线程安全概念" class="headerlink" title="线程安全概念"></a>线程安全概念</h1><blockquote>
<p>线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作， <strong>调用这个对象的行为</strong>都可以获得正确的结果，那这个对象是线程安全的。</p>
</blockquote>
<p>即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这个并不容易做到。</p>
<p>因此一般将定义弱化一些,即将调用这个对象的行为限定为<strong>单次调用</strong>，若其他描述成立，则称它线程安全。</p>
<p>在一项工作进行前，会被不停中断与切换，对象的属性可能会在中断期间被修改和变脏。如何保证程序在计算机中准确无误地运行。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>编写线程安全的代码，本质上就是管理对<strong>状态</strong>的访问，而且通常都是<strong>共享、可变</strong>的状态。</p>
<p>一个对象的状态就是它的数据，存储在状态变量中，如静态域、实例域。共享即一个变量可以被多个线程访问。可变即变量的值在其生命周期内都可以改变。真正要做到的线程安全是在不可控制的并发访问当中保护数据。</p>
<p>无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。</p>
<p>java的同步机制：synchronized(独占锁)，volatile、显示锁和原子变量的使用</p>
<p>修复同步隐患</p>
<ul>
<li>不跨线程的共享变量</li>
<li>使用状态变量为不可变的</li>
<li>在任何访问状态变量的时候使用同步</li>
</ul>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>当我们在一个无状态对象中增加一个状态时，例如增加一个命中计数器count++来统计所处理的请求数量。</p>
<p>但是在多线程下，这种自增操作可能会丢失一些更新操作，该语句会转换为多个字节码指令，包含3个独立的操作：读取、修改、写入。其结果状态依赖于之前的状态。</p>
<p>而多线程在没有同步的情况下对一个count进行操作，如果初始值为0，则可能会出现每个线程读取得到的指都时0，之后进行递增操作，并将计数器的值设为1，之后写入。在这个过程中丢失了一次更改。</p>
<p>在Web服务中，命中计数器的少量偏差是我们可以接受的， 但是如果我们是在生成唯一的对象标识符，那么将导致严重的问题。</p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><blockquote>
<p>竞态条件：由于不恰当的执行时序而出现不正确的结果，即结果的出现依赖于线程的执行顺序</p>
</blockquote>
<p>当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件。即正确的结果依赖于运气</p>
<p><strong><em>常见场景</em></strong></p>
<ul>
<li>先检查后执行，即检查-修改。然鹅在检查-修改的中间时间，观察结果可能会失效，从而导致各种问题<ul>
<li>延迟初始化，确保只初始化一次。在多线程下可能会初始多次。</li>
</ul>
</li>
</ul>
<p>竞态条件并不总是产生错误，需要某种不恰当的执行时序。</p>
<h3 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h3><blockquote>
<p>数据竞争：如果在访问共享的非final类型的域时没有采用同步来进行协同，那么就会出现数据竞争。当一个线程写入一个变量而另一个线程接下来读取这个变量，或者读取一个之前由另一个线程写入的变量时，并且在这两个线程间没有使用同步，就可能会出现数据竞争。</p>
<p>如果代码存在数据竞争，那么这段代码就没有确定的语义</p>
</blockquote>
<p>并非所有的竞态条件都是数据竞争，也并非所有的数据竞争都是竞态条件，但二者都可能导致并非程序失败。</p>
<h3 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h3><p>要避免竞态条件，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。</p>
<blockquote>
<p><strong>原子操作</strong>：假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说就是原子的。</p>
<p>原子操作是指，对于访问同一个状态的所有操作(包括操作本身)来说，这个操作是一个以原子方式执行的操作。</p>
</blockquote>
<h2 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h2><p>当在Servlet中添加了一个状态变量，可以通过线程安全的对象来管理Servlet的状态来维护其线程安全性，但是当想在Servlet添加更多的状态，是否只需要增加更多的线程安全状态变量就可以了。</p>
<p>然而尽管两个状态变量都是安全的，但是对两个安全的状态变量进行操作并不一定是安全的，即它们独立的操作都是原子的，而对它们两个的操作是两个原子操作，在两次操作间存在空隙，因此不是一个原子操作，而存在竞态条件。</p>
<blockquote>
<p>要保证状态的一致性，就需要在单个原子操作中更新所有相关的状态变量</p>
</blockquote>
<h3 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h3><p>Java提供了一种内置的锁机制来支持原子性，即同步代码块<code>synchronized</code>，同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。之所以内置锁只是为了免去显式创建锁对象，</p>
<p>以synchronized修饰的方法是一种横跨整个方法体的同步代码块，锁就是方法调用所在的对象。静态的synchronized以Class对象为锁。</p>
<p>每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁或监视器锁(Monitor)。获得内置锁的唯一途径就是进入由整个锁保护的同步代码块或方法。</p>
<p>而内置锁的存在使得线程安全变得简单，但是却过于极端，导致服务的响应性会很低，即一个性能问题。</p>
<h3 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h3><p>当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞，然而由于内置锁可重入，即当某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。</p>
<p>重入意味着锁的操作粒度是线程，而不是调用。重入的一种实现是为每个锁关联一个获取计数值和一个所有者线程，当计数值为0时，这个锁被认为是没有被任何线程持有，当线程请求一个未被持有的锁时，JVM记录锁的持有者，并将计数器+1。</p>
<p>重入使得子类如果重写了父类的<code>synchronized</code>方法，之后调用父类的方法不会产生死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">log</span> <span class="keyword">extends</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">do</span>();</span><br><span class="line">    &#125;	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为两个do都时<code>synchronized</code>的，因此每个方法都会在执行前获取Widget的锁，如果不可重入，则当调用<code>super.do</code>时会阻塞。而重入避免了该情况</p>
<h2 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h2><p>锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问，只要始终遵循这些协议就能保持状态的一致性。</p>
<p>访问共享状态的复合操作都必须是原子操作以避免产生竞态条件，如果在复合操作中持有一个锁，则会使得复合操作称为原子操作。仅仅将复合操作封装到一个同步代码块中是不够的，如果使用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。</p>
<p>常见的<strong>错误</strong>是只有在写入共享变量时才需要使用同步。</p>
<blockquote>
<p>对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，这种情况下我们称状态变量是由这个锁保护的。</p>
</blockquote>
<blockquote>
<p>每个共享的和可变的变量都应该只有一个锁来保护，从而使维护人员知道是哪一个锁</p>
</blockquote>
<p>一种常见的加锁约定是将所有的可变状态都封装在对象内部，帮通过对象的内置锁对所有访问可边状态的代码路径进行同步，使得在该对象上不会发生并发访问。但是这种模式不会得到强制，即如果在添加新的方法时忘记使用了同步，则加锁协议就被破坏了。</p>
<blockquote>
<p>对于包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护</p>
</blockquote>
<h2 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h2><p>对于Servlet，如果通过Servlet对象的内置锁保护每一个状态变量，即对整个service方法进行同步，这种简单且粗粒度的方法能确保线程安全性，但是代价很高。service如果同步了，则每次只能有应该线程可以执行，背离了Servlet的初衷，即需要能同时处理多个请求，在负载过高的情况下将给用户带来糟糕的体验。</p>
<p><strong>不良并发应用程序</strong>：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。</p>
<p>通过缩小同步代码块的作用范围可以很容易做到既确保Servlet的并发性，同时又维护线程安全性。要确保同步代码块不要过小，并且不要将本应时原子的操作拆分到多个同步代码块中，<strong>应</strong>尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。</p>
<p>应当在程序中使用一种同步机制，两种不同的同步机制会带来混乱，并且不会在性能或安全性上带来任何好处，例如在<code>synchronized</code>中使用<code>Atomic</code>。</p>
<p><strong><em>判断同步代码块的合理大小</em></strong>。需要权衡安全性、简单性、性能。</p>
<blockquote>
<p>通常，在简单性和性能间存在相互制约因素。当实现某个同步策略时，一定不要盲目地未了性能而牺牲简单性(可能会破坏安全性)</p>
</blockquote>
<p>当使用锁时，应当清楚代码块中实现地功能，以及在执行该代码块时是否需要很长时间。如果需要，则都会带来活跃性或性能问题。</p>
<blockquote>
<p>当执行时间较长地计算或者可能无法快速完成地操作时，例如网络IO或IO，一定不要持有锁。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>编写线程安全的代码，本质上就是管理对<strong>状态</strong>的访问，而且通常都是<strong>共享、可变</strong>的状态。<ul>
<li><strong>动机</strong>：无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。<ul>
<li>要保证状态的一致性，就需要在单个原子操作中更新所有相关的状态变量</li>
<li>并不仅仅是只需要在写入地时候需要同步</li>
<li>每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁(封装在对象中)</li>
</ul>
</li>
</ul>
</li>
<li>同步将使得性能降低。判断同步代码块地合理大小<ul>
<li>当执行时间较长地计算或者可能无法快速完成地操作时，例如网络IO或IO，一定不要持有锁。</li>
</ul>
</li>
<li>加锁的机制不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</li>
</ul>
<h1 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h1><p>如何共享和发布对象，从而使它们能够安全地由多个线程同时访问。并且实现内存可见性。</p>
<blockquote>
<p>内存可见性：希望确保当一个线程修改了对象状态后，其他线程能够看到发生地状态变化。</p>
</blockquote>
<h2 id="线程安全级别"><a href="#线程安全级别" class="headerlink" title="线程安全级别"></a>线程安全级别</h2><p>线程安全限定于多个线程间存在共享数据访问这个前提，如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度看，程序是串行执行还是多线程执行对它没有区别</p>
<p>依照线程安全的<strong>安全程度</strong>排序来看，Java中各种操作共享的数据分为以下5类：</p>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>final对象，不可边的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要采用任何的线程安全保障措施。</p>
<p>只要一个不可变的对象被正确地构建出来(this引用没有逃逸)，那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程中处于不一致的状态。</p>
<ul>
<li>对于一个<strong>数据类型</strong>，只需要在定义时使用final即可</li>
<li>对于一个<strong>对象</strong>，则需要保证对象的行为不糊对其状态产生任何影响才行。例如String，subString会返回一个新的字符串，对其本身没有影响。</li>
</ul>
<h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>指完全满足定义。即使一个类的所有方法都时被synchronized修饰的，也不意味着调用它永远都不需要同步手段了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread removeThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)&#123;</span><br><span class="line">            vector.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread printThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)&#123;</span><br><span class="line">            System.out.println(vector.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    removeThread.start();</span><br><span class="line">    printThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例当中，依然时线程不安全的，当remove刚好删除一个元素，导致序号i已经不可用，此时去访问数组会抛出ArrayIndexOutOfBoundsException</p>
<p>而要改为绝对安全则需要将<code>synchronized(vector)</code></p>
<h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>保证单次调用下，线程是安全的，对于特定顺序的连续调用，则可能需要使用额外的同步手段。Java中的大多数线程安全类都属于该类型</p>
<h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>对象本身并不是线程安全，但可以在调用端正确使用同步手段来保证对象在并发环境可以安全使用。一般常说类不是线程安全的绝大部分是指该情况。</p>
<h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>无论调用端是否采用了同步措施，都无法在多线程环境并发使用的代码。</p>
<p>例如Thread的<code>suspend()</code>与<code>resume()</code>，如果两个线程同时持有一个线程对象，一个尝试中断线程，另一个尝试恢复线程。当并发进行时，无论调用是否同步，目标线程都存在死锁风险。</p>
<h2 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h2><p>导致共享变量在线程间不可见的原因</p>
<ul>
<li>线程交叉执行</li>
<li>重排序结合线程交叉执行</li>
<li>共享变量更新后的值没有在工作内存与主内存间及时更新</li>
</ul>
<p>因为我认为这块属于JMM方面，因此详情查看<strong>Java并发：JMM</strong></p>
<h2 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h2><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>发布对象：发布一个对象指它能够被当前作用域以外的代码所使用。发布一个对象，同时将发布该对象所有的非私有域引用的对象。</p>
<p>发布对象的场景：例如将应该指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。</p>
<p>很多情况下，我们确保对象及其内部状态不被发布。而某些情况下，我们又需要发布某个对象，如果在发布时要确保线程安全，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。不安全发布的<strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafePublish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] states = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接获得了私有对象states的引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String[] getStates()&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UnsafePublish unsafePublish = <span class="keyword">new</span> UnsafePublish();</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">        <span class="comment">//发布states对象,无法确定其他线程是否会修改该对象的数据</span></span><br><span class="line">        <span class="comment">//因此在使用这个对象的数据的时候,无法完全确定对象里面的数据</span></span><br><span class="line">        <span class="comment">//即线程不安全的</span></span><br><span class="line">        unsafePublish.getStates()[<span class="number">0</span>] = <span class="string">"d"</span>;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>发布对象的方法</em></strong></p>
<ul>
<li>将对象的引用保存在应该公有的静态变量中，以便任何类和线程都能看到该对象。</li>
</ul>
<h3 id="逸出"><a href="#逸出" class="headerlink" title="逸出"></a>逸出</h3><p>对象逸出：一个对象在尚未准备好的时候就发布，使得它被其他线程可见。</p>
<p>逸出会破坏线程安全性，当应该对象逸出后，你必须假设有某个类或线程可能会误用对象，这正是使用封装的最主要原因。封装能够使得对程序的正确性进行分析变得可能，使得无意中破坏涉及约束条件变得更难。</p>
<p>逸出：</p>
<ul>
<li>this引用在构造期间逸出，即对象在没有通过构造函数构造完毕（执行到了构造函数的某一句）时候逸出。<ul>
<li>当对象在构造函数当中创建一个线程，this引用总是被新线程共享</li>
<li>当发布一个内部的类的实例，也会隐式发布了实例本身，因为内部类的实例中包含了对其原类的实例的隐含引用</li>
</ul>
</li>
</ul>
<p>如果要在构造函数中创建线程</p>
<ul>
<li>使用<strong>工厂方法</strong>或者<strong>私有构造函数</strong>来完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//在这里启动了一个线程,新线程已经可以看到escape类的对象		</span></span><br><span class="line">        listener = <span class="keyword">new</span> EventListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>&#123;</span><br><span class="line">                <span class="keyword">do</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">       SafeListener safe = <span class="keyword">new</span> SafeListener();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>访问共享的、可变的数据要求使用同步。一个可以避免同步的方法就是<strong>不共享数据</strong>。当对象封装在一个线程当中，则自动成为线程安全的。即使被封闭的对象本身不是线程安全的。</p>
<blockquote>
<p>线程封闭：如果数据仅仅在单线程当中访问，则不需要任何同步</p>
</blockquote>
<p>Java中并没有强制规定某个变量必须由锁来保护，同样在Java语言中也无法强制将对象封闭在某个线程中，Java通过使用局部变量和ThreadLocal实现。</p>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p><strong><em>示例</em></strong></p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<ul>
<li>Swing将事件分发到线程当中</li>
<li>JDBC从池中分配一个对象给线程。</li>
</ul>
<h3 id="线程封闭方法："><a href="#线程封闭方法：" class="headerlink" title="线程封闭方法："></a>线程封闭方法：</h3><blockquote>
<p>Ad-hoc线程封闭：维护线程封闭性完全由程序实现来承担。</p>
</blockquote>
<p>程序控制实现，最糟糕。因为没有任何一种语言特性能够将对象封闭到目标线程上。</p>
<p>volatile存在一种特殊的线程访问，确保只通过单一线程写入共享的volatile变量，则操作便是共享</p>
<blockquote>
<p>堆栈封闭：局部变量，无并发问题。</p>
</blockquote>
<p>是线程限制的特例，只能通过局部变量才可以触及对象。本地变量使得对象更容易被限制在线程本地中<strong>，本地变量本身就被限制在执行线程</strong>中，它们存在于执行线程栈。其他线程无法访问这个栈</p>
<p>堆栈封闭比Ad-hoc更易于维护，也更健壮。JVM保证了基本类型的局部变量始终封闭在堆栈中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>例如下面方法当中的numPairs。在该方法当中，实例化的animals只有一个引用指向它，因此它保存在线程的栈当中，确保了不会破坏栈封闭性。倘若发布了animals或其内部对象的引用，则破坏了限制，并导致了对象逸出。</p>
<p>如果在线程内部上下文使用非线程安全的对象，那么该对象仍然时线程安全的，但是只有开发代码的人员才知道那些对象需要被封闭到执行线程中，以及被封闭的对象是否线程安全，如果没有明确说明，则后续维护很容易使得对象逸出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span></span>&#123;</span><br><span class="line">	SortedSet&lt;Animal&gt; animals;</span><br><span class="line">    <span class="keyword">int</span> numPairs = <span class="number">0</span>;</span><br><span class="line">    Animal candidate = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    animals = <span class="keyword">new</span> TreeSet&lt;Animal&gt;(<span class="keyword">new</span> SpeciesGenderComparator());</span><br><span class="line">    animals.addAll(candidates);</span><br><span class="line">    <span class="keyword">for</span>(Animal a : animals)&#123;</span><br><span class="line">        <span class="keyword">if</span>(candidate == <span class="keyword">null</span> || !candidate.isPotentialMate(a))&#123;</span><br><span class="line">            candidate = a;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ark.load(<span class="keyword">new</span> AnimalPair(candidate, a));</span><br><span class="line">            ++numPairs;</span><br><span class="line">            candidate = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numPairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ThreadLocal：使得线程中的某个值与保存值的对象关联起来。</p>
</blockquote>
<ul>
<li>ThreadLocal线程封闭：特别好的封闭方法。<ul>
<li>内部维护了一个map，key是线程名称，值是对象</li>
<li>更规范的方式，允许将每个线程与持有数值的对象关联在一起。ThradLocal提供了get和set，为每个使用它的线程维护一份单独的拷贝，所以get总是返回当前执行线程通过set设置的最新值。</li>
</ul>
</li>
<li>通常用于防止对可变的单实例变量或者全局变量进行共享。</li>
</ul>
<p>ThreadLocal提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的<strong>实例副本</strong>。ThreadLocal 变量通常被<code>private static</code>修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
<p>总的来说，<strong>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</strong>。可以使用 <code>java.lang.ThreadLocal</code> 类来实现线程本地存储功能。</p>
<p><strong><em>应用</em></strong></p>
<ul>
<li>当某个频繁执行的操作需要一个临时对象，例如缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用该技术。</li>
<li>如果将单线程的应用程序移植到多线程中，通过将共享的全局变量转换为Th’readLoacl对象(如果全局变量的语义允许)，可以维持线程安全性。</li>
<li>例如JDBC的全局连接不是线程安全的，因此将其保存到ThreadLocal当中，每个线程拥有属于自己的副本。</li>
</ul>
<p><strong><em>缺陷</em></strong></p>
<p>ThreadLocal会降低代码的可重用性，并在类间引入隐含的耦合性。</p>
<p><strong><em>示例</em></strong></p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>
<p>在不可变对象的内部仍可以使用可变对象来管理它们的状态。但这些可变对象对外而言是不可变的。</p>
<blockquote>
<p>除非需要更高的可见性，否则应将所有的域都声明为私有域</p>
<p>除非需要某个域是可变的，否则应将其声明为final域</p>
</blockquote>
<p>不可变的<strong>类型</strong>：</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
<p>不可变对象需要满足的<strong>条件</strong></p>
<ul>
<li>对象创建以后状态就不能修改<ul>
<li>将类声明为final</li>
</ul>
</li>
<li>对象所有域都是final类型<ul>
<li>所有域声明为私有</li>
<li>不设置set方法</li>
<li>将所有可变数据声明为final</li>
</ul>
</li>
<li>对象是正确创建的，this引用没有逸出<ul>
<li>通过构造器初始化所有成员</li>
<li>在get方法不直接返回对象本身，而是返回一个clone</li>
</ul>
</li>
</ul>
<p><strong>final关键字</strong>：类、方法、变量</p>
<p>final确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。</p>
<ul>
<li>修饰类：<ul>
<li>不能被继承</li>
<li>所有成员方法会隐式选择为final</li>
</ul>
</li>
<li>修饰方法<ul>
<li>锁定方法不能被继承修改</li>
</ul>
</li>
<li>修饰变量<ul>
<li>基本数据类型变量</li>
<li>引用类型变量（初始化后，不能指向另一个对象）</li>
</ul>
</li>
</ul>
<p>其他创建不可变对象方法</p>
<ul>
<li>对于集合类型，Collections.unmodifiableXXX：Collection、List、Set、Map…</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//创建final的map</span></span><br><span class="line">        map = Collections.unmodifiableMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//会抛出异常, map无法被修改</span></span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>,map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将返回一个新的map，将数据拷贝过去，然后将所有更改数据转换为了抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Guava：ImmutableXXX：Collection、List、Set、Map…</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableList&lt;Integer&gt; list = ImmutableList.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableSet set = ImmutableSet.copyOf(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer,Integer&gt; map = ImmutableMap.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer,Integer&gt; map2 = ImmutableMap.&lt;Integer,Integer&gt;builder()</span><br><span class="line">            .put(<span class="number">1</span>,<span class="number">2</span>).put(<span class="number">3</span>,<span class="number">4</span>).put(<span class="number">5</span>,<span class="number">6</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        set.add(4);</span></span><br><span class="line"><span class="comment">//        map2.put(1,4);</span></span><br><span class="line">        System.out.println(map2.get(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h2><p>当某些情况下希望在多个线程间共享对象，此时必须确保安全地进行共享。</p>
<h3 id="不正确的发布"><a href="#不正确的发布" class="headerlink" title="不正确的发布"></a>不正确的发布</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Holder holder</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initHolder</span><span class="params">()</span></span>&#123;</span><br><span class="line">	holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码会存在可见性问题，其他线程看到地Holder对象将处于不一致地状态，即使在该对象地构造函数中已经正确地构建了不变性条件，这种不正确的发布会使得其他线程看到尚未创建完成的对象。未被正确发布的对象存在两个问题：</p>
<ul>
<li>除了发布对象的线程外，其他线程可以看到的Holder域是一个失效值，因此将看到一个空引用或之前的旧值</li>
<li>线程看到Holder引用的值是最新的，但Holder状态的值是失效的，即可能线程第一次读取域时得到失效值，再次读取这个域会得到一个更新值。</li>
</ul>
<h3 id="不可变对象与初始化安全性"><a href="#不可变对象与初始化安全性" class="headerlink" title="不可变对象与初始化安全性"></a>不可变对象与初始化安全性</h3><p>JMM为不可对象的共享提供了一种特殊的初始化安全性保证。</p>
<p>即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说</p>
<h3 id="安全发布的常用模式"><a href="#安全发布的常用模式" class="headerlink" title="安全发布的常用模式"></a>安全发布的常用模式</h3><h3 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h3><h3 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h3><h3 id="安全地共享对象"><a href="#安全地共享对象" class="headerlink" title="安全地共享对象"></a>安全地共享对象</h3><h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><blockquote>
<p>同步指多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个(或一些)线程使用。</p>
<p>互斥是实现同步的一种手段。</p>
</blockquote>
<p>互斥同步最主要的问题是进行线程阻塞与唤醒带来的性能问题。悲观的并发策略。</p>
<ul>
<li>临界区、互斥量、信号量都是主要互斥实现方法。</li>
<li>synchronized关键字：需要系统帮助完成</li>
<li>J.U.C包下的重入锁，例如ReentrantLock</li>
</ul>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>由于硬件指令集的发展而出现。基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，则采用其他补偿措施（例如不断重试，直到成功）。</p>
<p>由于该方法大多实现不需要将线程挂起，即称为非阻塞同步。</p>
<ul>
<li>测试并设置 Test and Set</li>
<li>获取并增加 Fetch and Increment</li>
<li>交换 Swap</li>
<li>比较并交换 Compare and Swap     CAS<ul>
<li>ABA问题，如果要解决ABA问题可以使用Atomic，但是可能互斥同步更高效一些。</li>
</ul>
</li>
<li>加载链接/条件存储 Load-Linked/Store-Conditional     LL/SC</li>
</ul>
<h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>对于一些方法本身不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此由一些代码天生就是线程安全的。</p>
<h4 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h4><p>即纯代码。不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<p>如果一个方法，它的返回结果时可以预测的，即只要输入了相同的数据，就能返回相同的结果。那么就满足可重入的要求。</p>
<h4 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h4><p>如果一段代码中所需要的数据必须与其他代码共享，那就看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，就可以将共享数据的可见范围限制在同一个线程内，这样无须同步也能保证线程间不会出现数据争用的问题。</p>
<p>例如大部分消费队列的架构模式都会将产品的消费过程尽量在一个线程中消费完，例如一个请求对应一个服务器线程的处理方式。</p>
<p>通过ThreadLocal实现。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>线程安全的实现方式:</p>
<ul>
<li>线程封闭。包括堆栈封闭、ThreadLocal</li>
<li>互斥同步</li>
<li>非阻塞同步</li>
<li>可重入代码</li>
<li>final</li>
</ul>
<p>原则</p>
<ul>
<li>可见性</li>
<li>原子性</li>
<li>有序性</li>
</ul>
<p>需要注意</p>
<ul>
<li>线程逸出的风险</li>
</ul>
<h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><p>原子性：Atomic包、CAS算法、synchronized、Lock</p>
<p>可见性：synchronized、volatile</p>
<p>有序性：happens-before</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/youzhidakeai/concurrency" target="_blank" rel="noopener">慕课网《Java并发编程入门与高并发面试 》课程学习</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/并发编程/" rel="tag"># 并发编程</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2019/03/01/Java/base/JVM：类文件与类加载/" rel="next" title="JVM：类文件与类加载">
                <i class="fa fa-chevron-left"></i> JVM：类文件与类加载
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2019/03/02/OS/计算机操作系统：虚拟内存/" rel="prev" title="计算机操作系统（三）：虚拟内存">
                计算机操作系统（三）：虚拟内存 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">204</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#线程安全概念"><span class="nav-number">1.</span> <span class="nav-text">线程安全概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子性"><span class="nav-number">1.2.</span> <span class="nav-text">原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#竞态条件"><span class="nav-number">1.2.1.</span> <span class="nav-text">竞态条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据竞争"><span class="nav-number">1.2.2.</span> <span class="nav-text">数据竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复合操作"><span class="nav-number">1.2.3.</span> <span class="nav-text">复合操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加锁机制"><span class="nav-number">1.3.</span> <span class="nav-text">加锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内置锁"><span class="nav-number">1.3.1.</span> <span class="nav-text">内置锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重入"><span class="nav-number">1.3.2.</span> <span class="nav-text">重入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用锁来保护状态"><span class="nav-number">1.4.</span> <span class="nav-text">用锁来保护状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#活跃性与性能"><span class="nav-number">1.5.</span> <span class="nav-text">活跃性与性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象的共享"><span class="nav-number">2.</span> <span class="nav-text">对象的共享</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全级别"><span class="nav-number">2.1.</span> <span class="nav-text">线程安全级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变"><span class="nav-number">2.1.1.</span> <span class="nav-text">不可变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绝对线程安全"><span class="nav-number">2.1.2.</span> <span class="nav-text">绝对线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相对线程安全"><span class="nav-number">2.1.3.</span> <span class="nav-text">相对线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程兼容"><span class="nav-number">2.1.4.</span> <span class="nav-text">线程兼容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程对立"><span class="nav-number">2.1.5.</span> <span class="nav-text">线程对立</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存可见性"><span class="nav-number">2.2.</span> <span class="nav-text">内存可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发布与逸出"><span class="nav-number">2.3.</span> <span class="nav-text">发布与逸出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发布"><span class="nav-number">2.3.1.</span> <span class="nav-text">发布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逸出"><span class="nav-number">2.3.2.</span> <span class="nav-text">逸出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程封闭"><span class="nav-number">2.4.</span> <span class="nav-text">线程封闭</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程封闭方法："><span class="nav-number">2.4.1.</span> <span class="nav-text">线程封闭方法：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不变性"><span class="nav-number">2.5.</span> <span class="nav-text">不变性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安全发布"><span class="nav-number">2.6.</span> <span class="nav-text">安全发布</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不正确的发布"><span class="nav-number">2.6.1.</span> <span class="nav-text">不正确的发布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变对象与初始化安全性"><span class="nav-number">2.6.2.</span> <span class="nav-text">不可变对象与初始化安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全发布的常用模式"><span class="nav-number">2.6.3.</span> <span class="nav-text">安全发布的常用模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事实不可变对象"><span class="nav-number">2.6.4.</span> <span class="nav-text">事实不可变对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变对象"><span class="nav-number">2.6.5.</span> <span class="nav-text">可变对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全地共享对象"><span class="nav-number">2.6.6.</span> <span class="nav-text">安全地共享对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全的实现方法"><span class="nav-number">2.7.</span> <span class="nav-text">线程安全的实现方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥同步"><span class="nav-number">2.7.1.</span> <span class="nav-text">互斥同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非阻塞同步"><span class="nav-number">2.7.2.</span> <span class="nav-text">非阻塞同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无同步方案"><span class="nav-number">2.7.3.</span> <span class="nav-text">无同步方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可重入代码"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">可重入代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程本地存储"><span class="nav-number">2.7.3.2.</span> <span class="nav-text">线程本地存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">2.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结-2"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">23:08</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        




  <script>
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=66458302";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  























  <script src="/js/local-search.js?v=7.2.0"></script>














</body>
</html>
