<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    search: {
      root: '/',
      path: 'search.xml'
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="数据库 Redis服务器的数据库实现： 服务器保存数据库的方法。 客户端切换数据库的方法。 数据库保存键值对的方法。 数据库的增删改查的实现方法。 服务器保存键的过期时间的方法。 服务器自动删除过期键的方法。 Redis2.8数据库通知功能的实现。    服务器中的数据库Redis服务器将所有数据库保存在服务器状态redis.h/redisServer中： 123456struct redisSe">
<meta name="keywords" content="NoSQL,Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis：单机数据库的实现">
<meta property="og:url" content="http://yoursite.com/2019/03/04/数据库/Redis：单机数据库的实现/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数据库 Redis服务器的数据库实现： 服务器保存数据库的方法。 客户端切换数据库的方法。 数据库保存键值对的方法。 数据库的增删改查的实现方法。 服务器保存键的过期时间的方法。 服务器自动删除过期键的方法。 Redis2.8数据库通知功能的实现。    服务器中的数据库Redis服务器将所有数据库保存在服务器状态redis.h/redisServer中： 123456struct redisSe">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/assets/1552468398778.png">
<meta property="og:image" content="http://yoursite.com/assets/1552468706260.png">
<meta property="og:image" content="http://yoursite.com/assets/1552468722522.png">
<meta property="og:image" content="http://yoursite.com/assets/1552468871546.png">
<meta property="og:image" content="http://yoursite.com/assets/1552468919035.png">
<meta property="og:image" content="http://yoursite.com/assets/1552469157583.png">
<meta property="og:image" content="http://yoursite.com/assets/1552470569474.png">
<meta property="og:image" content="http://yoursite.com/assets/1552470819774.png">
<meta property="og:image" content="http://yoursite.com/assets/1552470946418.png">
<meta property="og:image" content="http://yoursite.com/assets/1566436870819.png">
<meta property="og:image" content="http://yoursite.com/assets/1566400379933.png">
<meta property="og:image" content="http://yoursite.com/assets/1566403644529.png">
<meta property="og:image" content="http://yoursite.com/assets/1566437953284.png">
<meta property="og:image" content="http://yoursite.com/assets/1566435828805.png">
<meta property="og:image" content="http://yoursite.com/assets/1566435854117.png">
<meta property="og:updated_time" content="2019-08-22T01:39:35.818Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis：单机数据库的实现">
<meta name="twitter:description" content="数据库 Redis服务器的数据库实现： 服务器保存数据库的方法。 客户端切换数据库的方法。 数据库保存键值对的方法。 数据库的增删改查的实现方法。 服务器保存键的过期时间的方法。 服务器自动删除过期键的方法。 Redis2.8数据库通知功能的实现。    服务器中的数据库Redis服务器将所有数据库保存在服务器状态redis.h/redisServer中： 123456struct redisSe">
<meta name="twitter:image" content="http://yoursite.com/assets/1552468398778.png">
  <link rel="canonical" href="http://yoursite.com/2019/03/04/数据库/Redis：单机数据库的实现/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Redis：单机数据库的实现 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-top">
      
    

    <a href="/top/" rel="section"><i class="menu-item-icon fa fa-fw fa-signal"></i> <br>阅读排行</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>

</div>
    </header>

    

  <a href="https://github.com/smallpocket" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/数据库/Redis：单机数据库的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">Redis：单机数据库的实现

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-04 18:37:09" itemprop="dateCreated datePublished" datetime="2019-03-04T18:37:09+08:00">2019-03-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-22 09:39:35" itemprop="dateModified" datetime="2019-08-22T09:39:35+08:00">2019-08-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">14k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">25 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul>
<li>Redis服务器的数据库实现：<ul>
<li>服务器保存数据库的方法。</li>
<li>客户端切换数据库的方法。</li>
<li>数据库保存键值对的方法。</li>
<li>数据库的增删改查的实现方法。</li>
<li>服务器保存键的过期时间的方法。</li>
<li>服务器自动删除过期键的方法。</li>
<li>Redis2.8数据库通知功能的实现。</li>
</ul>
</li>
</ul>
<h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis服务器将所有数据库保存在服务器状态redis.h/redisServer中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//一个数组，保存着服务器中所有的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">//服务器中的数据库数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>每个redis客户端都有自己的目标数据库，即写命令的操作对象，默认为0号数据库。</p>
<p>执行select 2（需要转换到的数据库，即db[2]）命令可切换目标数据库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>;</span>&#123;</span><br><span class="line">    <span class="comment">//记录客户端当前使用的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure>

<h2 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h2><p>Redis是一个键值对数据库服务器，服务器每一个数据库都是由一个redisDb表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//数据库键空间，保存着数据库中所有的键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure>

<p>键空间与用户所见的数据库是直接对应的，键空间的键就是数据库的键，键空间的值就是数据库的值。</p>
<p>数据库的键空间是一个字典，所以所有针对数据库的操作都是通过对键空间的字典进行操作来实现的。</p>
<p><strong>添加新键</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="built_in">date</span> <span class="string">"222"</span></span><br></pre></td></tr></table></figure>

<p><strong>删除键</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del date</span><br></pre></td></tr></table></figure>

<p><strong>更新键</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="built_in">date</span> <span class="string">"balst"</span></span><br></pre></td></tr></table></figure>

<p><strong>取值</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get date</span><br></pre></td></tr></table></figure>

<p>等命令。</p>
<p><strong>读写键空间的维护操作</strong></p>
<p>当使用Redis命令对数据库进行读写，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作：</p>
<ul>
<li>读取一个键后，服务器会根据键是否存在来更新服务器的键空间命中次数或不命中次数。</li>
<li>读取一个键后，服务器会更新键LRU时间，用于计算键的闲置时间。</li>
<li>服务器在读取一个键时发现该键已经过期，服务器会先删除这个过期键，然后才执行余下的其他操作。</li>
<li>如果有客户端使用Watch监视了某个键，服务器在对该键进行修改后，会将这个键标记为脏，从而让事务注意到这个键已经被修改。</li>
<li>服务器每次修改一个键后，都会对脏键计数器++，这个计数器会触发服务器的持久化以及复制操作。</li>
<li>如果服务器开启了数据库通知功能，那么在对键进行修改后，服务器将按配置发送给相应的数据库通知。</li>
</ul>
<h2 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h2><p>使用EXPIRE命令或者PEXPIRE，以毫秒或秒的精度为数据库的某个键设置生存时间。在经过指定的时间，服务器会自动删除生存时间为0的键。</p>
<p>以Expireat或PExpireat为键设置过期时间，当过期时间来临，自动删除该键。</p>
<p><strong>保存过期时间</strong></p>
<p>redisDb结构中的expires字典保存了数据库中所有键的过期时间，称为过期字典。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict *expires;<span class="comment">//值是long long类型的整数，保存这个键指向的数据库键的过期时间</span></span><br></pre></td></tr></table></figure>

<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设置过期时间：expire &lt;key&gt; &lt;ttl&gt;</span><br><span class="line">删除过期时间：persist &lt;key&gt;</span><br><span class="line">获取剩余过期时间：ttl &lt;key&gt;</span><br></pre></td></tr></table></figure>

<p><strong>过期键判定</strong></p>
<ul>
<li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</li>
<li>检查当前UNIX时间戳是否大于键的过期时间，如果是则键已过期。</li>
</ul>
<h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>如果一个键过期了，那么它什么时候会被删除呢：</p>
<ul>
<li>定时删除：<ul>
<li>在设置键的过期时间的同时，创建一个定时器，让定时器在过期时间来临时，立即执行对键的删除操作。</li>
<li>CPU时间不友好，可能占用相当一部分的CPU时间。</li>
<li>创建一个定时器需要时间事件，而时间事件的实现方式是无序链表，不能高效处理大量时间事件。</li>
</ul>
</li>
<li>惰性删除：<ul>
<li>放任键过期不管，每次从键空间获取键时，都检查获得的键是否过期。</li>
<li>对内存最不友好，可能导致内存泄漏。</li>
</ul>
</li>
<li>定期删除：<ul>
<li>每隔一段时间，就对数据库进行一次检查，删除里面的过期键。删除的数量以及检查多少数据库由算法决定。</li>
</ul>
</li>
</ul>
<h2 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h2><p>采用惰性删除与定期删除两种策略：</p>
<ul>
<li>惰性删除：读写操作前判断ttl，如过期则删除。</li>
<li>定期删除：在redis定时事件中随机抽取部分key判断ttl。<ul>
<li>函数运行时从一定量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</li>
<li>全局变量记录当前函数检查的进度，下一次调用时会接着上一次的进度处理，即上次到了10号数据库，下次从11号数据库开始。</li>
<li>不断迭代，直到所有数据库都检查一次，开始再次迭代。</li>
</ul>
</li>
</ul>
<p>特点：</p>
<ul>
<li>并不一定是按照设置事件准时地过期。</li>
<li>定期删除的时候会判断过期比例，达到阈值才会退出。</li>
</ul>
<p>建议打散key的过期事件，避免大量key在同一时间点过期。</p>
<h2 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h2><p>过期键对Redis服务器中其他模块的影响。</p>
<p><strong>生成RDB文件</strong></p>
<p>SAVE命令或BGSAVE命令创建一个新的RDB文件时，已过期的键不会被保存到新创建的RDB文件中。</p>
<p>是经过压缩的二进制格式，fork子进程dump可能会造成瞬间卡顿。</p>
<p><strong>载入RDB文件</strong></p>
<p>在启动Redis服务器，如果开启了RDB功能，服务器会对RDB文件载入：</p>
<ul>
<li>如果服务器以主服务器模式运行，那么载入RDB文件时，过期键将会忽略。</li>
<li>如果以从服务器运行，文件中所有键，不管是否过期，都会载入到数据库中。<ul>
<li>主从服务器进行数据同步时，从服务器的数据库就会被清空，因此过期键对从服务器也不会造成影响。</li>
</ul>
</li>
</ul>
<p><strong>AOF文件写入</strong></p>
<p>当服务器以AOF持久化模式运行时，如果键已经过期，但没有删除，那么AOF文件不会因为这个过期键产生任何影响。</p>
<p>当过期键被删除后，程序会向AOF文件追加DEL命令，以显式记录该键已经被删除。</p>
<ul>
<li>先写aof缓存，再同步到aof文件。</li>
<li>AOF重写，达到阈值时触发，减少文件大小。</li>
</ul>
<p><strong>AOF重写</strong></p>
<p>已过期的键不会被保存到重写后的AOF文件中。</p>
<p><strong>复制</strong></p>
<p>当服务器允许在复制模式下，从服务器的过期键删除动作由主服务器控制：</p>
<ul>
<li>主服务器在删除一个过期键后，会显式向所有从服务器发送一个DEL命令。</li>
<li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将其删除，而是继续像处理未过期键一样处理。</li>
<li>从服务器只有在接到主服务器的DEL命令才会删除过期键。<ul>
<li>实现了主从数据库的数据一致性。</li>
</ul>
</li>
</ul>
<p><strong>应用</strong></p>
<p>利用AOF文件容灾。可以将数据恢复到最近3天任意小时粒度。</p>
<h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>Redis2.8，可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</p>
<ul>
<li><p>键空间通知，关注某个键执行了什么命令。</p>
<ul>
<li><p><code>SUBSCRIBE _keyspace@0_:message</code></p>
</li>
<li><p>当键执行了set命令，则返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;message&quot; </span><br><span class="line">&quot;_keyspace@0_:message&quot;</span><br><span class="line">&quot;set&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>键事件通知，关注某个命令被什么键执行了。</p>
<ul>
<li><p><code>SUBSCRIBE _keyevent@0_:del</code>订阅所有的del行为。</p>
</li>
<li><p>当key1被删除了：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;message&quot; </span><br><span class="line">&quot;_keyspace@0_:del&quot;</span><br><span class="line">&quot;key1&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>服务的<code>notify-keyspace-events</code>选项决定了服务器所发送通知的类型。</p>
<ul>
<li>AKE：让服务器发送所有类型的键空间通知和键事件通知。</li>
<li>AK：发送所有类型的键空间通知。</li>
<li>AE：发送所有类型的键事件通知。</li>
<li>K$：只发送和字符串键有关的键空间通知。</li>
<li>El：只发送和列表键有关的键事件通知。</li>
</ul>
<h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><p>通知功能由notify.c/notifyKeyspaceEvent函数实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>type：想要发送的通知的类型。判断是否是服务器允许发送的通知。</li>
<li>event：事件的名称。</li>
<li>key：产生事件的键。</li>
<li>dbid：产生事件的数据库号码。</li>
</ul>
<p>发送通知的实现：</p>
<ul>
<li>如果给定的通知不是服务器允许发送的通知，则直接返回。</li>
<li>发送键空间通知<ul>
<li>将通知发送到频道<em>keyspace@dbid\</em>:&lt;key&gt;。</li>
<li>内容为键所发生的事件&lt;event&gt;</li>
<li>构建频道命中。</li>
<li>发送通知。等同于执行PUBLISH。</li>
</ul>
</li>
<li>发送键事件通知。<ul>
<li>将通知发送到频道<em>keyevent@dbid\</em>:&lt;key&gt;。</li>
<li>内容为发生事件的键&lt;key&gt;</li>
<li>构建频道名称。</li>
<li>发送通知。等同于执行PUBLISH。</li>
</ul>
</li>
</ul>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>redis所有数据保持在内存中，对数据的更新将异步地保存到磁盘当中。</p>
<ul>
<li>启动优先级：RDB低，AOF高（AOF可以保存最新的数据）。</li>
<li>体积：RDB小，其是二进制。AOF大，是日志形式。</li>
<li>恢复速度：RDB快，AOF慢。</li>
<li>数据安全性：RDB<strong>丢数据</strong>，AOF根据策略决定。</li>
<li>轻重：RDB重，AOF轻。</li>
</ul>
<p>最佳策略：</p>
<ul>
<li>小分片。一个Redis进程不要分配太大内存。</li>
</ul>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，每个非空数据库又可以包含任意个键值对。</p>
<p>数据库状态：服务器中的非空数据库以及它们的键值对。</p>
<p>Redis是内存数据库，将数据库状态存储在内存当中，如果服务器进程一旦退出，则数据库状态也会消失不见。</p>
<p>因此提供了RDB持久化功能，<strong>将Redis在内存当中的数据库状态保存到磁盘当中</strong>。</p>
<ul>
<li>RDB持久化既可以手动，也可以根据服务器配置定期执行。将某个时间点上的数据库状态保存到一个RDB文件中。</li>
<li>RDB持久化功能生成的RDB文件是一个压缩的二进制文件。</li>
</ul>
<h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><ul>
<li>生成命令：SAVE于BGSAVE：<ul>
<li>SAVE是同步的，会阻塞Redis服务器进程，直到RDB文件创建完毕为止。</li>
<li>BGSAVE是一个异步命令，会<code>fork()</code>一个子进程，子进程负责创建RDB文件，服务器进程继续处理命令。</li>
<li>如果存在老的RDB文件，则会覆盖。</li>
</ul>
</li>
</ul>
<p>RDB文件的载入时在服务器启动时自动执行，只要检测到RDB文件，就会自动载入。在载入文件期间，服务器一直处于阻塞状态。</p>
<p>与AOF对比：</p>
<ul>
<li>AOF文件的更新频率通常比RDB文件更新频率高，因此：<ul>
<li>如果服务器开启了AOF持久化功能，服务器会优先使用AOF文件来还原数据库状态。</li>
<li>只有在AOF持久化功能处于关闭状态，服务器才会使用RDB文件来还原数据库状态。</li>
</ul>
</li>
</ul>
<h3 id="自动间隔保存"><a href="#自动间隔保存" class="headerlink" title="自动间隔保存"></a>自动间隔保存</h3><p>Redis允许用户通过服务器配置save选项，让服务器每隔一段时间自动执行一次BGSAVE。</p>
<h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p>结构：</p>
<p><img src="/assets/1552468398778.png" alt="1552468398778"></p>
<ul>
<li>RDB文件保存的是二进制数据，而不是C字符串。</li>
<li>REDIS：长度为5字节，通过检测该字符，快速检查所载入的文件是否为RDB文件。</li>
<li>db_version：4字节，是一个字符串表示的整数，记录了RDB文件版本号。</li>
<li>database：包含0或任意个数据库，以及各个数据库中的键值对数据。</li>
<li>EOF：长度为1字节，表示正文内容结束。</li>
<li>check_sum：一个8字节长的无符号整数，保存一个校验和，通过对前4部分计算得出。服务器载入RDB文件时，会将载入数据计算得出的校验和与check_sum进行比较，以检查文件是否出错或损坏。</li>
</ul>
<p><strong>database部分</strong></p>
<p>如果0号与3号数据库非空，则：</p>
<p><img src="/assets/1552468706260.png" alt="1552468706260"></p>
<p>每个非空数据库在RDB文件中的保存：</p>
<p><img src="/assets/1552468722522.png" alt="1552468722522"></p>
<ul>
<li>SELECTDB：长度为1字节，表示接下来读取的是一个数据库号码。</li>
<li>db_number：保存着一个数据库号码，长度1、2、5字节，当读取到的时候，服务器使用select进行数据库切换。</li>
<li>key_value_pairs保存所有键值对数据。</li>
</ul>
<p><strong>key_value_pairs</strong></p>
<p>如果键值对带有过期时间，则也会保存在内。不带过期时间的表示：</p>
<p><img src="/assets/1552468871546.png" alt="1552468871546"></p>
<p><img src="/assets/1552468919035.png" alt="1552468919035"></p>
<ul>
<li>TYPE：对象类型或者底层编码，决定如何读入和解释value数据。</li>
<li>key：字符串对象。</li>
<li>EXPIRETIME_MS：1字节，表示接下来将读取一个过期时间，以毫秒为单位。</li>
<li>ms：8字节带符号整数，记录一个毫秒为单位的UNIX时间戳。</li>
</ul>
<p><strong>value的编码</strong></p>
<p>不同类型的值对象在RDB文件中的保存结构：</p>
<ul>
<li><p>字符串对象</p>
</li>
<li><p>列表对象</p>
</li>
<li><p>集合对象</p>
</li>
<li><p>哈希表对象</p>
</li>
<li><p>有序集合对象</p>
</li>
</ul>
<h3 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h3><h3 id="应用策略"><a href="#应用策略" class="headerlink" title="应用策略"></a>应用策略</h3><p>关闭。但如果主从复制的话，则需要RDB写入。</p>
<p>集中管理。RDB对数据备份具有作用，其文件较小，作为快照也容易管理。</p>
<p>主从，从开。</p>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>通过保存Redis服务器所执行的写命令来记录数据库状态。</p>
<p><img src="/assets/1552469157583.png" alt="1552469157583"></p>
<p>写入的命令都是以Redis的命令请求协议格式保存的。</p>
<h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>功能实现分为：命令追加、文件写入、文件同步三个步骤。</p>
<p><strong>命令追加</strong></p>
<p>当服务器执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾。</p>
<p><strong>文件写入与同步</strong></p>
<ul>
<li>文件写入：只是写入到了内存缓冲区，可能还没有写到文件所拥有的磁盘数据块上。</li>
<li>文件同步：将缓冲区中的内容冲洗到磁盘上。</li>
</ul>
<p>Redis服务器进程就是一个事件循环，在循环中的：</p>
<ul>
<li>文件事件负责接收客户端的命令请求，以及向客户端发送命令恢复。</li>
<li>时间事件负责执行像serverCron函数这样需要定时运行的函数。</li>
</ul>
<p>服务器在处理文件事件时可能执行写命令，使得一些内容被追加到aof_buf缓冲区，因此服务器每次结束一个事件循环前，都会调用函数，考虑是否将aof_buf缓冲区里的内容写入和保存到AOF文件中。</p>
<p><img src="/assets/1552470569474.png" alt="1552470569474"></p>
<p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值决定：</p>
<ul>
<li>值为always，将缓冲区内所有内容写入并同步到AOF文件。</li>
<li>默认为everysec，将缓冲区内所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过1S，则再次对AOF文件进行同步。</li>
<li>no，将缓冲区内所有内容写入并同步到AOF文件，但并不进行同步，何时同步由操作系统决定。</li>
</ul>
<h3 id="AOF文件载入与数据还原"><a href="#AOF文件载入与数据还原" class="headerlink" title="AOF文件载入与数据还原"></a>AOF文件载入与数据还原</h3><p><img src="/assets/1552470819774.png" alt="1552470819774"></p>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>随着服务器允许，AOF文件内容与体积会越来越大，可能会对服务器造成影响，并且文件太大会使得AOF文件进行数据还原时间太长。</p>
<p>AOF文件重写：创建一个新的AOF文件替代现有的AOF文件，新旧的AOF保存的数据库状态相同，但是新的AOF文件不包含任何浪费空间的冗余指令。</p>
<p>冗余指令：</p>
<p><img src="/assets/1552470946418.png" alt="1552470946418"></p>
<p><strong>AOF文件重写的实现</strong></p>
<p>通过读取服务器当前数据的状态来实现。</p>
<p><strong>AOF后台重写</strong></p>
<p>因为Redis使用单个线程处理命令请求，如果由服务器调用重写，则会无法处理客户端命令请求：</p>
<p>使用子进程进行重写。</p>
<ul>
<li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以避免在使用锁的情况下，保证数据的安全性。</li>
<li>在AOF重写期间，可能会出现对现有数据库状态的修改。<ul>
<li>设置AOF重写缓冲区，当Redis执行完一个写命令，会将命令同时发送给AOF缓冲区与AOF重写缓冲区。</li>
<li>当子进程完成AOF后，向父进程发送信号，将AOF重写缓冲区所有内容写入新AOF文件。</li>
<li>替换原有的AOF文件。</li>
</ul>
</li>
</ul>
<h3 id="应用策略-1"><a href="#应用策略-1" class="headerlink" title="应用策略"></a>应用策略</h3><p>开。对服务器压力不是很大。</p>
<p>everysec执行。</p>
<h2 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h2><p>CPU：</p>
<ul>
<li>RDB和AOF文件生成，属于CPU密集型。</li>
<li>优化：不做CPU绑定，不和CPU密集型部署。</li>
</ul>
<p>内存：</p>
<ul>
<li>fork内存开销， copy-on-write。</li>
<li>不要和高硬盘负载服务部署在一起：存储服务、消息队列等。</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>Redis服务器是一个事件驱动程序，需要处理一下两类事件：</p>
<ul>
<li>文件事件：Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，服务器通过监听并处理这些事件完成一系列的网络通信操作。</li>
<li>时间事件：需要在给定的时间点执行的操作。</li>
</ul>
<p><img src="/assets/1566436870819.png" alt="1566436870819"></p>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>Redis基于Reactor模式开发了自己的网络事件处理器，这个处理器被称为文件事件处理器。</p>
<ul>
<li>文件事件处理器使用IO多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接accept、read、write、close等操作时，与操作相对应的文件事件就会产生，此时文件事件就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>文件事件处理器将IO事件监听与事件执行分离，保持了Redis内部单线程设计的简单性。</p>
<h3 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h3><p><img src="/assets/1566400379933.png" alt="1566400379933"></p>
<p>服务器通常会连接多个套接字，因此多个文件事件有可能会并发地出现。</p>
<p>尽管会并发地出现，但是IO多路复用程序总是会将所有产生事件的套接字都放到有关队列中，然后通过这个队列，以有序、同步、每次有关套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕后，IO多路复用程序才会继续传送下一个套接字。</p>
<p>文件事件分派器会接收IO多路复用程序传来的套接字，根据套接字产生的事件类型调用相应的事件处理器。</p>
<p>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器时一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。</p>
<h3 id="IO多路复用程序的实现"><a href="#IO多路复用程序的实现" class="headerlink" title="IO多路复用程序的实现"></a>IO多路复用程序的实现</h3><p>其所有功能都是通过包装select、epoll、evport和kqueue这些IO多路复用函数库来实现的。</p>
<h3 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h3><p>IO多路复用程序可以监听多个套接字的ae.h/AE_READABLE事件和ae.h/AE_WRITABLE事件。</p>
<ul>
<li>当套接字变得可读时（即客户端对套接字执行write事件，或执行close操作，<strong>即Redis读取客户端的写入</strong>），或有新的可应答套接字出现时（客户端对服务器的监听套接字执行connect），套接字产生AE_READABLE事件。</li>
<li>当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件。</li>
</ul>
<p>IO多路复用程序允许服务器同时监听套接字的AE_READABLE事件与AE_WRITABLE事件，如果应该套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE处理完毕才会处理AE_WRITABLE。</p>
<p>即如果套接字可读又可写，则先处理读套接字，再处理写套接字。</p>
<h3 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h3><p>Redis为文件事件编写了多个处理器，分别用于实现不同的网络通信需求：</p>
<ul>
<li>为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</li>
<li>为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</li>
<li>为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令恢复处理器。</li>
<li>当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</li>
</ul>
<p><strong><em>连接应答处理器</em></strong></p>
<ul>
<li>当Redis服务器进行初始化时，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来。</li>
<li>当有客户端连接服务器监听套接字时，就会产生AE_READABLE事件。</li>
<li>引发连接应答处理器执行并执行相应的套接字应答操作。</li>
</ul>
<p><strong><em>命令请求处理器</em></strong></p>
<p>负责从套接字中读入客户端发送的命令请求内容。</p>
<ul>
<li>当一个客户端向服务器发送命令请求时，就会产生AE_READABLE事件。</li>
<li>引发命令请求处理器执行，并执行相应的套接字读入操作。</li>
<li>在客户端连接服务器的整个过程当中，服务器会一直为客户端套接字的AE_READABLE事件关联命令请求处理器。</li>
</ul>
<p><strong><em>命令回复处理器</em></strong></p>
<p>负责将服务器执行命令后得到的命令回复通过套接字返回给客户端。</p>
<ul>
<li>当有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来。</li>
<li>当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件。</li>
<li>引发命令回复处理器执行，并执行相应的套接字写入操作。</li>
<li>命令回复发送完毕后，服务器就会解除命令回复处理器与客户端套接字的AE_WRITABLE事件间的关联。</li>
</ul>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis的时间事件分为两类，其类型取决于时间事件处理器的返回值：</p>
<ul>
<li>定时事件：让一个程序在指定的时间后执行一次。<ul>
<li>时间处理器返回ae.h/AE_NOMORE即为定时事件，执行一次后就删除。Redis暂时不使用。</li>
</ul>
</li>
<li>周期性事件：让一段程序每隔一段时间就执行一次。<ul>
<li>非AE_NOMORE的整数值，则该值为每次执行的时间间隔。</li>
</ul>
</li>
</ul>
<p>一个时间事件主要有以下三个属性：</p>
<ul>
<li>id：服务器为时间事件创建的全局唯一ID，新事件的ID&gt;旧事件的ID。</li>
<li>when：毫秒精度的UNIX时间戳，记录了时间事件的到达事件。</li>
<li>timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器去处理事件。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>服务器将所有的时间事件都放在一个无序链表当中，每当事件事件执行器运行时，就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<p>新的时间事件总会插入在表头，即按ID逆序排序。</p>
<p>正常情况下的时间事件只有serverCron，即链表大小非常小，不会影响性能。</p>
<h3 id="ServerCron"><a href="#ServerCron" class="headerlink" title="ServerCron"></a>ServerCron</h3><p>Redis服务器需要对自身的资源和状态进行自检和调整，从而保证服务器可以长期、稳定的运行，而这些操作由serverCron负责执行。</p>
<ul>
<li>更新服务器的各类统计信息，比如是时间、内存占用、数据库占用情况等。</li>
<li>清理数据库中的过期键值对。</li>
<li>关闭和清理连接失效的客户端。</li>
<li>尝试进行AOF或RDB持久化操作。</li>
<li>如果服务器是主服务器，那么对从服务器进行定期同步。</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试。</li>
</ul>
<p>可以通过修改hz选项调整每秒执行次数。Redis2.6执行次数为10次/s。</p>
<h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>Redis需要考虑何时处理文件事件，何时处理时间事件，花多少时间处理它们等等。</p>
<p>事件的调度与执行由ae.c/aeProcessEvents负责，其处理流程为：</p>
<ul>
<li>获取到达时间离当前时间最接近的时间事件。</li>
<li>计算最接近的时间事件距离到达还要多少毫秒。</li>
<li>如果事件已经到达，那么时间可能为负数，则将它设定为0.</li>
<li>根据remaind_ms的值，创建timeval结构。</li>
<li>阻塞并等待文件事件的产生，最大阻塞时间由传入的timeval结构决定。<ul>
<li>如果remaind_ms==0，则非阻塞，aeApiPoll调用后立即返回。</li>
<li>这个设计避免了忙等待，也确保不会阻塞太长时间。</li>
</ul>
</li>
<li>处理所有已经产生的文件事件。</li>
<li>处理所有已到达的时间事件。</li>
</ul>
<p>所有的事件处理都是<strong>同步、有序、原子</strong>执行的，不会中途中断事件处理，也不会抢占，因此事件处理器都会尽可能减少程序阻塞事件，并在有时候需要主动让出执行权避免事件饥饿的可能性。</p>
<p>若将一个命令回复写入到客户端套接字，如果写入字节超过预设常量就会主动break跳出，将余下数据留到下次再写。时间事件将持久化操作放入到了子进程当中。</p>
<p><img src="/assets/1566403644529.png" alt="1566403644529"></p>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>Redis服务器是典型的一对多服务器程序：一个程序可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器接收并处理客户端发送的命令请求，并向客户端返回命令回复。</p>
<p>通过使用由IO多路复用技术实现的文件事件处理器，Redis使用单线程单进程处理命令，并与多个客户端进行网络通信。</p>
<p>对于每个要连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient，其保存了客户端当前的状态信息，以及执行相关功能时需要的数据结构：</p>
<ul>
<li>客户端的套接字描述符。</li>
<li>客户端的名字。</li>
<li>客户端的标志值flag。</li>
<li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li>
<li>客户端当前要指向的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li>
<li>客户端的输入缓冲区和输出缓冲区。</li>
<li>客户端的复制状态信息，以及进行复制所需的数据结构。</li>
<li>客户端指向BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li>
<li>客户端的事务状态，以及执行watch命令时用到的数据结构。</li>
<li>客户端执行发布与订阅功能时用到的数据结构。</li>
<li>客户端的身份验证标志。</li>
<li>客户端的创建事件，客户端和服务器的最后一次通信的事件，以及客户端的输出缓冲区大小超出<strong>软性限制</strong>的时间。</li>
</ul>
<p>客户端的结构属性是一个链表，保存了所有与服务器连接的客户端的状态，要对客户端执行批量操作、对指定客户端操作都可以通过遍历它来完成。</p>
<h2 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h2><ul>
<li>通用的属性。</li>
<li>与特定功能相关的属性。操作数据库需要用到的db属性和dictid属性，执行事务时要用到的mstate属性，执行watch命令需要用到的watched_keys属性等。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd;	<span class="comment">//记录客户端正在使用的套接字描述符。</span></span><br><span class="line">    robj *name;<span class="comment">//客户端名称。</span></span><br><span class="line">    <span class="keyword">int</span> flags;<span class="comment">//客户端的角色，以及客户端当前所处的状态。</span></span><br><span class="line">    sds querybuf;<span class="comment">//输入缓冲区，保存客户端发送的命令请求。</span></span><br><span class="line">    robj **argv;<span class="comment">//命令参数。</span></span><br><span class="line">    <span class="keyword">int</span> argc;<span class="comment">//命令参数的个数。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span><span class="comment">//命令的实现函数，根据argv[0]确定。</span></span><br><span class="line">    <span class="keyword">char</span> buf[REDIS_REPLY_CHUNK_BYTES];<span class="comment">//固定大小的缓冲区，默认值16KB</span></span><br><span class="line">    <span class="keyword">int</span> bufpos;<span class="comment">//记录了buf数组目前已经使用的字节数量。</span></span><br><span class="line">    <span class="built_in">list</span> *reply;<span class="comment">//可变大小的缓冲区。</span></span><br><span class="line">    <span class="keyword">int</span> authenticated;<span class="comment">//身份验证状态。</span></span><br><span class="line">    <span class="keyword">time_t</span> ctime;<span class="comment">//客户端创建时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastinteraction;<span class="comment">//客户都安与服务器最后一次交互时间</span></span><br><span class="line">    <span class="keyword">time_t</span> obuf_soft_limit_reached_time;<span class="comment">//记录输出缓冲区第一次到达软性限制的时间。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>套接字描述符</em></strong></p>
<p>不同的客户端类型fd的值不同。</p>
<ul>
<li>伪客户端值为-1，伪客户端处理的命令请求来源于AOF或Lua脚本，而不是网络，因此不需要套接字连接。<ul>
<li>载入AOF文件还原数据库状态。执行LUA脚本。</li>
</ul>
</li>
<li>普通客户端的值&gt;-1的整数。</li>
</ul>
<p><strong><em>名字</em></strong></p>
<p>默认情况下客户端是没有名字的。</p>
<p>使用client setname可以设置名称。</p>
<p><strong><em>标志</em></strong></p>
<p>flags的值可以伪单个标志，也可以是多个标志的或语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = &lt;flag1&gt; [| &lt;flag2&gt; ...]</span><br></pre></td></tr></table></figure>

<p>每个标志用一个常量来表示，一部分标志记录了客户端的角色。</p>
<ul>
<li>主从复制时，主服务器会成为从服务器的客户端，从服务器也会成为主服务器的客户端。Redis_Maser标志客户端代表的是一个主服务器，Redis_Server代表客户端是一个从服务器。</li>
<li>Redis_PRE_Psync代表客户端版本低于Redis2.8，不可用Psync进行同步。</li>
<li>Redis_Lua_Client标识客户端是专门用于处理Lua脚本的伪客户端。</li>
<li>Redis_Force_AOF强制服务器将当前执行的命令写入到AOF文件。</li>
<li>….</li>
</ul>
<p><strong><em>输入缓冲区</em></strong></p>
<p>用于保存客户端发送的命令请求。</p>
<p>输入缓冲区会根据输入内容动态扩容或缩小，但最大大小不能超过1GB，否则将关闭该客户端。</p>
<p><strong><em>命令与命令参数</em></strong></p>
<p>服务器对缓冲区的内容进行分析，将参数与参数个数分别保存到客户端状态的argv和argc属性。</p>
<p><strong><em>命令的实现函数</em></strong></p>
<p>服务器将根据argv[0]的值在命令表当中查找命令所对应的命令实现函数。</p>
<p><strong><em>输出缓冲区</em></strong></p>
<p>每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个大小是可变的：</p>
<ul>
<li>固定大小的缓冲区用于保存长度较小的回复，如OK、错误回复等。默认大小16KB。</li>
<li>可变大小的缓冲区用于保存长度较大的回复。<ul>
<li>当固定大小缓冲区不可用时使用。</li>
</ul>
</li>
</ul>
<p><strong><em>身份验证</em></strong></p>
<p>authenticated用于记录客户端是否通过了身份验证。</p>
<p>如果值为0，则未通过，否则代表已经通过。此时只有AUTH命令可执行，其他都会被拒绝。</p>
<p><strong><em>时间</em></strong></p>
<h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h2><p>如果客户端是通过网络连接与服务器进行连接的普通客户都安，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器建立相应的客户端状态。</p>
<p><strong><em>关闭客户端</em></strong></p>
<p>客户端可用因为多种原因被关闭：</p>
<ul>
<li>客户端进程退出或被杀死。</li>
<li>客户端向服务器发送了带有不符合协议格式的命令请求。</li>
<li>客户端成为了Client kill命令的目标。</li>
<li>用户为服务器设置了timeout配置项，当空转时间超过timeout，则会被关闭。<ul>
<li>如果主从复制正在被BLPOP等命令阻塞，或在执行Subscribe等订阅命令，即使客户端空转也不会被服务器关闭。</li>
</ul>
</li>
<li>客户端发送的命令请求大小超过了输入缓冲区的限制（默认1GB）。</li>
<li>要发送给客户端的命令回复超过了输出缓冲区的限制大小。Redis使用了两种模式限制其大小：<ul>
<li>硬性限制：如果大小超过了硬性限制，则立即关闭。</li>
<li>软性限制：输出缓冲区的大小超过了软性但没有超过硬性，则将记录下其到达软性限制的起始时间，并继续监视客户端，如果一直超出软性限制并持续时间超过服务器设定的时长，则关闭客户端。</li>
</ul>
</li>
</ul>
<p><strong>Lua脚本的伪客户端</strong>：在服务器初始化时创建，并一直存在。</p>
<p><strong>AOF文件的伪客户端</strong>：服务器在载入AOF文件时，会创建用于执行AOF文件中redis命令的伪客户端，在载入完成后会关闭。</p>
<h2 id="客户端连接池Jedis"><a href="#客户端连接池Jedis" class="headerlink" title="客户端连接池Jedis"></a>客户端连接池Jedis</h2><p>客户端是线程池，而redis是单线程，即客户端与redis建立多个连接。</p>
<p><img src="/assets/1566437953284.png" alt="1566437953284"></p>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源关联来维持服务器自身的运转。</p>
<h2 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h2><p>当使用客户端执行：<code>set key value</code>，则服务器与客户端的操作有：</p>
<ul>
<li>客户端向服务器发送命令请求<code>set key value</code>。</li>
<li>服务器接收并处理客户端发来的命令请求<code>set key value</code>，在数据库中进行设置操作，并产生命令回复OK。</li>
<li>服务器将命令回复OK发送给客户端。</li>
<li>客户端接收服务器返回的命令回复OF，并将这个回复打印。</li>
</ul>
<h3 id="发送、读取命令请求"><a href="#发送、读取命令请求" class="headerlink" title="发送、读取命令请求"></a>发送、读取命令请求</h3><p>客户端会首先将这个命令转换伪协议格式，然后将命令发送，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n</span><br></pre></td></tr></table></figure>

<p>客户端的写入导致连接套接字可读，服务器将调用命令请求处理器来执行以下操作：</p>
<ul>
<li>读取套接字当中的协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里。</li>
<li>对输入缓冲区内的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性中。</li>
<li>调用命令执行器，执行客户端指定的命令。</li>
</ul>
<h3 id="命令执行器"><a href="#命令执行器" class="headerlink" title="命令执行器"></a>命令执行器</h3><p><strong><em>查找命令实现</em></strong></p>
<ul>
<li>根据argv[0]参数，在命令表（字典）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性中。</li>
</ul>
<p>redis的redisCommand结构：</p>
<p><img src="/assets/1566435828805.png" alt="1566435828805"></p>
<p>sflags可用的标志值：</p>
<p><img src="/assets/1566435854117.png" alt="1566435854117"></p>
<p>对于set命令，器函数伪setCommand，命令参数个数为-3，接收3个或以上的参数。命令标识符为“wm”，标识是一个写入命令，并在执行前服务器需要对占用内存进行检查，因为该命令可能占用大量内存。</p>
<p><strong><em>执行预备操作</em></strong></p>
<p>程序需要进行一些预备操作保证命令可正确、顺利地被执行。</p>
<ul>
<li>检查客户端状态的cmd指针是否执行NULL，如果是即找不到相应命令。</li>
<li>根据redisCommand的arity检查给定参数个数是否正确，如果不正确不执行后续步骤。</li>
<li>检查客户端是否通过了身份验证，如果没有只能执行AUTH。</li>
<li>如果服务器打开了maxmemory，则执行命令前先检查内存占用，并在有需要时进行内存回收。</li>
<li>如果服务器上一次执行BGSAVE出错，并服务器打开了stop-writes-on-bgsave-error，且服务器要执行写命令，那么将拒绝执行该命令。</li>
<li>如果正在执行SUBSCRIBE订阅频道，或PushSCRIBE订阅模式，那么服务器只会执行Subscribe、psubscribe、unsubscribe、punsubscribe。</li>
<li>如果服务器正在进行数据载入，那么客户端的命令必须带有l标识才会被执行，例如info、publish、shutdown。</li>
<li>如果服务器因为执行Lua而超时进入阻塞，则只会执行shutdown nosave和script kill。</li>
<li>如果客户端正在执行事务，那么只会执行EXEC、DISCARD、MULTI、Watch，其他命令都会放入事务队列中。</li>
<li>如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数发送给监视器。</li>
</ul>
<p><strong><em>调用命令的实现函数</em></strong></p>
<p>即执行proc(client)即可。命令回复会保存在客户端状态的输出缓冲区，服务器为套接字关联命令回复处理器，处理器负责将命令回复返回客户端。</p>
<p><strong><em>执行后续工作</em></strong></p>
<ul>
<li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</li>
<li>根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds，并将calls计数器++。</li>
<li>如果开启了AOF，则AOF模块将命令写入AOF缓冲区。</li>
<li>如果有主从，则服务器会将刚执行的命令传播给所有从服务器。</li>
</ul>
<h3 id="客户端接收"><a href="#客户端接收" class="headerlink" title="客户端接收"></a>客户端接收</h3><p>当客户端套接字可写，服务器就会执行命令回复处理器将保存在输出缓冲区中的命令回复发送给客户端。</p>
<h2 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h2><ul>
<li>更新服务器的时间缓存。</li>
<li>更新LRU时钟。</li>
<li>更新服务器每秒执行命令次数。</li>
<li>更新服务器的内存峰值记录。</li>
<li>处理Sigterm信号。</li>
<li>管理客户端资源。</li>
<li>管理数据库资源。</li>
<li>执行被延迟的BGRewriteAOF。</li>
<li>检查持久化操作的运行状态。</li>
<li>将AOF缓冲区的内容写入AOF文件。</li>
<li>关闭异步客户端。</li>
<li>增加cronloops计数器的值。</li>
</ul>
<h2 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/NoSQL/" rel="tag"># NoSQL</a>
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2019/03/04/数据库/Redis：数据结构与对象/" rel="next" title="Redis：数据结构与对象">
                <i class="fa fa-chevron-left"></i> Redis：数据结构与对象
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2019/03/05/Java/base/Java并发：Java实现/" rel="prev" title="Java并发：Java实现">
                Java并发：Java实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">196</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库"><span class="nav-number">1.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#服务器中的数据库"><span class="nav-number">1.1.</span> <span class="nav-text">服务器中的数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切换数据库"><span class="nav-number">1.2.</span> <span class="nav-text">切换数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库键空间"><span class="nav-number">1.3.</span> <span class="nav-text">数据库键空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置键的生存时间或过期时间"><span class="nav-number">1.4.</span> <span class="nav-text">设置键的生存时间或过期时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过期键删除策略"><span class="nav-number">1.5.</span> <span class="nav-text">过期键删除策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis的过期键删除策略"><span class="nav-number">1.6.</span> <span class="nav-text">Redis的过期键删除策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF、RDB和复制功能对过期键的处理"><span class="nav-number">1.7.</span> <span class="nav-text">AOF、RDB和复制功能对过期键的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库通知"><span class="nav-number">1.8.</span> <span class="nav-text">数据库通知</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发送通知"><span class="nav-number">1.8.1.</span> <span class="nav-text">发送通知</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#持久化"><span class="nav-number">2.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB持久化"><span class="nav-number">2.1.</span> <span class="nav-text">RDB持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB文件的创建与载入"><span class="nav-number">2.1.1.</span> <span class="nav-text">RDB文件的创建与载入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动间隔保存"><span class="nav-number">2.1.2.</span> <span class="nav-text">自动间隔保存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB文件结构"><span class="nav-number">2.1.3.</span> <span class="nav-text">RDB文件结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析RDB文件"><span class="nav-number">2.1.4.</span> <span class="nav-text">分析RDB文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用策略"><span class="nav-number">2.1.5.</span> <span class="nav-text">应用策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF持久化"><span class="nav-number">2.2.</span> <span class="nav-text">AOF持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF持久化的实现"><span class="nav-number">2.2.1.</span> <span class="nav-text">AOF持久化的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF文件载入与数据还原"><span class="nav-number">2.2.2.</span> <span class="nav-text">AOF文件载入与数据还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF重写"><span class="nav-number">2.2.3.</span> <span class="nav-text">AOF重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用策略-1"><span class="nav-number">2.2.4.</span> <span class="nav-text">应用策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开销"><span class="nav-number">2.3.</span> <span class="nav-text">开销</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事件"><span class="nav-number">3.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件事件"><span class="nav-number">3.1.</span> <span class="nav-text">文件事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件事件处理器的构成"><span class="nav-number">3.1.1.</span> <span class="nav-text">文件事件处理器的构成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO多路复用程序的实现"><span class="nav-number">3.1.2.</span> <span class="nav-text">IO多路复用程序的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件的类型"><span class="nav-number">3.1.3.</span> <span class="nav-text">事件的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件事件的处理器"><span class="nav-number">3.1.4.</span> <span class="nav-text">文件事件的处理器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间事件"><span class="nav-number">3.2.</span> <span class="nav-text">时间事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">3.2.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServerCron"><span class="nav-number">3.2.2.</span> <span class="nav-text">ServerCron</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件的调度与执行"><span class="nav-number">3.3.</span> <span class="nav-text">事件的调度与执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#客户端"><span class="nav-number">4.</span> <span class="nav-text">客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端属性"><span class="nav-number">4.1.</span> <span class="nav-text">客户端属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端的创建与关闭"><span class="nav-number">4.2.</span> <span class="nav-text">客户端的创建与关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端连接池Jedis"><span class="nav-number">4.3.</span> <span class="nav-text">客户端连接池Jedis</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务器"><span class="nav-number">5.</span> <span class="nav-text">服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#命令请求的执行过程"><span class="nav-number">5.1.</span> <span class="nav-text">命令请求的执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发送、读取命令请求"><span class="nav-number">5.1.1.</span> <span class="nav-text">发送、读取命令请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令执行器"><span class="nav-number">5.1.2.</span> <span class="nav-text">命令执行器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端接收"><span class="nav-number">5.1.3.</span> <span class="nav-text">客户端接收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#serverCron函数"><span class="nav-number">5.2.</span> <span class="nav-text">serverCron函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化服务器"><span class="nav-number">5.3.</span> <span class="nav-text">初始化服务器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">1.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">38:57</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        




  <script>
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=66458302";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  























  <script src="/js/local-search.js?v=7.2.0"></script>














</body>
</html>
