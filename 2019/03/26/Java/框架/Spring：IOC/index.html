<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    search: {
      root: '/',
      path: 'search.xml'
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="IOC背景提出问题IOC的理论背景 我们知道在面向对象设计的软件系统中，它的底层都是由N个对象构成的，各个对象之间通过相互合作，最终实现系统地业务逻辑。  如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以">
<meta name="keywords" content="Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring：IOC">
<meta property="og:url" content="http://yoursite.com/2019/03/26/Java/框架/Spring：IOC/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="IOC背景提出问题IOC的理论背景 我们知道在面向对象设计的软件系统中，它的底层都是由N个对象构成的，各个对象之间通过相互合作，最终实现系统地业务逻辑。  如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/assets/30130748-488045b61d354b019a088b9cb7fc2d73.png">
<meta property="og:image" content="http://yoursite.com/assets/30131157-f547678cffaf421b89373e3bb308757d.png">
<meta property="og:image" content="http://yoursite.com/assets/a38f263e5e9ed2725b03">
<meta property="og:image" content="http://yoursite.com/assets/30131727-a8268fe6370049028078e6b8a1cbc88f.png">
<meta property="og:image" content="http://yoursite.com/assets/30132051-58562511cc6541fdb2636081e455d808.png">
<meta property="og:image" content="http://yoursite.com/assets/1566475154937.png">
<meta property="og:image" content="http://yoursite.com/assets/1566483720864.png">
<meta property="og:image" content="http://yoursite.com/assets/1566485398765.png">
<meta property="og:image" content="http://yoursite.com/assets/1566523105743.png">
<meta property="og:image" content="http://yoursite.com/assets/1566523731977.png">
<meta property="og:image" content="http://yoursite.com/assets/d30db7f74094dfcb7889">
<meta property="og:image" content="http://yoursite.com/assets/efb2c685e23f1028dca6">
<meta property="og:image" content="http://yoursite.com/assets/a9a3d098dbaf18b3f343">
<meta property="og:image" content="http://yoursite.com/assets/dependency.gif">
<meta property="og:image" content="http://yoursite.com/assets/injector.gif">
<meta property="og:image" content="http://yoursite.com/assets/locator.gif">
<meta property="og:updated_time" content="2019-08-29T03:15:45.326Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring：IOC">
<meta name="twitter:description" content="IOC背景提出问题IOC的理论背景 我们知道在面向对象设计的软件系统中，它的底层都是由N个对象构成的，各个对象之间通过相互合作，最终实现系统地业务逻辑。  如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以">
<meta name="twitter:image" content="http://yoursite.com/assets/30130748-488045b61d354b019a088b9cb7fc2d73.png">
  <link rel="canonical" href="http://yoursite.com/2019/03/26/Java/框架/Spring：IOC/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Spring：IOC | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-top">
      
    

    <a href="/top/" rel="section"><i class="menu-item-icon fa fa-fw fa-signal"></i> <br>阅读排行</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>

</div>
    </header>

    

  <a href="https://github.com/smallpocket" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/26/Java/框架/Spring：IOC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">Spring：IOC

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-26 21:00:29" itemprop="dateCreated datePublished" datetime="2019-03-26T21:00:29+08:00">2019-03-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 11:15:45" itemprop="dateModified" datetime="2019-08-29T11:15:45+08:00">2019-08-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">20k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">36 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="IOC背景"><a href="#IOC背景" class="headerlink" title="IOC背景"></a>IOC背景</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p><strong><em>IOC的理论背景</em></strong></p>
<p>我们知道在面向对象设计的软件系统中，它的底层都是由N个对象构成的，各个对象之间通过相互合作，最终实现系统地业务逻辑。</p>
<p><img src="/assets/30130748-488045b61d354b019a088b9cb7fc2d73.png" alt="img"></p>
<p>如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。</p>
<p>齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。</p>
<p><img src="/assets/30131157-f547678cffaf421b89373e3bb308757d.png" alt="img"></p>
<p>耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson 1996年提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>依赖注入。</li>
<li>依赖检查。</li>
<li>自动装配。</li>
<li>支持集合。</li>
<li>指定初始化方法和销毁方法。</li>
<li>支持某些回调方法。</li>
</ul>
<p>IOC使得对象只需要发挥自己的特长即可，让你脱离对依赖对象的维护，只需要随用随取，不需要关心依赖对象的任何过程。</p>
<p><img src="/assets/a38f263e5e9ed2725b03" alt="img"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><p>IOC涉及代码解耦、设计模式、代码优化等问题的考量。</p>
<p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</p>
<p>1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p>
<p>IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：</p>
<p><img src="/assets/30131727-a8268fe6370049028078e6b8a1cbc88f.png" alt="img"></p>
<p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p>
<p>我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：</p>
<p><img src="/assets/30132051-58562511cc6541fdb2636081e455d808.png" alt="img"></p>
<p>我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！</p>
<p>我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：</p>
<p>软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p>
<p>软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p>
<p>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p>
<h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><p>Spring框架的核心是Spring容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过XML，Java注解或Java代码提供。</p>
<p>IOC容器支持加载服务时的饿汉式初始化和懒加载。</p>
<h3 id="从代码角度来理解"><a href="#从代码角度来理解" class="headerlink" title="从代码角度来理解"></a>从代码角度来理解</h3><blockquote>
<p>依赖注入：让调用类对某一接口实现类的依赖关系由第三方注入，以移除调用类对某一接口实现类的依赖。</p>
</blockquote>
<p>以使用演员编排剧本来理解。</p>
<p>不使用IOC，即直接使用演员编排剧本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoAttack</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cityGeteAsk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		LiuDeHua ldh = <span class="keyword">new</span> LiuDeHua();</span><br><span class="line">		ldh.responseAsk(<span class="string">"墨者A"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是演员刘德华直接侵入了剧本，而使得剧本与演员直接耦合。而明智的设定应该基于<strong>抽象</strong>，即应该围绕故事的角色，而不是具体的演员。</p>
<p>因此为角色定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoAttack</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cityGeteAsk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//引入角色接口。</span></span><br><span class="line">		GeLi geli = <span class="keyword">new</span> LiuDeHua();</span><br><span class="line">		<span class="comment">//使用接口展开剧情</span></span><br><span class="line">		geli.responseAsk(<span class="string">"墨者A"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这个版本依然存在问题，因为MoAttack同时依赖于接口与LiuDeHua，而不仅仅是依赖于角色。但是角色又必须最终通过具体的演员而实现。</p>
<p>那么如何让LiuDeHua最终与剧本无关而又能完成GeLi的具体动作，则是导演在开演时，将LiuDeHua的角色安排在GeLi角色上，导演负责剧本、角色、饰演者三者的协调控制。</p>
<p><img src="/assets/1566475154937.png" alt="1566475154937"></p>
<h3 id="IOC关键"><a href="#IOC关键" class="headerlink" title="IOC关键"></a>IOC关键</h3><p>控制反转：</p>
<ul>
<li>控制。指选择GeLi角色扮演者的控制权。</li>
<li>反转。这种控制权从剧本中移除，移交到导演手中，即某一接口的具体实现类的选择控制权从调用类中移除，转交给第三方决定，即由Spring容器借Bean配置来进行控制。</li>
</ul>
<blockquote>
<p>即类本身只需要关注它自己的职责。</p>
</blockquote>
<h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><p><strong><em>优点</em></strong></p>
<ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或JNDI查找机制。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载服务。</li>
</ul>
<p><strong><em>缺点</em></strong></p>
<p>使用IOC框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。</p>
<ol>
<li>软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。</li>
<li>由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。</li>
<li>具体到IOC框架产品(比如：Spring)来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。</li>
<li>IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。</li>
</ol>
<p>我们大体可以得出这样的结论：</p>
<ul>
<li>一些工作量不大的项目或者产品，不太适合使用IOC框架产品。</li>
<li>如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。</li>
<li>最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，像WEB2.0网站就是这种情况。</li>
</ul>
<h1 id="Spring-IOC-1"><a href="#Spring-IOC-1" class="headerlink" title="Spring IOC"></a>Spring IOC</h1><p>IOC为控制反转，把传统意义上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。由容器动态地将某种依赖关系注入到组件中。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Spring实现"><a href="#Spring实现" class="headerlink" title="Spring实现"></a>Spring实现</h3><p>spring的IOC容器种类：</p>
<ul>
<li>BeanFactory - BeanFactory就像一个包含bean集合的工厂类。它会在客户端要求时实例化bean。</li>
<li>ApplicationContext - ApplicationContext接口扩展了BeanFactory接口。它在BeanFactory基础上提供了一些额外的功能。</li>
</ul>
<table>
<thead>
<tr>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td>它使用懒加载</td>
<td>它使用即时加载</td>
</tr>
<tr>
<td>它使用语法显式提供资源对象</td>
<td>它自己创建和管理资源对象</td>
</tr>
<tr>
<td>不支持国际化</td>
<td>支持国际化</td>
</tr>
<tr>
<td>不支持基于依赖的注解</td>
<td>支持基于依赖的注解</td>
</tr>
</tbody></table>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h3><p>即通过类的构造函数，将接口实现类通过构造函数变量传入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoAttack</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> GeLi geli;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MoAttack</span><span class="params">(GeLi geli)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.geli = geli;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数不需要关心谁去扮演该角色，但是在类被构造出来后，一定存在这样一个演员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span></span>&#123;</span><br><span class="line">		GeLi geli = <span class="keyword">new</span> LiuDeHua();</span><br><span class="line">        <span class="comment">//注入具体的饰演者</span></span><br><span class="line">        MoAttack mo = <span class="keyword">new</span> MoAttack(geli);</span><br><span class="line">        mo.cityGateAsk();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h3><p>在剧本执行过程当中，可以动态的注入相应的角色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoAttack</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> GeLi geli;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">setGeli</span><span class="params">(GeLi geli)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.geli = geli;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h3><p>将调用类所有依赖注入的方法抽取到一个接口当中，调用类通过实现该接口提供相应的注入方法，通过接口注入必须先声明一个ActorArrangable。</p>
<p>这种方式下多出一个新的接口，增加一个新类，并不提倡。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActorArrangable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">injectGeli</span><span class="params">(GeLi geli)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MoAttack实现接口提供具体的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoAttack</span> <span class="keyword">implements</span> <span class="title">ActorArrangable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> GeLi geli;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectGeli</span><span class="params">(GeLi geli)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.geli = geli;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cityGateAsk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        geli.responseAsk(<span class="string">"墨者A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span></span>&#123;</span><br><span class="line">		MoAttack mo = <span class="keyword">new</span> MoAttack();</span><br><span class="line">		GeLi geli = <span class="keyword">new</span> LiuDeHua();</span><br><span class="line">		mo.injectGeli(geli);</span><br><span class="line">		mo.cityGateAsk();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring实现-1"><a href="#Spring实现-1" class="headerlink" title="Spring实现"></a>Spring实现</h3><p>前面的实现只是将实例化工作移动到了Director类，而这些代码依然存在。而我们希望使用第三方代理机构来实现这一工作，将剧本、演员、导演解耦。</p>
<p>Spring中的IoC的实现原理就是工厂模式加反射机制。</p>
<ul>
<li>通过反射创造实例。</li>
<li>获取需要注入的接口实现类并将其赋值给该接口。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span> </span>&#123;</span><br><span class="line">        Fruit f=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">"io.github.dunwu.spring.Apple"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IOC容器启动流程"><a href="#IOC容器启动流程" class="headerlink" title="IOC容器启动流程"></a>IOC容器启动流程</h1><h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h2><p>参见<a href="[https://smallpocket.github.io/2019/08/26/Java/%E6%A1%86%E6%9E%B6/Spring%EF%BC%9ABean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/](https://smallpocket.github.io/2019/08/26/Java/框架/Spring：Bean生命周期/)">Spring：Bean生命周期</a></p>
<h1 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h1><p>Spring中的IOC的实现原理就是工厂模式加反射机制。</p>
<p>IOC中最基本的技术就是“<strong>反射(Reflection)</strong>”编程，目前.Net C#、Java和PHP5等语言均支持，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。反射的应用是很广泛的，很多的成熟的框架，比如象Java中的Hibernate、Spring框架，.Net中 NHibernate、Spring.Net框架都是把“反射”做为最基本的技术手段。</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Bean工厂是Spring框架最核心的接口，提供了高级IOC的配置机制，使得管理不同类型的Java对象称为可能。</p>
<p>应用上下文ApplicationContext建立在BeanFactory基础上提供了更多面向应用的功能，提供了国际化支持和框架事件体系，更易于创建实际应用。</p>
<ul>
<li>BeanFactory一般称为IOC容器。是Spring框架的基础设施，面向Spring本身。</li>
<li>ApplicationContext一般称为应用上下文。面向使用Spring框架开发者，几乎所有场景都可以使用ApplicationContext而不是BeanFactory。</li>
</ul>
<h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>BeanFactory是类的通用工厂，可以创建并管理各种类的对象，Spring称这些被创建和管理的Java对象为Bean。</p>
<p><strong><em>BeanFactory的类体系结构</em></strong></p>
<p>BeanFactory由多种实现，最常用的是XmlBeanFactory，但在Spring当中已经废弃，建议使用XmlBeanDefinitionReader、DefaultListableBeanFactory代替。</p>
<p><img src="/assets/1566483720864.png" alt="1566483720864"></p>
<p>可见BeanFactory位于结构树的顶层，其功能通过其他接口得到不断扩展。</p>
<h4 id="子接口"><a href="#子接口" class="headerlink" title="子接口"></a>子接口</h4><ul>
<li>ListableBeanFactory。该接口定义了访问容器中Bean基本信息的若干方法，如查看Bean的个数，获取某一类型Bean的配置名、查看容器中是否包含某一Bean等。</li>
<li>HierarchicalBeanFactory。父子级联Ioc容器的接口，子容器可以通过接口方法访问父容器。</li>
<li>ConfigurableBeanFactory。该接口增强了IOC容器的可定制性，定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法。</li>
<li>AutowireCapableBeanFactory。定义了将容器中的Bean按某种规则(名字匹配，类型匹配)进行自动装配的方法。</li>
<li>SingletonBeanRegistry。定义了允许在运行期间向容器注册单例Bean的方法。</li>
<li>BeanDefinitionRegistry。Spring配置文件中的每个&lt;bean&gt;节点元素在Spring容器里都通过一个BeanDefinition对象标识，它描述了Bean的配置信息，而BeanDefinition Registry提供了向容器手工注册BeanDefinition对象的方法。</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>getBean(String beanName)。</li>
</ul>
<p>从容器中返回特定名称的Bean。</p>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>BeanFactory是Spring的心脏，ApplicationContext是完整的身体，其由BeanFactory派生而来，提供了更多面向实际应用的功能。</p>
<p>在BeanFactory当中很多功能需要以编程的方式实现，而在ApplicationContext当中可以通过配置的方式实现。</p>
<p><strong><em>类体系结构</em></strong></p>
<p>ApplicationContext的主要实现类是：</p>
<ul>
<li>ClassPathXmlApplicationContext。默认从类路径加载配置文件。</li>
<li>FileSystemXmlApplicationContext。默认从文件系统中装载配置文件。</li>
</ul>
<p><img src="/assets/1566485398765.png" alt="1566485398765"></p>
<p>ConfigurableApplicationContext扩展于ApplicationContext，增加了refresh()与close()使得ApplicationContext具有启动、刷新和关闭应用上下文的能力，即可清除缓存并重新装载配置信息。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>ApplicationContext功能集成自HierarchicalBeanFactory、ListableBeanFactory，并在此基础上通过多个其他接口扩展了BeanFactory的功能，接口包括：</p>
<ul>
<li>ApplicationEventPublisher。<ul>
<li>容容器具有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。</li>
<li>实现了ApplicationListener事件监听接口的Bean可以接收到容器事件并对事件进行响应处理。</li>
<li>在ApplicationContext抽象实现类当中存在一个ApplicationEventMulticaster，它负责保存所有的监听器，以便在容器产生上下文事件时通知这些事件监听者。</li>
</ul>
</li>
</ul>
<p>让容器具有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了ApplicationListener事件监听接口的Bean可以</p>
<ul>
<li>MessageSource。<ul>
<li>为应用提供国际化消息访问的功能。</li>
</ul>
</li>
<li>ResourcePatternResolver。<ul>
<li>可以通过带前缀的Ant风格的资源文件路径装载Spring的配置文件。</li>
</ul>
</li>
<li>LifeCycle。<ul>
<li>提供了<code>start()</code>与<code>stop()</code>两个方法，主要用于控制异步处理过程。</li>
<li>在具体使用时，该接口会同时被ApplicationContext实现以及具体的Bean实现，ApplicationContext将start/stop信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度等目的。</li>
</ul>
</li>
</ul>
<h3 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h3><p>专门为Web应用准备，允许从相对于Web根目录的路径中装载配置文件完成初始化工作。从WebApplicationContext中可以获得ServletContext中，以便Web应用环境可以访问Spring应用上下文。</p>
<p>Spring为此提供了一个工具类WebApplicationContextUtils，通过该类的<code>getWebApplicationContext(ServletContext sc)</code>可以从ServletContext中获取WebApplicationContext实例。</p>
<p>在非Web应用下，Bean只有Singleton和prototype两种作用域，在WebApplicationContext为Bean增添了新的作用域：request、session、global session。</p>
<p><img src="/assets/1566523105743.png" alt="1566523105743"></p>
<p>为了Web容器的上下文应用与Spring的Web应用上下文互相访问，WebApplicationContext定义了一个常量ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，在上下文启动时，WebApplication即以此为键放置在ServletContext的属性列表当中。通过以下语句从Web容器中获取WebApplicationContext：</p>
<p><img src="/assets/1566523731977.png" alt="1566523731977"></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化需要有ServletContext实例，即必须在用有Web容器的前提下才能完成启动工作。</p>
<h3 id="父子容器"><a href="#父子容器" class="headerlink" title="父子容器"></a>父子容器</h3><p>通过HierarchicalBeanFactory接口，Spring的IOC容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的Bean，但芙蓉区不能访问子容器的Bean。</p>
<p>在容器内，Bean的id必须唯一，但子容器可以拥有一个与父容器id相同的Bean，该体系增强了Spring容器架构的扩展性与灵活性。</p>
<p>MVC当中，展现层的Bean位于子容器当中，而业务层与持久层Bean位于父容器中，这样展现层Bean可以引用业务层与持久层Bean，但反过来却无法看到。</p>
<h2 id="IOC容器的实现"><a href="#IOC容器的实现" class="headerlink" title="IOC容器的实现"></a>IOC容器的实现</h2><p>需要实现的两个关键技术， 以明确服务的对象是谁、需要为服务对象提供什么样的服务：</p>
<ul>
<li>对象的构建。</li>
<li>对象的绑定。</li>
</ul>
<p>实现方式：</p>
<ul>
<li>硬编码。</li>
<li>配置文件。</li>
<li>注解。</li>
</ul>
<p>Spring通过一个配置文件来描述Bean以及Bean之间的依赖关系。利用Java语言的反射功能实例化Bean并建立Bean之间的依赖关系。</p>
<h3 id="BeanFactory-1"><a href="#BeanFactory-1" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>参见<a href="[https://smallpocket.github.io/2019/08/26/Java/%E6%A1%86%E6%9E%B6/Spring%EF%BC%9ABean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/](https://smallpocket.github.io/2019/08/26/Java/框架/Spring：Bean生命周期/)">Spring：Bean生命周期</a></p>
<h3 id="ApplicationContext-1"><a href="#ApplicationContext-1" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>ApplicationContext 容器建立BeanFactory之上，拥有BeanFactory的所有功能，但在实现上会有所差别。</p>
<p>我认为<strong>差别</strong>主要体现在两个方面：</p>
<ul>
<li>bean的生成方式；</li>
<li>扩展了BeanFactory的功能，提供了更多企业级功能的支持。</li>
<li>ApplicationContext采用的非懒加载方式。它会在启动阶段完成所有的初始化，并不会等到getBean()才执行<ul>
<li>所以，相对于BeanFactory来 说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容 器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中， ApplicationContext类型的容器是比较合适的选择。</li>
</ul>
</li>
</ul>
<p><strong><em>bean的加载方式</em></strong></p>
<p>BeanFactory提供BeanReader来从配置文件中读取bean配置。相应的ApplicationContext也提供几个读取配置文件的方式：</p>
<ul>
<li><p>FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径</p>
</li>
<li><p>ClassPathXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。</p>
</li>
<li><p>WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。</p>
</li>
<li><p>AnnotationConfigApplicationContext</p>
</li>
<li><p>ConfigurableWebApplicationContext</p>
<p><img src="/assets/d30db7f74094dfcb7889" alt="img"></p>
<p>ApplicationContext 还额外增加了三个历能：</p>
</li>
<li><p>ApplicationEventPublisher</p>
</li>
<li><p>ResourceLoader</p>
</li>
<li><p>MessageResource</p>
</li>
</ul>
<h2 id="资源访问"><a href="#资源访问" class="headerlink" title="资源访问"></a>资源访问</h2><h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>ResourceLoader并不能将其看成是Spring独有的功能，spring Ioc只是借助于ResourceLoader来实现资源加载。也提供了各种各样的资源加载方式：</p>
<ul>
<li><p>DefaultResourceLoader 首先检查资源路径是否以classpath:前缀打头，如果是，则尝试构造ClassPathResource类 型资源并返回。否则， 尝试通过URL，根据资源路径来定位资源 </p>
</li>
<li><p>FileSystemResourceLoader 它继承自Default-ResourceLoader，但覆写了getResourceByPath(String)方法，使之从文件系统加载资源并以 FileSystemResource类型返回 </p>
<ul>
<li><p>ResourcePatternResolver  批量查找的ResourceLoader</p>
<p><img src="/assets/efb2c685e23f1028dca6" alt="img"></p>
<p>spring与ResourceLoader之间的关系</p>
<p><img src="/assets/a9a3d098dbaf18b3f343" alt="img"></p>
<p>所有ApplicationContext的具体实现类都会直接或者间接地实现AbstractApplicationContext,AbstactApplicationContext 依赖了了DeffaultResourceLoader, ApplicationContext 继承了ResourcePatternResolver,所到头来ApplicationContext的具体实现类都会具有DefaultResourceLoader 和 PathMatchingResourcePatterResolver的功能。这也就是会什么ApplicationContext可以实现统一资源定位。</p>
</li>
</ul>
</li>
</ul>
<p><strong><em>ApplicationEventPublisher（在介绍spring事件的时候再详细讲）</em></strong></p>
<ol>
<li>ApplicationEvent：继承自EventObject，同时是spring的application中事件的父类，需要被自定义的事件继承。 </li>
<li>ApplicationListener：继承自EventListener，spring的application中的监听器必须实现的接口，需要被自定义的监听器实现其onApplicationEvent方法 </li>
<li>ApplicationEventPublisherAware：在spring的context中希望能发布事件的类必须实现的接口，该接口中定义了设置ApplicationEventPublisher的方法，由ApplicationContext调用并设置。在自己实现的ApplicationEventPublisherAware子类中，需要有ApplicationEventPublisher属性的定义。 </li>
<li>ApplicationEventPublisher：spring的事件发布者接口，定义了发布事件的接口方法publishEvent。因为ApplicationContext实现了该接口，因此spring的ApplicationContext实例具有发布事件的功能(publishEvent方法在AbstractApplicationContext中有实现)。在使用的时候，只需要把ApplicationEventPublisher的引用定义到ApplicationEventPublisherAware的实现中，spring容器会完成对ApplicationEventPublisher的注入。</li>
</ol>
<p><strong><em>MessageSource</em></strong></p>
<p>提供国际化支持，不讲了，有需要请转至：<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.sina.com.cn%2Fs%2Fblog_85d71fb70101cyp5.html" target="_blank" rel="noopener">blog.sina.com.cn/s/blog_85d7…</a></p>
<p># 四、最佳实践<br>注解扫描</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-2.5.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.spring21"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>component/service/controller注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Food food;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFood</span><span class="params">(Food food)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.food = food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bean的前置后置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Food food;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">setFood</span><span class="params">(Food food)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.food = food;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"饭前洗手"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"饭后刷牙"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解加载"><a href="#注解加载" class="headerlink" title="注解加载"></a>注解加载</h3><p>基于类注解的配置方式。</p>
<p>该功能来自于JavaConfig的子项目，已成为Spring核心框架一部分。标注@Configuration注解的POJO即可提供Spring需要的Bean配置信息。</p>
<h3 id="IOC容器的初始化过程"><a href="#IOC容器的初始化过程" class="headerlink" title="IOC容器的初始化过程"></a>IOC容器的初始化过程</h3><p>Resource 定位：我们一般使用外部资源来描述 Bean 对象，所以 IOC 容器第一步就是需要定位 Resource 外部资源 。Resource 的定位其实就是 BeanDefinition 的资源定位，它是由 ResourceLoader 通过统一的 Resource 接口来完成的，这个 Resource 对各种形式的 BeanDefinition 的使用都提供了统一接口 。</p>
<p>载入：第二个过程就是 BeanDefinition 的载入 ,BeanDefinitionReader 读取 , 解析 Resource 定位的资源，也就是将用户定义好的 Bean 表示成 IOC 容器的内部数据结构也就是 BeanDefinition, 在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，通过这样的数据结构， IOC 容器能够对 Bean 进行更好的管理 。 在配置文件中每一个都对应着一个 BeanDefinition 对象 。</p>
<p>注册：第三个过程则是注册，即向 IOC 容器注册这些 BeanDefinition ，这个过程是通过 BeanDefinitionRegistery 接口来实现的 。</p>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="深度理解依赖注入（Dependence-Injection）"><a href="#深度理解依赖注入（Dependence-Injection）" class="headerlink" title="深度理解依赖注入（Dependence Injection）"></a>深度理解依赖注入（Dependence Injection）</h3><h4 id="依赖在哪里"><a href="#依赖在哪里" class="headerlink" title="依赖在哪里"></a>依赖在哪里</h4><p>  老马举了一个小例子，是开发一个电影列举器（MovieList），这个电影列举器需要使用一个电影查找器（MovieFinder）提供的服务，伪码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*服务的接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">  <span class="function">ArrayList <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*服务的消费者*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Movie[] moviesDirectedBy(String arg) &#123;</span><br><span class="line">      List allMovies = finder.findAll();</span><br><span class="line">    <span class="keyword">for</span> (Iterator it = allMovies.iterator(); it.hasNext();) &#123;</span><br><span class="line">         Movie movie = (Movie) it.next();</span><br><span class="line">         <span class="keyword">if</span> (!movie.getDirector().equals(arg)) it.remove();</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> (Movie[]) allMovies.toArray(<span class="keyword">new</span> Movie[allMovies.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*消费者内部包含一个将指向具体服务类型的实体对象*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> MovieFinder finder;</span><br><span class="line">    <span class="comment">/*消费者需要在某一个时刻去实例化具体的服务。这是我们要解耦的关键所在，</span></span><br><span class="line"><span class="comment">    *因为这样的处理方式造成了服务消费者和服务提供者的强耦合关系（这种耦合是在编译期就确定下来的）。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieLister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finder = <span class="keyword">new</span> ColonDelimitedMovieFinder(<span class="string">"movies1.txt"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码的注释中可以看到，MovieLister和ColonDelimitedMovieFinder（这可以使任意一个实现了MovieFinder接口的类型）之间存在强耦合关系，如下图所示：</p>
<p><img src="/assets/dependency.gif" alt="img"></p>
<p>这使得MovieList很难作为一个成熟的组件去发布，因为在不同的应用环境中（包括同一套软件系统被不同用户使用的时候），它所要依赖的电影查找器可能是千差万别的。所以，为了能实现真正的基于组件的开发，必须有一种机制能同时满足下面两个要求：</p>
<p> （1）解除MovieList对具体MoveFinder类型的强依赖（编译期依赖）。</p>
<p> （2）在运行的时候为MovieList提供正确的MovieFinder类型的实例。</p>
<p>换句话说，就是在运行的时候才产生MovieList和MovieFinder之间的依赖关系（把这种依赖关系在一个合适的时候“注入”运行时），这恐怕就是Dependency Injection这个术语的由来。再换句话说，我们提到过解除强依赖，这并不是说MovieList和MovieFinder之间的依赖关系不存在了，事实上MovieList无论如何也需要某类MovieFinder提供的服务，我们只是把这种依赖的建立时间推后了，从编译器推迟到运行时了。</p>
<p>依赖关系在OO程序中是广泛存在的，只要A类型中用到了B类型实例，A就依赖于B。前面笔者谈到的内容是把概念抽象到了服务使用者和服务提供者的角度，这也符合现在SOA的设计思路。从另一种抽象方式上来看，可以把MovieList看成我们要构建的主系统，而MovieFinder是系统中的plugin，主系统并不强依赖于任何一个插件，但一旦插件被加载，主系统就应该可以准确调用适当插件的功能。</p>
<p>其实不管是面向服务的编程模式，还是基于插件的框架式编程，为了实现松耦合（服务调用者和提供者之间的or框架和插件之间的），都需要在必要的位置实现面向接口编程，在此基础之上，还应该有一种方便的机制实现具体类型之间的运行时绑定，这就是DI所要解决的问题。</p>
<h4 id="DI的实现方式"><a href="#DI的实现方式" class="headerlink" title="DI的实现方式"></a>DI的实现方式</h4><p>和上面的图1对应的是，如果我们的系统实现了依赖注入，组件间的依赖关系就变成了图2：</p>
<p><img src="/assets/injector.gif" alt="img"></p>
<p>说白了，就是要提供一个容器，由容器来完成（1）具体ServiceProvider的创建（2）ServiceUser和ServiceProvider的运行时绑定。下面我们就依次来看一下三种典型的依赖注入方式的实现。特别要说明的是，要理解依赖注入的机制，关键是理解容器的实现方式。本文后面给出的容器参考实现，均为黄忠成老师的代码，笔者仅在其中加上了一些关键注释而已。</p>
<p><strong><em>Constructor Injection（构造器注入）</em></strong></p>
<p> 我们可以看到，在整个依赖注入的数据结构中，涉及到的重要的类型就是ServiceUser, ServiceProvider和Assembler三者，而这里所说的构造器，指的是ServiceUser的构造器。也就是说，在构造ServiceUser实例的时候，才把真正的ServiceProvider传给他：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  	<span class="comment">//其他内容，省略</span></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="title">MovieLister</span><span class="params">(MovieFinder finder)</span></span></span><br><span class="line"><span class="function">   	</span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.finder = finder;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看看Assembler应该如何构建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MutablePicoContainer <span class="title">configureContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	MutablePicoContainer pico = <span class="keyword">new</span> DefaultPicoContainer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面就是把ServiceProvider和ServiceUser都放入容器的过程，以后就由容器来提供ServiceUser的已完成依赖注入实例，</span></span><br><span class="line"><span class="comment">//其中用到的实例参数和类型参数一般是从配置档中读取的，这里是个简单的写法。</span></span><br><span class="line"><span class="comment">//所有的依赖注入方法都会有类似的容器初始化过程，本文在后面的小节中就不再重复这一段代码了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   	Parameter[] finderParams =  &#123;<span class="keyword">new</span> ConstantParameter(<span class="string">"movies1.txt"</span>)&#125;;</span><br><span class="line">    pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams);</span><br><span class="line">  	pico.registerComponentImplementation(MovieLister.class);</span><br><span class="line">    <span class="comment">//至此，容器里面装入了两个类型，其中没给出构造参数的那一个（MovieLister）将依靠其在构造器中定义的传入参数类型，在容器中</span></span><br><span class="line">    <span class="comment">//进行查找，找到一个类型匹配项即可进行构造初始化。</span></span><br><span class="line">   	<span class="keyword">return</span> pico;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在强调一下的是，依赖并未消失，只是延后到了容器被构建的时刻。所以正如图2中您已经看到的，容器本身（更准确的说，是一个容器运行实例的构建过程）对ServiceUser和ServiceProvoder都是存在依赖关系的。所以，在这样的体系结构里，ServiceUser、ServiceProvider和容器都是稳定的，互相之间也没有任何依赖关系；所有的依赖关系、所有的变化都被封装进了容器实例的创建过程里，符合我们对服务应用的理解。而且，在实际开发中我们一般会采用配置文件来辅助容器实例的创建，将这种变化性排斥到编译期之外。</p>
<p>即使还没给出后面的代码，你也一定猜得到，这个container类一定有一个GetInstance(Type t)这样的方法，这个方法会为我们返回一个已经注入完毕的MovieLister。 一个简单的应用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithPico</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	MutablePicoContainer pico = configureContainer();</span><br><span class="line">   	MovieLister lister = (MovieLister) pico.getComponentInstance(MovieLister.class);</span><br><span class="line">   	Movie[] movies = lister.moviesDirectedBy(<span class="string">"Sergio Leone"</span>);</span><br><span class="line">    assertEquals(<span class="string">"Once Upon a Time in the West"</span>, movies[<span class="number">0</span>].getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面最关键的就是对pico.getComponentInstance的调用。Assembler会在这个时候调用MovieLister的构造器，构造器的参数就是当时通过pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams)设置进去的实际的ServiceProvider–ColonMovieFinder。下面请看这个容器的参考代码：</p>
<p><strong><em>Setter Injection（设值注入）</em></strong></p>
<p>这种注入方式和构造注入实在很类似，唯一的区别就是前者在构造函数的调用过程中进行注入，而它是通过给属性赋值来进行注入。无怪乎PicoContainer和Spring都是同时支持这两种注入方式。Spring对通过XML进行配置有比较好的支持，也使得Spring中更常使用设值注入的方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &lt;beans&gt;</span><br><span class="line">     &lt;bean id=<span class="string">"MovieLister"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"spring.MovieLister"</span>&gt;</span><br><span class="line">         &lt;property name=<span class="string">"finder"</span>&gt;</span><br><span class="line">             &lt;ref local=<span class="string">"MovieFinder"</span>/&gt;</span><br><span class="line">         &lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line">     &lt;bean id=<span class="string">"MovieFinder"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"spring.ColonMovieFinder"</span>&gt;</span><br><span class="line">         &lt;property name=<span class="string">"filename"</span>&gt;</span><br><span class="line">             &lt;value&gt;movies1.txt&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>下面也给出支持设值注入的容器参考实现，大家可以和构造器注入的容器对照起来看，里面的差别很小，主要的差别就在于，在获取对象实例（GetInstance）的时候，前者是通过反射得到待创建类型的构造器信息，然后根据构造器传入参数的类型在容器中进行查找，并构造出合适的实例；而后者是通过反射得到待创建类型的所有属性，然后根据属性的类型在容器中查找相应类型的实例。</p>
<p><strong><em>Interface Injection (接口注入)</em></strong></p>
<p>   这是笔者认为最不够优雅的一种依赖注入方式。要实现接口注入，首先ServiceProvider要给出一个接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InjectFinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">injectFinder</span><span class="params">(MovieFinder finder)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，ServiceUser必须实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MovieLister: InjectFinder</span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectFinder</span><span class="params">(MovieFinder finder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.finder = finder;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容器所要做的，就是根据接口定义调用其中的inject方法完成注入过程，这里就不在赘述了，总的原理和上面两种依赖注入模式没有太多区别。</p>
<h4 id="除了DI，还有Service-Locator"><a href="#除了DI，还有Service-Locator" class="headerlink" title="除了DI，还有Service Locator"></a>除了DI，还有Service Locator</h4><p>上面提到的依赖注入只是消除ServiceUser和ServiceProvider之间的依赖关系的一种方法，还有另一种方法：服务定位器（Service Locator）。也就是说，由ServiceLocator来专门负责提供具体的ServiceProvider。当然，这样的话ServiceUser不仅要依赖于服务的接口，还依赖于ServiceContract。仍然是最早提到过的电影列举器的例子，如果使用Service Locator来解除依赖的话，整个依赖关系应当如下图所示：<br><img src="/assets/locator.gif" alt="img"></p>
<p>用起来也很简单，在一个适当的位置（比如在一组相关服务即将被调用之前）对ServiceLocator进行初始化，用到的时候就直接用ServiceLocator返回ServiceProvider实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务定位器的初始化</span></span><br><span class="line">ServiceLocator locator = <span class="keyword">new</span> ServiceLocator();</span><br><span class="line">locator.loadService(<span class="string">"MovieFinder"</span>, <span class="keyword">new</span> ColonMovieFinder(<span class="string">"movies1.txt"</span>));</span><br><span class="line">ServiceLocator.load(locator);</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务定义器的使用</span></span><br><span class="line"><span class="comment">//其实这个使用方式体现了服务定位器和依赖注入模式的最大差别：ServiceUser需要显示的调用ServiceLocator，从而获取自己需要的服务对象；</span></span><br><span class="line"><span class="comment">//而依赖注入则是隐式的由容器完成了这一切。</span></span><br><span class="line">MovieFinder finder = (MovieFinder) ServiceLocator.getService(<span class="string">"MovieFinder"</span>);</span><br></pre></td></tr></table></figure>

<p>正因为上面提到过的ServiceUser对ServiceLocator的依赖性，从提高模块的独立性（比如说，你可能把你构造的ServiceUser或者ServiceProvider给第三方使用）上来说，依赖注入可能更好一些，这恐怕也是为什么大多数的IOC框架都选用了DI的原因。ServiceLocator最大的优点可能在于实现起来非常简单，如果您开发的应用没有复杂到需要采用一个IOC框架的程度，也许您可以试着采用它。</p>
<p><strong>3.广义的服务</strong><br>文中很多地方提到服务使用者（ServiceUser）和服务提供者（ServiceProvider）的概念，这里的“服务”是一种非常广义的概念，在语法层面就是指最普通的依赖关系（类型A中有一个B类型的变量，则A依赖于B）。如果您把服务理解为WCF或者Web Service中的那种服务概念，您会发现上面所说的所有技术手段都是没有意义的。以WCF而论，其客户端和服务器端本就是依赖于Contract的松耦合关系，其实这也从另一个角度说明了SOA应用的优势所在。</p>
<h1 id="IOC扩展"><a href="#IOC扩展" class="headerlink" title="IOC扩展"></a>IOC扩展</h1><p>Spring IOC还提供了Bean实例缓存、生命周期管理、Bean实例代理、事件发布、资源装载等高级服务。</p>
<h2 id="反省总结"><a href="#反省总结" class="headerlink" title="反省总结"></a>反省总结</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/xingyukun/archive/2007/10/20/931331.html" target="_blank" rel="noopener">深度理解依赖注入（Dependence Injection）</a></li>
<li><a href="https://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html" target="_blank" rel="noopener">浅谈IOC–说清楚IOC是什么</a></li>
<li><a href="https://www.imooc.com/article/256370" target="_blank" rel="noopener">JAVA关于Spring 面试题汇总</a></li>
<li><a href="https://juejin.im/post/593386ca2f301e00584f8036#heading-4" target="_blank" rel="noopener">IoC-spring 的灵魂(带你轻松理解IOC思想及bean对象的生成过程)</a></li>
<li><a href="[https://huzb.me/2019/03/03/Spring%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88/](https://huzb.me/2019/03/03/Spring源码浅析——容器刷新流程概览/)">Spring 源码浅析——容器刷新流程概览</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/Spring/" rel="tag"># Spring</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2019/03/26/Java/框架/Spring：入门/" rel="next" title="Spring：入门">
                <i class="fa fa-chevron-left"></i> Spring：入门
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2019/03/26/Java/框架/Spring：AOP/" rel="prev" title="Spring：AOP">
                Spring：AOP <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">196</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#IOC背景"><span class="nav-number">1.</span> <span class="nav-text">IOC背景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#提出问题"><span class="nav-number">1.1.</span> <span class="nav-text">提出问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用"><span class="nav-number">1.2.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#适用性"><span class="nav-number">1.2.1.</span> <span class="nav-text">适用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用场景"><span class="nav-number">1.2.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基础概述"><span class="nav-number">1.3.</span> <span class="nav-text">基础概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是IOC"><span class="nav-number">1.3.1.</span> <span class="nav-text">什么是IOC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-IOC"><span class="nav-number">1.3.2.</span> <span class="nav-text">Spring IOC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从代码角度来理解"><span class="nav-number">1.3.3.</span> <span class="nav-text">从代码角度来理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC关键"><span class="nav-number">1.3.4.</span> <span class="nav-text">IOC关键</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#权衡"><span class="nav-number">1.4.</span> <span class="nav-text">权衡</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-IOC-1"><span class="nav-number">2.</span> <span class="nav-text">Spring IOC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring实现"><span class="nav-number">2.1.1.</span> <span class="nav-text">Spring实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现"><span class="nav-number">2.2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数注入"><span class="nav-number">2.2.1.</span> <span class="nav-text">构造函数注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setter注入"><span class="nav-number">2.2.2.</span> <span class="nav-text">setter注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口注入"><span class="nav-number">2.2.3.</span> <span class="nav-text">接口注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring实现-1"><span class="nav-number">2.2.4.</span> <span class="nav-text">Spring实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IOC容器启动流程"><span class="nav-number">3.</span> <span class="nav-text">IOC容器启动流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#refresh"><span class="nav-number">3.1.</span> <span class="nav-text">refresh()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IOC底层原理"><span class="nav-number">4.</span> <span class="nav-text">IOC底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-1"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC容器"><span class="nav-number">4.2.</span> <span class="nav-text">IOC容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory"><span class="nav-number">4.2.1.</span> <span class="nav-text">BeanFactory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#子接口"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">子接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationContext"><span class="nav-number">4.2.2.</span> <span class="nav-text">ApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebApplicationContext"><span class="nav-number">4.2.3.</span> <span class="nav-text">WebApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#父子容器"><span class="nav-number">4.2.4.</span> <span class="nav-text">父子容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC容器的实现"><span class="nav-number">4.3.</span> <span class="nav-text">IOC容器的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory-1"><span class="nav-number">4.3.1.</span> <span class="nav-text">BeanFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationContext-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">ApplicationContext</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源访问"><span class="nav-number">4.4.</span> <span class="nav-text">资源访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ResourceLoader"><span class="nav-number">4.4.1.</span> <span class="nav-text">ResourceLoader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解加载"><span class="nav-number">4.4.2.</span> <span class="nav-text">注解加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC容器的初始化过程"><span class="nav-number">4.4.3.</span> <span class="nav-text">IOC容器的初始化过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计思想"><span class="nav-number">4.4.4.</span> <span class="nav-text">设计思想</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进阶"><span class="nav-number">4.5.</span> <span class="nav-text">进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#深度理解依赖注入（Dependence-Injection）"><span class="nav-number">4.5.1.</span> <span class="nav-text">深度理解依赖注入（Dependence Injection）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#依赖在哪里"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">依赖在哪里</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DI的实现方式"><span class="nav-number">4.5.1.2.</span> <span class="nav-text">DI的实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#除了DI，还有Service-Locator"><span class="nav-number">4.5.1.3.</span> <span class="nav-text">除了DI，还有Service Locator</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IOC扩展"><span class="nav-number">5.</span> <span class="nav-text">IOC扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#反省总结"><span class="nav-number">5.1.</span> <span class="nav-text">反省总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">1.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">38:44</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        




  <script>
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=66458302";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  























  <script src="/js/local-search.js?v=7.2.0"></script>














</body>
</html>
