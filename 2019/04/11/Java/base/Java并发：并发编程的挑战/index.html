<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    search: {
      root: '/',
      path: 'search.xml'
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="问题并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战。  性能与可伸缩性： 上下文切换的问题、锁的竞争。   活跃性危险： 死锁、饥饿、糟糕的响应性、活锁。   受限于硬件和软件的资源限制问题。  概述 性能与可伸缩性首先要保证程序能正常运行，然后仅当程序的性能需求和测试结果要求程序执行的更">
<meta name="keywords" content="并发编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发：并发编程的挑战">
<meta property="og:url" content="http://yoursite.com/2019/04/11/Java/base/Java并发：并发编程的挑战/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="问题并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战。  性能与可伸缩性： 上下文切换的问题、锁的竞争。   活跃性危险： 死锁、饥饿、糟糕的响应性、活锁。   受限于硬件和软件的资源限制问题。  概述 性能与可伸缩性首先要保证程序能正常运行，然后仅当程序的性能需求和测试结果要求程序执行的更">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/assets/162a01b71ebc4842">
<meta property="og:image" content="http://yoursite.com/assets/1565230366029.png">
<meta property="og:image" content="http://yoursite.com/assets/1554968889175.png">
<meta property="og:image" content="http://yoursite.com/assets/1554969302239.png">
<meta property="og:image" content="http://yoursite.com/assets/1554969314949.png">
<meta property="og:image" content="http://yoursite.com/assets/1554969499806.png">
<meta property="og:updated_time" content="2019-09-08T08:36:51.134Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发：并发编程的挑战">
<meta name="twitter:description" content="问题并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战。  性能与可伸缩性： 上下文切换的问题、锁的竞争。   活跃性危险： 死锁、饥饿、糟糕的响应性、活锁。   受限于硬件和软件的资源限制问题。  概述 性能与可伸缩性首先要保证程序能正常运行，然后仅当程序的性能需求和测试结果要求程序执行的更">
<meta name="twitter:image" content="http://yoursite.com/assets/162a01b71ebc4842">
  <link rel="canonical" href="http://yoursite.com/2019/04/11/Java/base/Java并发：并发编程的挑战/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java并发：并发编程的挑战 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-top">
      
    

    <a href="/top/" rel="section"><i class="menu-item-icon fa fa-fw fa-signal"></i> <br>阅读排行</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>

</div>
    </header>

    

  <a href="https://github.com/smallpocket" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/11/Java/base/Java并发：并发编程的挑战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">Java并发：并发编程的挑战

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-11 15:23:26" itemprop="dateCreated datePublished" datetime="2019-04-11T15:23:26+08:00">2019-04-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-08 16:36:51" itemprop="dateModified" datetime="2019-09-08T16:36:51+08:00">2019-09-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">9.3k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">17 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战。</p>
<ul>
<li>性能与可伸缩性：<ul>
<li>上下文切换的问题、锁的竞争。</li>
</ul>
</li>
<li>活跃性危险：<ul>
<li>死锁、饥饿、糟糕的响应性、活锁。</li>
</ul>
</li>
<li>受限于硬件和软件的资源限制问题。</li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/assets/162a01b71ebc4842" alt="思维导图"></p>
<h1 id="性能与可伸缩性"><a href="#性能与可伸缩性" class="headerlink" title="性能与可伸缩性"></a>性能与可伸缩性</h1><p>首先要保证程序能正常运行，然后仅当程序的性能需求和测试结果要求程序执行的更快时，才应该设法提高它的运行速度。</p>
<h2 id="对性能的思考"><a href="#对性能的思考" class="headerlink" title="对性能的思考"></a>对性能的思考</h2><p>提升性能意味着用更少的资源做更多的事情。<strong>资源</strong>指CPU时钟周期、内存、网络带宽、IO带宽、数据库请求、磁盘空间以及其他资源。</p>
<p>当操作性能由于某种特定的资源而受限时，通常称为<strong>资源密集型操作</strong>，例如CPU密集型、数据库密集型。</p>
<p>使用多个线程相比于单个线程总会引入一些额外的性能开销：</p>
<ul>
<li>线程间的协调，例如加锁、触发信号以及内存同步等。</li>
<li>上下文切换、线程的创建和销毁。</li>
<li>线程的调度等。</li>
</ul>
<p>因此想要通过并发获得更好的性能，就需要努力做好两件事情：更有效地利用现有处理资源、在出现新的处理资源时使程序尽可能利用这些新资源。</p>
<h3 id="性能与可伸缩性-1"><a href="#性能与可伸缩性-1" class="headerlink" title="性能与可伸缩性"></a>性能与可伸缩性</h3><p>应用程序的性能可以使用多个指标来衡量：服务时间、延迟时间、吞吐率、效率、可伸缩性、容量等：</p>
<ul>
<li>运行速度：某个指定的任务单元需要多块才能处理完成，用于衡量程序的运行速度。例如服务时间、等待时间。</li>
<li>处理能力：计算资源一定的情况下，能完成多少工作。例如生产量、吞吐量。</li>
</ul>
<blockquote>
<p>可伸缩性：当增加计算资源时(CPU、内存、存储或IO带宽)，程序的吞吐量或者处理能力能相应地增加。</p>
</blockquote>
<p><strong><em>性能调优</em></strong></p>
<p>通常目的时用更小的代价完成相同的工作，例如通过缓存重用之前的结果，或更换算法。</p>
<p><strong><em>可伸缩性调优</em></strong></p>
<p>目的是将问题的计算并行化，从而能利用更多的计算资源完成更多的工作。</p>
<p>对于多快与多少两个指标，是完全独立的，有时候甚至是相互矛盾的。要实现更高的可伸缩性或硬件利用率，通常会增加各个人物所要处理的工作量。</p>
<h3 id="评估各种性能权衡因素"><a href="#评估各种性能权衡因素" class="headerlink" title="评估各种性能权衡因素"></a>评估各种性能权衡因素</h3><p>大多数优化措施不成熟的原因之一：它们通常无法获得一组明确的需求。</p>
<blockquote>
<p>避免不成熟的优化。首先使程序正确，然后再提高运行速度——如果它还运行地不够快。</p>
</blockquote>
<p>当进行决策时，有时候通过增加某种形式的成本来降低另一种形式的开销。大多数性能决策都包含多个变量，并且非常依赖于运行环境。在使得某个方案比其他方案更快前，首先要明确：</p>
<ul>
<li>更快的含义时什么</li>
<li>该方法在什么条件下运行地更快？低负载还是高负载？大数据集还是小数据集？能否通过测试结果验证答案</li>
<li>这些条件在运行环境中的发生频率？能否通过测试结果验证答案</li>
<li>在其他不同条件的环境中能否使用这些代码</li>
<li>在实现这种性能提升时需要付出哪些隐含的代价，例如增加开发风险或维护开销？这种权衡是否合适？</li>
</ul>
<p>对于并发，开发人员对于哪些地方存在性能问题，哪种方法的运行速度更快，以及哪种方法的可伸缩性更高，往往会存在错误的直觉。因此在性能调优时一定要有明确的性能需求(什么时候需要调优，什么时候应该停止)。并且需要应该测试环境进行测试是否达到了预期目标。</p>
<blockquote>
<p>以测试为基准，不要猜测。</p>
</blockquote>
<h2 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h2><blockquote>
<p>明确并行部分的代码与串行部分的代码后再进行优化。</p>
</blockquote>
<p>大多数并发程序都是由一系列的并行工作和串行工作组成的。Amdahl定律描述的是：在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中可并行组件与串行组件所占的比重。假设F是必须被串行执行的部分，则在包含N个处理器的机器中，最高加速比为：<br>$$<br>Speedup&lt;1/(F+(1-F)/N)<br>$$<br>即如果程序有50%的计算需要串行执行，那么最高加速比只能是2。该理论还量化了串行化的效率。</p>
<p><img src="/assets/1565230366029.png" alt="1554968889175"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>当代多核CPU成为主流，系统可能拥有数百个处理器，一些在4路系统中看似具有可伸缩性的算法，可能存在一些隐含的可伸缩瓶颈。</p>
<h2 id="线程引入的开销"><a href="#线程引入的开销" class="headerlink" title="线程引入的开销"></a>线程引入的开销</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>如果可运行的线程大于CPU的数量，那么OS最终会将某个正在运行的线程调度出来，从而使其他线程能够使用CPU，这将导致一次上下文切换。</p>
<p><strong><em>上下文切换概念</em></strong></p>
<p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<p><strong>损耗</strong>：</p>
<ul>
<li>保存上一个任务状态、再加载下一个任务状态所消耗的时间。并且新的线程数据可能不在缓存中，将导致一些缓存丢失，使得线程在首次调度运行时更加缓慢。因此线程有一个最小执行时间。</li>
<li>应用程序、OS、JVM使用一组相同的CPU，在JVM和OS的代码中消耗越多的CPU时钟周期，应用程序的可用CPU时钟周期就越少。</li>
</ul>
<p><strong>单核处理器实现多线程执行代码：</strong></p>
<p>CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。</p>
<h4 id="多线程未必很快"><a href="#多线程未必很快" class="headerlink" title="多线程未必很快"></a>多线程未必很快</h4><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。</p>
<p>多线程就是几乎同时执行多个线程（一个处理器在某一个时间点上永远都只能是一个线程！即使这个处理器是多核的，除非有多个处理器才能实现多个线程同时运行）。CPU通过给每个线程分配CPU时间片来实现伪同时运行，因为CPU时间片一般很短很短，所以给人一种同时运行的感觉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 执行次数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> count = <span class="number">10000l</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//并发计算</span></span><br><span class="line">    concurrency();</span><br><span class="line">    <span class="comment">//单线程计算</span></span><br><span class="line">    serial();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concurrency</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                a += <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        b--;</span><br><span class="line">    &#125;</span><br><span class="line">    thread.join();</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">    System.out.println(<span class="string">"concurrency :"</span> + time + <span class="string">"ms,b="</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        a += <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        b--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">    System.out.println(<span class="string">"serial:"</span> + time + <span class="string">"ms,b="</span> + b + <span class="string">",a="</span> + a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/1554968889175.png" alt="1554968889175"></p>
<h4 id="测试上下文切换"><a href="#测试上下文切换" class="headerlink" title="测试上下文切换"></a>测试上下文切换</h4><ul>
<li>使用Lmbench3（性能分析工具）可以测量上下文切换的<strong>时长。</strong></li>
<li>一般相当于5000~10000个时钟周期，即几微秒。</li>
<li>使用vmstat可以测量上下文切换的<strong>次数。</strong><ul>
<li>一般一秒1000多次，如果内核占有率很高(10%以上)，那么通常表示调度活动发生很频繁，可能由IO或竞争锁导致的。</li>
</ul>
</li>
</ul>
<h4 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h4><p>上下文切换又分为2种：让步式上下文切换和<strong>抢占式上下文切换</strong>。前者是指执行线程主动释放CPU，与锁竞争严重程度成正比，可通过减少锁竞争和使用CAS算法来避免；后者是指线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，一般由于<strong>线程数大于CPU可用核心数引起</strong>，可通过适当减少线程数和使用协程来避免。</p>
<p>如果线程频繁发生阻塞，它们将无法使用完整的调度时间片。在程序上发生越多的阻塞，与CPU密集型的程序就会发生越多的上下文切换，从而增加调度开销，因此降低吞吐量。</p>
<p><strong>方法</strong></p>
<ul>
<li>无锁并发编程：<ul>
<li>避免使用锁，如将数据ID按照HASH算法取模分段，不同线程处理不同段的数据。</li>
</ul>
</li>
<li>CAS算法。</li>
<li>使用最少线程。<ul>
<li>避免创造太多的线程，使得大量线程处于等待。</li>
</ul>
</li>
<li>使用协程。<ul>
<li>单线程当中实现多任务的调度，并在单个线程里维持多个任务的切换。</li>
</ul>
</li>
</ul>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>通过减少大量waiting线程来减少上下文切换：</p>
<p><img src="/assets/1554969302239.png" alt="1554969302239"></p>
<p><img src="/assets/1554969314949.png" alt="1554969314949"></p>
<h3 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h3><p>内存操作的性能开销包括多个方面，例如<code>volatile</code>提供的可见性会使用到一些特殊指令，即内存栅栏(<code>Memory Barrier</code>)内存栅栏可以刷新缓存，使得缓存无效，刷新硬件写缓存，以及停止执行管道。并且会对性能带来间接影响，因为将抑制一些优化操作。</p>
<p>评估同步带来的性能影响，要区分有竞争的同步和无竞争的同步(volatile通常是非竞争的)。synchrnized对无竞争的同步进行了优化，非竞争的同步对整体性能影响微乎其微。</p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>竞争的同步可能需要OS介入，从而增加开销。当在锁上发生竞争时，竞争失败的线程肯定会则是，JVM在实现阻塞行为时可以采用自旋等待，或OS挂起被阻塞的线程。具体的效率高低要取决于上下文切换的开销以及在成功获得锁之前等待的时间。</p>
<h2 id="减少锁竞争"><a href="#减少锁竞争" class="headerlink" title="减少锁竞争"></a>减少锁竞争</h2><p>串行操作会降低并行性，上下文切换也会降低性能，在锁上发生竞争将同时导致这两种问题。</p>
<blockquote>
<p>在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。</p>
</blockquote>
<p>减少锁发生竞争的可能性有:</p>
<ul>
<li>锁的请求频率。</li>
<li>每次持有该锁的时间：<ul>
<li>即缩小锁的范围。</li>
<li>降低线程请求锁的频率，可以通过<strong>锁分解</strong>和<strong>锁分段</strong>等技术实现，使得不同线程在不同的数据或一个数据的不同部分上操作。<ul>
<li>锁分段一定要表现出在锁上的竞争频率高于在锁保护的数据上发生的频率。</li>
</ul>
</li>
</ul>
</li>
<li>也可以使用带有协调机制的独占锁，这些机制允许更高的并发性。</li>
</ul>
<p>当每个请求都请求多个变量时，锁的粒度将很难降低。</p>
<h2 id="监测CPU的利用率"><a href="#监测CPU的利用率" class="headerlink" title="监测CPU的利用率"></a>监测CPU的利用率</h2><p>当测试可伸缩性时，通常要确保处理器得到充分利用。UNIX上的vmstat可以查看CPU的忙碌状态。如果所有的CPU利用率并不均匀，那么首要目标就是进一步找出程序中的并行性，不均匀的利用率表明大多数计算都是由一小组线程完成的。通常有以下几种原因:</p>
<ul>
<li>负载不充足。测试的程序中可能没有足够多的负载，因而可以在测试时增加负载，并检查利用率、响应时间、服务时间等指标的变化。</li>
<li>IO密集。可以通过iostat或perfmon判断某个程序是否磁盘IO密集的，或通过监测网络的通信流量判断是否需要高带宽。</li>
<li>外部限制。如果应用程序依赖于外部服务，可能性能瓶颈是在外部服务中。</li>
<li>锁竞争。使用分析工具可以找到程序中存在何种程度的锁竞争，以及在哪些锁上存在激烈的竞争。如果因为激烈的竞争，<strong>则在线程转储中会频繁出现</strong>。</li>
</ul>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。所以在进行并发编程时，要考虑这些资源的限制。</p>
<ul>
<li>服务器的带宽只有2Mb/s，某个资源的下载速度是1Mb/s每秒，系统启动10个线程下载资源，下载速度不会变成10Mb/s。</li>
<li>硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。</li>
<li>软件资源限制有数据库的连接数和socket连接数等。</li>
</ul>
<h3 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h3><p>本来是并发编程，但由于资源限制，导致并行退化为串行。在此情况下，由于上下文切换与资源调度，导致执行速度更慢。</p>
<p>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。例如，之前看到一段程序使用多线程在办公网并发地下载和处理数据时，导致CPU利用率达到100%，几个小时都不能运行完成任务，后来修改成单线程，一个小时就执行完成了。</p>
<h3 id="解决资源限制"><a href="#解决资源限制" class="headerlink" title="解决资源限制"></a>解决资源限制</h3><ul>
<li>对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行。比如使用ODPS、Hadoop或者自己搭建服务器集群，不同的机器处理不同的数据。可以通过“数据ID%机器数”，计算得到一个机器编号，然后由对应编号的机器处理这笔数据。</li>
<li>对于软件资源限制，可以考虑使用资源池将资源复用。比如使用连接池将数据库和Socket连接复用，或者在调用对方webservice接口获取数据时，只建立一个连接。</li>
</ul>
<h3 id="在资源限制情况下进行并发编程"><a href="#在资源限制情况下进行并发编程" class="headerlink" title="在资源限制情况下进行并发编程"></a>在资源限制情况下进行并发编程</h3><p>如何在资源限制的情况下，让程序执行得更快呢？</p>
<ul>
<li>方法就是，根据不同的资源限制调整程序的并发度：<ul>
<li>比如下载文件程序依赖于两个资源——带宽和硬盘读写速度。</li>
<li>有数据库操作时，涉及数据库连接数，如果SQL语句执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。</li>
</ul>
</li>
</ul>
<h1 id="活跃性危险"><a href="#活跃性危险" class="headerlink" title="活跃性危险"></a>活跃性危险</h1><p>在安全性与活跃性间通常存在某种制衡，我们使用加锁确保线程安全，但如果过度使用加锁，则可能导致锁顺序死锁。</p>
<p>如果使用线程池和信号量来限制对资源的使用，可能导致资源死锁。<strong>Java程序无法从死锁中恢复过来</strong>，因此设计时一定要排除可能导致死锁的条件。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>死锁的必要条件：</p>
<ul>
<li>互斥条件。</li>
<li>请求和保持条件。</li>
<li>不剥夺条件。</li>
<li>环路等待条件。</li>
</ul>
<p>解决锁：</p>
<ul>
<li>持有锁一定时间，依然在等待的话，则释放持有的所有锁。</li>
</ul>
<p><strong>死锁示例</strong></p>
<p>A、B锁互相等待：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String A = <span class="string">"A"</span>;</span><br><span class="line">    <span class="comment">/** B锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String B = <span class="string">"B"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DeadLockDemo().deadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出现的场景"><a href="#出现的场景" class="headerlink" title="出现的场景"></a>出现的场景</h3><ul>
<li>t1拿到锁之后，因为一些异常情况没有释放锁（死循环）。</li>
<li>t1拿到一个数据库锁，释放锁的时候抛出了异常，没释放掉。</li>
</ul>
<p><strong><em>锁顺序死锁</em></strong></p>
<p>两个线程试图以不同的顺序来获得相同的锁。如果按照相同的顺序来请求锁就不会出现循环的加锁依赖性。</p>
<blockquote>
<p>如果所有线程都以固定的顺序来获得锁，那么程序中就不会出现锁顺序死锁的问题。</p>
</blockquote>
<p><strong><em>动态的锁顺序死锁</em></strong></p>
<p>有时候并不能清楚地知道是否在锁顺序上有足够的控制权来避免死锁的发生。</p>
<p>假设一个转账的场景，需要获得转账的账户A以及被转账的账户B的锁，那么假设同时发生A-&gt;B转账与B-&gt;A转账。则会产生死锁。</p>
<p>可以通过定义锁的顺序，并在整个应用程序中都按照这个顺序来获取锁。</p>
<p><strong><em>在协作对象间发生的死锁</em></strong></p>
<p>在协作对象间，很容易出现锁的获取顺序不同的问题，因为作为两个不同的业务场景，它们最开始需要的锁很可能是不同的。</p>
<blockquote>
<p>如果在持有锁时调用某个外部方法，那么将出现活跃性问题。在这个外部方法中可能或获取其他锁(可能产生死锁)，或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。</p>
</blockquote>
<p><strong><em>开放调用</em></strong></p>
<p>如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。</p>
<blockquote>
<p>在程序中应尽量使用开放调用，与那些在持有锁时调用外部方法的程序相比，更易于对依赖于开放调用的程序进行死锁分析。</p>
</blockquote>
<p><strong><em>资源死锁</em></strong></p>
<p>在相同的资源集合上等待时也会出现死锁，例如等待数据库连接。</p>
<p>另一种形式就是线程饥饿死锁，例如单线程的线程池中一个任务提交另一个任务，则第一个任务永远等待，另一个任务永远在队列中等待。</p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>在使用细粒度锁的程序中，可以通过使用一种两阶段策略来检查代码中的死锁：首先找出在什么地方将获取多个锁(使这个集合尽量小)，然后对所有这些示例进行全局分析，从而确保它们在整个程序中获取锁的顺序都保持一致。</p>
<p>利用dump线程查看到底哪个线程出现了问题，可见是42行、31行出现死锁：</p>
<p><img src="/assets/1554969499806.png" alt="1554969499806"></p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>当必须获取多个锁，那么在设计时必须考虑锁的顺序，尽量减少潜在的加锁交互数量，将获取锁需要遵守的协议写入文档。</p>
<p>常见方法：</p>
<ul>
<li>避免一个线程同时获取多个锁。</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。<ul>
<li>超时后释放锁，并在一段时间后重新尝试。但是对于嵌套的多个锁效果很差。</li>
</ul>
</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
</ul>
<h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>当线程由于无法访问它所需要的资源而不能继续执行时就发生了饥饿。</p>
<p>最常见的资源时CPU时钟周期。例如线程优先级（OS相关，增加平台依赖性）使用不当，或者持有锁时进行一些无法结束的结构，也会导致饥饿。</p>
<h2 id="丢失信号"><a href="#丢失信号" class="headerlink" title="丢失信号"></a>丢失信号</h2><h2 id="糟糕的响应性"><a href="#糟糕的响应性" class="headerlink" title="糟糕的响应性"></a>糟糕的响应性</h2><p>如果某个线程长时间占有一个锁，而其他想要访问整个容器的线程就需要等待很长时间。</p>
<h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁是另一种活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操，而且总会失败。</p>
<p>例如处理事务消息的程序，如果不能成功处理某个消息，则回滚整个事务，并将其重新放到队列的开头，如果消息处理器处理某种特定类型的消息存在错误并导致事务失败，那么由于消息在队列开头，处理器将反复调用并一直失败。</p>
<h1 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h1><ol>
<li>线程间如何通信。通信指线程间以何种机制交换信息。</li>
<li>线程间如何同步。</li>
</ol>
<p>在命令式编程中，线程通信机制有两种：</p>
<ul>
<li>共享内存。<ul>
<li>线程间共享程序的公共状态，通过读写内存中的公共状态进行隐式通信。</li>
<li>同步是显式进行的，程序员必须显式指定某个方法或某段代码需要在线程间互斥执行。</li>
</ul>
</li>
<li>消息传递。<ul>
<li>线程间没有公共状态，必须通过发送消息来显式进行通信。</li>
<li>同步是隐式进行的，消息的发送必须在消息的接受前。</li>
</ul>
</li>
</ul>
<p><strong>Java并发采用的是共享内存模型</strong></p>
<p>Java线程间通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<h1 id="多线程开发良好的实践"><a href="#多线程开发良好的实践" class="headerlink" title="多线程开发良好的实践"></a>多线程开发良好的实践</h1><ul>
<li>给线程起个有意义的名字，这样可以方便找 Bug。</li>
<li>缩小同步范围，从而减少锁争用。例如对于synchronized，应该尽量使用同步块而不是同步方法。</li>
<li>多用同步工具少用<code>wait()</code>和<code>notify()</code>。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger这些同步类简化了编码操作，而用<code>wait()</code>和<code>notify()</code>很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的JDK中还会不断优化和完善。</li>
<li>使用BlockingQueue实现生产者消费者问题。</li>
<li>多用并发集合少用同步集合，例如应该使用ConcurrentHashMap而不是Hashtable。</li>
<li>使用本地变量和不可变类来保证线程安全。</li>
<li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>建议多使用JDK并发包提供的并发容器和工具类来解决并发问题，因为这些类都已经通过了充分的测试和优化，均可解决了本章提到的几个挑战。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/qq_34337272/article/details/79844051" target="_blank" rel="noopener">Java多线程学习（七）并发编程中一些问题</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/并发编程/" rel="tag"># 并发编程</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2019/04/08/计算机网络/计算机网络：网络层/" rel="next" title="计算机网络：网络层">
                <i class="fa fa-chevron-left"></i> 计算机网络：网络层
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2019/04/11/Java/base/Java并发：并发机制的底层原理/" rel="prev" title="Java并发：并发机制的底层原理">
                Java并发：并发机制的底层原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">209</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#问题"><span class="nav-number">1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#性能与可伸缩性"><span class="nav-number">3.</span> <span class="nav-text">性能与可伸缩性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对性能的思考"><span class="nav-number">3.1.</span> <span class="nav-text">对性能的思考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#性能与可伸缩性-1"><span class="nav-number">3.1.1.</span> <span class="nav-text">性能与可伸缩性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#评估各种性能权衡因素"><span class="nav-number">3.1.2.</span> <span class="nav-text">评估各种性能权衡因素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Amdahl定律"><span class="nav-number">3.2.</span> <span class="nav-text">Amdahl定律</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#应用"><span class="nav-number">3.2.1.</span> <span class="nav-text">应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程引入的开销"><span class="nav-number">3.3.</span> <span class="nav-text">线程引入的开销</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文切换"><span class="nav-number">3.3.1.</span> <span class="nav-text">上下文切换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程未必很快"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">多线程未必很快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试上下文切换"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">测试上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何减少上下文切换"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">如何减少上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实战"><span class="nav-number">3.3.1.4.</span> <span class="nav-text">实战</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存同步"><span class="nav-number">3.3.2.</span> <span class="nav-text">内存同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞"><span class="nav-number">3.3.3.</span> <span class="nav-text">阻塞</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#减少锁竞争"><span class="nav-number">3.4.</span> <span class="nav-text">减少锁竞争</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#监测CPU的利用率"><span class="nav-number">3.5.</span> <span class="nav-text">监测CPU的利用率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源限制"><span class="nav-number">3.6.</span> <span class="nav-text">资源限制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">3.6.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引发的问题"><span class="nav-number">3.6.2.</span> <span class="nav-text">引发的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决资源限制"><span class="nav-number">3.6.3.</span> <span class="nav-text">解决资源限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在资源限制情况下进行并发编程"><span class="nav-number">3.6.4.</span> <span class="nav-text">在资源限制情况下进行并发编程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#活跃性危险"><span class="nav-number">4.</span> <span class="nav-text">活跃性危险</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁"><span class="nav-number">4.1.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#是什么"><span class="nav-number">4.1.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#出现的场景"><span class="nav-number">4.1.2.</span> <span class="nav-text">出现的场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁检测"><span class="nav-number">4.1.3.</span> <span class="nav-text">死锁检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁避免"><span class="nav-number">4.1.4.</span> <span class="nav-text">死锁避免</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#饥饿"><span class="nav-number">4.2.</span> <span class="nav-text">饥饿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#丢失信号"><span class="nav-number">4.3.</span> <span class="nav-text">丢失信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#糟糕的响应性"><span class="nav-number">4.4.</span> <span class="nav-text">糟糕的响应性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#活锁"><span class="nav-number">4.5.</span> <span class="nav-text">活锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发编程模型的两个关键问题"><span class="nav-number">5.</span> <span class="nav-text">并发编程模型的两个关键问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程开发良好的实践"><span class="nav-number">6.</span> <span class="nav-text">多线程开发良好的实践</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">40:56</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        




  <script>
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=66458302";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  























  <script src="/js/local-search.js?v=7.2.0"></script>














</body>
</html>
