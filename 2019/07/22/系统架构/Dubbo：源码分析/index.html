<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Dubbo">
<meta name="keywords" content="Dubbo">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo：源码分析">
<meta property="og:url" content="http://yoursite.com/2019/07/22/系统架构/Dubbo：源码分析/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Dubbo">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/07/22/系统架构/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/assets/java-spi-result.jpg">
<meta property="og:image" content="http://yoursite.com/2019/07/22/系统架构/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/assets/dubbo-spi-result.jpg">
<meta property="og:image" content="http://yoursite.com/2019/07/22/系统架构/Dubbo：源码分析/assets/service-registry.png">
<meta property="og:image" content="http://yoursite.com/2019/07/22/系统架构/Dubbo：源码分析/assets/15417503733794.jpg">
<meta property="og:updated_time" content="2019-07-24T11:22:43.688Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dubbo：源码分析">
<meta name="twitter:description" content="Dubbo">
<meta name="twitter:image" content="http://yoursite.com/2019/07/22/系统架构/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/assets/java-spi-result.jpg">






  <link rel="canonical" href="http://yoursite.com/2019/07/22/系统架构/Dubbo：源码分析/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Dubbo：源码分析 | Hexo</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c90f7388e03d4ed7e98a545b1d69200e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
    <a href="/schedule/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>Schedule</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/系统架构/Dubbo：源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Dubbo：源码分析
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-22 16:24:52" itemprop="dateCreated datePublished" datetime="2019-07-22T16:24:52+08:00">2019-07-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-24 19:22:43" itemprop="dateModified" datetime="2019-07-24T19:22:43+08:00">2019-07-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/22/系统架构/Dubbo：源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments: </span> <span class="post-comments-count gitment-comments-count" data-xid="/2019/07/22/系统架构/Dubbo：源码分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          
              <div class="post-description">Dubbo</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Dubbo的服务"><a href="#Dubbo的服务" class="headerlink" title="Dubbo的服务"></a>Dubbo的服务</h1><h1 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SPI全称为Service Provider Interface，是一种服务发现机制。SPI的本质是将接口类的全限定名配置在文件中，由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。</p>
<p>基于此特性，可以很容易地通过SPI机制为我们的程序提供拓展功能。</p>
<h2 id="SPI示例"><a href="#SPI示例" class="headerlink" title="SPI示例"></a>SPI示例</h2><h3 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h3><p>首先定义一个接口，声明为Robot</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义两个实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimusPrime</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, I am Optimus Prime."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bumblebee</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, I am Bumblebee."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在META-INF/services 文件夹下创建一个文件，名称为 Robot 的全限定名 org.apache.spi.Robot。文件内容为实现类的全限定的类名，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.spi.OptimusPrime</span><br><span class="line">org.apache.spi.Bumblebee</span><br></pre></td></tr></table></figure>

<p>编写测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaSPITest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class);</span><br><span class="line">        System.out.println(<span class="string">"Java SPI"</span>);</span><br><span class="line">        serviceLoader.forEach(Robot::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<p><img src="../%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/assets/java-spi-result.jpg" alt="img"></p>
<p>从测试结果可以看出，我们的两个实现类被成功的加载，并输出了相应的内容。关于 Java SPI 的演示先到这里，接下来演示 Dubbo SPI。</p>
<h3 id="Dubbo-SPI-1"><a href="#Dubbo-SPI-1" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h3><p>Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo 路径下，配置内容如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimusPrime = org.apache.spi.OptimusPrime</span><br><span class="line">bumblebee = org.apache.spi.Bumblebee</span><br></pre></td></tr></table></figure>

<p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外，在测试 Dubbo SPI 时，需要在 Robot 接口上标注 @SPI 注解。下面来演示 Dubbo SPI 的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboSPITest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader = </span><br><span class="line">            ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        Robot optimusPrime = extensionLoader.getExtension(<span class="string">"optimusPrime"</span>);</span><br><span class="line">        optimusPrime.sayHello();</span><br><span class="line">        Robot bumblebee = extensionLoader.getExtension(<span class="string">"bumblebee"</span>);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p><img src="../%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/assets/dubbo-spi-result.jpg" alt="img"></p>
<p>Dubbo SPI 除了支持按需加载接口实现类，还增加了 IOC 和 AOP 等特性</p>
<h2 id="Dubbo-SPI源码分析"><a href="#Dubbo-SPI源码分析" class="headerlink" title="Dubbo SPI源码分析"></a>Dubbo SPI源码分析</h2><p>ExtensionLoader的getExtensionLoader 会获取一个ExtensionLoader 实例，然后再通过 ExtensionLoader 的 getExtension 方法获取拓展类对象。这其中，getExtensionLoader 方法用于从缓存中获取与拓展类对应的 ExtensionLoader，若缓存未命中，则创建一个新的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboSPITest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader = </span><br><span class="line">            ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        <span class="comment">//获取拓展类</span></span><br><span class="line">        Robot optimusPrime = extensionLoader.getExtension(<span class="string">"optimusPrime"</span>);</span><br><span class="line">        optimusPrime.sayHello();</span><br><span class="line">        Robot bumblebee = extensionLoader.getExtension(<span class="string">"bumblebee"</span>);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析拓展类对象的获取过程"><a href="#分析拓展类对象的获取过程" class="headerlink" title="分析拓展类对象的获取过程"></a>分析拓展类对象的获取过程</h3><p>首先分析ExtensionLoader 的 getExtension 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"true"</span>.equals(name)) &#123;</span><br><span class="line">        <span class="comment">// 获取默认的拓展实现类</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Holder，顾名思义，用于持有目标对象</span></span><br><span class="line">    Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cachedInstances.putIfAbsent(name, <span class="keyword">new</span> Holder&lt;Object&gt;());</span><br><span class="line">        holder = cachedInstances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    Object instance = holder.get();</span><br><span class="line">    <span class="comment">// 双重检查</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建拓展实例</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                <span class="comment">// 设置实例到 holder 中</span></span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>创建拓展对象的过程</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从配置文件中加载所有的拓展类，可得到“配置项名称”到“配置类”的映射关系表</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过反射创建实例</span></span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向实例中注入依赖</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 循环创建 Wrapper 实例</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                <span class="comment">// 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例。</span></span><br><span class="line">                <span class="comment">// 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量</span></span><br><span class="line">                instance = injectExtension(</span><br><span class="line">                    (T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createExtension 方法的逻辑稍复杂一下，包含了如下的步骤：</p>
<ol>
<li>通过 getExtensionClasses 获取所有的拓展类</li>
<li>通过反射创建拓展对象</li>
<li>向拓展对象中注入依赖</li>
<li>将拓展对象包裹在相应的 Wrapper 对象中</li>
</ol>
<p>以上步骤中，第一个步骤是加载拓展类的关键，第三和第四个步骤是 Dubbo IOC 与 AOP 的具体实现。在接下来的章节中，将会重点分析 getExtensionClasses 方法的逻辑，以及简单介绍 Dubbo IOC 的具体实现。</p>
<h2 id="Dubbo-IOC"><a href="#Dubbo-IOC" class="headerlink" title="Dubbo IOC"></a>Dubbo IOC</h2><p>Dubbo IOC 是通过 setter 方法注入依赖。Dubbo 首先会通过反射获取到实例的所有方法，然后再遍历方法列表，检测方法名是否具有 setter 方法特征。若有，则通过 ObjectFactory 获取依赖对象，最后通过反射调用 setter 方法将依赖设置到目标对象中。整个过程对应的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历目标类的所有方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="comment">// 检测方法是否以 set 开头，且方法仅有一个参数，且方法访问级别为 public</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br><span class="line">                    &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                    &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                    <span class="comment">// 获取 setter 方法参数类型</span></span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取属性名，比如 setName 方法对应属性名 name</span></span><br><span class="line">                        String property = method.getName().length() &gt; <span class="number">3</span> ? </span><br><span class="line">                            method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + </span><br><span class="line">                            	method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line">                        <span class="comment">// 从 ObjectFactory 中获取依赖对象</span></span><br><span class="line">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 通过反射调用 setter 方法设置依赖</span></span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"fail to inject via method..."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，objectFactory 变量的类型为 AdaptiveExtensionFactory，AdaptiveExtensionFactory 内部维护了一个 ExtensionFactory 列表，用于存储其他类型的 ExtensionFactory。Dubbo 目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建自适应的拓展，后者是用于从 Spring 的 IOC 容器中获取所需的拓展。这两个类的类的代码不是很复杂，这里就不一一分析了。</p>
<p>Dubbo IOC 目前仅支持 setter 方式注入，总的来说，逻辑比较简单易懂。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章简单分别介绍了 Java SPI 与 Dubbo SPI 用法，并对 Dubbo SPI 的加载拓展类的过程进行了分析。另外，在 Dubbo SPI 中还有一块重要的逻辑这里没有进行分析，即 Dubbo SPI 的扩展点自适应机制。该机制的逻辑较为复杂，我们将会在下一篇文章中进行详细的分析。</p>
<p># </p>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC的核心实现是Protocol层，协议层主要由Protocol、Invoker、Exporter三个接口实现，他们的关系是：</p>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>首先看Protocol的接口方法</p>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">暴露远程服务</span><br><span class="line">协议在接收请求时，应记录请求来源方的地址信息</span><br><span class="line">export必须是幂等的，即暴露一个URL的invoke两次，和暴露一次没有区别</span><br><span class="line">export传入的invoke由框架实现并传入，协议不需要关心</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Export service for remote invocation: &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 1. Protocol should record request source address after receive a request:</span></span><br><span class="line"><span class="comment"> * RpcContext.getContext().setRemoteAddress();&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 2. export() must be idempotent, that is, there's no difference between invoking once and invoking twice when</span></span><br><span class="line"><span class="comment"> * export the same URL&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 3. Invoker instance is passed in by the framework, protocol needs not to care &lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;     Service type 服务的类型 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> invoker Service invoker 服务的执行者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> exporter reference for exported service, useful for unexport the service later 暴露服务的引用，用于取消暴露</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RpcException thrown when error occurs during export the service, for example: port is occupied 在暴露服务出错时抛出，比如端口已占用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line">&lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br></pre></td></tr></table></figure>

<h3 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">引用远程服务</span><br><span class="line">在用户调用refer返回的Invoker对象的invoke方法时，协议需要执行同URL远端export传入的Invoker对象的invoke方法</span><br><span class="line">refer返回的Invoker由协议实现，协议通常需要在此Invoker中发送远程请求</span><br><span class="line">在URL中设置check=<span class="keyword">false</span>时，连接失败不能抛出异常，并在内部自动恢复</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Refer a remote service: &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 1. When user calls `invoke()` method of `Invoker` object which's returned from `refer()` call, the protocol</span></span><br><span class="line"><span class="comment"> * needs to correspondingly execute `invoke()` method of `Invoker` object &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 2. It's protocol's responsibility to implement `Invoker` which's returned from `refer()`. Generally speaking,</span></span><br><span class="line"><span class="comment"> * protocol sends remote request in the `Invoker` implementation. &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 3. When there's check=false set in URL, the implementation must not throw exception but try to recover when</span></span><br><span class="line"><span class="comment"> * connection fails.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;  Service type 服务的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type Service class 服务的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url  URL address for the remote service 远程服务的URL地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> invoker service's local proxy 服务的本地代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RpcException when there's any error while connecting to the service provider 在连接服务提供者失败时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line">&lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h2><h2 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h2><h1 id="服务导出"><a href="#服务导出" class="headerlink" title="服务导出"></a>服务导出</h1><p>Dubbo 服务导出过程始于 Spring 容器发布刷新事件，Dubbo 在接收到事件后，会立即执行服务导出逻辑。整个逻辑大致可分为三个部分</p>
<ul>
<li>第一部分是前置工作，主要用于检查参数，组装 URL。</li>
<li>第二部分是导出服务，包含导出服务到本地 (JVM)，和导出服务到远程两个过程。</li>
<li>第三部分是向注册中心注册服务，用于服务发现。</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>服务导出的入口方法是 ServiceBean 的 onApplicationEvent。onApplicationEvent 是一个事件响应方法，该方法会在收到 Spring 上下文刷新事件后执行服务导出操作。方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否有延迟导出 &amp;&amp; 是否已导出 &amp;&amp; 是不是已被取消导出</span></span><br><span class="line">    <span class="keyword">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">        <span class="comment">// 导出服务</span></span><br><span class="line">        export();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法首先会根据条件决定是否导出服务，比如有些服务设置了延时导出，那么此时就不应该在此处导出。还有一些服务已经被导出了，或者当前服务被取消导出了，此时也不能再次导出相关服务。</p>
<p>注意这里的 isDelay 方法，这个方法字面意思是“是否延迟导出服务”，返回 true 表示延迟导出，false 表示不延迟导出。但是该方法真实意思却并非如此，当方法返回 true 时，表示无需延迟导出。返回 false 时，表示需要延迟导出。与字面意思恰恰相反，这个需要大家注意一下。下面我们来看一下这个方法的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -☆- ServiceBean</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 delay</span></span><br><span class="line">    Integer delay = getDelay();</span><br><span class="line">    ProviderConfig provider = getProvider();</span><br><span class="line">    <span class="keyword">if</span> (delay == <span class="keyword">null</span> &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果前面获取的 delay 为空，这里继续获取</span></span><br><span class="line">        delay = provider.getDelay();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 delay 是否为空，或者等于 -1</span></span><br><span class="line">    <span class="keyword">return</span> supportedApplicationListener &amp;&amp; (delay == <span class="keyword">null</span> || delay == -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暂时忽略 supportedApplicationListener 这个条件，当 delay 为空，或者等于-1时，该方法返回 true，而不是 false。这个方法的返回值让人有点困惑。该方法目前已被重构，详细请参考 <a href="https://github.com/apache/dubbo/pull/2686" target="_blank" rel="noopener">dubbo #2686</a>。</p>
<p>现在解释一下 supportedApplicationListener 变量含义，该变量用于表示当前的 Spring 容器是否支持 ApplicationListener，这个值初始为 false。在 Spring 容器将自己设置到 ServiceBean 中时，ServiceBean 的 setApplicationContext 方法会检测 Spring 容器是否支持 ApplicationListener。若支持，则将 supportedApplicationListener 置为 true。ServiceBean 是 Dubbo 与 Spring 框架进行整合的关键，可以看做是两个框架之间的桥梁。具有同样作用的类还有 ReferenceBean。</p>
<p>现在我们知道了 Dubbo 服务导出过程的起点，接下来对服务导出export的前置逻辑进行分析。</p>
<h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><p>前置工作主要包含两个部分</p>
<ul>
<li>配置检查。在导出服务之前，Dubbo 需要检查用户的配置是否合理，或者为用户补充缺省配置。</li>
<li>URL 装配。配置检查完成后，接下来需要根据这些配置组装 URL。在 Dubbo 中，URL 的作用十分重要。Dubbo 使用 URL 作为配置载体，所有的拓展点都是通过 URL 获取配置。这一点，官方文档中有所说明。</li>
</ul>
<blockquote>
<p>采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息。</p>
</blockquote>
<p>接下来，我们先来分析配置检查部分的源码，随后再来分析 URL 组装部分的源码。</p>
<h3 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h3><p>本节我们接着前面的源码向下分析，前面说过 onApplicationEvent 方法在经过一些判断后，会决定是否调用 export 方法导出服务。那么下面我们从 <code>export</code> 方法开始进行分析，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 export 和 delay 配置</span></span><br><span class="line">        <span class="keyword">if</span> (export == <span class="keyword">null</span>) &#123;</span><br><span class="line">            export = provider.getExport();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delay == <span class="keyword">null</span>) &#123;</span><br><span class="line">            delay = provider.getDelay();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 export 为 false，则不导出服务</span></span><br><span class="line">    <span class="keyword">if</span> (export != <span class="keyword">null</span> &amp;&amp; !export) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delay &gt; 0，延时导出服务</span></span><br><span class="line">    <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayExportExecutor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                doExport();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 立即导出服务</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doExport();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>export 方法对两项配置进行了检查，并根据配置执行相应的动作。首先是 export 配置，这个配置决定了是否导出服务。有时候我们只是想本地启动服务进行一些调试工作，我们并不希望把本地启动的服务暴露出去给别人调用。此时，我们可通过配置 export 禁止服务导出，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">export</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>delay 配置顾名思义，用于延迟导出服务，这个就不分析了。下面，我们继续分析源码，这次要分析的是 <code>doExport</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//立即导出服务</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already unexported!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exported = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 检测 interfaceName 是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (interfaceName == <span class="keyword">null</span> || interfaceName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"interface not allow null!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测 provider 是否为空，为空则新建一个，并通过系统变量为其初始化</span></span><br><span class="line">    checkDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面几个 if 语句用于检测 provider、application 等核心配置类对象是否为空，</span></span><br><span class="line">    <span class="comment">// 若为空，则尝试从其他配置类对象中获取相应的实例。</span></span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">            application = provider.getApplication();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">module</span> = provider.getModule();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">        <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">        <span class="keyword">if</span> (protocols == <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">            registries = <span class="keyword">module</span>.getRegistries();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">            registries = application.getRegistries();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测 ref 是否为泛化服务类型</span></span><br><span class="line">    <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> GenericService) &#123;</span><br><span class="line">        <span class="comment">// 设置 interfaceClass 为 GenericService.class</span></span><br><span class="line">        interfaceClass = GenericService.class;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">            <span class="comment">// 设置 generic = "true"</span></span><br><span class="line">            generic = Boolean.TRUE.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// ref 非 GenericService 类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread()</span><br><span class="line">                    .getContextClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对 interfaceClass，以及 &lt;dubbo:method&gt; 标签中的必要字段进行检查</span></span><br><span class="line">        checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">        <span class="comment">// 对 ref 合法性进行检测</span></span><br><span class="line">        checkRef();</span><br><span class="line">        <span class="comment">// 设置 generic = "false"</span></span><br><span class="line">        generic = Boolean.FALSE.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// local 和 stub 在功能应该是一致的，用于配置本地存根</span></span><br><span class="line">    <span class="keyword">if</span> (local != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"true"</span>.equals(local)) &#123;</span><br><span class="line">            local = interfaceName + <span class="string">"Local"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; localClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取本地存根类</span></span><br><span class="line">            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法</span></span><br><span class="line">        <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The local implementation class "</span> + localClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stub != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处的代码和上一个 if 分支的代码基本一致，这里省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测各种对象是否为空，为空则新建，或者抛出异常</span></span><br><span class="line">    checkApplication();</span><br><span class="line">    checkRegistry();</span><br><span class="line">    checkProtocol();</span><br><span class="line">    appendProperties(<span class="keyword">this</span>);</span><br><span class="line">    checkStubAndMock(interfaceClass);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="keyword">null</span> || path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        path = interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出服务</span></span><br><span class="line">    doExportUrls();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ProviderModel 表示服务提供者模型，此对象中存储了与服务提供者相关的信息。</span></span><br><span class="line">    <span class="comment">// 比如服务的配置信息，服务实例等。每个被导出的服务对应一个 ProviderModel。</span></span><br><span class="line">    <span class="comment">// ApplicationModel 持有所有的 ProviderModel。</span></span><br><span class="line">    ProviderModel providerModel = <span class="keyword">new</span> ProviderModel(getUniqueServiceName(), <span class="keyword">this</span>, ref);</span><br><span class="line">    ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是配置检查的相关分析，代码比较多，需要大家耐心看一下。下面对配置检查的逻辑进行简单的总结，如下：</p>
<ol>
<li>检测 <a href="dubbo:service" target="_blank" rel="noopener">dubbo:service</a> 标签的 interface 属性合法性，不合法则抛出异常</li>
<li>检测 ProviderConfig、ApplicationConfig 等核心配置类对象是否为空，若为空，则尝试从其他配置类对象中获取相应的实例。</li>
<li>检测并处理泛化服务和普通服务类</li>
<li>检测本地存根配置，并进行相应的处理</li>
<li>对 ApplicationConfig、RegistryConfig 等配置类进行检测，为空则尝试创建，若无法创建则抛出异常</li>
</ol>
<p>配置检查并非本文重点，因此这里不打算对 doExport 方法所调用的方法进行分析（doExportUrls 方法除外）。在这些方法中，除了 appendProperties 方法稍微复杂一些，其他方法逻辑不是很复杂。因此，大家可自行分析。</p>
<h3 id="多协议多注册中心导出服务"><a href="#多协议多注册中心导出服务" class="headerlink" title="多协议多注册中心导出服务"></a>多协议多注册中心导出服务</h3><p>Dubbo 允许我们使用不同的协议导出服务，也允许我们向多个注册中心注册服务。Dubbo 在 doExportUrls 方法中对多协议，多注册中心进行了支持。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载注册中心链接</span></span><br><span class="line">    List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 遍历 protocols，并在每个协议下导出服务</span></span><br><span class="line">    <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">        doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码首先是通过 loadRegistries 加载注册中心链接，然后再遍历 ProtocolConfig 集合导出每个服务。并在导出服务的过程中，将服务注册到注册中心。下面，我们先来看一下 loadRegistries 方法的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;URL&gt; <span class="title">loadRegistries</span><span class="params">(<span class="keyword">boolean</span> provider)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测是否存在注册中心配置类，不存在则抛出异常</span></span><br><span class="line">    checkRegistry();</span><br><span class="line">    List&lt;URL&gt; registryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    <span class="keyword">if</span> (registries != <span class="keyword">null</span> &amp;&amp; !registries.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (RegistryConfig config : registries) &#123;</span><br><span class="line">            String address = config.getAddress();</span><br><span class="line">            <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 若 address 为空，则将其设为 0.0.0.0</span></span><br><span class="line">                address = Constants.ANYHOST_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从系统属性中加载注册中心地址</span></span><br><span class="line">            String sysaddress = System.getProperty(<span class="string">"dubbo.registry.address"</span>);</span><br><span class="line">            <span class="keyword">if</span> (sysaddress != <span class="keyword">null</span> &amp;&amp; sysaddress.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                address = sysaddress;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检测 address 是否合法</span></span><br><span class="line">            <span class="keyword">if</span> (address.length() &gt; <span class="number">0</span> &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123;</span><br><span class="line">                Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">                <span class="comment">// 添加 ApplicationConfig 中的字段信息到 map 中</span></span><br><span class="line">                appendParameters(map, application);</span><br><span class="line">                <span class="comment">// 添加 RegistryConfig 字段信息到 map 中</span></span><br><span class="line">                appendParameters(map, config);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 添加 path、pid，protocol 等信息到 map 中</span></span><br><span class="line">                map.put(<span class="string">"path"</span>, RegistryService.class.getName());</span><br><span class="line">                map.put(<span class="string">"dubbo"</span>, Version.getProtocolVersion());</span><br><span class="line">                map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(<span class="string">"protocol"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(<span class="string">"remote"</span>)) &#123;</span><br><span class="line">                        map.put(<span class="string">"protocol"</span>, <span class="string">"remote"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        map.put(<span class="string">"protocol"</span>, <span class="string">"dubbo"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解析得到 URL 列表，address 可能包含多个注册中心 ip，</span></span><br><span class="line">                <span class="comment">// 因此解析得到的是一个 URL 列表</span></span><br><span class="line">                List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map);</span><br><span class="line">                <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                    url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());</span><br><span class="line">                    <span class="comment">// 将 URL 协议头设置为 registry</span></span><br><span class="line">                    url = url.setProtocol(Constants.REGISTRY_PROTOCOL);</span><br><span class="line">                    <span class="comment">// 通过判断条件，决定是否添加 url 到 registryList 中，条件如下：</span></span><br><span class="line">                    <span class="comment">// (服务提供者 &amp;&amp; register = true 或 null) </span></span><br><span class="line">                    <span class="comment">//    || (非服务提供者 &amp;&amp; subscribe = true 或 null)</span></span><br><span class="line">                    <span class="keyword">if</span> ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="keyword">true</span>))</span><br><span class="line">                            || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, <span class="keyword">true</span>))) &#123;</span><br><span class="line">                        registryList.add(url);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> registryList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadRegistries 方法主要包含如下的逻辑：</p>
<ol>
<li>检测是否存在注册中心配置类，不存在则抛出异常</li>
<li>构建参数映射集合，也就是 map</li>
<li>构建注册中心链接列表</li>
<li>遍历链接列表，并根据条件决定是否将其添加到 registryList 中</li>
</ol>
<p>关于多协议多注册中心导出服务就先分析到这，代码不是很多，接下来分析 URL 组装过程。</p>
<h3 id="组装-URL"><a href="#组装-URL" class="headerlink" title="组装 URL"></a>组装 URL</h3><p>配置检查完毕后，紧接着要做的事情是根据配置，以及其他一些信息组装 URL。前面说过，URL 是 Dubbo 配置的载体，通过 URL 可让 Dubbo 的各种配置在各个模块之间传递。URL 之于 Dubbo，犹如水之于鱼，非常重要。大家在阅读 Dubbo 服务导出相关源码的过程中，要注意 URL 内容的变化。既然 URL 如此重要，那么下面我们来了解一下 URL 组装的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">    String name = protocolConfig.getName();</span><br><span class="line">    <span class="comment">// 如果协议名为空，或空串，则将协议名变量设置为 dubbo</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        name = <span class="string">"dubbo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 添加 side、版本、时间戳以及进程号等信息到 map 中</span></span><br><span class="line">    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">    map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());</span><br><span class="line">    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">    <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射将对象的字段信息添加到 map 中</span></span><br><span class="line">    appendParameters(map, application);</span><br><span class="line">    appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">    appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">    appendParameters(map, protocolConfig);</span><br><span class="line">    appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method&gt; 标签的配置信息</span></span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 这段代码用于添加 Callback 配置到 map 中，代码太长，待会单独分析</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测 generic 是否为 "true"，并根据检测结果向 map 中添加不同的信息</span></span><br><span class="line">    <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">        map.put(Constants.GENERIC_KEY, generic);</span><br><span class="line">        map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">        <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(<span class="string">"revision"</span>, revision);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为接口生成包裹类 Wrapper，Wrapper 中包含了接口的详细信息，比如接口方法名数组，字段信息等</span></span><br><span class="line">        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">        <span class="comment">// 添加方法名到 map 中，如果包含多个方法名，则用逗号隔开，比如 method = init,destroy</span></span><br><span class="line">        <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"NO method found in service interface ..."</span>);</span><br><span class="line">            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将逗号作为分隔符连接方法名，并将连接后的字符串放入 map 中</span></span><br><span class="line">            map.put(Constants.METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">","</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 token 到 map 中</span></span><br><span class="line">    <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">            <span class="comment">// 随机生成 token</span></span><br><span class="line">            map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(Constants.TOKEN_KEY, token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断协议名是否为 injvm</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123;</span><br><span class="line">        protocolConfig.setRegister(<span class="keyword">false</span>);</span><br><span class="line">        map.put(<span class="string">"notify"</span>, <span class="string">"false"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上下文路径</span></span><br><span class="line">    String contextPath = protocolConfig.getContextpath();</span><br><span class="line">    <span class="keyword">if</span> ((contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span>) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        contextPath = provider.getContextpath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 host 和 port</span></span><br><span class="line">    String host = <span class="keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">    Integer port = <span class="keyword">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class="line">    <span class="comment">// 组装 URL</span></span><br><span class="line">    URL url = <span class="keyword">new</span> URL(name, host, port, (contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span> ? <span class="string">""</span> : contextPath + <span class="string">"/"</span>) + path, map);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码首先是将一些信息，比如版本、时间戳、方法名以及各种配置对象的字段信息放入到 map 中，map 中的内容将作为 URL 的查询字符串。构建好 map 后，紧接着是获取上下文路径、主机名以及端口号等信息。最后将 map 和主机名等数据传给 URL 构造方法创建 URL 对象。需要注意的是，这里出现的 URL 并非 java.net.URL，而是 com.alibaba.dubbo.common.URL。</p>
<p>上面省略了一段代码，这里简单分析一下。这段代码用于检测 <a href="dubbo:method" target="_blank" rel="noopener">dubbo:method</a> 标签中的配置信息，并将相关配置添加到 map 中。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method&gt; 标签的配置信息</span></span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MethodConfig method : methods) &#123;</span><br><span class="line">            <span class="comment">// 添加 MethodConfig 对象的字段信息到 map 中，键 = 方法名.属性名。</span></span><br><span class="line">            <span class="comment">// 比如存储 &lt;dubbo:method name="sayHello" retries="2"&gt; 对应的 MethodConfig，</span></span><br><span class="line">            <span class="comment">// 键 = sayHello.retries，map = &#123;"sayHello.retries": 2, "xxx": "yyy"&#125;</span></span><br><span class="line">            appendParameters(map, method, method.getName());</span><br><span class="line"></span><br><span class="line">            String retryKey = method.getName() + <span class="string">".retry"</span>;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                String retryValue = map.remove(retryKey);</span><br><span class="line">                <span class="comment">// 检测 MethodConfig retry 是否为 false，若是，则设置重试次数为0</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"false"</span>.equals(retryValue)) &#123;</span><br><span class="line">                    map.put(method.getName() + <span class="string">".retries"</span>, <span class="string">"0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取 ArgumentConfig 列表</span></span><br><span class="line">            List&lt;ArgumentConfig&gt; arguments = method.getArguments();</span><br><span class="line">            <span class="keyword">if</span> (arguments != <span class="keyword">null</span> &amp;&amp; !arguments.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (ArgumentConfig argument : arguments) &#123;</span><br><span class="line">                    <span class="comment">// 检测 type 属性是否为空，或者空串（分支1 ⭐️）</span></span><br><span class="line">                    <span class="keyword">if</span> (argument.getType() != <span class="keyword">null</span> &amp;&amp; argument.getType().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Method[] methods = interfaceClass.getMethods();</span><br><span class="line">                        <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">                                String methodName = methods[i].getName();</span><br><span class="line">                                <span class="comment">// 比对方法名，查找目标方法</span></span><br><span class="line">                                <span class="keyword">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class="line">                                    Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();</span><br><span class="line">                                    <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                                        <span class="comment">// 检测 ArgumentConfig 中的 type 属性与方法参数列表</span></span><br><span class="line">                                        <span class="comment">// 中的参数名称是否一致，不一致则抛出异常(分支2 ⭐️)</span></span><br><span class="line">                                        <span class="keyword">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class="line">                                            <span class="comment">// 添加 ArgumentConfig 字段信息到 map 中，</span></span><br><span class="line">                                            <span class="comment">// 键前缀 = 方法名.index，比如:</span></span><br><span class="line">                                            <span class="comment">// map = &#123;"sayHello.3": true&#125;</span></span><br><span class="line">                                            appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error: ..."</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 分支3 ⭐️</span></span><br><span class="line">                                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; argtypes.length; j++) &#123;</span><br><span class="line">                                            Class&lt;?&gt; argclazz = argtypes[j];</span><br><span class="line">                                            <span class="comment">// 从参数类型列表中查找类型名称为 argument.type 的参数</span></span><br><span class="line">                                            <span class="keyword">if</span> (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                appendParameters(map, argument, method.getName() + <span class="string">"."</span> + j);</span><br><span class="line">                                                <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span> &amp;&amp; argument.getIndex() != j) &#123;</span><br><span class="line">                                                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error: ..."</span>);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 用户未配置 type 属性，但配置了 index 属性，且 index != -1</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;    <span class="comment">// 分支4 ⭐️</span></span><br><span class="line">                        <span class="comment">// 添加 ArgumentConfig 字段信息到 map 中</span></span><br><span class="line">                        appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config must set index or type"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码 for 循环和 if else 分支嵌套太多，导致层次太深，不利于阅读，需要耐心看一下。大家在看这段代码时，注意把几个重要的条件分支找出来。只要理解了这几个分支的意图，就可以弄懂这段代码。请注意上面代码中⭐️符号，这几个符号标识出了4个重要的分支，下面用伪代码解释一下这几个分支的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 ArgumentConfig 列表</span></span><br><span class="line"><span class="keyword">for</span> (遍历 ArgumentConfig 列表) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type 不为 <span class="keyword">null</span>，也不为空串) &#123;    <span class="comment">// 分支1</span></span><br><span class="line">        <span class="number">1</span>. 通过反射获取 interfaceClass 的方法列表</span><br><span class="line">        <span class="keyword">for</span> (遍历方法列表) &#123;</span><br><span class="line">            <span class="number">1</span>. 比对方法名，查找目标方法</span><br><span class="line">        	<span class="number">2</span>. 通过反射获取目标方法的参数类型数组 argtypes</span><br><span class="line">            <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;    <span class="comment">// 分支2</span></span><br><span class="line">                <span class="number">1</span>. 从 argtypes 数组中获取下标 index 处的元素 argType</span><br><span class="line">                <span class="number">2</span>. 检测 argType 的名称与 ArgumentConfig 中的 type 属性是否一致</span><br><span class="line">                <span class="number">3</span>. 添加 ArgumentConfig 字段信息到 map 中，或抛出异常</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 分支3</span></span><br><span class="line">                <span class="number">1</span>. 遍历参数类型数组 argtypes，查找 argument.type 类型的参数</span><br><span class="line">                <span class="number">2</span>. 添加 ArgumentConfig 字段信息到 map 中</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;    <span class="comment">// 分支4</span></span><br><span class="line">		<span class="number">1</span>. 添加 ArgumentConfig 字段信息到 map 中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本节分析的源码中，appendParameters 这个方法出现的次数比较多，该方法用于将对象字段信息添加到 map 中。实现上则是通过反射获取目标对象的 getter 方法，并调用该方法获取属性值。然后再通过 getter 方法名解析出属性名，比如从方法名 getName 中可解析出属性 name。如果用户传入了属性名前缀，此时需要将属性名加入前缀内容。最后将 &lt;属性名，属性值&gt; 键值对存入到 map 中就行了。限于篇幅原因，这里就不分析 appendParameters 方法的源码了，大家请自行分析。</p>
<h2 id="导出-Dubbo-服务"><a href="#导出-Dubbo-服务" class="headerlink" title="导出 Dubbo 服务"></a>导出 Dubbo 服务</h2><p>前置工作做完，接下来就可以进行服务导出了。服务导出分为导出到本地 (JVM)，和导出到远程。在深入分析服务导出的源码前，我们先来从宏观层面上看一下服务导出逻辑。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">            .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">        <span class="comment">// 加载 ConfiguratorFactory，并生成 Configurator 实例，然后通过实例配置 url</span></span><br><span class="line">        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line">    <span class="comment">// 如果 scope = none，则什么都不做</span></span><br><span class="line">    <span class="keyword">if</span> (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">        <span class="comment">// scope != remote，导出到本地</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            exportLocal(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// scope != local，导出到远程</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                    url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class="line">                    <span class="comment">// 加载监视器链接</span></span><br><span class="line">                    URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">                    <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将监视器链接作为参数添加到 url 中</span></span><br><span class="line">                        url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String proxy = url.getParameter(Constants.PROXY_KEY);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                        registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 为服务提供类(ref)生成 Invoker</span></span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">                    <span class="comment">// DelegateProviderMetaDataInvoker 用于持有 Invoker 和 ServiceConfig</span></span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 导出服务，并生成 Exporter</span></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 不存在注册中心，仅导出服务</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                exporters.add(exporter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码根据 url 中的 scope 参数决定服务导出方式，分别如下：</p>
<ul>
<li>scope = none，不导出服务</li>
<li>scope != remote，导出到本地</li>
<li>scope != local，导出到远程</li>
</ul>
<p>不管是导出到本地，还是远程。进行服务导出之前，均需要先创建 Invoker，这是一个很重要的步骤。因此下面先来分析 Invoker 的创建过程。</p>
<h3 id="Invoker-创建过程"><a href="#Invoker-创建过程" class="headerlink" title="Invoker 创建过程"></a>Invoker 创建过程</h3><p>在 Dubbo 中，Invoker 是一个非常重要的模型。在服务提供端，以及服务引用端均会出现 Invoker。Dubbo 官方文档中对 Invoker 进行了说明，这里引用一下。</p>
<blockquote>
<p>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p>
</blockquote>
<p>既然 Invoker 如此重要，那么我们很有必要搞清楚 Invoker 的用途。Invoker 是由 ProxyFactory 创建而来，Dubbo 默认的 ProxyFactory 实现类是 JavassistProxyFactory。下面我们到 JavassistProxyFactory 代码中，探索 Invoker 的创建过程。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 为目标类创建 Wrapper</span></span><br><span class="line">    <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">    <span class="comment">// 创建匿名 Invoker 类对象，并实现 doInvoke 方法。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			<span class="comment">// 调用 Wrapper 的 invokeMethod 方法，invokeMethod 最终会调用目标方法</span></span><br><span class="line">            <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，JavassistProxyFactory 创建了一个继承自 AbstractProxyInvoker 类的匿名对象，并覆写了抽象方法 doInvoke。覆写后的 doInvoke 逻辑比较简单，仅是将调用请求转发给了 Wrapper 类的 invokeMethod 方法。Wrapper 用于“包裹”目标类，Wrapper 是一个抽象类，仅可通过 getWrapper(Class) 方法创建子类。在创建 Wrapper 子类的过程中，子类代码生成逻辑会对 getWrapper 方法传入的 Class 对象进行解析，拿到诸如类方法，类成员变量等信息。以及生成 invokeMethod 方法代码和其他一些方法代码。代码生成完毕后，通过 Javassist 生成 Class 对象，最后再通过反射创建 Wrapper 实例。相关的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Wrapper <span class="title">getWrapper</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;	</span><br><span class="line">    <span class="keyword">while</span> (ClassGenerator.isDynamicClass(c))</span><br><span class="line">        c = c.getSuperclass();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == Object.class)</span><br><span class="line">        <span class="keyword">return</span> OBJECT_WRAPPER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中获取 Wrapper 实例</span></span><br><span class="line">    Wrapper ret = WRAPPER_MAP.get(c);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 缓存未命中，创建 Wrapper</span></span><br><span class="line">        ret = makeWrapper(c);</span><br><span class="line">        <span class="comment">// 写入缓存</span></span><br><span class="line">        WRAPPER_MAP.put(c, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getWrapper 方法仅包含一些缓存操作逻辑，不难理解。下面我们看一下 makeWrapper 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Wrapper <span class="title">makeWrapper</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测 c 是否为基本类型，若是则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (c.isPrimitive())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can not create wrapper for primitive type: "</span> + c);</span><br><span class="line"></span><br><span class="line">    String name = c.getName();</span><br><span class="line">    ClassLoader cl = ClassHelper.getClassLoader(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c1 用于存储 setPropertyValue 方法代码</span></span><br><span class="line">    StringBuilder c1 = <span class="keyword">new</span> StringBuilder(<span class="string">"public void setPropertyValue(Object o, String n, Object v)&#123; "</span>);</span><br><span class="line">    <span class="comment">// c2 用于存储 getPropertyValue 方法代码</span></span><br><span class="line">    StringBuilder c2 = <span class="keyword">new</span> StringBuilder(<span class="string">"public Object getPropertyValue(Object o, String n)&#123; "</span>);</span><br><span class="line">    <span class="comment">// c3 用于存储 invokeMethod 方法代码</span></span><br><span class="line">    StringBuilder c3 = <span class="keyword">new</span> StringBuilder(<span class="string">"public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws "</span> + InvocationTargetException.class.getName() + <span class="string">"&#123; "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成类型转换代码及异常捕捉代码，比如：</span></span><br><span class="line">    <span class="comment">//   DemoService w; try &#123; w = ((DemoServcie) $1); &#125;&#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;</span></span><br><span class="line">    c1.append(name).append(<span class="string">" w; try&#123; w = (("</span>).append(name).append(<span class="string">")$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;"</span>);</span><br><span class="line">    c2.append(name).append(<span class="string">" w; try&#123; w = (("</span>).append(name).append(<span class="string">")$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;"</span>);</span><br><span class="line">    c3.append(name).append(<span class="string">" w; try&#123; w = (("</span>).append(name).append(<span class="string">")$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pts 用于存储成员变量名和类型</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; pts = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">// ms 用于存储方法描述信息（可理解为方法签名）及 Method 实例</span></span><br><span class="line">    Map&lt;String, Method&gt; ms = <span class="keyword">new</span> LinkedHashMap&lt;String, Method&gt;();</span><br><span class="line">    <span class="comment">// mns 为方法名列表</span></span><br><span class="line">    List&lt;String&gt; mns = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// dmns 用于存储“定义在当前类中的方法”的名称</span></span><br><span class="line">    List&lt;String&gt; dmns = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------✨ 分割线1 ✨-------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 public 访问级别的字段，并为所有字段生成条件判断语句</span></span><br><span class="line">    <span class="keyword">for</span> (Field f : c.getFields()) &#123;</span><br><span class="line">        String fn = f.getName();</span><br><span class="line">        Class&lt;?&gt; ft = f.getType();</span><br><span class="line">        <span class="keyword">if</span> (Modifier.isStatic(f.getModifiers()) || Modifier.isTransient(f.getModifiers()))</span><br><span class="line">            <span class="comment">// 忽略关键字 static 或 transient 修饰的变量</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成条件判断及赋值语句，比如：</span></span><br><span class="line">        <span class="comment">// if( $2.equals("name") ) &#123; w.name = (java.lang.String) $3; return;&#125;</span></span><br><span class="line">        <span class="comment">// if( $2.equals("age") ) &#123; w.age = ((Number) $3).intValue(); return;&#125;</span></span><br><span class="line">        c1.append(<span class="string">" if( $2.equals(\""</span>).append(fn).append(<span class="string">"\") )&#123; w."</span>).append(fn).append(<span class="string">"="</span>).append(arg(ft, <span class="string">"$3"</span>)).append(<span class="string">"; return; &#125;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成条件判断及返回语句，比如：</span></span><br><span class="line">        <span class="comment">// if( $2.equals("name") ) &#123; return ($w)w.name; &#125;</span></span><br><span class="line">        c2.append(<span class="string">" if( $2.equals(\""</span>).append(fn).append(<span class="string">"\") )&#123; return ($w)w."</span>).append(fn).append(<span class="string">"; &#125;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储 &lt;字段名, 字段类型&gt; 键值对到 pts 中</span></span><br><span class="line">        pts.put(fn, ft);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------✨ 分割线2 ✨-------------------------------------</span></span><br><span class="line"></span><br><span class="line">    Method[] methods = c.getMethods();</span><br><span class="line">    <span class="comment">// 检测 c 中是否包含在当前类中声明的方法</span></span><br><span class="line">    <span class="keyword">boolean</span> hasMethod = hasMethods(methods);</span><br><span class="line">    <span class="keyword">if</span> (hasMethod) &#123;</span><br><span class="line">        c3.append(<span class="string">" try&#123;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.getDeclaringClass() == Object.class)</span><br><span class="line">            <span class="comment">// 忽略 Object 中定义的方法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        String mn = m.getName();</span><br><span class="line">        <span class="comment">// 生成方法名判断语句，比如：</span></span><br><span class="line">        <span class="comment">// if ( "sayHello".equals( $2 )</span></span><br><span class="line">        c3.append(<span class="string">" if( \""</span>).append(mn).append(<span class="string">"\".equals( $2 ) "</span>);</span><br><span class="line">        <span class="keyword">int</span> len = m.getParameterTypes().length;</span><br><span class="line">        <span class="comment">// 生成“运行时传入的参数数量与方法参数列表长度”判断语句，比如：</span></span><br><span class="line">        <span class="comment">// &amp;&amp; $3.length == 2</span></span><br><span class="line">        c3.append(<span class="string">" &amp;&amp; "</span>).append(<span class="string">" $3.length == "</span>).append(len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> override = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method m2 : methods) &#123;</span><br><span class="line">            <span class="comment">// 检测方法是否存在重载情况，条件为：方法对象不同 &amp;&amp; 方法名相同</span></span><br><span class="line">            <span class="keyword">if</span> (m != m2 &amp;&amp; m.getName().equals(m2.getName())) &#123;</span><br><span class="line">                override = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对重载方法进行处理，考虑下面的方法：</span></span><br><span class="line">        <span class="comment">//    1. void sayHello(Integer, String)</span></span><br><span class="line">        <span class="comment">//    2. void sayHello(Integer, Integer)</span></span><br><span class="line">        <span class="comment">// 方法名相同，参数列表长度也相同，因此不能仅通过这两项判断两个方法是否相等。</span></span><br><span class="line">        <span class="comment">// 需要进一步判断方法的参数类型</span></span><br><span class="line">        <span class="keyword">if</span> (override) &#123;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; len; l++) &#123;</span><br><span class="line">                    <span class="comment">// 生成参数类型进行检测代码，比如：</span></span><br><span class="line">                    <span class="comment">// &amp;&amp; $3[0].getName().equals("java.lang.Integer") </span></span><br><span class="line">                    <span class="comment">//    &amp;&amp; $3[1].getName().equals("java.lang.String")</span></span><br><span class="line">                    c3.append(<span class="string">" &amp;&amp; "</span>).append(<span class="string">" $3["</span>).append(l).append(<span class="string">"].getName().equals(\""</span>)</span><br><span class="line">                            .append(m.getParameterTypes()[l].getName()).append(<span class="string">"\")"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 ) &#123;，完成方法判断语句，此时生成的代码可能如下（已格式化）：</span></span><br><span class="line">        <span class="comment">// if ("sayHello".equals($2) </span></span><br><span class="line">        <span class="comment">//     &amp;&amp; $3.length == 2</span></span><br><span class="line">        <span class="comment">//     &amp;&amp; $3[0].getName().equals("java.lang.Integer") </span></span><br><span class="line">        <span class="comment">//     &amp;&amp; $3[1].getName().equals("java.lang.String")) &#123;</span></span><br><span class="line">        c3.append(<span class="string">" ) &#123; "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据返回值类型生成目标方法调用语句</span></span><br><span class="line">        <span class="keyword">if</span> (m.getReturnType() == Void.TYPE)</span><br><span class="line">            <span class="comment">// w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]); return null;</span></span><br><span class="line">            c3.append(<span class="string">" w."</span>).append(mn).append(<span class="string">'('</span>).append(args(m.getParameterTypes(), <span class="string">"$4"</span>)).append(<span class="string">");"</span>).append(<span class="string">" return null;"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// return w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]);</span></span><br><span class="line">            c3.append(<span class="string">" return ($w)w."</span>).append(mn).append(<span class="string">'('</span>).append(args(m.getParameterTypes(), <span class="string">"$4"</span>)).append(<span class="string">");"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 &#125;, 生成的代码形如（已格式化）：</span></span><br><span class="line">        <span class="comment">// if ("sayHello".equals($2) </span></span><br><span class="line">        <span class="comment">//     &amp;&amp; $3.length == 2</span></span><br><span class="line">        <span class="comment">//     &amp;&amp; $3[0].getName().equals("java.lang.Integer") </span></span><br><span class="line">        <span class="comment">//     &amp;&amp; $3[1].getName().equals("java.lang.String")) &#123;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//     w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]); </span></span><br><span class="line">        <span class="comment">//     return null;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        c3.append(<span class="string">" &#125;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加方法名到 mns 集合中</span></span><br><span class="line">        mns.add(mn);</span><br><span class="line">        <span class="comment">// 检测当前方法是否在 c 中被声明的</span></span><br><span class="line">        <span class="keyword">if</span> (m.getDeclaringClass() == c)</span><br><span class="line">            <span class="comment">// 若是，则将当前方法名添加到 dmns 中</span></span><br><span class="line">            dmns.add(mn);</span><br><span class="line">        ms.put(ReflectUtils.getDesc(m), m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasMethod) &#123;</span><br><span class="line">        <span class="comment">// 添加异常捕捉语句</span></span><br><span class="line">        c3.append(<span class="string">" &#125; catch(Throwable e) &#123; "</span>);</span><br><span class="line">        c3.append(<span class="string">"     throw new java.lang.reflect.InvocationTargetException(e); "</span>);</span><br><span class="line">        c3.append(<span class="string">" &#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 NoSuchMethodException 异常抛出代码</span></span><br><span class="line">    c3.append(<span class="string">" throw new "</span> + NoSuchMethodException.class.getName() + <span class="string">"(\"Not found method \\\"\"+$2+\"\\\" in class "</span> + c.getName() + <span class="string">".\"); &#125;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------✨ 分割线3 ✨-------------------------------------</span></span><br><span class="line"></span><br><span class="line">    Matcher matcher;</span><br><span class="line">    <span class="comment">// 处理 get/set 方法</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Method&gt; entry : ms.entrySet()) &#123;</span><br><span class="line">        String md = entry.getKey();</span><br><span class="line">        Method method = (Method) entry.getValue();</span><br><span class="line">        <span class="comment">// 匹配以 get 开头的方法</span></span><br><span class="line">        <span class="keyword">if</span> ((matcher = ReflectUtils.GETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) &#123;</span><br><span class="line">            <span class="comment">// 获取属性名</span></span><br><span class="line">            String pn = propertyName(matcher.group(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 生成属性判断以及返回语句，示例如下：</span></span><br><span class="line">            <span class="comment">// if( $2.equals("name") ) &#123; return ($w).w.getName(); &#125;</span></span><br><span class="line">            c2.append(<span class="string">" if( $2.equals(\""</span>).append(pn).append(<span class="string">"\") )&#123; return ($w)w."</span>).append(method.getName()).append(<span class="string">"(); &#125;"</span>);</span><br><span class="line">            pts.put(pn, method.getReturnType());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配以 is/has/can 开头的方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((matcher = ReflectUtils.IS_HAS_CAN_METHOD_DESC_PATTERN.matcher(md)).matches()) &#123;</span><br><span class="line">            String pn = propertyName(matcher.group(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 生成属性判断以及返回语句，示例如下：</span></span><br><span class="line">            <span class="comment">// if( $2.equals("dream") ) &#123; return ($w).w.hasDream(); &#125;</span></span><br><span class="line">            c2.append(<span class="string">" if( $2.equals(\""</span>).append(pn).append(<span class="string">"\") )&#123; return ($w)w."</span>).append(method.getName()).append(<span class="string">"(); &#125;"</span>);</span><br><span class="line">            pts.put(pn, method.getReturnType());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配以 set 开头的方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((matcher = ReflectUtils.SETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) &#123;</span><br><span class="line">            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">            String pn = propertyName(matcher.group(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 生成属性判断以及 setter 调用语句，示例如下：</span></span><br><span class="line">            <span class="comment">// if( $2.equals("name") ) &#123; w.setName((java.lang.String)$3); return; &#125;</span></span><br><span class="line">            c1.append(<span class="string">" if( $2.equals(\""</span>).append(pn).append(<span class="string">"\") )&#123; w."</span>).append(method.getName()).append(<span class="string">"("</span>).append(arg(pt, <span class="string">"$3"</span>)).append(<span class="string">"); return; &#125;"</span>);</span><br><span class="line">            pts.put(pn, pt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 NoSuchPropertyException 异常抛出代码</span></span><br><span class="line">    c1.append(<span class="string">" throw new "</span> + NoSuchPropertyException.class.getName() + <span class="string">"(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class "</span> + c.getName() + <span class="string">".\"); &#125;"</span>);</span><br><span class="line">    c2.append(<span class="string">" throw new "</span> + NoSuchPropertyException.class.getName() + <span class="string">"(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class "</span> + c.getName() + <span class="string">".\"); &#125;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------✨ 分割线4 ✨-------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> id = WRAPPER_CLASS_COUNTER.getAndIncrement();</span><br><span class="line">    <span class="comment">// 创建类生成器</span></span><br><span class="line">    ClassGenerator cc = ClassGenerator.newInstance(cl);</span><br><span class="line">    <span class="comment">// 设置类名及超类</span></span><br><span class="line">    cc.setClassName((Modifier.isPublic(c.getModifiers()) ? Wrapper.class.getName() : c.getName() + <span class="string">"$sw"</span>) + id);</span><br><span class="line">    cc.setSuperClass(Wrapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加默认构造方法</span></span><br><span class="line">    cc.addDefaultConstructor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加字段</span></span><br><span class="line">    cc.addField(<span class="string">"public static String[] pns;"</span>);</span><br><span class="line">    cc.addField(<span class="string">"public static "</span> + Map.class.getName() + <span class="string">" pts;"</span>);</span><br><span class="line">    cc.addField(<span class="string">"public static String[] mns;"</span>);</span><br><span class="line">    cc.addField(<span class="string">"public static String[] dmns;"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = ms.size(); i &lt; len; i++)</span><br><span class="line">        cc.addField(<span class="string">"public static Class[] mts"</span> + i + <span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加方法代码</span></span><br><span class="line">    cc.addMethod(<span class="string">"public String[] getPropertyNames()&#123; return pns; &#125;"</span>);</span><br><span class="line">    cc.addMethod(<span class="string">"public boolean hasProperty(String n)&#123; return pts.containsKey($1); &#125;"</span>);</span><br><span class="line">    cc.addMethod(<span class="string">"public Class getPropertyType(String n)&#123; return (Class)pts.get($1); &#125;"</span>);</span><br><span class="line">    cc.addMethod(<span class="string">"public String[] getMethodNames()&#123; return mns; &#125;"</span>);</span><br><span class="line">    cc.addMethod(<span class="string">"public String[] getDeclaredMethodNames()&#123; return dmns; &#125;"</span>);</span><br><span class="line">    cc.addMethod(c1.toString());</span><br><span class="line">    cc.addMethod(c2.toString());</span><br><span class="line">    cc.addMethod(c3.toString());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 生成类</span></span><br><span class="line">        Class&lt;?&gt; wc = cc.toClass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置字段值</span></span><br><span class="line">        wc.getField(<span class="string">"pts"</span>).set(<span class="keyword">null</span>, pts);</span><br><span class="line">        wc.getField(<span class="string">"pns"</span>).set(<span class="keyword">null</span>, pts.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">        wc.getField(<span class="string">"mns"</span>).set(<span class="keyword">null</span>, mns.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">        wc.getField(<span class="string">"dmns"</span>).set(<span class="keyword">null</span>, dmns.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">int</span> ix = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method m : ms.values())</span><br><span class="line">            wc.getField(<span class="string">"mts"</span> + ix++).set(<span class="keyword">null</span>, m.getParameterTypes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Wrapper 实例</span></span><br><span class="line">        <span class="keyword">return</span> (Wrapper) wc.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cc.release();</span><br><span class="line">        ms.clear();</span><br><span class="line">        mns.clear();</span><br><span class="line">        dmns.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码很长，大家耐心看一下。我们在上面代码中做了大量的注释，并按功能对代码进行了分块，以帮助大家理解代码逻辑。下面对这段代码进行讲解。首先我们把目光移到分割线1之上的代码，这段代码主要用于进行一些初始化操作。比如创建 c1、c2、c3 以及 pts、ms、mns 等变量，以及向 c1、c2、c3 中添加方法定义和类型转换代码。接下来是分割线1到分割线2之间的代码，这段代码用于为 public 级别的字段生成条件判断取值与赋值代码。这段代码不是很难看懂，就不多说了。继续向下看，分割线2和分隔线3之间的代码用于为定义在当前类中的方法生成判断语句，和方法调用语句。因为需要对方法重载进行校验，因此到这这段代码看起来有点复杂。不过耐心看一下，也不是很难理解。接下来是分割线3和分隔线4之间的代码，这段代码用于处理 getter、setter 以及以 is/has/can 开头的方法。处理方式是通过正则表达式获取方法类型（get/set/is/…），以及属性名。之后为属性名生成判断语句，然后为方法生成调用语句。最后我们再来看一下分隔线4以下的代码，这段代码通过 ClassGenerator 为刚刚生成的代码构建 Class 类，并通过反射创建对象。ClassGenerator 是 Dubbo 自己封装的，该类的核心是 toClass() 的重载方法 toClass(ClassLoader, ProtectionDomain)，该方法通过 javassist 构建 Class。这里就不分析 toClass 方法了，大家请自行分析。</p>
<p>阅读 Wrapper 类代码需要对 javassist 框架有所了解。关于 javassist，大家如果不熟悉，请自行查阅资料，本节不打算介绍 javassist 相关内容。</p>
<p>好了，关于 Wrapper 类生成过程就分析到这。如果大家看的不是很明白，可以单独为 Wrapper 创建单元测试，然后单步调试。并将生成的代码拷贝出来，格式化后再进行观察和理解。</p>
<h3 id="导出服务到本地"><a href="#导出服务到本地" class="headerlink" title="导出服务到本地"></a>导出服务到本地</h3><p>本节我们来看一下服务导出相关的代码，按照代码执行顺序，本节先来分析导出服务到本地的过程。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 URL 的协议头等于 injvm，说明已经导出到本地了，无需再次导出</span></span><br><span class="line">    <span class="keyword">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">        URL local = URL.valueOf(url.toFullString())</span><br><span class="line">            .setProtocol(Constants.LOCAL_PROTOCOL)    <span class="comment">// 设置协议头为 injvm</span></span><br><span class="line">            .setHost(LOCALHOST)</span><br><span class="line">            .setPort(<span class="number">0</span>);</span><br><span class="line">        ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));</span><br><span class="line">        <span class="comment">// 创建 Invoker，并导出服务，这里的 protocol 会在运行时调用 InjvmProtocol 的 export 方法</span></span><br><span class="line">        Exporter&lt;?&gt; exporter = protocol.export(</span><br><span class="line">            proxyFactory.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class="line">        exporters.add(exporter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exportLocal 方法比较简单，首先根据 URL 协议头决定是否导出服务。若需导出，则创建一个新的 URL 并将协议头、主机名以及端口设置成新的值。然后创建 Invoker，并调用 InjvmProtocol 的 export 方法导出服务。下面我们来看一下 InjvmProtocol 的 export 方法都做了哪些事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 InjvmExporter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，InjvmProtocol 的 export 方法仅创建了一个 InjvmExporter，无其他逻辑。到此导出服务到本地就分析完了，接下来，我们继续分析导出服务到远程的过程。</p>
<h3 id="导出服务到远程"><a href="#导出服务到远程" class="headerlink" title="导出服务到远程"></a>导出服务到远程</h3><p>与导出服务到本地相比，导出服务到远程的过程要复杂不少，其包含了服务导出与服务注册两个过程。这两个过程涉及到了大量的调用，比较复杂。按照代码执行顺序，本节先来分析服务导出逻辑，服务注册逻辑将在下一节进行分析。下面开始分析，我们把目光移动到 RegistryProtocol 的 export 方法上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 导出服务</span></span><br><span class="line">    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取注册中心 URL，以 zookeeper 注册中心为例，得到的示例 URL 如下：</span></span><br><span class="line">    <span class="comment">// zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.2&amp;export=dubbo%3A%2F%2F172.17.48.52%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider</span></span><br><span class="line">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 URL 加载 Registry 实现类，比如 ZookeeperRegistry</span></span><br><span class="line">    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取已注册的服务提供者 URL，比如：</span></span><br><span class="line">    <span class="comment">// dubbo://172.17.48.52:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello</span></span><br><span class="line">    <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 register 参数</span></span><br><span class="line">    <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务提供者与消费者注册表中注册服务提供者</span></span><br><span class="line">    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 register 的值决定是否注册服务</span></span><br><span class="line">    <span class="keyword">if</span> (register) &#123;</span><br><span class="line">        <span class="comment">// 向注册中心注册服务</span></span><br><span class="line">        register(registryUrl, registeredProviderUrl);</span><br><span class="line">        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取订阅 URL，比如：</span></span><br><span class="line">    <span class="comment">// provider://172.17.48.52:20880/com.alibaba.dubbo.demo.DemoService?category=configurators&amp;check=false&amp;anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello</span></span><br><span class="line">    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);</span><br><span class="line">    <span class="comment">// 创建监听器</span></span><br><span class="line">    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">// 向注册中心进行订阅 override 数据</span></span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">// 创建并返回 DestroyableExporter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码看起来比较复杂，主要做如下一些操作：</p>
<ol>
<li>调用 doLocalExport 导出服务</li>
<li>向注册中心注册服务</li>
<li>向注册中心进行订阅 override 数据</li>
<li>创建并返回 DestroyableExporter</li>
</ol>
<p>在以上操作中，除了创建并返回 DestroyableExporter 没什么难度外，其他几步操作都不是很简单。这其中，导出服务和注册服务是本章要重点分析的逻辑。 订阅 override 数据并非本文重点内容，后面会简单介绍一下。下面先来分析 doLocalExport 方法的逻辑，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper&lt;T&gt; <span class="title">doLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">    String key = getCacheKey(originInvoker);</span><br><span class="line">    <span class="comment">// 访问缓存</span></span><br><span class="line">    ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">    <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (bounds) &#123;</span><br><span class="line">            exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">            <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建 Invoker 为委托类对象</span></span><br><span class="line">                <span class="keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));</span><br><span class="line">                <span class="comment">// 调用 protocol 的 export 方法导出服务</span></span><br><span class="line">                exporter = <span class="keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 写缓存</span></span><br><span class="line">                bounds.put(key, exporter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是典型的双重检查锁，大家在阅读 Dubbo 的源码中，会多次见到。接下来，我们把重点放在 Protocol 的 export 方法上。假设运行时协议为 dubbo，此处的 protocol 变量会在运行时加载 DubboProtocol，并调用 DubboProtocol 的 export 方法。所以，接下来我们目光转移到 DubboProtocol 的 export 方法上，相关分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务标识，理解成服务坐标也行。由服务组名，服务名，服务版本号以及端口组成。比如：</span></span><br><span class="line">    <span class="comment">// demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.1:20880</span></span><br><span class="line">    String key = serviceKey(url);</span><br><span class="line">    <span class="comment">// 创建 DubboExporter</span></span><br><span class="line">    DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    <span class="comment">// 将 &lt;key, exporter&gt; 键值对放入缓存中</span></span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地存根相关代码</span></span><br><span class="line">    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">        <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 省略日志打印代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器</span></span><br><span class="line">    openServer(url);</span><br><span class="line">    <span class="comment">// 优化序列化</span></span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们重点关注 DubboExporter 的创建以及 openServer 方法，其他逻辑看不懂也没关系，不影响理解服务导出过程。另外，DubboExporter 的代码比较简单，就不分析了。下面分析 openServer 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 host:port，并将其作为服务器实例的 key，用于标识当前的服务器实例</span></span><br><span class="line">    String key = url.getAddress();</span><br><span class="line">    <span class="keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">        <span class="comment">// 访问缓存</span></span><br><span class="line">        ExchangeServer server = serverMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建服务器实例</span></span><br><span class="line">            serverMap.put(key, createServer(url));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 服务器已创建，则根据 url 中的配置重置服务器</span></span><br><span class="line">            server.reset(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，在同一台机器上（单网卡），同一个端口上仅允许启动一个服务器实例。若某个端口上已有服务器实例，此时则调用 reset 方法重置服务器的一些配置。考虑到篇幅问题，关于服务器实例重置的代码就不分析了。接下来分析服务器实例的创建过程。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExchangeServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY,</span><br><span class="line">    <span class="comment">// 添加心跳检测配置到 url 中</span></span><br><span class="line">    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line">	<span class="comment">// 获取 server 参数，默认为 netty</span></span><br><span class="line">    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过 SPI 检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported server type: "</span> + str + <span class="string">", url: "</span> + url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加编码解码器参数</span></span><br><span class="line">    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class="line">    ExchangeServer server;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 ExchangeServer</span></span><br><span class="line">        server = Exchangers.bind(url, requestHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to start server..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">                                   </span><br><span class="line">	<span class="comment">// 获取 client 参数，可指定 netty，mina</span></span><br><span class="line">    str = url.getParameter(Constants.CLIENT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取所有的 Transporter 实现类名称集合，比如 supportedTypes = [netty, mina]</span></span><br><span class="line">        Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">        <span class="comment">// 检测当前 Dubbo 所支持的 Transporter 实现类名称列表中，</span></span><br><span class="line">        <span class="comment">// 是否包含 client 所表示的 Transporter，若不包含，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，createServer 包含三个核心的逻辑。第一是检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常。第二是创建服务器实例。第三是检测是否支持 client 参数所表示的 Transporter 拓展，不存在也是抛出异常。两次检测操作所对应的代码比较直白了，无需多说。但创建服务器的操作目前还不是很清晰，我们继续往下看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">    <span class="comment">// 获取 Exchanger，默认为 HeaderExchanger。</span></span><br><span class="line">    <span class="comment">// 紧接着调用 HeaderExchanger 的 bind 方法创建 ExchangeServer 实例</span></span><br><span class="line">    <span class="keyword">return</span> getExchanger(url).bind(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码比较简单，就不多说了。下面看一下 HeaderExchanger 的 bind 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">	<span class="comment">// 创建 HeaderExchangeServer 实例，该方法包含了多个逻辑，分别如下：</span></span><br><span class="line">	<span class="comment">//   1. new HeaderExchangeHandler(handler)</span></span><br><span class="line">	<span class="comment">//	 2. new DecodeHandler(new HeaderExchangeHandler(handler))</span></span><br><span class="line">	<span class="comment">//   3. Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler)))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeaderExchanger 的 bind 方法包含的逻辑比较多，但目前我们仅需关心 Transporters 的 bind 方法逻辑即可。该方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handlers == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelHandler handler;</span><br><span class="line">    <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">        handler = handlers[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果 handlers 元素数量大于1，则创建 ChannelHandler 分发器</span></span><br><span class="line">        handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取自适应 Transporter 实例，并调用实例方法</span></span><br><span class="line">    <span class="keyword">return</span> getTransporter().bind(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，getTransporter() 方法获取的 Transporter 是在运行时动态创建的，类名为 TransporterAdaptive，也就是自适应拓展类。TransporterAdaptive 会在运行时根据传入的 URL 参数决定加载什么类型的 Transporter，默认为 NettyTransporter。下面我们继续跟下去，这次分析的是 NettyTransporter 的 bind 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">	<span class="comment">// 创建 NettyServer</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> NettyServer(url, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里仅有一句创建 NettyServer 的代码，无需多说，我们继续向下看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServer</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类构造方法，这里就不用跟进去了，没什么复杂逻辑</span></span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">        localAddress = getUrl().toInetSocketAddress();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 ip 和端口</span></span><br><span class="line">        String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());</span><br><span class="line">        <span class="keyword">int</span> bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());</span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(Constants.ANYHOST_KEY, <span class="keyword">false</span>) || NetUtils.isInvalidLocalHost(bindIp)) &#123;</span><br><span class="line">            <span class="comment">// 设置 ip 为 0.0.0.0</span></span><br><span class="line">            bindIp = NetUtils.ANYHOST;</span><br><span class="line">        &#125;</span><br><span class="line">        bindAddress = <span class="keyword">new</span> InetSocketAddress(bindIp, bindPort);</span><br><span class="line">        <span class="comment">// 获取最大可接受连接数</span></span><br><span class="line">        <span class="keyword">this</span>.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);</span><br><span class="line">        <span class="keyword">this</span>.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用模板方法 doOpen 启动服务器</span></span><br><span class="line">            doOpen();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="string">"Failed to bind "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();</span><br><span class="line">        executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码多为赋值代码，不需要多讲。我们重点关注 doOpen 抽象方法，该方法需要子类实现。下面回到 NettyServer 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line">    <span class="comment">// 创建 boss 和 worker 线程池</span></span><br><span class="line">    ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">    ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line">    ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 ServerBootstrap</span></span><br><span class="line">    bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    channels = nettyHandler.getChannels();</span><br><span class="line">    bootstrap.setOption(<span class="string">"child.tcpNoDelay"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 设置 PipelineFactory</span></span><br><span class="line">    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">            <span class="keyword">return</span> pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 绑定到指定的 ip 和端口上</span></span><br><span class="line">    channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是 NettyServer 创建的过程，dubbo 默认使用的 NettyServer 是基于 netty 3.x 版本实现的，比较老了。因此 Dubbo 另外提供了 netty 4.x 版本的 NettyServer，大家可在使用 Dubbo 的过程中按需进行配置。</p>
<p>到此，关于服务导出的过程就分析完了。整个过程比较复杂，大家在分析的过程中耐心一些。并且多写 Demo 进行调试，以便能够更好的理解代码逻辑。</p>
<p>本节内容先到这里，接下来分析服务导出的另一块逻辑 — 服务注册。</p>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>本节我们来分析服务注册过程，服务注册操作对于 Dubbo 来说不是必需的，通过服务直连的方式就可以绕过注册中心。但通常我们不会这么做，直连方式不利于服务治理，仅推荐在测试服务时使用。对于 Dubbo 来说，注册中心虽不是必需，但却是必要的。因此，关于注册中心以及服务注册相关逻辑，我们也需要搞懂。</p>
<p>本节内容以 Zookeeper 注册中心作为分析目标，其他类型注册中心大家可自行分析。下面从服务注册的入口方法开始分析，我们把目光再次移到 RegistryProtocol 的 export 方法上。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// $&#123;导出服务&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (register) &#123;</span><br><span class="line">        <span class="comment">// 注册服务</span></span><br><span class="line">        register(registryUrl, registeredProviderUrl);</span><br><span class="line">        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);</span><br><span class="line">    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">// 订阅 override 数据</span></span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RegistryProtocol 的 export 方法包含了服务导出，注册，以及数据订阅等逻辑。其中服务导出逻辑上一节已经分析过了，本节将分析服务注册逻辑，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registedProviderUrl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 Registry</span></span><br><span class="line">    Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">    <span class="comment">// 注册服务</span></span><br><span class="line">    registry.register(registedProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>register 方法包含两步操作，第一步是获取注册中心实例，第二步是向注册中心注册服务。接下来分两节内容对这两步操作进行分析。</p>
<h4 id="创建注册中心"><a href="#创建注册中心" class="headerlink" title="创建注册中心"></a>创建注册中心</h4><p>本节内容以 Zookeeper 注册中心为例进行分析。下面先来看一下 getRegistry 方法的源码，这个方法由 AbstractRegistryFactory 实现。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    url = url.setPath(RegistryService.class.getName())</span><br><span class="line">            .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">            .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);</span><br><span class="line">    String key = url.toServiceString();</span><br><span class="line">    LOCK.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 访问缓存</span></span><br><span class="line">        Registry registry = REGISTRIES.get(key);</span><br><span class="line">        <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> registry;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缓存未命中，创建 Registry 实例</span></span><br><span class="line">        registry = createRegistry(url);</span><br><span class="line">        <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create registry..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入缓存</span></span><br><span class="line">        REGISTRIES.put(key, registry);</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        LOCK.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如上，getRegistry 方法先访问缓存，缓存未命中则调用 createRegistry 创建 Registry，然后写入缓存。这里的 createRegistry 是一个模板方法，由具体的子类实现。因此，下面我们到 ZookeeperRegistryFactory 中探究一番。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistryFactory</span> <span class="keyword">extends</span> <span class="title">AbstractRegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zookeeperTransporter 由 SPI 在运行时注入，类型为 ZookeeperTransporter$Adaptive</span></span><br><span class="line">    <span class="keyword">private</span> ZookeeperTransporter zookeeperTransporter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZookeeperTransporter</span><span class="params">(ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zookeeperTransporter = zookeeperTransporter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ZookeeperRegistry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZookeeperRegistryFactory 的 createRegistry 方法仅包含一句代码，无需解释，继续跟下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(url);</span><br><span class="line">    <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取组名，默认为 dubbo</span></span><br><span class="line">    String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">    <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">        <span class="comment">// group = "/" + group</span></span><br><span class="line">        group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = group;</span><br><span class="line">    <span class="comment">// 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter</span></span><br><span class="line">    zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">    <span class="comment">// 添加状态监听器</span></span><br><span class="line">    zkClient.addStateListener(<span class="keyword">new</span> StateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (state == RECONNECTED) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    recover();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码代码中，我们重点关注 ZookeeperTransporter 的 connect 方法调用，这个方法用于创建 Zookeeper 客户端。创建好 Zookeeper 客户端，意味着注册中心的创建过程就结束了。接下来，再来分析一下 Zookeeper 客户端的创建过程。</p>
<p>前面说过，这里的 zookeeperTransporter 类型为自适应拓展类，因此 connect 方法会在被调用时决定加载什么类型的 ZookeeperTransporter 拓展，默认为 CuratorZookeeperTransporter。下面我们到 CuratorZookeeperTransporter 中看一看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ZookeeperClient <span class="title">connect</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 CuratorZookeeperClient</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CuratorZookeeperClient(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续向下看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">CuratorWatcher</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CuratorFramework client;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CuratorZookeeperClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 CuratorFramework 构造器</span></span><br><span class="line">            CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()</span><br><span class="line">                    .connectString(url.getBackupAddress())</span><br><span class="line">                    .retryPolicy(<span class="keyword">new</span> RetryNTimes(<span class="number">1</span>, <span class="number">1000</span>))</span><br><span class="line">                    .connectionTimeoutMs(<span class="number">5000</span>);</span><br><span class="line">            String authority = url.getAuthority();</span><br><span class="line">            <span class="keyword">if</span> (authority != <span class="keyword">null</span> &amp;&amp; authority.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                builder = builder.authorization(<span class="string">"digest"</span>, authority.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 构建 CuratorFramework 实例</span></span><br><span class="line">            client = builder.build();</span><br><span class="line">            <span class="comment">// 添加监听器</span></span><br><span class="line">            client.getConnectionStateListenable().addListener(<span class="keyword">new</span> ConnectionStateListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState state)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (state == ConnectionState.LOST) &#123;</span><br><span class="line">                        CuratorZookeeperClient.<span class="keyword">this</span>.stateChanged(StateListener.DISCONNECTED);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == ConnectionState.CONNECTED) &#123;</span><br><span class="line">                        CuratorZookeeperClient.<span class="keyword">this</span>.stateChanged(StateListener.CONNECTED);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == ConnectionState.RECONNECTED) &#123;</span><br><span class="line">                        CuratorZookeeperClient.<span class="keyword">this</span>.stateChanged(StateListener.RECONNECTED);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 启动客户端</span></span><br><span class="line">            client.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CuratorZookeeperClient 构造方法主要用于创建和启动 CuratorFramework 实例。以上基本上都是 Curator 框架的代码，大家如果对 Curator 框架不是很了解，可以参考 Curator 官方文档。</p>
<p>本节分析了 ZookeeperRegistry 实例的创建过程，整个过程并不是很复杂。大家在看完分析后，可以自行调试，以加深理解。现在注册中心实例创建好了，接下来要做的事情是向注册中心注册服务，我们继续往下看。</p>
<h4 id="节点创建"><a href="#节点创建" class="headerlink" title="节点创建"></a>节点创建</h4><p>以 Zookeeper 为例，所谓的服务注册，本质上是将服务配置数据写入到 Zookeeper 的某个路径的节点下。为了让大家有一个直观的了解，下面我们将 Dubbo 的 demo 跑起来，然后通过 Zookeeper 可视化客户端 <a href="https://github.com/apache/zookeeper/tree/b79af153d0f98a4f3f3516910ed47234d7b3d74e/src/contrib/zooinspector" target="_blank" rel="noopener">ZooInspector</a> 查看节点数据。如下：</p>
<p><img src="assets/service-registry.png" alt="img"></p>
<p>从上图中可以看到 com.alibaba.dubbo.demo.DemoService 这个服务对应的配置信息（存储在 URL 中）最终被注册到了 /dubbo/com.alibaba.dubbo.demo.DemoService/providers/ 节点下。搞懂了服务注册的本质，那么接下来我们就可以去阅读服务注册的代码了。服务注册的接口为 register(URL)，这个方法定义在 FailbackRegistry 抽象类中。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.register(url);</span><br><span class="line">    failedRegistered.remove(url);</span><br><span class="line">    failedUnregistered.remove(url);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 模板方法，由子类实现</span></span><br><span class="line">        doRegister(url);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Throwable t = e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 check 参数，若 check = true 将会直接抛出异常</span></span><br><span class="line">        <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">        <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">        <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">            <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to register"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">"Failed to register"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录注册失败的链接</span></span><br><span class="line">        failedRegistered.add(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如上，我们重点关注 doRegister 方法调用即可，其他的代码先忽略。doRegister 方法是一个模板方法，因此我们到 FailbackRegistry 子类 ZookeeperRegistry 中进行分析。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 Zookeeper 客户端创建节点，节点路径由 toUrlPath 方法生成，路径格式如下:</span></span><br><span class="line">        <span class="comment">//   /$&#123;group&#125;/$&#123;serviceInterface&#125;/providers/$&#123;url&#125;</span></span><br><span class="line">        <span class="comment">// 比如</span></span><br><span class="line">        <span class="comment">//   /dubbo/org.apache.dubbo.DemoService/providers/dubbo%3A%2F%2F127.0.0.1......</span></span><br><span class="line">        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to register..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，ZookeeperRegistry 在 doRegister 中调用了 Zookeeper 客户端创建服务节点。节点路径由 toUrlPath 方法生成，该方法逻辑不难理解，就不分析了。接下来分析 create 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String path, <span class="keyword">boolean</span> ephemeral)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ephemeral) &#123;</span><br><span class="line">        <span class="comment">// 如果要创建的节点类型非临时节点，那么这里要检测节点是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (checkExists(path)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = path.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归创建上一级路径</span></span><br><span class="line">        create(path.substring(<span class="number">0</span>, i), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 ephemeral 的值创建临时或持久节点</span></span><br><span class="line">    <span class="keyword">if</span> (ephemeral) &#123;</span><br><span class="line">        createEphemeral(path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createPersistent(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法先是通过递归创建当前节点的上一级路径，然后再根据 ephemeral 的值决定创建临时还是持久节点。createEphemeral 和 createPersistent 这两个方法都比较简单，这里简单分析其中的一个。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEphemeral</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 Curator 框架创建节点</span></span><br><span class="line">        client.create().withMode(CreateMode.EPHEMERAL).forPath(path);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NodeExistsException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，到此关于服务注册的过程就分析完了。整个过程可简单总结为：先创建注册中心实例，之后再通过注册中心实例注册服务。本节先到这，接下来分析数据订阅过程。</p>
<h3 id="订阅-override-数据"><a href="#订阅-override-数据" class="headerlink" title="订阅 override 数据"></a>订阅 override 数据</h3><p>// 待补充</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本篇文章详细分析了 Dubbo 服务导出过程，包括配置检测，URL 组装，Invoker 创建过程、导出服务以及注册服务等等。篇幅比较大，需要大家耐心阅读。本篇文章先就到这，如果文章有不妥错误之处，希望大家能够进行反馈或修正。</p>
<h1 id="服务引入"><a href="#服务引入" class="headerlink" title="服务引入"></a>服务引入</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>上一篇文章详细分析了服务导出的过程，本篇文章我们趁热打铁，继续分析服务引用过程。在 Dubbo 中，我们可以通过两种方式引用远程服务。第一种是使用服务直连的方式引用服务，第二种方式是基于注册中心进行引用。服务直连的方式仅适合在调试或测试服务的场景下使用，不适合在线上环境使用。因此，本文我将重点分析通过注册中心引用服务的过程。从注册中心中获取服务配置只是服务引用过程中的一环，除此之外，服务消费者还需要经历 Invoker 创建、代理类创建等步骤。这些步骤，将在后续章节中一一进行分析。</p>
<h2 id="2-服务引用原理"><a href="#2-服务引用原理" class="headerlink" title="2.服务引用原理"></a>2.服务引用原理</h2><p>Dubbo 服务引用的时机有两个，第一个是在 Spring 容器调用 ReferenceBean 的 afterPropertiesSet 方法时引用服务，第二个是在 ReferenceBean 对应的服务被注入到其他类中时引用。这两个引用服务的时机区别在于，第一个是饿汉式的，第二个是懒汉式的。默认情况下，Dubbo 使用懒汉式引用服务。如果需要使用饿汉式，可通过配置 <a href="dubbo:reference" target="_blank" rel="noopener">dubbo:reference</a> 的 init 属性开启。下面我们按照 Dubbo 默认配置进行分析，整个分析过程从 ReferenceBean 的 getObject 方法开始。当我们的服务被注入到其他类中时，Spring 会第一时间调用 getObject 方法，并由该方法执行服务引用逻辑。按照惯例，在进行具体工作之前，需先进行配置检查与收集工作。接着根据收集到的信息决定服务用的方式，有三种，第一种是引用本地 (JVM) 服务，第二是通过直连方式引用远程服务，第三是通过注册中心引用远程服务。不管是哪种引用方式，最后都会得到一个 Invoker 实例。如果有多个注册中心，多个服务提供者，这个时候会得到一组 Invoker 实例，此时需要通过集群管理类 Cluster 将多个 Invoker 合并成一个实例。合并后的 Invoker 实例已经具备调用本地或远程服务的能力了，但并不能将此实例暴露给用户使用，这会对用户业务代码造成侵入。此时框架还需要通过代理工厂类 (ProxyFactory) 为服务接口生成代理类，并让代理类去调用 Invoker 逻辑。避免了 Dubbo 框架代码对业务代码的侵入，同时也让框架更容易使用。</p>
<p>以上就是服务引用的大致原理，下面我们深入到代码中，详细分析服务引用细节。</p>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><p>服务引用的入口方法为 ReferenceBean 的 getObject 方法，该方法定义在 Spring 的 FactoryBean 接口中，ReferenceBean 实现了这个方法。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already destroyed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测 ref 是否为空，为空则通过 init 方法创建</span></span><br><span class="line">    <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// init 方法主要用于处理配置，以及调用 createProxy 生成代理类</span></span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两个方法的代码比较简短，并不难理解。这里需要特别说明一下，如果你对 2.6.4 及以下版本的 getObject 方法进行调试时，会碰到比较奇怪的的问题。这里假设你使用 IDEA，且保持了 IDEA 的默认配置。当你面调试到 get 方法的<code>if (ref == null)</code>时，你会发现 ref 不为空，导致你无法进入到 init 方法中继续调试。导致这个现象的原因是 Dubbo 框架本身有一些小问题。该问题已经在 pull request <a href="https://github.com/apache/dubbo/pull/2754" target="_blank" rel="noopener">#2754</a> 修复了此问题，并跟随 2.6.5 版本发布了。如果你正在学习 2.6.4 及以下版本，可通过修改 IDEA 配置规避这个问题。首先 IDEA 配置弹窗中搜索 toString，然后取消<code>Enable &#39;toString&#39; object view</code>勾选。具体如下：</p>
<p><img src="assets/15417503733794.jpg" alt="img"></p>
<h3 id="3-1-处理配置"><a href="#3-1-处理配置" class="headerlink" title="3.1 处理配置"></a>3.1 处理配置</h3><p>Dubbo 提供了丰富的配置，用于调整和优化框架行为，性能等。Dubbo 在引用或导出服务时，首先会对这些配置进行检查和处理，以保证配置的正确性。配置解析逻辑封装在 ReferenceConfig 的 init 方法中，下面进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 避免重复初始化</span></span><br><span class="line">    <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 检测接口名合法性</span></span><br><span class="line">    <span class="keyword">if</span> (interfaceName == <span class="keyword">null</span> || interfaceName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"interface not allow null!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测 consumer 变量是否为空，为空则创建</span></span><br><span class="line">    checkDefault();</span><br><span class="line">    appendProperties(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (getGeneric() == <span class="keyword">null</span> &amp;&amp; getConsumer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置 generic</span></span><br><span class="line">        setGeneric(getConsumer().getGeneric());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是否为泛化接口</span></span><br><span class="line">    <span class="keyword">if</span> (ProtocolUtils.isGeneric(getGeneric())) &#123;</span><br><span class="line">        interfaceClass = GenericService.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载类</span></span><br><span class="line">            interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread()</span><br><span class="line">                    .getContextClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -------------------------------✨ 分割线1 ✨------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从系统变量中获取与接口名对应的属性值</span></span><br><span class="line">    String resolve = System.getProperty(interfaceName);</span><br><span class="line">    String resolveFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (resolve == <span class="keyword">null</span> || resolve.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从系统属性中获取解析文件路径</span></span><br><span class="line">        resolveFile = System.getProperty(<span class="string">"dubbo.resolve.file"</span>);</span><br><span class="line">        <span class="keyword">if</span> (resolveFile == <span class="keyword">null</span> || resolveFile.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 从指定位置加载配置文件</span></span><br><span class="line">            File userResolveFile = <span class="keyword">new</span> File(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.home"</span>)), <span class="string">"dubbo-resolve.properties"</span>);</span><br><span class="line">            <span class="keyword">if</span> (userResolveFile.exists()) &#123;</span><br><span class="line">                <span class="comment">// 获取文件绝对路径</span></span><br><span class="line">                resolveFile = userResolveFile.getAbsolutePath();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolveFile != <span class="keyword">null</span> &amp;&amp; resolveFile.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(resolveFile));</span><br><span class="line">                <span class="comment">// 从文件中加载配置</span></span><br><span class="line">                properties.load(fis);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unload ..., cause:..."</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != fis) fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    logger.warn(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取与接口名对应的配置</span></span><br><span class="line">            resolve = properties.getProperty(interfaceName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve != <span class="keyword">null</span> &amp;&amp; resolve.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 resolve 赋值给 url</span></span><br><span class="line">        url = resolve;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -------------------------------✨ 分割线2 ✨------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 从 consumer 中获取 Application 实例，下同</span></span><br><span class="line">            application = consumer.getApplication();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">module</span> = consumer.getModule();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">            registries = consumer.getRegistries();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            monitor = consumer.getMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">            registries = <span class="keyword">module</span>.getRegistries();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            monitor = <span class="keyword">module</span>.getMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">            registries = application.getRegistries();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            monitor = application.getMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测 Application 合法性</span></span><br><span class="line">    checkApplication();</span><br><span class="line">    <span class="comment">// 检测本地存根配置合法性</span></span><br><span class="line">    checkStubAndMock(interfaceClass);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// -------------------------------✨ 分割线3 ✨------------------------------</span></span><br><span class="line">    </span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    Map&lt;Object, Object&gt; attributes = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 side、协议版本信息、时间戳和进程号等信息到 map 中</span></span><br><span class="line">    map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);</span><br><span class="line">    map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());</span><br><span class="line">    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">    <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非泛化服务</span></span><br><span class="line">    <span class="keyword">if</span> (!isGeneric()) &#123;</span><br><span class="line">        <span class="comment">// 获取版本</span></span><br><span class="line">        String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">        <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(<span class="string">"revision"</span>, revision);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取接口方法列表，并添加到 map 中</span></span><br><span class="line">        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">        <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(<span class="string">"methods"</span>, Constants.ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(<span class="string">"methods"</span>, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">","</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(Constants.INTERFACE_KEY, interfaceName);</span><br><span class="line">    <span class="comment">// 将 ApplicationConfig、ConsumerConfig、ReferenceConfig 等对象的字段信息添加到 map 中</span></span><br><span class="line">    appendParameters(map, application);</span><br><span class="line">    appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">    appendParameters(map, consumer, Constants.DEFAULT_KEY);</span><br><span class="line">    appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// -------------------------------✨ 分割线4 ✨------------------------------</span></span><br><span class="line">    </span><br><span class="line">    String prefix = StringUtils.getServiceKey(map);</span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 遍历 MethodConfig 列表</span></span><br><span class="line">        <span class="keyword">for</span> (MethodConfig method : methods) &#123;</span><br><span class="line">            appendParameters(map, method, method.getName());</span><br><span class="line">            String retryKey = method.getName() + <span class="string">".retry"</span>;</span><br><span class="line">            <span class="comment">// 检测 map 是否包含 methodName.retry</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                String retryValue = map.remove(retryKey);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"false"</span>.equals(retryValue)) &#123;</span><br><span class="line">                    <span class="comment">// 添加重试次数配置 methodName.retries</span></span><br><span class="line">                    map.put(method.getName() + <span class="string">".retries"</span>, <span class="string">"0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 添加 MethodConfig 中的“属性”字段到 attributes</span></span><br><span class="line">            <span class="comment">// 比如 onreturn、onthrow、oninvoke 等</span></span><br><span class="line">            appendAttributes(attributes, method, prefix + <span class="string">"."</span> + method.getName());</span><br><span class="line">            checkAndConvertImplicitConfig(method, map, attributes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// -------------------------------✨ 分割线5 ✨------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务消费者 ip 地址</span></span><br><span class="line">    String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);</span><br><span class="line">    <span class="keyword">if</span> (hostToRegistry == <span class="keyword">null</span> || hostToRegistry.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        hostToRegistry = NetUtils.getLocalHost();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInvalidLocalHost(hostToRegistry)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Specified invalid registry ip from property..."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(Constants.REGISTER_IP_KEY, hostToRegistry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 attributes 到系统上下文中</span></span><br><span class="line">    StaticContext.getSystemContext().putAll(attributes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理类</span></span><br><span class="line">    ref = createProxy(map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据服务名，ReferenceConfig，代理类构建 ConsumerModel，</span></span><br><span class="line">    <span class="comment">// 并将 ConsumerModel 存入到 ApplicationModel 中</span></span><br><span class="line">    ConsumerModel consumerModel = <span class="keyword">new</span> ConsumerModel(getUniqueServiceName(), <span class="keyword">this</span>, ref, interfaceClass.getMethods());</span><br><span class="line">    ApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码很长，做的事情比较多。这里根据代码逻辑，对代码进行了分块，下面我们一起来看一下。</p>
<p>首先是方法开始到分割线1之间的代码。这段代码主要用于检测 ConsumerConfig 实例是否存在，如不存在则创建一个新的实例，然后通过系统变量或 dubbo.properties 配置文件填充 ConsumerConfig 的字段。接着是检测泛化配置，并根据配置设置 interfaceClass 的值。接着来看分割线1到分割线2之间的逻辑。这段逻辑用于从系统属性或配置文件中加载与接口名相对应的配置，并将解析结果赋值给 url 字段。url 字段的作用一般是用于点对点调用。继续向下看，分割线2和分割线3之间的代码用于检测几个核心配置类是否为空，为空则尝试从其他配置类中获取。分割线3与分割线4之间的代码主要用于收集各种配置，并将配置存储到 map 中。分割线4和分割线5之间的代码用于处理 MethodConfig 实例。该实例包含了事件通知配置，比如 onreturn、onthrow、oninvoke 等。分割线5到方法结尾的代码主要用于解析服务消费者 ip，以及调用 createProxy 创建代理对象。关于该方法的详细分析，将会在接下来的章节中展开。</p>
<h3 id="3-2-引用服务"><a href="#3-2-引用服务" class="headerlink" title="3.2 引用服务"></a>3.2 引用服务</h3><p>本节我们要从 createProxy 开始看起。从字面意思上来看，createProxy 似乎只是用于创建代理对象的。但实际上并非如此，该方法还会调用其他方法构建以及合并 Invoker 实例。具体细节如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">    URL tmpUrl = <span class="keyword">new</span> URL(<span class="string">"temp"</span>, <span class="string">"localhost"</span>, <span class="number">0</span>, map);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isJvmRefer;</span><br><span class="line">    <span class="keyword">if</span> (isInjvm() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// url 配置被指定，则不做本地引用</span></span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            isJvmRefer = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 根据 url 的协议、scope 以及 injvm 等参数检测是否需要本地引用</span></span><br><span class="line">        <span class="comment">// 比如如果用户显式配置了 scope=local，此时 isInjvmRefer 返回 true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) &#123;</span><br><span class="line">            isJvmRefer = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isJvmRefer = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 injvm 配置值</span></span><br><span class="line">        isJvmRefer = isInjvm().booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地引用</span></span><br><span class="line">    <span class="keyword">if</span> (isJvmRefer) &#123;</span><br><span class="line">        <span class="comment">// 生成本地引用 URL，协议为 injvm</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">        <span class="comment">// 调用 refer 方法构建 InjvmInvoker 实例</span></span><br><span class="line">        invoker = refprotocol.refer(interfaceClass, url);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 远程引用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// url 不为空，表明用户可能想进行点对点调用</span></span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当需要配置多个 url 时，可用分号进行分割，这里会进行切分</span></span><br><span class="line">            String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">            <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                    URL url = URL.valueOf(u);</span><br><span class="line">                    <span class="keyword">if</span> (url.getPath() == <span class="keyword">null</span> || url.getPath().length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 设置接口全限定名为 url 路径</span></span><br><span class="line">                        url = url.setPath(interfaceName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 检测 url 协议是否为 registry，若是，表明用户想使用指定的注册中心</span></span><br><span class="line">                    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                        <span class="comment">// 将 map 转换为查询字符串，并作为 refer 参数的值添加到 url 中</span></span><br><span class="line">                        urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 合并 url，移除服务提供者的一些配置（这些配置来源于用户配置的 url 属性），</span></span><br><span class="line">                        <span class="comment">// 比如线程池相关配置。并保留服务提供者的部分配置，比如版本，group，时间戳等</span></span><br><span class="line">                        <span class="comment">// 最后将合并后的配置设置为 url 查询字符串中。</span></span><br><span class="line">                        urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 加载注册中心 url</span></span><br><span class="line">            List&lt;URL&gt; us = loadRegistries(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; !us.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                    URL monitorUrl = loadMonitor(u);</span><br><span class="line">                    <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 添加 refer 参数到 url 中，并将 url 添加到 urls 中</span></span><br><span class="line">                    urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未配置注册中心，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such any registry to reference..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单个注册中心或服务提供者(服务直连，下同)</span></span><br><span class="line">        <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用 RegistryProtocol 的 refer 构建 Invoker 实例</span></span><br><span class="line">            invoker = refprotocol.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 多个注册中心或多个服务提供者，或者两者混合</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">            URL registryURL = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取所有的 Invoker</span></span><br><span class="line">            <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                <span class="comment">// 通过 refprotocol 调用 refer 构建 Invoker，refprotocol 会在运行时</span></span><br><span class="line">                <span class="comment">// 根据 url 协议头加载指定的 Protocol 实例，并调用实例的 refer 方法</span></span><br><span class="line">                invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class="line">                <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                    registryURL = url;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果注册中心链接不为空，则将使用 AvailableCluster</span></span><br><span class="line">                URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);</span><br><span class="line">                <span class="comment">// 创建 StaticDirectory 实例，并由 Cluster 对多个 Invoker 进行合并</span></span><br><span class="line">                invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(u, invokers));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean c = check;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span> &amp;&amp; consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        c = consumer.isCheck();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        c = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// invoker 可用性检查</span></span><br><span class="line">    <span class="keyword">if</span> (c &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No provider available for the service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成代理类</span></span><br><span class="line">    <span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码很多，不过逻辑比较清晰。首先根据配置检查是否为本地调用，若是，则调用 InjvmProtocol 的 refer 方法生成 InjvmInvoker 实例。若不是，则读取直连配置项，或注册中心 url，并将读取到的 url 存储到 urls 中。然后根据 urls 元素数量进行后续操作。若 urls 元素数量为1，则直接通过 Protocol 自适应拓展类构建 Invoker 实例接口。若 urls 元素数量大于1，即存在多个注册中心或服务直连 url，此时先根据 url 构建 Invoker。然后再通过 Cluster 合并多个 Invoker，最后调用 ProxyFactory 生成代理类。Invoker 的构建过程以及代理类的过程比较重要，因此接下来将分两小节对这两个过程进行分析。</p>
<h4 id="3-2-1-创建-Invoker"><a href="#3-2-1-创建-Invoker" class="headerlink" title="3.2.1 创建 Invoker"></a>3.2.1 创建 Invoker</h4><p>Invoker 是 Dubbo 的核心模型，代表一个可执行体。在服务提供方，Invoker 用于调用服务提供类。在服务消费方，Invoker 用于执行远程调用。Invoker 是由 Protocol 实现类构建而来。Protocol 实现类有很多，本节会分析最常用的两个，分别是 RegistryProtocol 和 DubboProtocol，其他的大家自行分析。下面先来分析 DubboProtocol 的 refer 方法源码。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line">    <span class="comment">// 创建 DubboInvoker</span></span><br><span class="line">    DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">    invokers.add(invoker);</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法看起来比较简单，不过这里有一个调用需要我们注意一下，即 getClients。这个方法用于获取客户端实例，实例类型为 ExchangeClient。ExchangeClient 实际上并不具备通信能力，它需要基于更底层的客户端实例进行通信。比如 NettyClient、MinaClient 等，默认情况下，Dubbo 使用 NettyClient 进行通信。接下来，我们简单看一下 getClients 方法的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">    <span class="comment">// 是否共享连接</span></span><br><span class="line">    <span class="keyword">boolean</span> service_share_connect = <span class="keyword">false</span>;</span><br><span class="line">  	<span class="comment">// 获取连接数，默认为0，表示未配置</span></span><br><span class="line">    <span class="keyword">int</span> connections = url.getParameter(Constants.CONNECTIONS_KEY, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果未配置 connections，则共享连接</span></span><br><span class="line">    <span class="keyword">if</span> (connections == <span class="number">0</span>) &#123;</span><br><span class="line">        service_share_connect = <span class="keyword">true</span>;</span><br><span class="line">        connections = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExchangeClient[] clients = <span class="keyword">new</span> ExchangeClient[connections];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (service_share_connect) &#123;</span><br><span class="line">            <span class="comment">// 获取共享客户端</span></span><br><span class="line">            clients[i] = getSharedClient(url);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化新的客户端</span></span><br><span class="line">            clients[i] = initClient(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里根据 connections 数量决定是获取共享客户端还是创建新的客户端实例，默认情况下，使用共享客户端实例。getSharedClient 方法中也会调用 initClient 方法，因此下面我们一起看一下这两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">getSharedClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    String key = url.getAddress();</span><br><span class="line">    <span class="comment">// 获取带有“引用计数”功能的 ExchangeClient</span></span><br><span class="line">    ReferenceCountExchangeClient client = referenceClientMap.get(key);</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!client.isClosed()) &#123;</span><br><span class="line">            <span class="comment">// 增加引用计数</span></span><br><span class="line">            client.incrementAndGetCount();</span><br><span class="line">            <span class="keyword">return</span> client;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            referenceClientMap.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    locks.putIfAbsent(key, <span class="keyword">new</span> Object());</span><br><span class="line">    <span class="keyword">synchronized</span> (locks.get(key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (referenceClientMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> referenceClientMap.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ExchangeClient 客户端</span></span><br><span class="line">        ExchangeClient exchangeClient = initClient(url);</span><br><span class="line">        <span class="comment">// 将 ExchangeClient 实例传给 ReferenceCountExchangeClient，这里使用了装饰模式</span></span><br><span class="line">        client = <span class="keyword">new</span> ReferenceCountExchangeClient(exchangeClient, ghostClientMap);</span><br><span class="line">        referenceClientMap.put(key, client);</span><br><span class="line">        ghostClientMap.remove(key);</span><br><span class="line">        locks.remove(key);</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法先访问缓存，若缓存未命中，则通过 initClient 方法创建新的 ExchangeClient 实例，并将该实例传给 ReferenceCountExchangeClient 构造方法创建一个带有引用计数功能的 ExchangeClient 实例。ReferenceCountExchangeClient 内部实现比较简单，就不分析了。下面我们再来看一下 initClient 方法的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">initClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端类型，默认为 netty</span></span><br><span class="line">    String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加编解码和心跳包参数到 url 中</span></span><br><span class="line">    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测客户端类型是否存在，不存在则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExchangeClient client;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 lazy 配置，并根据配置值决定创建的客户端类型</span></span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(Constants.LAZY_CONNECT_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="comment">// 创建懒加载 ExchangeClient 实例</span></span><br><span class="line">            client = <span class="keyword">new</span> LazyConnectExchangeClient(url, requestHandler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建普通 ExchangeClient 实例</span></span><br><span class="line">            client = Exchangers.connect(url, requestHandler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to create remoting client for service..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initClient 方法首先获取用户配置的客户端类型，默认为 netty。然后检测用户配置的客户端类型是否存在，不存在则抛出异常。最后根据 lazy 配置决定创建什么类型的客户端。这里的 LazyConnectExchangeClient 代码并不是很复杂，该类会在 request 方法被调用时通过 Exchangers 的 connect 方法创建 ExchangeClient 客户端，该类的代码本节就不分析了。下面我们分析一下 Exchangers 的 connect 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">    <span class="comment">// 获取 Exchanger 实例，默认为 HeaderExchangeClient</span></span><br><span class="line">    <span class="keyword">return</span> getExchanger(url).connect(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，getExchanger 会通过 SPI 加载 HeaderExchangeClient 实例，这个方法比较简单，大家自己看一下吧。接下来分析 HeaderExchangeClient 的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 这里包含了多个调用，分别如下：</span></span><br><span class="line">    <span class="comment">// 1. 创建 HeaderExchangeHandler 对象</span></span><br><span class="line">    <span class="comment">// 2. 创建 DecodeHandler 对象</span></span><br><span class="line">    <span class="comment">// 3. 通过 Transporters 构建 Client 实例</span></span><br><span class="line">    <span class="comment">// 4. 创建 HeaderExchangeClient 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的调用比较多，我们这里重点看一下 Transporters 的 connect 方法。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelHandler handler;</span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        handler = <span class="keyword">new</span> ChannelHandlerAdapter();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">        handler = handlers[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 handler 数量大于1，则创建一个 ChannelHandler 分发器</span></span><br><span class="line">        handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 Transporter 自适应拓展类，并调用 connect 方法生成 Client 实例</span></span><br><span class="line">    <span class="keyword">return</span> getTransporter().connect(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，getTransporter 方法返回的是自适应拓展类，该类会在运行时根据客户端类型加载指定的 Transporter 实现类。若用户未配置客户端类型，则默认加载 NettyTransporter，并调用该类的 connect 方法。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 NettyClient 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NettyClient(url, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就不继续跟下去了，在往下就是通过 Netty 提供的 API 构建 Netty 客户端了，大家有兴趣自己看看。到这里，关于 DubboProtocol 的 refer 方法就分析完了。接下来，继续分析 RegistryProtocol 的 refer 方法逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 取 registry 参数值，并将其设置为协议头</span></span><br><span class="line">    url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);</span><br><span class="line">    <span class="comment">// 获取注册中心实例</span></span><br><span class="line">    Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">    <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 url 查询字符串转为 Map</span></span><br><span class="line">    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));</span><br><span class="line">    <span class="comment">// 获取 group 配置</span></span><br><span class="line">    String group = qs.get(Constants.GROUP_KEY);</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((Constants.COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span></span><br><span class="line">                || <span class="string">"*"</span>.equals(group)) &#123;</span><br><span class="line">            <span class="comment">// 通过 SPI 加载 MergeableCluster 实例，并调用 doRefer 继续执行服务引用逻辑</span></span><br><span class="line">            <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 doRefer 继续执行服务引用逻辑</span></span><br><span class="line">    <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码首先为 url 设置协议头，然后根据 url 参数加载注册中心实例。然后获取 group 配置，根据 group 配置决定 doRefer 第一个参数的类型。这里的重点是 doRefer 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 RegistryDirectory 实例</span></span><br><span class="line">    RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">    <span class="comment">// 设置注册中心和协议</span></span><br><span class="line">    directory.setRegistry(registry);</span><br><span class="line">    directory.setProtocol(protocol);</span><br><span class="line">    Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">    <span class="comment">// 生成服务消费者链接</span></span><br><span class="line">    URL subscribeUrl = <span class="keyword">new</span> URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册服务消费者，在 consumers 目录下新节点</span></span><br><span class="line">    <span class="keyword">if</span> (!Constants.ANY_VALUE.equals(url.getServiceInterface())</span><br><span class="line">            &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,</span><br><span class="line">                Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅 providers、configurators、routers 等节点数据</span></span><br><span class="line">    directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,</span><br><span class="line">            Constants.PROVIDERS_CATEGORY</span><br><span class="line">                    + <span class="string">","</span> + Constants.CONFIGURATORS_CATEGORY</span><br><span class="line">                    + <span class="string">","</span> + Constants.ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个注册中心可能有多个服务提供者，因此这里需要将多个服务提供者合并为一个</span></span><br><span class="line">    Invoker invoker = cluster.join(directory);</span><br><span class="line">    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，doRefer 方法创建一个 RegistryDirectory 实例，然后生成服务者消费者链接，并向注册中心进行注册。注册完毕后，紧接着订阅 providers、configurators、routers 等节点下的数据。完成订阅后，RegistryDirectory 会收到这几个节点下的子节点信息。由于一个服务可能部署在多台服务器上，这样就会在 providers 产生多个节点，这个时候就需要 Cluster 将多个服务节点合并为一个，并生成一个 Invoker。关于 RegistryDirectory 和 Cluster，本文不打算进行分析，相关分析将会在随后的文章中展开。</p>
<h4 id="3-2-2-创建代理"><a href="#3-2-2-创建代理" class="headerlink" title="3.2.2 创建代理"></a>3.2.2 创建代理</h4><p>Invoker 创建完毕后，接下来要做的事情是为服务接口生成代理对象。有了代理对象，即可进行远程调用。代理对象生成的入口方法为 ProxyFactory 的 getProxy，接下来进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 调用重载方法</span></span><br><span class="line">    <span class="keyword">return</span> getProxy(invoker, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, <span class="keyword">boolean</span> generic)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取接口列表</span></span><br><span class="line">    String config = invoker.getUrl().getParameter(<span class="string">"interfaces"</span>);</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; config.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 切分接口列表</span></span><br><span class="line">        String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);</span><br><span class="line">        <span class="keyword">if</span> (types != <span class="keyword">null</span> &amp;&amp; types.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            interfaces = <span class="keyword">new</span> Class&lt;?&gt;[types.length + <span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 设置服务接口类和 EchoService.class 到 interfaces 中</span></span><br><span class="line">            interfaces[<span class="number">0</span>] = invoker.getInterface();</span><br><span class="line">            interfaces[<span class="number">1</span>] = EchoService.class;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 加载接口类</span></span><br><span class="line">                interfaces[i + <span class="number">1</span>] = ReflectUtils.forName(types[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (interfaces == <span class="keyword">null</span>) &#123;</span><br><span class="line">        interfaces = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;invoker.getInterface(), EchoService.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 http 和 hessian 协议提供泛化调用支持，参考 pull request #1827</span></span><br><span class="line">    <span class="keyword">if</span> (!invoker.getInterface().equals(GenericService.class) &amp;&amp; generic) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = interfaces.length;</span><br><span class="line">        Class&lt;?&gt;[] temp = interfaces;</span><br><span class="line">        <span class="comment">// 创建新的 interfaces 数组</span></span><br><span class="line">        interfaces = <span class="keyword">new</span> Class&lt;?&gt;[len + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, interfaces, <span class="number">0</span>, len);</span><br><span class="line">        <span class="comment">// 设置 GenericService.class 到数组中</span></span><br><span class="line">        interfaces[len] = GenericService.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用重载方法</span></span><br><span class="line">    <span class="keyword">return</span> getProxy(invoker, interfaces);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] types)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如上，上面大段代码都是用来获取 interfaces 数组的，我们继续往下看。getProxy(Invoker, Class&lt;?&gt;[]) 这个方法是一个抽象方法，下面我们到 JavassistProxyFactory 类中看一下该方法的实现代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成 Proxy 子类（Proxy 是抽象类）。并调用 Proxy 子类的 newInstance 方法创建 Proxy 实例</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码并不多，首先是通过 Proxy 的 getProxy 方法获取 Proxy 子类，然后创建 InvokerInvocationHandler 对象，并将该对象传给 newInstance 生成 Proxy 实例。InvokerInvocationHandler 实现自 JDK 的 InvocationHandler 接口，具体的用途是拦截接口类调用。该类逻辑比较简单，这里就不分析了。下面我们重点关注一下 Proxy 的 getProxy 方法，如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Proxy <span class="title">getProxy</span><span class="params">(Class&lt;?&gt;... ics)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用重载方法</span></span><br><span class="line">    <span class="keyword">return</span> getProxy(ClassHelper.getClassLoader(Proxy.class), ics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Proxy <span class="title">getProxy</span><span class="params">(ClassLoader cl, Class&lt;?&gt;... ics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ics.length &gt; <span class="number">65535</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// 遍历接口列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ics.length; i++) &#123;</span><br><span class="line">        String itf = ics[i].getName();</span><br><span class="line">        <span class="comment">// 检测类型是否为接口</span></span><br><span class="line">        <span class="keyword">if</span> (!ics[i].isInterface())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(itf + <span class="string">" is not a interface."</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 重新加载接口类</span></span><br><span class="line">            tmp = Class.forName(itf, <span class="keyword">false</span>, cl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测接口是否相同，这里 tmp 有可能为空</span></span><br><span class="line">        <span class="keyword">if</span> (tmp != ics[i])</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ics[i] + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接接口全限定名，分隔符为 ;</span></span><br><span class="line">        sb.append(itf).append(<span class="string">';'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用拼接后的接口名作为 key</span></span><br><span class="line">    String key = sb.toString();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; cache;</span><br><span class="line">    <span class="keyword">synchronized</span> (ProxyCacheMap) &#123;</span><br><span class="line">        cache = ProxyCacheMap.get(cl);</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cache = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            ProxyCacheMap.put(cl, cache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Proxy proxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 从缓存中获取 Reference&lt;Proxy&gt; 实例</span></span><br><span class="line">            Object value = cache.get(key);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Reference&lt;?&gt;) &#123;</span><br><span class="line">                proxy = (Proxy) ((Reference&lt;?&gt;) value).get();</span><br><span class="line">                <span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 并发控制，保证只有一个线程可以进行后续操作</span></span><br><span class="line">            <span class="keyword">if</span> (value == PendingGenerationMarker) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他线程在此处进行等待</span></span><br><span class="line">                    cache.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 放置标志位到缓存中，并跳出 while 循环进行后续操作</span></span><br><span class="line">                cache.put(key, PendingGenerationMarker);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> id = PROXY_CLASS_COUNTER.getAndIncrement();</span><br><span class="line">    String pkg = <span class="keyword">null</span>;</span><br><span class="line">    ClassGenerator ccp = <span class="keyword">null</span>, ccm = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 ClassGenerator 对象</span></span><br><span class="line">        ccp = ClassGenerator.newInstance(cl);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; worked = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;Method&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ics.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 检测接口访问级别是否为 protected 或 privete</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(ics[i].getModifiers())) &#123;</span><br><span class="line">                <span class="comment">// 获取接口包名</span></span><br><span class="line">                String npkg = ics[i].getPackage().getName();</span><br><span class="line">                <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pkg = npkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!pkg.equals(npkg))</span><br><span class="line">                        <span class="comment">// 非 public 级别的接口必须在同一个包下，否者抛出异常</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加接口到 ClassGenerator 中</span></span><br><span class="line">            ccp.addInterface(ics[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历接口方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : ics[i].getMethods()) &#123;</span><br><span class="line">                <span class="comment">// 获取方法描述，可理解为方法签名</span></span><br><span class="line">                String desc = ReflectUtils.getDesc(method);</span><br><span class="line">                <span class="comment">// 如果方法描述字符串已在 worked 中，则忽略。考虑这种情况，</span></span><br><span class="line">                <span class="comment">// A 接口和 B 接口中包含一个完全相同的方法</span></span><br><span class="line">                <span class="keyword">if</span> (worked.contains(desc))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                worked.add(desc);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> ix = methods.size();</span><br><span class="line">                <span class="comment">// 获取方法返回值类型</span></span><br><span class="line">                Class&lt;?&gt; rt = method.getReturnType();</span><br><span class="line">                <span class="comment">// 获取参数列表</span></span><br><span class="line">                Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 生成 Object[] args = new Object[1...N]</span></span><br><span class="line">                StringBuilder code = <span class="keyword">new</span> StringBuilder(<span class="string">"Object[] args = new Object["</span>).append(pts.length).append(<span class="string">"];"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pts.length; j++)</span><br><span class="line">                    <span class="comment">// 生成 args[1...N] = ($w)$1...N;</span></span><br><span class="line">                    code.append(<span class="string">" args["</span>).append(j).append(<span class="string">"] = ($w)$"</span>).append(j + <span class="number">1</span>).append(<span class="string">";"</span>);</span><br><span class="line">                <span class="comment">// 生成 InvokerHandler 接口的 invoker 方法调用语句，如下：</span></span><br><span class="line">                <span class="comment">// Object ret = handler.invoke(this, methods[1...N], args);</span></span><br><span class="line">                code.append(<span class="string">" Object ret = handler.invoke(this, methods["</span> + ix + <span class="string">"], args);"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回值不为 void</span></span><br><span class="line">                <span class="keyword">if</span> (!Void.TYPE.equals(rt))</span><br><span class="line">                    <span class="comment">// 生成返回语句，形如 return (java.lang.String) ret;</span></span><br><span class="line">                    code.append(<span class="string">" return "</span>).append(asArgument(rt, <span class="string">"ret"</span>)).append(<span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line">                methods.add(method);</span><br><span class="line">                <span class="comment">// 添加方法名、访问控制符、参数列表、方法代码等信息到 ClassGenerator 中 </span></span><br><span class="line">                ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkg == <span class="keyword">null</span>)</span><br><span class="line">            pkg = PACKAGE_NAME;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建接口代理类名称：pkg + ".proxy" + id，比如 org.apache.dubbo.proxy0</span></span><br><span class="line">        String pcn = pkg + <span class="string">".proxy"</span> + id;</span><br><span class="line">        ccp.setClassName(pcn);</span><br><span class="line">        ccp.addField(<span class="string">"public static java.lang.reflect.Method[] methods;"</span>);</span><br><span class="line">        <span class="comment">// 生成 private java.lang.reflect.InvocationHandler handler;</span></span><br><span class="line">        ccp.addField(<span class="string">"private "</span> + InvocationHandler.class.getName() + <span class="string">" handler;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为接口代理类添加带有 InvocationHandler 参数的构造方法，比如：</span></span><br><span class="line">        <span class="comment">// porxy0(java.lang.reflect.InvocationHandler arg0) &#123;</span></span><br><span class="line">        <span class="comment">//     handler=$1;</span></span><br><span class="line">    	<span class="comment">// &#125;</span></span><br><span class="line">        ccp.addConstructor(Modifier.PUBLIC, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;InvocationHandler.class&#125;, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>], <span class="string">"handler=$1;"</span>);</span><br><span class="line">        <span class="comment">// 为接口代理类添加默认构造方法</span></span><br><span class="line">        ccp.addDefaultConstructor();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成接口代理类</span></span><br><span class="line">        Class&lt;?&gt; clazz = ccp.toClass();</span><br><span class="line">        clazz.getField(<span class="string">"methods"</span>).set(<span class="keyword">null</span>, methods.toArray(<span class="keyword">new</span> Method[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建 Proxy 子类名称，比如 Proxy1，Proxy2 等</span></span><br><span class="line">        String fcn = Proxy.class.getName() + id;</span><br><span class="line">        ccm = ClassGenerator.newInstance(cl);</span><br><span class="line">        ccm.setClassName(fcn);</span><br><span class="line">        ccm.addDefaultConstructor();</span><br><span class="line">        ccm.setSuperClass(Proxy.class);</span><br><span class="line">        <span class="comment">// 为 Proxy 的抽象方法 newInstance 生成实现代码，形如：</span></span><br><span class="line">        <span class="comment">// public Object newInstance(java.lang.reflect.InvocationHandler h) &#123; </span></span><br><span class="line">        <span class="comment">//     return new org.apache.dubbo.proxy0($1);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        ccm.addMethod(<span class="string">"public Object newInstance("</span> + InvocationHandler.class.getName() + <span class="string">" h)&#123; return new "</span> + pcn + <span class="string">"($1); &#125;"</span>);</span><br><span class="line">        <span class="comment">// 生成 Proxy 实现类</span></span><br><span class="line">        Class&lt;?&gt; pc = ccm.toClass();</span><br><span class="line">        <span class="comment">// 通过反射创建 Proxy 实例</span></span><br><span class="line">        proxy = (Proxy) pc.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ccp != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            ccp.release();</span><br><span class="line">        <span class="keyword">if</span> (ccm != <span class="keyword">null</span>)</span><br><span class="line">            ccm.release();</span><br><span class="line">        <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="keyword">null</span>)</span><br><span class="line">                cache.remove(key);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 写缓存</span></span><br><span class="line">                cache.put(key, <span class="keyword">new</span> WeakReference&lt;Proxy&gt;(proxy));</span><br><span class="line">            <span class="comment">// 唤醒其他等待线程</span></span><br><span class="line">            cache.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码比较复杂，我们写了大量的注释。大家在阅读这段代码时，要搞清楚 ccp 和 ccm 的用途，不然会被搞晕。ccp 用于为服务接口生成代理类，比如我们有一个 DemoService 接口，这个接口代理类就是由 ccp 生成的。ccm 则是用于为 org.apache.dubbo.common.bytecode.Proxy 抽象类生成子类，主要是实现 Proxy 类的抽象方法。下面以 org.apache.dubbo.demo.DemoService 这个接口为例，来看一下该接口代理类代码大致是怎样的（忽略 EchoService 接口）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.common.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxy0</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">demo</span>.<span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.reflect.Method[] methods;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> java.lang.reflect.InvocationHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">(java.lang.reflect.InvocationHandler arg0)</span> </span>&#123;</span><br><span class="line">        handler = $<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">sayHello</span><span class="params">(java.lang.String arg0)</span> </span>&#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        args[<span class="number">0</span>] = ($w) $<span class="number">1</span>;</span><br><span class="line">        Object ret = handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], args);</span><br><span class="line">        <span class="keyword">return</span> (java.lang.String) ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，到这里代理类生成逻辑就分析完了。整个过程比较复杂，大家需要耐心看一下。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>本篇文章对服务引用的过程进行了较为详尽的分析，还有一些逻辑暂时没有分析到，比如 Directory、Cluster。这些接口及实现类功能比较独立，后续会单独成文进行分析。暂时我们可以先把这些类看成黑盒，只要知道这些类的用途即可。关于服务引用过程就分析到这里。</p>
<h1 id="服务字典"><a href="#服务字典" class="headerlink" title="服务字典"></a>服务字典</h1><h1 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h1><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h1 id="服务调用过程"><a href="#服务调用过程" class="headerlink" title="服务调用过程"></a>服务调用过程</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

      
    </div>

    

    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Heper</li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://yoursite.com/2019/07/22/系统架构/Dubbo：源码分析/" title="Dubbo：源码分析">http://yoursite.com/2019/07/22/系统架构/Dubbo：源码分析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under CC BY-NC-SA 3.0 unless stating additionally.</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Dubbo/" rel="tag"># Dubbo</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/22/系统架构/RPC：概述/" rel="next" title="RPC：概述">
                <i class="fa fa-chevron-left"></i> RPC：概述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/22/Java/base/JavaBase：类型信息/" rel="prev" title="JavaBase：类型信息">
                JavaBase：类型信息 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="Heper">
            
              <p class="site-author-name" itemprop="name">Heper</p>
              <p class="site-description motion-element" itemprop="description">To be awesome</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">227</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/smallpocket" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Dubbo的服务"><span class="nav-number">1.</span> <span class="nav-text">Dubbo的服务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dubbo-SPI"><span class="nav-number">2.</span> <span class="nav-text">Dubbo SPI</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SPI示例"><span class="nav-number">2.2.</span> <span class="nav-text">SPI示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-SPI"><span class="nav-number">2.2.1.</span> <span class="nav-text">Java SPI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dubbo-SPI-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">Dubbo SPI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dubbo-SPI源码分析"><span class="nav-number">2.3.</span> <span class="nav-text">Dubbo SPI源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分析拓展类对象的获取过程"><span class="nav-number">2.3.1.</span> <span class="nav-text">分析拓展类对象的获取过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dubbo-IOC"><span class="nav-number">2.4.</span> <span class="nav-text">Dubbo IOC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">2.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RPC"><span class="nav-number">3.</span> <span class="nav-text">RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Protocol"><span class="nav-number">3.1.</span> <span class="nav-text">Protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#export"><span class="nav-number">3.1.1.</span> <span class="nav-text">export</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#refer"><span class="nav-number">3.1.2.</span> <span class="nav-text">refer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Invoker"><span class="nav-number">3.2.</span> <span class="nav-text">Invoker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exporter"><span class="nav-number">3.3.</span> <span class="nav-text">Exporter</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务导出"><span class="nav-number">4.</span> <span class="nav-text">服务导出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析"><span class="nav-number">4.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前置工作"><span class="nav-number">4.2.</span> <span class="nav-text">前置工作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#检查配置"><span class="nav-number">4.2.1.</span> <span class="nav-text">检查配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多协议多注册中心导出服务"><span class="nav-number">4.2.2.</span> <span class="nav-text">多协议多注册中心导出服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组装-URL"><span class="nav-number">4.2.3.</span> <span class="nav-text">组装 URL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#导出-Dubbo-服务"><span class="nav-number">4.3.</span> <span class="nav-text">导出 Dubbo 服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Invoker-创建过程"><span class="nav-number">4.3.1.</span> <span class="nav-text">Invoker 创建过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导出服务到本地"><span class="nav-number">4.3.2.</span> <span class="nav-text">导出服务到本地</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导出服务到远程"><span class="nav-number">4.3.3.</span> <span class="nav-text">导出服务到远程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务注册"><span class="nav-number">4.3.4.</span> <span class="nav-text">服务注册</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建注册中心"><span class="nav-number">4.3.4.1.</span> <span class="nav-text">创建注册中心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节点创建"><span class="nav-number">4.3.4.2.</span> <span class="nav-text">节点创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#订阅-override-数据"><span class="nav-number">4.3.5.</span> <span class="nav-text">订阅 override 数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">4.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务引入"><span class="nav-number">5.</span> <span class="nav-text">服务引入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-简介"><span class="nav-number">5.1.</span> <span class="nav-text">1. 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-服务引用原理"><span class="nav-number">5.2.</span> <span class="nav-text">2.服务引用原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-源码分析"><span class="nav-number">5.3.</span> <span class="nav-text">3.源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-处理配置"><span class="nav-number">5.3.1.</span> <span class="nav-text">3.1 处理配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-引用服务"><span class="nav-number">5.3.2.</span> <span class="nav-text">3.2 引用服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-创建-Invoker"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">3.2.1 创建 Invoker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-创建代理"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">3.2.2 创建代理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-总结"><span class="nav-number">5.4.</span> <span class="nav-text">4.总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务字典"><span class="nav-number">6.</span> <span class="nav-text">服务字典</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务路由"><span class="nav-number">7.</span> <span class="nav-text">服务路由</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#负载均衡"><span class="nav-number">8.</span> <span class="nav-text">负载均衡</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务调用过程"><span class="nav-number">9.</span> <span class="nav-text">服务调用过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">10.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2013 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>

  

  
</div>


  



  <div class="powered-by">Powered by <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" rel="external nofollow" href="https://theme-next.org">NexT.Gemini</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname,
            owner: 'smallpocket',
            repo: 'Blog',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '435e469c98444b64d4133c7d692994c93a94c194',
            
                client_id: 'a5dc6afe65772e33c437'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  

  

  

  

  

  

</body>
</html>
