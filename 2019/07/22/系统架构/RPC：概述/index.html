<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: 'OZTK1BY156',
      apiKey: '170e5456de98e8b1e1d4de202887d0aa',
      indexName: 'BlogIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'کپی',
      copy_success: 'کپی شد',
      copy_failure: 'کپی انجام نشد'
    }
  };
</script>

  <meta name="description" content="RPC提出问题 考虑将“无所不在”的对象作为所有问题的解决之道，其思想是所有相互协作的对象彼此都知道对方在哪里 当在一台计算机上的某个对象需要调用在另一台计算机上的某个对象时就会发送一个包含这个请求的详细信息的网络消息。 远程对象响应请求，并返回客户端    概述客户端服务器角色我们需要的机制并不是HTTP的机制，而是客户端程序员以常规的方式进行方法调用而无需操心将数据发送到网络上或解析响应之类的">
<meta property="og:type" content="article">
<meta property="og:title" content="RPC：概述">
<meta property="og:url" content="http://yoursite.com/2019/07/22/系统架构/RPC：概述/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="RPC提出问题 考虑将“无所不在”的对象作为所有问题的解决之道，其思想是所有相互协作的对象彼此都知道对方在哪里 当在一台计算机上的某个对象需要调用在另一台计算机上的某个对象时就会发送一个包含这个请求的详细信息的网络消息。 远程对象响应请求，并返回客户端    概述客户端服务器角色我们需要的机制并不是HTTP的机制，而是客户端程序员以常规的方式进行方法调用而无需操心将数据发送到网络上或解析响应之类的">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/07/22/系统架构/RPC：概述/assets/1563772474306.png">
<meta property="og:image" content="http://yoursite.com/2019/07/22/系统架构/OS/assets/20160630-lpc.png">
<meta property="og:image" content="http://yoursite.com/2019/07/22/系统架构/RPC：概述/assets/1563773031397.png">
<meta property="og:image" content="http://yoursite.com/2019/07/22/系统架构/RPC：概述/assets/1563773983561.png">
<meta property="og:image" content="http://yoursite.com/2019/07/22/系统架构/RPC：概述/assets/1563777082595.png">
<meta property="og:image" content="http://yoursite.com/2019/07/22/系统架构/RPC：概述/assets/dubbo-architecture.jpg">
<meta property="og:image" content="http://yoursite.com/2019/07/22/系统架构/RPC：概述/assets/1563778296842.png">
<meta property="og:updated_time" content="2019-07-26T01:29:26.037Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RPC：概述">
<meta name="twitter:description" content="RPC提出问题 考虑将“无所不在”的对象作为所有问题的解决之道，其思想是所有相互协作的对象彼此都知道对方在哪里 当在一台计算机上的某个对象需要调用在另一台计算机上的某个对象时就会发送一个包含这个请求的详细信息的网络消息。 远程对象响应请求，并返回客户端    概述客户端服务器角色我们需要的机制并不是HTTP的机制，而是客户端程序员以常规的方式进行方法调用而无需操心将数据发送到网络上或解析响应之类的">
<meta name="twitter:image" content="http://yoursite.com/2019/07/22/系统架构/RPC：概述/assets/1563772474306.png">
  <link rel="canonical" href="http://yoursite.com/2019/07/22/系统架构/RPC：概述/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>RPC：概述 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="تغییر ناوبری">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>صفحه اصلی</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>درباره</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>برچسب ها</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>دسته بندی ها</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>بایگانی</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>زمان بندی</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>جستجو</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="algolia-popup popup search-popup">
  <div class="algolia-search">
    <div class="algolia-search-input-icon">
      <i class="fa fa-search"></i>
    </div>
    <div class="algolia-search-input" id="algolia-search-input"></div>
  </div>

  <div class="algolia-results">
    <div id="algolia-stats"></div>
    <div id="algolia-hits"></div>
    <div id="algolia-pagination" class="algolia-pagination"></div>
  </div>

  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>



    </div>
</nav>

</div>
    </header>

    

  <a href="https://github.com/smallpocket" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/系统架构/RPC：概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">RPC：概述

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">نوشته شده در</span>
              

              
                
              

              <time title="ایجاد شده: 2019-07-22 12:32:30" itemprop="dateCreated datePublished" datetime="2019-07-22T12:32:30+08:00">2019-07-22</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">ویرایش شده در</span>
                
                <time title="تغییر یافته: 2019-07-26 09:29:26" itemprop="dateModified" datetime="2019-07-26T09:29:26+08:00">2019-07-26</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">در</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/07/22/系统架构/RPC：概述/" class="post-meta-item leancloud_visitors" data-flag-title="RPC：概述">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">بازدیدها: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">نظرات: </span>
    
  
    <a href="/2019/07/22/系统架构/RPC：概述/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/07/22/系统架构/RPC：概述/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><ul>
<li>考虑将“无所不在”的对象作为所有问题的解决之道，其思想是所有相互协作的对象彼此都知道对方在哪里<ul>
<li>当在一台计算机上的某个对象需要调用在另一台计算机上的某个对象时就会发送一个包含这个请求的详细信息的网络消息。</li>
<li>远程对象响应请求，并返回客户端</li>
</ul>
</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="客户端服务器角色"><a href="#客户端服务器角色" class="headerlink" title="客户端服务器角色"></a>客户端服务器角色</h3><p>我们需要的机制并不是HTTP的机制，而是客户端程序员以常规的方式进行方法调用而无需操心将数据发送到网络上或解析响应之类的问题。</p>
<p>即在客户端为远程对象安装一个代理，对于客户端来说就像是要访问的远程对象一样，客户调用该代理时只需要进行常规的方法调用。代理负责使用网络协议与服务器联系。</p>
<h3 id="什么是RPC服务"><a href="#什么是RPC服务" class="headerlink" title="什么是RPC服务"></a>什么是RPC服务</h3><p>RPC协议是一种通过网络从远程计算机程序上请求服务来得到计算服务或数据服务，且不需要了解底层网络技术的协议和框架。RPC框架负责屏蔽底层的传输方式（TCP或者UDP）、序列化方式（XML/Json/二进制）和通信细节。框架使用者只需要了解谁在什么位置提供了什么样的远程服务接口即可，开发者不需要关心底层通信细节和调用过程。</p>
<ul>
<li>简单，RPC的语义十分清晰和简单，便于建立分布式系统</li>
<li>高效，能够高效地实现远程的过程调用</li>
<li>通用，RPC导出的服务可以供多个使用者用于不同的目的。</li>
</ul>
<h3 id="核心技术点"><a href="#核心技术点" class="headerlink" title="核心技术点"></a>核心技术点</h3><p>RPC框架实现的几个核心技术点总结如下：</p>
<ol>
<li>远程服务提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构，或者中间态的服务定义文件，例如 Thrift 的 IDL 文件，WS-RPC 的 WSDL 文件定义，甚至也可以是服务端的接口说明文档；服务调用者需要通过一定的途径获取远程服务调用相关信息，例如服务端接口定义 Jar 包导入，获取服务端 IDL 文件等。</li>
<li>远程代理对象：服务调用者调用的服务实际是远程服务的本地代理，对于 Java 语言，它的实现就是 JDK 的动态代理，通过动态代理的拦截机制，将本地调用封装成远程服务调用。</li>
<li>通信：RPC 框架与具体的协议无关，例如 Spring 的远程调用支持 HTTP Invoke、RMI Invoke，MessagePack 使用的是私有的二进制压缩协议。</li>
<li>序列化：远程通信，需要将对象转换成二进制码流进行网络传输，不同的序列化框架，支持的数据类型、数据包大小、异常类型以及性能等都不同。不同的 RPC 框架应用场景不同，因此技术选择也会存在很大差异。一些做的比较好的 RPC 框架，可以支持多种序列化方式，有的甚至支持用户自定义序列化框架（Hadoop Avro）。</li>
</ol>
<h3 id="RPC协议实现"><a href="#RPC协议实现" class="headerlink" title="RPC协议实现"></a>RPC协议实现</h3><ul>
<li>RPC协议以传输协议（HTTP，又或者TCP/UDP）为基础，为两个不同的应用程序传递数据。</li>
<li>RPC采用客户端/服务端模式，请求程序就是一个客户端，服务提供程序就是一个服务端<ul>
<li><img src="assets/1563772474306.png" alt="1563772474306"></li>
</ul>
</li>
</ul>
<h1 id="RPC服务的原理"><a href="#RPC服务的原理" class="headerlink" title="RPC服务的原理"></a>RPC服务的原理</h1><p><strong><em>Socket套接字</em></strong></p>
<p>网络上的两个程序通过一个双向通信连接实现数据的交换，这个连接的一端被称为Socket，用于描述IP地址和端口，是一个通信连接的句柄，可以用来实现不同计算机间的通信，是网络编程接口的具体实现。</p>
<h2 id="本地调用过程"><a href="#本地调用过程" class="headerlink" title="本地调用过程"></a>本地调用过程</h2><p>考虑C语言的调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fd：一个整形数，表示一个文件</span></span><br><span class="line"><span class="comment">//buf：一个字符数组，用于存储读入的数据</span></span><br><span class="line"><span class="comment">//nbytes：另一个整形数，记录实际读入的字节数，即数组长度</span></span><br><span class="line">count = read(fd , buf , nbytes);</span><br></pre></td></tr></table></figure>

<ul>
<li>在主程序中进行调用该函数，则调用之前堆栈的状态如图2(a)所示。</li>
<li>为了进行调用，调用方首先把参数反序压入堆栈，即为最后一个参数先压入，如图2(b)所示。</li>
<li>在read操作运行完毕后，它将返回值放在某个寄存器中，移出返回地址，并将控制权交回给调用方。</li>
<li>调用方随后将参数从堆栈中移出，使堆栈还原到最初的状态。</li>
</ul>
<p><img src="../OS/assets/20160630-lpc.png" alt></p>
<p>一般为阻塞send，因为如同本地方法调用一般，需要先执行完需要执行的函数，才执行之后的</p>
<h2 id="RPC调用过程"><a href="#RPC调用过程" class="headerlink" title="RPC调用过程"></a>RPC调用过程</h2><p>在本地调用过程中，read例程由链接器从库中提取出来，然后插入到目标程序当中。即通过编译的方式实现这一过程。而在RPC调用中并不可行，因为目标函数是存在于远端程序上，</p>
<p>因此RPC调用是建立在语言级别的，必须使用socket通信完成，为使得RPC调用如同本地调用一般透明，则出现了几个新的概念</p>
<ul>
<li>客户存根：存根就像代理一样，当read实际上是一个远程过程时（位于文件服务器所在机器上运行的过程），库中就放入read的另一个版本（代理代码），即<strong>客户存根</strong><ul>
<li>在具体调用过程中，调用者调用存根如同调用本地代码一样方便</li>
</ul>
</li>
<li>服务器存根：客户存根的等价物</li>
<li>其具体的原理为：<ul>
<li>对于每个独立的远程过程都有一个存根。当客户机调用原厂过程时，RPC系统调用合适的存根，并传递远程过程的参数</li>
<li>该存根位于服务器的端口，并编组参数（涉及将参数打包成可通过网络传输的形式），接着存根使用消息传递向服务器发送一个消息。</li>
<li>服务器的一个类似存根接收这一消息，并调用服务器上的过程。如有必要，返回值可通过同样的技术返回客户机</li>
</ul>
</li>
</ul>
<p><img src="assets/1563773031397.png" alt="1563773031397"></p>
<ul>
<li>客户端以正常的方式调用客户存根。<ul>
<li>从客户端的角度来看，这个调用仿佛就是调用一个本地方法，而它的真正执行是发生在远端服务器上的。客户存根的方法将参数打包并封装成一个或多个网络消息体并发送到服务端。</li>
<li>将参数封装到网络消息中的过程称为<strong>编码</strong>，它将所有的数据化为字节数组格式</li>
</ul>
</li>
<li>客户存根生成一个消息，然后调用本地操作系统；<ul>
<li>调用OS的socket套接字接口来向远程服务发送我们编码的网络消息</li>
</ul>
</li>
<li>客户端操作系统将消息发送给远程操作系统；<ul>
<li>OS使用某种协议，如TCP传输到远程服务端</li>
</ul>
</li>
<li>远程操作系统将消息交给服务器存根；<ul>
<li>远程OS套接字收到消息，并将消息传递到指定端口</li>
</ul>
</li>
<li>服务器存根调将参数提取出来，而后调用服务器；<ul>
<li>服务器存根对参数进行解码，通常会将参数从标准的网络格式转换为特定的语言格式</li>
</ul>
</li>
<li>服务器执行要求的操作，操作完成后将结果返回给服务器存根；<ul>
<li>服务器存根调用服务端的方法，并且将从客户端接收的参数传递给该方法，它运行具体的功能并返回，这部分代码的执行对于客户端来说就是远程过程调用</li>
</ul>
</li>
<li>服务器存根将结果打包成一个消息，而后调用本地操作系统；<ul>
<li>将最后的结果进行编码并序列化，打包成网络参数等，</li>
</ul>
</li>
<li>服务器操作系统将含有结果的消息发送给客户端操作系统；</li>
<li>客户端操作系统将消息交给客户存根；</li>
<li>客户存根将结果从消息中提取出来，返回给调用它的客户存根。</li>
</ul>
<h1 id="RPC实现"><a href="#RPC实现" class="headerlink" title="RPC实现"></a>RPC实现</h1><h2 id="Java-RMI"><a href="#Java-RMI" class="headerlink" title="Java RMI"></a>Java RMI</h2><p>对象被抽离出类，类里面包含操作，对这些类和方法的注册形成了第二代RPC</p>
<p>JavaRMI使程序员可以创建分布式应用程序，能够从其他JVM中调用远程对象的方法。</p>
<p>只要客户端应用程序具有对远程对象的引用，就可以进行远程调用，该引用是通过查找RMI提供的命名服务（RMI注册表）中的远程对象得到的，调用该引用就可以像调用本地方法一样调用远程方法，然后接收方法执行之后传递回来的返回值。</p>
<p><strong><em>RMI架构</em></strong></p>
<p><img src="assets/1563773983561.png" alt="1563773983561"></p>
<p><strong><em>RMI中分布式对象模型的特点</em></strong></p>
<ul>
<li>服务对象的引用可以作为参数传递或作为结果返回</li>
<li>调用远程服务对象的方法就像调用本地对象的方法一样</li>
<li>内置的Java的instanceof可以测试远程对象实现的远程接口，就像本地使用方法一样</li>
<li>调用远程对象的方法实际上是与远程服务接口进行交互，而不是实现类</li>
<li>远程方法调用过程中，参数和返回值是通过传递值类实现的，而不是传递引用</li>
<li>远程对象的引用是通过引用传递的，一切真实的操作发生在远程的服务端</li>
<li>客户端必须处理因为远程调用而导致的额外的异常。</li>
</ul>
<h3 id="存根与参数编码"><a href="#存根与参数编码" class="headerlink" title="存根与参数编码"></a>存根与参数编码</h3><p>客户端的存根构造了一个信息块：</p>
<ul>
<li>被使用的远程对象的标识符</li>
<li>被调用的方法的描述</li>
<li>编组后的参数</li>
</ul>
<p>存根将此消息发送给服务器，在服务器的另一端，接收器对象执行以下动作：</p>
<ul>
<li>定位要调用的远程对象</li>
<li>调用所需要的方法，并传递客户端提供的参数</li>
<li>捕获返回值或该调用产生的异常</li>
<li>将返回值编组，打包送回给客户端存根</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>主要包括接口和对象类、远程接口实现类、生成存根代码、注册接口和查找对象、分布式的垃圾回收器</p>
<p><strong><em>接口和对象类</em></strong></p>
<p>首先定义一个要被传输的对象类，它需要实现Serializable，以能够序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>远程对象的接口需要扩展Remote接口，并且当远程方法调用失败后会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPersonInf</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>远程接口实现类</em></strong></p>
<p>可以使用java.rmi.server.RemoteServer和它的子类来实现远程调用功能，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPersonInf</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>生成存根代码</em></strong></p>
<p>存根可以由rmic编译器生成，Java1.5后，支持运行时动态生成存根类</p>
<p><strong><em>注册接口和查找对象</em></strong></p>
<p>创建Server代码，绑定特定的端口并注册远程接口的实现类，远程对象接口也可以通过java.rmi.Naming使用基于URL的方法进行注册。</p>
<p>RMI的URL以<code>rmi:</code>开头，后接服务器与一个可选的端口号，服务器告诉注册表在给定位置将这个名字关联到该对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PersonService personService = <span class="keyword">new</span> PersonServiceImpl();</span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">6600</span>);</span><br><span class="line">            Context namingContext = <span class="keyword">new</span> InitialContext();</span><br><span class="line">            namingContext.rebind(<span class="string">"rmi://127.0.0.1:8800/person-service"</span>, personService);</span><br><span class="line">            System.out.println(<span class="string">"service started"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Client，获取远程接口对应的远程实现类，并通过远程接口操作，以Nmaing.lookup绑定远程对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PersonService personService = (PersonService) Naming.lookup(<span class="string">"rmi://127.0.0.1:8800/person-service"</span>);</span><br><span class="line">            Person person = personService.getPersonInf(<span class="number">5</span>);</span><br><span class="line">            System.out.println(person.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>分布式的垃圾回收器</em></strong></p>
<p>启动服务端，再运行客户端即可以看到远程调用结果，然而如何判断服务器上的引用对象何时被垃圾回收。</p>
<p>RMI创建了一个分布式环境，运行在一个JVM上的进程可以访问运行在不同JVM进程上驻留的对象，即一个服务器上的进程需要知道一个对象在什么时候不会被客户引用，并且可以删除。</p>
<p>使用RMI的JVM中支持两种操作：标记脏数据和清理。</p>
<ul>
<li>当对象仍在使用时，本地JVM会定期向服务器的JVM发送一个标记脏数据的调用。标记脏数据基于服务器给定的时间间隔定期重新发送心跳信息</li>
<li>当客户端没有更多的本地引用远程对象时，会发送一个清理调用给服务器，因此服务器只需要计算客户端发送的清理调用或者说心跳超时，即可删除对象。</li>
</ul>
<h3 id="RMI架构"><a href="#RMI架构" class="headerlink" title="RMI架构"></a>RMI架构</h3><p><img src="assets/1563777082595.png" alt="1563777082595"></p>
<ul>
<li>顶层是存根/骨架层，通过对将要传输的数据编码成流的行驶传递到远程引用层。</li>
<li>远程引用层定义了RMI连接的调用语义并给予实现，RMI在进行远程调用时，用到JRMP协议，这一层提供了专门用于引用远程服务的RemoteRef对象</li>
<li>传输层在JVM间建立基于流的网络连接，并负责设置和管理这些连接。</li>
</ul>
<h3 id="远程方法中的参数与返回值"><a href="#远程方法中的参数与返回值" class="headerlink" title="远程方法中的参数与返回值"></a>远程方法中的参数与返回值</h3><p>对于从一个JVM向另一个JVM传递值，我们将其区分为两种情况，传递远程对象和传递非远程对象。</p>
<ul>
<li>若客户端传递了一个对WareHouse的引用，即通过它可以调用远程的仓库对象的一个存根给另一个对象，即传递远程对象的实例</li>
<li>传递一般的Java对象，即传递非远程对象，即序列化</li>
</ul>
<p><strong><em>传递远程对象</em></strong></p>
<p>当一个对远程对象的引用从一个虚拟机传递到另一个虚拟机时，该远程对象的发送者和接收者都将持有一个对同一个对象的引用，这个引用并非是一个内存位置，而是由网络地址和该远程对象的唯一标识符组成的。</p>
<p><strong><em>动态类加载</em></strong></p>
<p>当服务器返回了一个Product接口的一个实例，客户端编译时需要Product.class的类文件，但是客户端本身是没有其实例Book类，说明客户端需要拥有在运行时加载额外类的能力。</p>
<p>客户端使用了与RMI注册表相同的机制，即类由服务器提供服务，</p>
<h2 id="SOA与微服务"><a href="#SOA与微服务" class="headerlink" title="SOA与微服务"></a>SOA与微服务</h2><p>第三代RPC框架已经超越了RPC本身，主要是面向服务的实现，实现了服务的管理和治理，提供了服务监控的方法等。</p>
<h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><p>面向服务的架构（SOA）是一种软件架构模式，一些应用程序组件通过网络通信协议向其他组件传递服务，这种服务间的通信可以是简单的数据传递，也可以是两个或更多个彼此需要协调的服务间相互连接。</p>
<p>在SOA中根据服务的功能，将服务分为服务消费者和服务生产者两个主要角色。</p>
<p><img src="assets/dubbo-architecture.jpg" alt="dubbo-architucture"></p>
<h3 id="Web-Service和ESB"><a href="#Web-Service和ESB" class="headerlink" title="Web Service和ESB"></a>Web Service和ESB</h3><p>根据场景SOA具体可以分为标准的WebService和企业服务总线ESB</p>
<p>Web Service底层使用HTTP，类似一个远程服务提供者，可以通过SOAP协议或RESTful协议实现。Web Service是一个平台独立、低耦合、自包含的基于可编程的Web应用程序，可使用开放的XML和JSON描述、发布、发现、协调和配置这些应用程序，用于开发分布式的应用程序。</p>
<p>其特点是服务独立，服务间通过SOAP协议调用，服务内容通过WSDL描述，服务注册与发现通过UDDI实现</p>
<p>ESB是集成架构的分割，允许通过公共通信总线进行通信。</p>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务与SOA一脉相承，更侧重与服务间的隔离，让服务做专门的事情，可以敏捷迭代与上线。服务是一种软件架构模式，其中的复杂应用程序由微小而独立的进程组成，使用与语言无关的API通信。</p>
<p><img src="assets/1563778296842.png" alt="1563778296842"></p>
<p><strong><em>微服务与SOA的差异</em></strong></p>
<ul>
<li>微服务中，服务可以独立于其他服务进行操作和部署，更容易经常部署新版本的服务或独立扩展服务。</li>
<li>微服务容错方面表现良好，若在一个微服务机器上存在内存泄漏，则只有该服务器受影响，因为微服务与微服务间是隔离的</li>
<li>SOA服务可能共享数据存储，而微服务中每个服务都具有独立的数据存储</li>
<li>SOA与微服务的主要区别是规模和范围，微服务发展了异步等，但微服务概念是包含在大的SOA体系中。从实现层次角度讲，某个子系统可能是由微服务实现的，多个这样的子系统可能是采用SOA实现的。</li>
</ul>
<h1 id="RPC协议选型"><a href="#RPC协议选型" class="headerlink" title="RPC协议选型"></a>RPC协议选型</h1><p>RPC协议的具体实现方式可以不同，RPC调用的协议选择包含两部分</p>
<ul>
<li>协议栈：广义上协议栈可以分为公有协议和私有协议，例如 HTTP、SMPP、WebService 等都是公有协议；如果是某个公司或者组织内部自定义、自己使用的协议，没有被国际标准化组织接纳和认可的，往往划为私有协议，例如 Thrift 协议。</li>
<li>序列化方式：同一种协议也可以承载多种序列化方式，以 HTTP 协议为例，它可以承载文本类序列化方式，例如：XML、JSON 等，也可以承载二进制序列化方式，例如谷歌的 Protobuf。</li>
</ul>
<p>而不同的协议选择对RPC调用的性能、开发难度和问题定位效率都有影响，因此，选择哪种协议，对RPC框架而言至关重要。由于各个协议都有自己的优缺点，有的看重性能和时延、有的更看重跨语言和可维护性。</p>
<p><strong><em>私有协议流行的原因</em></strong></p>
<p>由某个企业自己制订，协议实现细节不愿公开，只在企业自己生产的设备之间使用的协议。私有协议具有封闭性、垄断性、排他性等特点。如果网上大量存在私有（非标准）协议，现行网络或用户一旦使用了它，后进入的厂家设备就必须跟着使用这种非标准协议，才能够互连互通，否则根本不可能进入现行网络。这样，使用非标准协议的厂家就实现了垄断市场的愿望。</p>
<h2 id="RPC通信方式"><a href="#RPC通信方式" class="headerlink" title="RPC通信方式"></a>RPC通信方式</h2><p>在传统的 Java 应用中，通常使用以下 4 种方式进行跨节点通信。</p>
<p>1．通过 RMI 进行远程服务调用。</p>
<p>2．通过 Java 的 Socket+Java 序列化的方式进行跨节点调用。</p>
<p>3．利用一些开源的 RPC 框架进行远程服务调用，例如 Facebook 的 Thrift，Google 的 gRPC 等。</p>
<p>4．利用标准的公有协议进行跨节点服务调用，例如 HTTP+XML、Restful+JSON 或者 WebService。</p>
<p>跨节点的远程服务调用，除了链路层的物理连接外，还需要对请求和响应消息进行编解码。在请求和应答消息本身以外，也需要携带一些其他控制和管理类指令，例如链路建立的握手请求和响应消息、链路检测的心跳消息等。当这些功能组合到一起之后，就会形成私有协议。</p>
<p>私有协议的优点：灵活性高，可以按照业务的使用场景来设计和优化，在某个公司或者组织内部使用时也可以按需定制和演进，所以大部分 RPC 框架都支持私有二进制协议，例如阿里的 Dubbo、华为的 ServiceComb、Apache 的 Thrift 等。</p>
<h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><p>当进行远程跨进程服务调用时，需要把被传输的数据结构 / 对象序列化为字节数组或者 ByteBuffer。而当远程服务读取到 ByteBuffer 对象或者字节数组时，需要将其反序列化为原始的数据结构/对象。利用序列化框架可以实现上述转换工作。</p>
<p>Java 序列化从JDK 1.1版本就已经提供，它不需要添加额外的类库，只需实现 java.io.Serializable并生成序列ID即可，因此，它从诞生之初就得到了广泛的应用。但是在远程服务调用（RPC）时，很少直接使用Java序列化进行消息的编解码和传输，这又是什么原因呢？下面通过分析 Java 序列化的缺点来找出答案:</p>
<ol>
<li>无法跨语言，是 Java 序列化最致命的问题。对于跨进程的服务调用，服务提供者可能会使用 C++ 或者其他语言开发，当我们需要和异构语言进程交互时，Java 序列化就难以胜任。由于 Java 序列化技术是 Java 语言内部的私有协议，其它语言并不支持，对于用户来说它完全是黑盒。对于 Java 序列化后的字节数组，别的语言无法进行反序列化，这就严重阻碍了它的应用。事实上，目前几乎所有流行的Java RPC通信框架，都没有使用 Java 序列化作为编解码框架，原因就在于它无法跨语言，而这些RPC框架往往需要支持跨语言调用。</li>
<li>相比于业界的一些序列化框架，Java默认的序列化效能较低，主要体现在：序列化之后的字节数组体积较大，性能较低。在同等情况下，编码后的字节数组越大，存储的时候就越占空间，存储的硬件成本就越高，并且在网络传输时更占带宽，导致系统的吞吐量降低。Java 序列化后的码流偏大也一直被业界所诟病，导致它的应用范围受到了很大限制。</li>
</ol>
<p>当前比较流行的序列化方式可以分为两大类:</p>
<ol>
<li>文本类序列化方式：主要包括 JSON 和 XML，它们的优点是：支持跨语言、可读性好、配套的支持工具比较全。缺点就是：序列化之后的码流比较大、冗余内容多，性能相对比较差。</li>
<li>私有的二进制类序列化方式：比较流行的有 Thrift 序列化框架、MessagePack 和谷歌的 Protobuf 框架。它的优点是性能高，缺点就是可读性差，支撑的工具链不健全。</li>
</ol>
<h2 id="协议选型"><a href="#协议选型" class="headerlink" title="协议选型"></a>协议选型</h2><p>尽管公有协议种类繁多，例如之前非常流行的 WebService、WADL 等，但目前来看，如果选择公有协议，HTTP 协议还是首选，具有 Rest 风格的 Restful + JSON 接口是当前最流行的方式。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2019/07/21/系统架构/Dubbo：概述/" rel="next" title="Dubbo：概述">
                <i class="fa fa-chevron-left"></i> Dubbo：概述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2019/07/22/系统架构/Dubbo：源码分析/" rel="prev" title="Dubbo：源码分析">
                Dubbo：源码分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            فهرست مطالب
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            نمای کلی
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">219</span>
          <span class="site-state-item-name">پست ها</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">دسته بندی ها</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">برجسب ها</span>
        
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RPC"><span class="nav-number">1.</span> <span class="nav-text">RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#提出问题"><span class="nav-number">1.1.</span> <span class="nav-text">提出问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.2.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端服务器角色"><span class="nav-number">1.2.1.</span> <span class="nav-text">客户端服务器角色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是RPC服务"><span class="nav-number">1.2.2.</span> <span class="nav-text">什么是RPC服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心技术点"><span class="nav-number">1.2.3.</span> <span class="nav-text">核心技术点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC协议实现"><span class="nav-number">1.2.4.</span> <span class="nav-text">RPC协议实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RPC服务的原理"><span class="nav-number">2.</span> <span class="nav-text">RPC服务的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#本地调用过程"><span class="nav-number">2.1.</span> <span class="nav-text">本地调用过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC调用过程"><span class="nav-number">2.2.</span> <span class="nav-text">RPC调用过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RPC实现"><span class="nav-number">3.</span> <span class="nav-text">RPC实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-RMI"><span class="nav-number">3.1.</span> <span class="nav-text">Java RMI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#存根与参数编码"><span class="nav-number">3.1.1.</span> <span class="nav-text">存根与参数编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">3.1.2.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RMI架构"><span class="nav-number">3.1.3.</span> <span class="nav-text">RMI架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程方法中的参数与返回值"><span class="nav-number">3.1.4.</span> <span class="nav-text">远程方法中的参数与返回值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SOA与微服务"><span class="nav-number">3.2.</span> <span class="nav-text">SOA与微服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SOA"><span class="nav-number">3.2.1.</span> <span class="nav-text">SOA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-Service和ESB"><span class="nav-number">3.2.2.</span> <span class="nav-text">Web Service和ESB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#微服务"><span class="nav-number">3.2.3.</span> <span class="nav-text">微服务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RPC协议选型"><span class="nav-number">4.</span> <span class="nav-text">RPC协议选型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC通信方式"><span class="nav-number">4.1.</span> <span class="nav-text">RPC通信方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列化方式"><span class="nav-number">4.2.</span> <span class="nav-text">序列化方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协议选型"><span class="nav-number">4.3.</span> <span class="nav-text">协议选型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
</div>
  <div class="powered-by">قدرت گرفته از <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">پوسته – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  











  
  <script>
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log(`Failed to save Visitor num, with error message: ${responseJSON.error}`);
              })
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! More info at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log(`LeanCloud Counter Error: ${responseJSON.code} ${responseJSON.error}`);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
                'X-LC-Key': 'uTVcNIWdMCGpicrhTKygpKXi',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
            const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
            if (localhost.test(document.URL)) return;
            addCount(Counter);
          
        });
    });
  </script>












  
<link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">
<script src="/lib/algolia-instant-search/instantsearch.min.js"></script>


<script src="/js/algolia-search.js?v=7.2.0"></script>














    
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
    appKey: 'uTVcNIWdMCGpicrhTKygpKXi',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn'
  });
</script>


</body>
</html>
