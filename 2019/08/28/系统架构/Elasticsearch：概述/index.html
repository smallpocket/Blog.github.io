<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    search: {
      root: '/',
      path: 'search.xml'
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="Elasticsearch应用适用性 不适合用在那些数据价值不高、对写入性能有要求、数据量大而成本受限的场景中。  缺陷 字段类型无法修改。在需要添加新数据与新字段的时候，如果elasticSearch进行搜索是可能需要重新修改格式。之前的数据需要重新同步，对数据的管理有很多困难。一旦数据格式出现改变，会变得非常麻烦。 ES在数据结构灵活度上高于MySQL但远不如MongoDB。   写入性能较低">
<meta name="keywords" content="Elasticsearch">
<meta property="og:type" content="article">
<meta property="og:title" content="Elasticsearch：概述">
<meta property="og:url" content="http://yoursite.com/2019/08/28/系统架构/Elasticsearch：概述/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Elasticsearch应用适用性 不适合用在那些数据价值不高、对写入性能有要求、数据量大而成本受限的场景中。  缺陷 字段类型无法修改。在需要添加新数据与新字段的时候，如果elasticSearch进行搜索是可能需要重新修改格式。之前的数据需要重新同步，对数据的管理有很多困难。一旦数据格式出现改变，会变得非常麻烦。 ES在数据结构灵活度上高于MySQL但远不如MongoDB。   写入性能较低">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/assets/1567147497368.png">
<meta property="og:image" content="http://yoursite.com/assets/1567147531015.png">
<meta property="og:image" content="http://yoursite.com/assets/1567564294197.png">
<meta property="og:image" content="http://yoursite.com/assets/1567566224758.png">
<meta property="og:image" content="http://yoursite.com/assets/1567067619776.png">
<meta property="og:image" content="http://yoursite.com/assets/1567067688072.png">
<meta property="og:image" content="http://yoursite.com/assets/1567604324720.png">
<meta property="og:image" content="http://yoursite.com/assets/1567669526235.png">
<meta property="og:image" content="http://yoursite.com/assets/1567606295972.png">
<meta property="og:image" content="http://yoursite.com/assets/1567607118204.png">
<meta property="og:image" content="http://yoursite.com/assets/1567676617810.png">
<meta property="og:updated_time" content="2019-09-09T08:35:27.517Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Elasticsearch：概述">
<meta name="twitter:description" content="Elasticsearch应用适用性 不适合用在那些数据价值不高、对写入性能有要求、数据量大而成本受限的场景中。  缺陷 字段类型无法修改。在需要添加新数据与新字段的时候，如果elasticSearch进行搜索是可能需要重新修改格式。之前的数据需要重新同步，对数据的管理有很多困难。一旦数据格式出现改变，会变得非常麻烦。 ES在数据结构灵活度上高于MySQL但远不如MongoDB。   写入性能较低">
<meta name="twitter:image" content="http://yoursite.com/assets/1567147497368.png">
  <link rel="canonical" href="http://yoursite.com/2019/08/28/系统架构/Elasticsearch：概述/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Elasticsearch：概述 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-top">
      
    

    <a href="/top/" rel="section"><i class="menu-item-icon fa fa-fw fa-signal"></i> <br>阅读排行</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>

</div>
    </header>

    

  <a href="https://github.com/smallpocket" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/系统架构/Elasticsearch：概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">Elasticsearch：概述

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-28 23:51:35" itemprop="dateCreated datePublished" datetime="2019-08-28T23:51:35+08:00">2019-08-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-09 16:35:27" itemprop="dateModified" datetime="2019-09-09T16:35:27+08:00">2019-09-09</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">18k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">33 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>不适合用在那些数据价值不高、对写入性能有要求、数据量大而成本受限的场景中。</li>
</ul>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul>
<li>字段类型无法修改。在需要添加新数据与新字段的时候，如果elasticSearch进行搜索是可能需要重新修改格式。之前的数据需要重新同步，对数据的管理有很多困难。一旦数据格式出现改变，会变得非常麻烦。<ul>
<li>ES在数据结构灵活度上高于MySQL但远不如MongoDB。</li>
</ul>
</li>
<li>写入性能较低。<ul>
<li>自动建立索引使得ES的写入性能也收到了影响，要明显低于MongoDB。</li>
</ul>
</li>
<li>高硬件资源消耗。大数据量下64G内存+SSD基本是标配。<ul>
<li>对于同样的数据ES占用的存储空间也要明显大于MongoDB（建那么多索引能不占空间吗？）。</li>
</ul>
</li>
</ul>
<h1 id="DOC"><a href="#DOC" class="headerlink" title="DOC"></a>DOC</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><h3 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h3><p>应用中的对象很少只是简单的键值列表，例如MySQL数据库那样，更多的时候它拥有复杂的数据结构，例如包含日期、地理位置、另一个对象或数组。</p>
<p>而数据库是行列组成的表格，如果要将一个对象存储到MySQL当中，则就像是将一个丰富、信息表现力强的对象拆散了放入一个非常大的表格中。你不得不拆散对象以适应表模式(一列对应一个字段)，然后在查询时再进行重建。</p>
<p>Elasticsearch是面向文档的，意味着它可以存储整个对象或文档，然而它不仅仅时存储，还会索引每个文档的内容使之可以被搜索。再Elasticsearch中，你可以对文档(并非表结构)进行索引、搜索、排序、过滤。这种理解数据的方式与MySQL完全不同，也是Elasticsearch能够进行复杂的全文搜索的原因之一。</p>
<p><strong>Elasticsearch使用JSON作为文档序列化格式。</strong></p>
<p>程序中大多的实体或对象能够被序列化为包含键值对的JSON对象。通常我们可以认为对象与文档时等价相通的。</p>
<ul>
<li>对象时应该JSON结构体，类似于HashMap等，内部还可能包含其他对象。</li>
<li>文档在Elasticsearch当中特指最顶层结构或者跟对象序列化成的JSON数据，以唯一ID标识并存储在ES中。</li>
</ul>
<h3 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h3><p>文档不仅仅只有数据，还包含了元数据–关于文档的信息，其中三个必须的元数据节点时：</p>
<ul>
<li><code>_index</code>：文档存储的地方：<ul>
<li>在ES当中index类似于数据库，是存储和索引关联数据的地方。</li>
<li>实际上数据被存储和索引在<strong>分片</strong>中，索引只是一个把一个或多个分片分组在一起的逻辑空间。</li>
</ul>
</li>
<li><code>_type</code>：文档代表的对象的类：<ul>
<li>应用中，使用对象表示一些事物，每个对象都属于一个类，类定义了属性或与对象关联的数据。在关联数据库中，相同类的对象被存在一个表中。</li>
<li>ES当中，使用相同<code>type</code>的文档表示相同的事物，因为它们的数据结构也是相同的。每个<code>type</code>都有自己的mapping或结构定义，类型的mapping会告诉ES不同的文档如何被索引。</li>
</ul>
</li>
<li><code>_id</code>：文档的唯一标识：<ul>
<li>与index和type组合时，就可以唯一标识一个文档。</li>
</ul>
</li>
</ul>
<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>在Elasticsearch中，文档归属于一种类型(type)，而这些类型存在于索引(index)中，我们可以画一些简单的对比图来类比传统关系型数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Relational	DB	-&gt;	Databases	-&gt;	Tables	-&gt;	Rows	-&gt;	Columns </span><br><span class="line">Elasticsearch	-&gt;	Indices		-&gt;	Types	-&gt;	Documents	-&gt;	Fields</span><br></pre></td></tr></table></figure>

<p>Elasticsearch集群可以包含多个索引(indices)（数据库），每一个索引可以包含多个类型 (types)（表），每一个类型包含多个文档(documents)（行），然后每个文档包含多个字段 (Fields)（列）。</p>
<p>在Elasticsearch中<strong>索引具有不同的涵义</strong>：</p>
<ul>
<li>索引(名词)：一个索引就像时传统关系数据库中的数据库，它时相关文档存储的地方</li>
<li>索引(动词)：索引一个文档，表示把一个文档存储到索引(名词n)中。以便它可以被检索或者查询，很像SQL的<code>insert</code>，但差别是如果文档已经存在，新的文档将覆盖旧的文档</li>
<li>倒排索引：传统数据库为特定列增加一个索引，例如B-Tree索引来加速检索。而Elasticsearch和Lucene使用倒排索引的数据结构达到目的。</li>
</ul>
<p>默认情况下，文档中的所有字段都会被索引(拥有一个倒排索引)，只有这样他们才是可被搜索的。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>索引index实际上是一个用来指向一个或多个shard的逻辑命名空间。</p>
<p>一个shard是一个最小级别工作单元，它只是保存了索引中所有数据的一部分。</p>
<h3 id="索引设置"><a href="#索引设置" class="headerlink" title="索引设置"></a>索引设置</h3><ul>
<li>number_of_shards。定义一个索引的主分片个数，默认值是<code>5</code>。这个配置在索引创建后不能修改。</li>
<li>number_of_replicas。每个主分片的复制分片个数，默认是<code>1</code>。这个配置可以随时在活跃的索引上修改。</li>
<li>analysis。配置已经存在的分析器或创建自定义分析器来定制化你的索引。</li>
</ul>
<h3 id="type和mapping"><a href="#type和mapping" class="headerlink" title="type和mapping"></a>type和mapping</h3><p>类型在Elasticsearch中表示一组相似的文档。类型由一个名称（比如user或blogpost）和一个类似数据库表结构的映射组成，描述了文档中可能包含的每个字段的属性，数据类型（比如string，integer或date），和是否这些字段需要被Lucene索引或储存。</p>
<p><strong><em>Lucene如何处理文档</em></strong></p>
<p>Lucene中，一个文档由一组简单的键值对组成，一个字段至少需要有一个值，但是任何字段都可以有多个值。类似的，一个单独的字符串可能在分析过程中被转换为多个值。</p>
<p>Lucene不关心这些值是字符串、数字或日期，所有的值都被当成不透明字节。当我们在Lucene中索引一个文档时，每个字段的值都被加到相关字段的倒排索引中。</p>
<p><strong><em>类型是如何实现的</em></strong></p>
<p>每个类型有各自的Mapping和文档，保存在index当中。</p>
<p>Lucene没有文档类型的概念，每个文档的类型名被储存在一个叫_type的元数据字段上。当我们搜索一种特殊类型的文档时，Elasticsearch简单的通过_type字段来过滤出这些文档。</p>
<p>Lucene同样没有映射的概念。映射是Elasticsearch将复杂JSON文档映射成Lucene需要的扁平化数据的方式。</p>
<ul>
<li>即当一个字段声明为了string，则加入索引前数据会被analyzer进行分析。</li>
</ul>
<h3 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h3><p>映射的最高层即根对象，其可能包含：</p>
<ul>
<li>一个properties节点。列出文档可能包含的每个字段的映射。</li>
<li>多个元数据字段。每一个都以下划线开头，例如_type等。</li>
<li>设置项。如analyzer等。</li>
<li>其他设置，可以同时应用在根对象和其他object类型的字段上，例如enabled，dynamic和include_in_all。</li>
</ul>
<h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p><strong><em>_source</em></strong></p>
<p>ES用JSON字符串表示文档主题保存在_source字段中，_source字段在写入磁盘前会被压缩。</p>
<p>这几乎始终是需要的功能，因为：</p>
<ul>
<li>搜索结果中能够得到完整的文档，不需要额外去别的数据源查找文档。</li>
<li>如果缺失_source，则部分更新请求不起作用。</li>
<li>当你的映射有变化，而且你需要重新索引数据时，你可以直接在Elasticsearch中操作而不需要重新从别的数据源中取回数据。</li>
<li>你可以从_source中通过get或search请求取回部分字段，而不是整个文档。</li>
<li>样更容易排查错误，因为你可以准确的看到每个文档中包含的内容，而不是只能从一堆ID中猜测他们的内容。</li>
</ul>
<p><strong><em>_all</em></strong></p>
<p><strong><em>_id</em></strong></p>
<p>文档的唯一标识由四个元数据字段组成：</p>
<ul>
<li>_id。文档的字符串ID。</li>
<li>_type。文档的类型名。</li>
<li>_index。文档所在的索引。</li>
<li>_uid。_type与_id连接成的type#id。</li>
</ul>
<h3 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h3><p>当Elasticsearch处理一个位置的字段时，它通过【动态映射】来确定字段的数据类型且自动将该字段加到类型映射中。</p>
<p>有时这是理想的行为，有时却不是。或许你不知道今后会有哪些字段加到文档中，但是你希望它们能自动被索引。或许你仅仅想忽略它们。特别是当你使用Elasticsearch作为主数据源时，你希望未知字段能抛出一个异常来警示你。</p>
<p>通过dynamic可以控制这些行为，它接受下面几个选项：</p>
<ul>
<li>true。自动添加字段(默认)。</li>
<li>false。忽略字段。</li>
<li>strict。遇到未知字段抛出异常。</li>
</ul>
<h3 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h3><p>虽然你可以给索引添加新的类型，或给类型添加新的字段，但是你不能添加新的分析器或修改已有字段。否则已被索引的数据会变得不正确而你的搜索也不会正常工作。</p>
<p>修改在已存在的数据最简单的方法是重新索引：创建一个新配置好的索引，然后将所有的文档从旧的索引复制到新的上。</p>
<h2 id="数据的基本操作"><a href="#数据的基本操作" class="headerlink" title="数据的基本操作"></a>数据的基本操作</h2><h3 id="Search-响应"><a href="#Search-响应" class="headerlink" title="Search 响应"></a>Search 响应</h3><ul>
<li>hits。表示匹配到的文档总数。<ul>
<li>_score。相关性得分。</li>
</ul>
</li>
<li>took。搜索花费的毫秒数。</li>
<li>shards。参与查询的分片数有多少成功与失败。<ul>
<li>分片可能失败，如果一些故障导致主分片与复制分片都故障，那么这个分片的数据无法响应搜索请求。</li>
<li>此时仍然会返回剩余分片的结果。</li>
</ul>
</li>
<li>timeout。查询超时与否。<ul>
<li>不会停止执行查询，它仅仅告诉你目前顺利返回结果的节点然后关闭连接。在后台，其他分片可能依旧执行查询，尽管结果已经被发送。</li>
<li>使用超时是因为对于你的业务需求来说非常重要，而不是因为你想中断执行长时间运行的查询。</li>
</ul>
</li>
</ul>
<h3 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h3><h3 id="BULK"><a href="#BULK" class="headerlink" title="BULK"></a>BULK</h3><h3 id="读写文档的并发操作"><a href="#读写文档的并发操作" class="headerlink" title="读写文档的并发操作"></a>读写文档的并发操作</h3><h2 id="Search-API"><a href="#Search-API" class="headerlink" title="Search API"></a>Search API</h2><h2 id="结构化查询"><a href="#结构化查询" class="headerlink" title="结构化查询"></a>结构化查询</h2><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><h2 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h2><h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><h2 id="地理信息查询"><a href="#地理信息查询" class="headerlink" title="地理信息查询"></a>地理信息查询</h2><h2 id="控制相关度"><a href="#控制相关度" class="headerlink" title="控制相关度"></a>控制相关度</h2><h1 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h1><p>mapping机制用于进行字段类型确认，将每个字段匹配为一种确定的数据类型(String、number、boolean、date等)。</p>
<p>ES的Mapping也称为模式定义，即对数据建模。</p>
<h2 id="Mapping-1"><a href="#Mapping-1" class="headerlink" title="Mapping"></a>Mapping</h2><h3 id="数据类型差异"><a href="#数据类型差异" class="headerlink" title="数据类型差异"></a>数据类型差异</h3><p>当在索引中处理数据时，会有一些东西似乎被破坏了。</p>
<p>假设索引中存在12个tweets，只有应该包含日期2014-09-15，进行查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /search?q=2014 //12个结果</span><br><span class="line">GET /search?q=2014-09-15 //12个结果</span><br><span class="line">GET /search?q=date:2014-09-15 //1个结果</span><br><span class="line">GET /search?q=date:2014 //0个结果</span><br></pre></td></tr></table></figure>

<p>当进行全日期的查询时，得到12个tweets，而针对date字段进行年度查询却什么都不返回。即我们针对_all字段进行查询可全部返回，但是针对date字段却不能返回。</p>
<p>这是因为数据在_all字段的索引方式与在date字段的索引方式不同而导致。</p>
<h3 id="数据类型与字段信息"><a href="#数据类型与字段信息" class="headerlink" title="数据类型与字段信息"></a>数据类型与字段信息</h3><p>为了将日期字段处理成日期，将数字字段处理为数字等，ES需要找到每个字段都包含了什么类型，这些类型和字段的信息<strong>存储在mapping</strong>中。</p>
<p>索引中每个文档都有一个类型(type)。每个类型拥有自己的映射(mapping)或者模式定义(schema definition)。一个映射定义了字段类型，每个字段的数据类型，以及字段被Elasticsearch处理的方式。映射还用于设置关联到类型上的元数据。</p>
<p>支持的<strong>简单字段类型</strong>：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>表示的数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>string</td>
</tr>
<tr>
<td>Whole number</td>
<td>byte、short、integer、long</td>
</tr>
<tr>
<td>Floating point</td>
<td>float、double</td>
</tr>
<tr>
<td>Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>Date</td>
<td>date</td>
</tr>
</tbody></table>
<p>当你索引一个包含新字段的文档，即一个之前没有的字段，ES将使用动态映射猜测字段类型，其来自于JSON基本数据类型：</p>
<table>
<thead>
<tr>
<th>JSON type</th>
<th>Field type</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>Whole number:123</td>
<td>long</td>
</tr>
<tr>
<td>Floating point:1123.4</td>
<td>double</td>
</tr>
<tr>
<td>String,valid date:”2014-12-15”</td>
<td>date</td>
</tr>
<tr>
<td>String:”FOO”</td>
<td>string</td>
</tr>
</tbody></table>
<h3 id="自定义字段映射"><a href="#自定义字段映射" class="headerlink" title="自定义字段映射"></a>自定义字段映射</h3><p>某些时候需要自定义一些特殊类型，尤其是字符串字段类型，自定义类型可以帮助：</p>
<ul>
<li>区分全文字符串字段和准确字符串字段，即分词与不分词。</li>
<li>使用特定语言的分析器。</li>
<li>优化部分匹配字段。</li>
<li>指定自定义日期格式。</li>
<li>等。</li>
</ul>
<p>对于mapping而言最重要的字段参数是type。</p>
<p>对于string字段，最重要的映射参数是index和analyer。</p>
<ul>
<li>index，控制字符串以何种方式被索引：<ul>
<li>analyzed，默认值。首先分析这个字符串，然后索引，即进行全文形式的索引。</li>
<li>not_analyzed。索引这个字段，使其可以被搜索，但是索引内容与指定值一样，不分析此字段。</li>
<li>no。不索引这个字段。</li>
</ul>
</li>
<li>analyzer，只当哪一种分析器将在搜索和索引时使用。<ul>
<li>standard，默认值。</li>
<li>whitespace等。</li>
</ul>
</li>
</ul>
<h3 id="更新mapping"><a href="#更新mapping" class="headerlink" title="更新mapping"></a>更新mapping</h3><p>可以在第一次创建索引的时候指定映射的类型。此外，你也可以晚些时候为新类型添加映射（或者为已有的类型更新映射）。</p>
<p>可以向已有映射中增加字段，但你不能修改它。如果一个字段在映射中已经存在，这可能意味着那个字段的数据已经被索引。如果你改变了字段映射，那已经被索引的数据将错误并且不能被正确的搜索到。</p>
<h3 id="复合核心字段类型"><a href="#复合核心字段类型" class="headerlink" title="复合核心字段类型"></a>复合核心字段类型</h3><p>JSON还有null值，数组和对象，所有这些Elasticsearch都支持：</p>
<p><strong><em>多值字段</em></strong></p>
<p>若想让tag字段包含多个值，我们可以索引一个标签数组来代替单一字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;tag&quot;: [&quot;search&quot;, &quot;nosql&quot;]&#125;</span><br></pre></td></tr></table></figure>

<p>对于数组不需要特殊的映射，任何一个字段可以包含0-N个值，同样对于全文字段将被分析并产生多个词。</p>
<p>即数组中的所有值必须为同一类型，若使用字段索引一个数组，ES将使用第一个值的类型来确定这个新字段的类型。</p>
<p>数组是<strong>作为多值字段</strong>被索引的，它们没有顺序。在搜索阶段你<strong>不能指定“第一个值”或者“最后一个值”</strong>。倒不如把数组当作一个值集合(bag of values)</p>
<p><strong><em>空字段</em></strong></p>
<p>数组可以为空，即等价为0个值，而Lucene无法存储null，因此这个字段被认为是空字段而不被索引。</p>
<p><strong><em>多层对象</em></strong></p>
<p>即JSON object，即hashmap。内部对象经常用于在另一个对中嵌入一个实体或对象。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>:&#123;</span><br><span class="line">        <span class="attr">"name"</span>:&#123;</span><br><span class="line">            <span class="attr">"full"</span>: <span class="string">"Jo sh"</span>,</span><br><span class="line">            <span class="attr">"first"</span>: <span class="string">"jo"</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>内部对象的映射</em></strong></p>
<p>ES会动态检测新对象的字段，并映射它们为object类型，将每个字段加到properties字段下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">        "propertiex"：&#123;</span><br><span class="line">        	"name":&#123;</span><br><span class="line">        		"type": "object",</span><br><span class="line">        		"properties":&#123;</span><br><span class="line">            	"full": &#123;"type": "string"&#125;,</span><br><span class="line">            	"first": &#123;"type": "string"&#125;</span><br><span class="line">    			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>内部对象是怎样被索引的</em></strong></p>
<p>Lucene并不会去了解内部对象，一个Lucene文件包含一个键-值对应的扁平表单，因此ES为了有效索引内部对象，则转换了文件的格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user.name.full"</span>:[jo,sh],</span><br><span class="line">    <span class="attr">"user.name.first"</span>:[jo]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>对象-数组</em></strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"followers"</span>:[</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="attr">"age"</span>: <span class="number">35</span>,	</span><br><span class="line">			<span class="attr">"name"</span>:	<span class="string">"Mary	White"</span></span><br><span class="line">		&#125;,								</span><br><span class="line">    	&#123;	</span><br><span class="line">        	<span class="attr">"age"</span>:	<span class="number">26</span>,	</span><br><span class="line">        	<span class="attr">"name"</span>:	<span class="string">"Alex	Jones"</span></span><br><span class="line">    	&#125;,								</span><br><span class="line">    	&#123;	</span><br><span class="line">        	<span class="attr">"age"</span>:	<span class="number">19</span>,	</span><br><span class="line">        	<span class="attr">"name"</span>:	<span class="string">"Lisa	Smith"</span></span><br><span class="line">    	&#125;				</span><br><span class="line">	] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则此时由于文件被扁平化，值之间的关联被消除了。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;				</span><br><span class="line">	<span class="attr">"followers.age"</span>: [<span class="number">19</span>,	<span class="number">26</span>,	<span class="number">35</span>],				</span><br><span class="line">	<span class="attr">"followers.name"</span>: [alex,jones,lisa,smith,mary,white] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时需要使用<strong>嵌套对象</strong>。</p>
<h2 id="对数据建模"><a href="#对数据建模" class="headerlink" title="对数据建模"></a>对数据建模</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /search?q=<span class="number">2014</span> <span class="comment">//12个结果  使用_all，索引类型是string</span></span><br></pre></td></tr></table></figure>

<p>ES将对字段类型进行猜测，动态生成了字段和类型的映射关系。_all字段是默认字段，其类型为string。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /search?q=date:<span class="number">2014</span>-<span class="number">09</span>-<span class="number">15</span> <span class="comment">//1个结果 索引类型为date，</span></span><br></pre></td></tr></table></figure>

<ul>
<li>因此string与date字段的索引方式是不同的。在ES当中每一种核心数据类型是以不同的方式进行索引的。</li>
<li>最大的差别在于确切值与全文文本间的区别对待。是区分<strong>搜索引擎与数据库的根本差异</strong>。</li>
</ul>
<h3 id="确切值与全文文本"><a href="#确切值与全文文本" class="headerlink" title="确切值与全文文本"></a>确切值与全文文本</h3><p>ES的数据类型分为确切值与全文文本。</p>
<ul>
<li>确切值是确定的，例如Date与Id等。即“FOO”与“Foo”就不同。</li>
<li>全文文本，是文本化的数据，是一种非结构化数据。<ul>
<li>对于全文文本的查询，我们会询问这篇文章与查询的匹配度如何，即对于查询条件，文档的相关性有多高。</li>
<li>即想查询在全文中包含文本的部分。以及针对UK将返回United Kingdom，针对jump能够匹配jumps等。</li>
</ul>
</li>
<li>针对全文查询，ES首先对文本Analyzes，然后使用结果建立一个倒排索引。</li>
</ul>
<h3 id="对索引建模"><a href="#对索引建模" class="headerlink" title="对索引建模"></a>对索引建模</h3><h3 id="对文档建模"><a href="#对文档建模" class="headerlink" title="对文档建模"></a>对文档建模</h3><h3 id="Mapping-amp-Setting"><a href="#Mapping-amp-Setting" class="headerlink" title="Mapping &amp; Setting"></a>Mapping &amp; Setting</h3><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>ES使用倒排索引结构做快速的全文搜索，倒排索引由在文档中出行的唯一的单词列表以及对于每个单词在文档中的位置组成。</p>
<p>为了建立倒排索引，我们首先切分每个文档的content字段为单独的单词，我们将它们叫做<strong>词(terms)或表征(tokens)</strong>。</p>
<p>假设存在两个文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the lazy dog</span><br><span class="line">Quick brown foxes leap over lazy dos in summer</span><br></pre></td></tr></table></figure>

<p>将所有的唯一词放入列表并排序。</p>
<p><img src="/assets/1567147497368.png" alt="1567147497368"></p>
<p>当搜索<code>quick brown</code>，则只需要找到每个词在哪个文档出现即可：</p>
<p><img src="/assets/1567147531015.png" alt="1567147531015"></p>
<p>此时加入相似度算法，则可以所Doc1具有更高的匹配度。</p>
<h2 id="修复数据"><a href="#修复数据" class="headerlink" title="修复数据"></a>修复数据</h2><h2 id="文本Analysis"><a href="#文本Analysis" class="headerlink" title="文本Analysis"></a>文本Analysis</h2><p>Analysis用于进行全文文本的分词，以建立供搜索用的反向索引。</p>
<p>由于你只可以找到确实存在于索引中的词，因此索引文本和查询字符串都要标准化成相同的形式。</p>
<p>标准化和标记化的过程叫做分词Analysis。分析的过程：</p>
<ul>
<li>首先标记化一个文本块为适用于倒排索引单独的词。</li>
<li>标准化这些词为标准形式，提高可搜索性。</li>
</ul>
<p>这个工作是分析器(analyzer)完成的。一个分析器(analyzer)只是一个包装用于将三个功能放到一个包里。</p>
<h2 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h2><h1 id="Search运行机制"><a href="#Search运行机制" class="headerlink" title="Search运行机制"></a>Search运行机制</h1><p>对于ES，你可以根据ID进行检索，但是其真正的强大在于可以从混乱的数据中找出有意义的信息。</p>
<p>ES不仅会存储文档，也会索引(indexes)文档内容以使得它可以被搜索。每个文档里的字段都会被索引并被查询。在简单查询时，ES可以使用索引的索引。</p>
<p>搜索可以：</p>
<ul>
<li>类似于age这样的字段上使用结构化查询，join_date这样的字段上进行排序，与SQL的结构化查询一样。</li>
<li>全文检索，使用所有字段来匹配关键字，然后按照关联性排序返回结果。</li>
</ul>
<p>在ES当中：</p>
<ul>
<li>Mapping。数据在每个字段中的解释说明。</li>
<li>Analysis。全文是如何处理的可被搜索的。</li>
<li>Query DSL。ES使用的灵活的、强大的查询语言。</li>
</ul>
<h2 id="分布式搜索方式"><a href="#分布式搜索方式" class="headerlink" title="分布式搜索方式"></a>分布式搜索方式</h2><p>搜索是如何在分布式环境中执行的。</p>
<p>一个CRUD操作只处理一个单独的文档。文档的唯一性由_index，_type和routing-value（通常默认是该文档的_id）的组合来确定。这意味着我们可以准确知道集群中的哪个分片持有这个文档。</p>
<p>由于不知道哪个文档会匹配查询（文档可能存放在集群中的任意分片上），所以搜索需要一个更复杂的模型。一个搜索不得不通过查询每一个我们感兴趣的索引的分片副本，来看是否含有任何匹配的文档。</p>
<p>但是，找到所有匹配的文档只完成了这件事的一半。在搜索（search）API返回一页结果前，来自多个分片的结果必须被组合放到一个有序列表中。因此，搜索的执行过程分两个阶段：</p>
<ul>
<li>查询。</li>
<li>然后取回（query then fetch）。</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><img src="/assets/1567564294197.png" alt="1567564294197"></p>
<ul>
<li>客户端发送应该search到Node3。<ul>
<li>Node3首先接受到请求，成为协调节点。即向所有相关的分片广播搜索请求并且把它们的响应整合成一个全局的有序结果集，将结果集返回给客户端。<ul>
<li>搜索请求可以被每个分片的原本或任意副本处理，因此当更多的副本时可以提高搜索吞吐量，对于后续请求，协调节点会轮询所有的分片副本以分摊负载。</li>
</ul>
</li>
<li>Node3创建了应该长度为from+size的空优先级队列。</li>
</ul>
</li>
<li>Node3转发这个搜索请求到索引中每个分片的原本或副本。<ul>
<li>每个分片在本地执行这个查询并且将结果存到一个大小为from+size的有序本地优先队列中。</li>
</ul>
</li>
<li>每个分片分会Doc的<strong>ID</strong>和它优先队列中所有Doc的<strong>排序值</strong>给协调节点Node3。<ul>
<li>Node3将这些值合并到自己的优先队列中产生全局排序结果。</li>
<li>类似于归并。</li>
</ul>
</li>
</ul>
<h3 id="取回"><a href="#取回" class="headerlink" title="取回"></a>取回</h3><p>查询阶段辨别出那些满足搜索请求的Doc，但我们仍然要取回那些Doc本身，即取回阶段。</p>
<p><img src="/assets/1567566224758.png" alt="1567566224758"></p>
<ul>
<li>协调节点辨别出哪个Doc需要取回，并向相关分片发出Get请求。<ul>
<li>协调节点为每个持有Doc的分片简历多点Get然后发送请求到处理查询阶段的分页副本。</li>
</ul>
</li>
<li>每个分片加载Doc并且根据需要丰富它们，然后将Doc返回协调节点。<ul>
<li>加载Doc主体_source，如果需要，还会根据元数据丰富结果和高亮搜索片断。</li>
</ul>
</li>
<li>一旦所有的Doc被取回，则将结果返回给客户端。</li>
</ul>
<h3 id="深分页"><a href="#深分页" class="headerlink" title="深分页"></a>深分页</h3><p>查询然后取回过程虽然支持通过使用from和size参数进行分页，但是它使得所有的分片都要保留一个优先队列，如果是很大的size，或足够大的from，则排序将非常繁重，占用很高的性能。</p>
<p>如果你确实需要从集群里获取大量documents，你可以通过设置搜索类型scan禁用排序，来高效地做这件事。</p>
<h2 id="搜索选项"><a href="#搜索选项" class="headerlink" title="搜索选项"></a>搜索选项</h2><p>一些Query String可选参数能够影响搜索过程。</p>
<h3 id="preference"><a href="#preference" class="headerlink" title="preference"></a>preference</h3><p>preference参数允许你控制使用哪个分片或哪个节点来处理搜索请求。</p>
<p>使用随机字符串可以避免<strong>结果震荡问题</strong>。</p>
<ul>
<li>当你按照timestamp字段进行结果排序，并且两个Doc有相应的timestamp，由于搜索请求是在所有有效的分片副本间轮询的，这两个Doc可能在原始分片中是一种顺序，在副本分片中是另一种顺序。</li>
<li>因此用户每次刷新页面，第一次Doc1，Doc2，第二次Doc2，Doc1。<ul>
<li>可以使用用户的SessionID设置preference参数。</li>
</ul>
</li>
</ul>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>通常，协调节点会等待接收所有分片的回答。如果有一个节点遇到问题，它会拖慢整个搜索请求。</p>
<p>timeout告诉协调节点最多等待多久，就可以放弃等待而将已有结果返回。返回部分结果总比什么都没有好。</p>
<p>_shards参数将指出搜索是否超时，所有分片是否成功答复。</p>
<h3 id="routing"><a href="#routing" class="headerlink" title="routing"></a>routing</h3><p>反映路由选择。</p>
<p>可以在建立索引时提供一个自定义的routing参数来保证所有相关的document（如属于单个用户的document）被存放在一个单独的分片中。在搜索时，你可以指定一个或多个routing值来限制只搜索那些分片而不是搜索index里的全部分片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /search?routing=user_1</span><br></pre></td></tr></table></figure>

<p>在设计非常大的搜索系统时非常有效。</p>
<h3 id="search-type"><a href="#search-type" class="headerlink" title="search_type"></a>search_type</h3><p>可以指定搜索类型，虽然query_then_fetch是默认的搜索类型。</p>
<ul>
<li>count。只有query阶段，没有取回阶段。</li>
<li>query_and_fetch。将查询与取回合并为一个步骤，是一个内部优化选项。</li>
<li>dfs_query_then_fetch和dfs_query_and_fetch。dfs是一个预查询阶段，会从全部相关的分片里取回项目频数来计算全局的项目频数。</li>
<li>scan。与scroll滚屏一起使用，可以高效地取回巨大数量的结果，它通过禁用排序来实现的。</li>
</ul>
<h2 id="扫描与滚屏"><a href="#扫描与滚屏" class="headerlink" title="扫描与滚屏"></a>扫描与滚屏</h2><p>可以高效地取回巨大数量的结果，它通过禁用排序来实现的，不需要付出深分页的代价。</p>
<h3 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h3><p>一个滚屏搜索允许我们做一个初始阶段搜索并且持续批量从Elasticsearch里拉取结果直到没有结果剩下。这有点像传统数据库里的cursors（游标）。</p>
<p>滚屏搜索会及时制作快照。这个快照不会包含任何在初始阶段搜索请求后对index做的修改。它通过将旧的数据文件保存在手边，所以可以保护index的样子看起来像搜索开始时的样子。</p>
<h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h3><p>禁用排序，并传递一个scroll告诉ES应该scroll多久。</p>
<h1 id="分布式特性"><a href="#分布式特性" class="headerlink" title="分布式特性"></a>分布式特性</h1><h2 id="集群和节点"><a href="#集群和节点" class="headerlink" title="集群和节点"></a>集群和节点</h2><p>节点node是一个运行着地Elasticsearch实例，集群cluster是一组具有相同<code>cluster.name</code>的节点集合，他们协同工作，共享数据并提供故障转移和扩展功能。</p>
<p>修改<code>cluster.name</code>可以通过修改<code>config/</code>目录下的<code>elasticsearch.yml</code>文件，然后重启Elasticsearch来实现。</p>
<h3 id="天然分布式"><a href="#天然分布式" class="headerlink" title="天然分布式"></a>天然分布式</h3><p>Elasticsearch可以扩展到上百、千的服务器来处理PB级的数据，Elasticsearch的设计隐藏了分布式本身的复杂性。</p>
<p>Elasticsearch在分布式概念上做了很大程度上的透明化，在教程中你不需要知道任何关于分布式系统、分片、集群发现或者其他大量的分布式概念。所有的节点既可以运行在你的笔记本上，也可以运行在拥有100个节点的集群上，其工作方式是一样的。</p>
<p>Elasticsearch致力于隐藏分布式系统的复杂性。以下这些操作都是在底层自动完成的：</p>
<ul>
<li>将你的文档分区到不同的容器或者分片(shards)中，它们可以存在于一个或多个节点中。 </li>
<li>将分片均匀的分配到各个节点，对索引和搜索做负载均衡。 </li>
<li>冗余每一个分片，防止硬件故障造成的数据丢失。 </li>
<li>将集群中任意一个节点上的请求路由到相应数据所在的节点。 </li>
<li>无论是增加节点，还是移除节点，分片都可以做到无缝的扩展和迁移。</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="空集群"><a href="#空集群" class="headerlink" title="空集群"></a>空集群</h3><p>一个节点就是一个ElasticSearch实例，而一个集群由一个或多个节点组成，它们具有相同的<code>cluster.name</code>，它们协同工作，分析数据和负载。</p>
<p>当加入新的节点或删除一个节点，集群就会感知到并平衡数据。</p>
<p><strong><em>主节点</em></strong></p>
<p>集群中一个节点会被选举为<strong>主节点</strong>，它将临时管理集群级别的一些变更，例如新建或删除索引，增加或移除节点等。</p>
<p>主节点不参与文档级别的变更或搜索，意味着在流量增长时，主节点不会称为集群的瓶颈，且任意节点都可以成为主节点。</p>
<p>作为用户我们可以与集群中的任何节点通信，包括主节点。每一个节点都知道文档存在于哪个节点上，它们可以转发请求到相应的节点，我们访问的节点负责收集各节点返回的数据，最后一起返回给客户端。这一切由ES处理。</p>
<h3 id="Shard"><a href="#Shard" class="headerlink" title="Shard"></a>Shard</h3><p>分片就是一个Lucene实例，并且它本身就是一个完整的搜索引擎，我们的文档存储在分片中，并且在分片中被索引，但是我们的应用程序不会直接与shards通信，而是与索引直接通信。</p>
<p>Shard是ES集群中分发数据的关键，把分片类比成数据的容器，文档存储在分片中，然后分片分配到你集群的节点上。当集群扩容或缩小，<strong>ES将会自动在你的节点间迁移分片</strong>，以使得集群保持平衡。</p>
<p>Shard分类：</p>
<ul>
<li>主分片。索引中的每个文档属于一个单独的主分片，所以主分片的数量决定了索引最多能够存储多少数据。<ul>
<li>理论上能够存储的大小没有限制，限制取决于实际的使用情况，硬件存储的大小、文档的大小和复杂度，如何索引和查询你的文档，以及期望的响应时间。</li>
<li>当index创建后，主分片的数量就确定了。</li>
<li>number_of_shards参数。</li>
</ul>
</li>
<li>复制分片。是主分片的副本，防止硬件故障导致数据丢失。<ul>
<li>可提供读请求，例如搜索或从其他shard取回文档。</li>
<li>index创建后复制分片的数量可随时调整。</li>
<li>number_of_replicas参数。</li>
</ul>
</li>
</ul>
<h3 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h3><p>集群健康有三种状态：</p>
<ul>
<li>green。所有主要分片和复制分片都可用。</li>
<li>yellow。所有主要分片可用，但不是所有复制分片都可用。</li>
<li>red。不是所有主要分片都可用。</li>
</ul>
<p>查询集群信息：<code>GET /_cluster/health</code>，status表示集群的服务状况。</p>
<p>在索引建立后，集群首先是yellow状态，因为所有的复制分片还是没有unassigned的，它们不会被分配到节点上，在同一个节点上保存相同的数据副本是不必要的。</p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>单节点上运行有单点故障风险，即没有数据备份。为了防止则启动另一个节点。</p>
<p>可以使用同样的命令行在同样的目录下进行创建，一个节点可以启动多个ES实例。</p>
<p>只要第二个节点与第一个节点具有相同的<code>cluster.name</code>，具体值查看./config/elasticsearch.yml，它就能自动发现并加入第一个节点所在的集群。其原理是进行网络广播。</p>
<p>当第二个节点加入集群，则三个复制分片也将被分配，分别对应三个主分片。文档将首先被存储在主分片中，然后并发复制到对应的复制节点上。此时的集群状态为green。</p>
<h3 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h3><p>当启动第三个节点，集群会重新组织。</p>
<p>在原有情况下，两个节点各自拥有3个分片。此时将进行分片的移动，将其中一个主分片和一个复制分片移动到节点3上。</p>
<p>分片本身是一个完整的搜索引擎，它可以使用单一节点的所有资源。主分片或者复制分片都可以处理读请求——搜索或文档检索，所以数据的冗余越多，我们能处理的搜索吞吐量就越大。</p>
<p>当然在相同数量节点上增加更多的复制分片并不能提高性能，因为对硬件资源占用减少。</p>
<h3 id="应对故障"><a href="#应对故障" class="headerlink" title="应对故障"></a>应对故障</h3><p>对于这样一个集群：</p>
<p><img src="/assets/1567067619776.png" alt="1567067619776"></p>
<p>若杀死Node1，则由于杀死了主节点Master，而一个<strong>集群必须拥有主节点才能使得其功能正常</strong>，因此各个节点选举了一个新的主节点。</p>
<p><img src="/assets/1567067688072.png" alt="1567067688072"></p>
<p>此时，主分片1与2丢失，而<strong>索引在丢失主分片时不可用</strong>，则此时状态为red。因此新的主节点负责将复制分片升级为主分片，此时集群健康回到yellow。但是不是green，因为复制分片没有全部分配。</p>
<p>如果我们重启了Node1，集群能够重新分配丢失的复制分片，并将只从主分片上复制在故障期间有数据变更的那一部分。</p>
<h2 id="分布式增删改查"><a href="#分布式增删改查" class="headerlink" title="分布式增删改查"></a>分布式增删改查</h2><p>考虑数据是如何在集群中分布和获取的相关技术细节。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ul>
<li>当你索引一个文档，它被存储在单独一个主分片上。ES是如何知道文档属于哪个分片的呢？</li>
<li>当你创建一个新文档，它是如何知道是应该存储在分片1还是分片2上呢？</li>
</ul>
<p>进程不能是随机的，因为将来要检索文档，因此根据算法进行决定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//routing值是一个任意字符串，默认是_id，但也可以自定义。</span></span><br><span class="line"><span class="comment">//这个routing字符串通过哈希函数生产一个数字，然后除以主切片数量得到一个余数</span></span><br><span class="line">shard = hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure>

<p>因此主分片的数量只能在创建索引时定义且不能修改，如果主分片的数量在未来改变了，所有先前的路由就失效了，文档无法找到。</p>
<p>所有的文档API都接收一个<code>routing</code>参数，用来自定义文档到分片的映射，自定义路由值可以确保所有的相关文档都保存在同一个分片中。</p>
<h3 id="分片交互"><a href="#分片交互" class="headerlink" title="分片交互"></a>分片交互</h3><p>假设有3个节点的集群，它包含一个叫做blogs的索引并拥有两个主分片，每个主分片有两个复制分片。</p>
<p>我们能够发送请求给集群中任意一个节点，每个节点都有能力处理任意请求，每个节点都知道任意文档所在的节点，所以也能将请求转发到需要的节点。</p>
<p>接收请求的节点称为<strong>请求节点</strong>。</p>
<h3 id="新建、索引和删除"><a href="#新建、索引和删除" class="headerlink" title="新建、索引和删除"></a>新建、索引和删除</h3><p>新建、索引和删除请求都是写操作，它们必须在主分片（Node1）上成功完成才能复制到相关的复制分片上。其步骤是：</p>
<ul>
<li>客户端给Node1发送新建、索引和删除请求。</li>
<li>节点使用文档_id确定文档属于分片0，因此将请求转发到Node3，分片0位于这个节点上。</li>
<li>Node3在主分片上执行请求，如果成功，它转发请求到相应的位于Node1、Node2的复制节点上。<ul>
<li>当所有的复制节点报告成功，Node3报告成功到请求的节点，请求的节点再报告给客户端。</li>
<li>即当客户端收到响应时，文档的修改已经应用到了主分片和所有复制分片上。</li>
</ul>
</li>
</ul>
<p><strong><em>同步/异步复制</em></strong></p>
<ul>
<li>复制的默认值是sync，导致主分片得到复制分片的成功响应后才返回。<ul>
<li>sync更优，因为允许ES强制反馈传输。</li>
</ul>
</li>
<li>可以设置<code>replication</code>为async，请求在主分片上被执行后就会返回给客户端。它依然会转发请求给复制节点，但你不知道成功与否。<ul>
<li>async可能会因为在不等待其他分片就绪的情况下发送太多请求而使得ES过载。</li>
</ul>
</li>
</ul>
<p><strong><em>可用分片数</em></strong></p>
<ul>
<li>默认主分片在尝试写入时需要规定数量或过半的分片可用。这是为了防止数据被写入到错误的网络分区。<ul>
<li>int ((primary + number_of_replicas) / 2) + 1</li>
<li>consistency允许的值为：<ul>
<li>one，即只有一个主分片。</li>
<li>all，所有的主分片和复制分片。</li>
<li>quorum，默认，或过半分片。</li>
</ul>
</li>
<li>number_of_replicas是在索引中的设置，用于<strong>定义</strong>复制分片的数量，而不是现在<strong>活动</strong>的复制节点的数量。</li>
</ul>
</li>
</ul>
<p><strong><em>timeout</em></strong></p>
<p>当分片副本不足时，ES会等待更多的分片出现，默认等待一分钟，如果需要则可设置更早。</p>
<p>新索引默认有1个复制分片，这意味着为了满足quorum的要求需要两个活动的分片。 当然，这个默认设置将阻止我们在单一节点集群中进行操作。为了避开这个问题，规定数量只有在number_of_replicas大于一时才生效。</p>
<h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><p>文档能够从主分片或任意一个复制分片被检索。在主分片或复制分片上检索一个文档必要的顺序步骤：</p>
<ul>
<li>客户端给Node1发送get请求。</li>
<li>节点使用文档的_id确定文档属于分片0，分片0对应的复制分片在3个节点上都有，此时它转发到Node2。</li>
<li>Node2返回文档给Node1然后返回客户端。</li>
</ul>
<p>可能情况时一个被索引的文档已经存在于主分片上，却没有来得及同步到复制分片上，这时复制分片会报告文档未找到，主分片会成功返回文档。</p>
<p>一旦索引请求成功返回给用户，文档则在主切片和复制分片都是可用的。</p>
<h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>为什么bulk使用\n，则是因为批量中每个引用的文档属于不同的主分片，每个分片可能被分布于集群中的某个节点上。</p>
<p>意味着批量中的每个操作需要被转发到对应的分片和节点上。</p>
<p>而如果使用JSON，则需要：</p>
<ul>
<li>解析JSON为数组，包括文档数据，可能非常大。</li>
<li>检查每个请求决定应该到哪个分片上。</li>
<li>为每个分片创建应该请求的数组。</li>
<li>序列化这些数组为内部传输格式。</li>
<li>发送请求到每个分片。</li>
</ul>
<p>即使可行，也会使得大量RAM承载本质上相同的数据，并需要JVM进行回收。因此ES使用网络缓冲区中一行行读取数据，使用换行符识别并进行解析，然后决定哪些分片来处理这个请求。</p>
<p>因此ES使用最小内存在进行。</p>
<h2 id="深入分片"><a href="#深入分片" class="headerlink" title="深入分片"></a>深入分片</h2><p>分片是底层的工作单元。但分片到底是什么，它怎样工作？</p>
<ul>
<li>为什么搜索是近实时的？</li>
<li>为什么文档的CRUD操作是实时的？</li>
<li>ES怎样保证更新持久化，即使断电也不会丢失？</li>
<li>为什么删除文档不会立即释放空间？</li>
<li>什么是refresh，flush，optimize API，以及什么时候你该使用它们？</li>
</ul>
<h3 id="使文本可以被搜索"><a href="#使文本可以被搜索" class="headerlink" title="使文本可以被搜索"></a>使文本可以被搜索</h3><p>为了使得文本可以被全文搜索，一种可行的方案是使用倒排索引。倒排索引包含了出现在所有文档中唯一的词值或词的有序列表，以及每个词所属的文档列表。</p>
<p>倒排索引存储了比包含一个特定term的文档列表多的多的信息，它可能存储包含每个term的文档数量、一个term出现在指定文档中的频次，每个文档中term的顺序，每个文档的长度、平均长度。</p>
<p>这些统计信息使得ES知道哪些term更重要，哪些文档更重要，即<strong>相关性</strong>。即为了实现倒排索引，必须要找到集合中所有的文档。</p>
<p>在全文检索的早些时候，会为整个文档集合建立一个大索引，并且写入磁盘。只有新的索引准备好了，它就会替代旧的索引，最近的修改才可以被检索。</p>
<p><strong><em>不可变性</em></strong></p>
<p>写入磁盘的倒排索引是不可变的，其拥有如下好处：</p>
<ul>
<li>不需要锁。如果从来不需要更新一个索引，就不必担心多个程序同时尝试修改。 </li>
<li>一旦索引被读入文件系统的缓存(译者:在内存)，它就一直在那儿，因为不会改变。只要文件系统缓存有足够的空间，大部分的读会直接访问内存而不是磁盘。这有助于性能提升。 </li>
<li>在索引的声明周期内，所有的其他缓存都可用。它们不需要在每次数据变化了都重建，因为数据不会变。 </li>
<li>写入单个大的倒排索引，可以压缩数据，较少磁盘IO和需要缓存索引的内存大小。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不可变，因此<strong>如果想建立一个新的文档，则必须重建整个索引</strong>。</li>
</ul>
<h3 id="动态索引"><a href="#动态索引" class="headerlink" title="动态索引"></a>动态索引</h3><p>是如何在<strong>保持不可变好处的同时更新倒排索引</strong>？即使用多个索引。</p>
<p>不是重写整个倒排索引，而是<strong>增加额外的索引反映最近的变化</strong>，每个倒排索引都可以按照顺序查询，从最老的开始，最后把结果聚合。</p>
<p>ES底层依赖的Lucene，引入了per-segment search的概念。一个<strong>段</strong>是有完整功能的倒排索引，但是现在<strong>Lucene中的索引指的是段的集合，再加上提交点</strong>(commit point，包含所有段的文件)。</p>
<p><img src="/assets/1567604324720.png" alt="1567604324720"></p>
<p>新的文档，在被写入磁盘的段前，首先写入内存区的索引缓存，即内存缓冲区有即将提交文档的Lucene索引：</p>
<p><img src="/assets/1567669526235.png" alt="1567669526235"></p>
<p><strong><em>索引 VS 分片</em></strong></p>
<p>Lucene索引是ES中的分片，ES中的索引是分片的集合。在ES搜索索引时，它发送查询请求给该索引下的所有分片，然后过滤这些结果，聚合成全局的结果。</p>
<p>一个per-segment search如下工作：</p>
<ul>
<li>新的文档首先写入内存区的索引缓存。</li>
<li>不时，这些buffer被提交。<ul>
<li>一个新的段-额外的倒排索引-写入磁盘。</li>
<li>新的提交点写入磁盘，包含新段的名称。</li>
<li>磁盘时fsynced(文件同步)，所有写操作等待文件系统缓存同步到磁盘，确保它们可以被物理写入。</li>
</ul>
</li>
<li>新段被打开，它包含的文档可以被检索。</li>
<li>内存的缓存被清除，等待接收新的文档。</li>
</ul>
<p><img src="/assets/1567606295972.png" alt="1567606295972"></p>
<p>当一个请求被接受，所有段依次查询。所有段上的Term统计信息被聚合，确保每个term和文档的相关性被正确计算。通过这种方式，新的文档以较小的代价加入索引。</p>
<p><strong><em>删除和更新</em></strong></p>
<p>段是不可变的，即文档既不能从旧的段中移除，旧的段也不能更新以反映文档最新的版本。相反，每一个提交点包括一个.del文件，包含了段上已经被删除的文档。</p>
<p>当一个文档被删除，它实际上只是在.del文件中被标记为删除，依然可以匹配查询，但是最终返回之前会被从结果中删除。</p>
<p>文档的更新操作是类似的：当一个文档被更新，旧版本的文档被标记为删除，新版本的文档在新的段中索引。也许该文档的不同版本都会匹配一个查询，但是更老版本会从结果中删除。</p>
<h3 id="近实时搜索"><a href="#近实时搜索" class="headerlink" title="近实时搜索"></a>近实时搜索</h3><p>由于per-segment search机制，索引和搜索一个文档之间是有延迟的，新的文档会在几分钟内被搜索，但这个时间太久。</p>
<p>由于一个新的段到磁盘需要fsync操作，确保段能够被物理地写入磁盘中，即时电源失效也不会丢失数据，但fsync是昂贵的，不能在每个文档被索引时就触发。因此需要一种更轻量级的方式使得新的文档可以被搜索。</p>
<p>在ES与磁盘中间加入<strong>缓存</strong>，即使用内存。在内存索引缓存中的文档被写入新的段，先将新的段首先写入缓存，之后在一段时间后同步到磁盘。即缓存内容写入了段中，但是uncommited。</p>
<p>Lucene允许新段写入打开，好让它们包括的文档可搜索，而不用执行一次全量提交。这是比提交更轻量的过程，可以经常操作，而不会影响性能：</p>
<p><img src="/assets/1567607118204.png" alt="1567607118204"></p>
<p><strong><em>refresh API</em></strong></p>
<p><strong>refresh是写入打开一个新段的轻量级过程</strong>。默认情况下，每个分片<strong>每秒</strong>自动刷新一次。因此ES是近实时的搜索，文档的改动一般在1s内可见。</p>
<h3 id="持久化变更"><a href="#持久化变更" class="headerlink" title="持久化变更"></a>持久化变更</h3><p>没用fsync同步文件系统缓存到磁盘，我们不能确保电源失效，甚至正常退出应用后，数据的安全。为了ES的可靠性，需要确保变更持久化到磁盘。</p>
<p>全提交同步段到磁盘，写提交点，这会列出所有的已知的段。在重启，或重新打开索引时，ES使用这次提交点决定哪些段属于当前的分片。</p>
<p>当我们通过每秒的刷新获得近实时的搜索，我们依然需要定时地执行全提交确保能从失败中恢复。但是提交之间的文档怎么办？我们也不想丢失它们。</p>
<p>ES增加了事务日志（translog），来记录每次操作。</p>
<ul>
<li>当一个文档被索引，它被加入到内存缓存，同时加到事务日志。</li>
<li>refresh使得分片的进入如下状态，每秒分片都进行refresh。<ul>
<li>内存缓冲段的文档写入段中，但没有fsync。</li>
<li>段被打开，使得新的文档可以被搜索。</li>
<li>缓存被清除，但事务日志依然在。</li>
</ul>
</li>
<li>更多的文档加入到缓冲区，重复过程2。</li>
<li>当日志很大的时候，新的日志会创建，会进行一次全提交：<ul>
<li>内存缓冲区的所有文档会写入到新段中。</li>
<li>清除缓存。</li>
<li>一个提交点写入硬盘。</li>
<li>文件系统缓存通过fsync操作flush到硬盘。</li>
<li>事务日志被清除。</li>
</ul>
</li>
</ul>
<p>事务日志记录了没有flush到硬盘的所有操作。当故障重启后，ES会用最近一次提交点从硬盘恢复所有已知的段，并且从日志里恢复所有的操作。</p>
<p>事务日志还用来提供实时的CRUD操作。当你尝试用ID进行CRUD时，它在检索相关段内的文档前会首先检查日志最新的改动。这意味着ES可以实时地获取文档的最新版本。 </p>
<p><strong><em>flush API</em></strong></p>
<p>在ES中，进行一次提交并删除事务日志的操作叫做flush。分片每30分钟，或事务日志过大会进行一次flush操作。</p>
<p>当你要重启或关闭一个索引，flush该索引是很有用的。当ES尝试恢复或者重新打开一个索引时，它必须重放所有事务日志中的操作，所以日志越小，恢复速度越快。</p>
<h3 id="合并段"><a href="#合并段" class="headerlink" title="合并段"></a>合并段</h3><p>通过每秒自动刷新创建新的段，用不了多久段的数量就爆炸了。有太多的段是一个问题。每个段消费文件句柄，内存，cpu资源。更重要的是，每次搜索请求都需要依次检查每个段。段越多，查询越慢。</p>
<p>ES通过后台合并段解决该问题，小段被合并为大段，再合并为更大的段。以两个提交的段和一个未提交的段合并为了一个更大的段所示：</p>
<ul>
<li>索引过程中，refresh会创建新的段，并打开它。</li>
<li>合并过程会在后台选择一些小的段合并成大的段，这个过程不会中断索引和搜索。</li>
<li>合并大的段会消耗很多IO和CPU，如果不检查会影响到搜索性能。默认情况下，ES会限制合并过程，这样搜索就可以有足够的资源进行。</li>
</ul>
<p><img src="/assets/1567676617810.png" alt="1567676617810"></p>
<p>合并后：</p>
<ul>
<li>新的段flush到了硬盘。</li>
<li>新的提交点写入新的段，排除旧的段。</li>
<li>新的段打开供搜索。</li>
<li>旧的段被删除。</li>
</ul>
<p><strong><em>optimize API</em></strong></p>
<p>optimize API描述为强制合并段API。它强制分片合并段以达到指定max_num_segments参数。这是为了减少段的数量（通常为1）达到提高搜索性能的目的。</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>ES的聚合(aggregations)允许你在数据上生成复杂的分析统计，类似于<code>Group by</code>但是功能更强大。</p>
<p>例如找到所有职员中最大的共同点(兴趣爱好)是什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type: application/json&quot; -XGET &quot;http://localhost:9200/megacorp/employee/_search?pretty&quot; -d&apos;&#123;</span><br><span class="line">	&quot;aggs&quot;:&#123;</span><br><span class="line">		&quot;all_interests&quot;:&#123;</span><br><span class="line">			&quot;terms&quot;:&#123;&quot;field&quot;: &quot;interests&quot;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>聚合也允许分级汇总。例如，让我们统计每种兴趣下职员的平均年龄。</p>
<h2 id="聚合-1"><a href="#聚合-1" class="headerlink" title="聚合"></a>聚合</h2><h3 id="Bucket-Aggregation"><a href="#Bucket-Aggregation" class="headerlink" title="Bucket Aggregation"></a>Bucket Aggregation</h3><p>Terms</p>
<p>Data Histogram</p>
<p>Range</p>
<p>Sampler</p>
<h2 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/Elasticsearch/" rel="tag"># Elasticsearch</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2019/08/26/系统架构/消息队列：RabbitMQ进阶/" rel="next" title="消息队列：RabbitMQ进阶">
                <i class="fa fa-chevron-left"></i> 消息队列：RabbitMQ进阶
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2019/09/07/Java/base/Java并发：Disruptor/" rel="prev" title="Java并发：Disruptor">
                Java并发：Disruptor <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">205</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Elasticsearch"><span class="nav-number">1.</span> <span class="nav-text">Elasticsearch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用"><span class="nav-number">1.1.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#适用性"><span class="nav-number">1.1.1.</span> <span class="nav-text">适用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺陷"><span class="nav-number">1.1.2.</span> <span class="nav-text">缺陷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DOC"><span class="nav-number">2.</span> <span class="nav-text">DOC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文档"><span class="nav-number">2.1.</span> <span class="nav-text">文档</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向文档"><span class="nav-number">2.1.1.</span> <span class="nav-text">面向文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文档元数据"><span class="nav-number">2.1.2.</span> <span class="nav-text">文档元数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Index"><span class="nav-number">2.2.</span> <span class="nav-text">Index</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用"><span class="nav-number">2.2.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引设置"><span class="nav-number">2.2.2.</span> <span class="nav-text">索引设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type和mapping"><span class="nav-number">2.2.3.</span> <span class="nav-text">type和mapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根对象"><span class="nav-number">2.2.4.</span> <span class="nav-text">根对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元数据"><span class="nav-number">2.2.5.</span> <span class="nav-text">元数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态映射"><span class="nav-number">2.2.6.</span> <span class="nav-text">动态映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重建索引"><span class="nav-number">2.2.7.</span> <span class="nav-text">重建索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据的基本操作"><span class="nav-number">2.3.</span> <span class="nav-text">数据的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Search-响应"><span class="nav-number">2.3.1.</span> <span class="nav-text">Search 响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CURD"><span class="nav-number">2.3.2.</span> <span class="nav-text">CURD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BULK"><span class="nav-number">2.3.3.</span> <span class="nav-text">BULK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写文档的并发操作"><span class="nav-number">2.3.4.</span> <span class="nav-text">读写文档的并发操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Search-API"><span class="nav-number">2.4.</span> <span class="nav-text">Search API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构化查询"><span class="nav-number">2.5.</span> <span class="nav-text">结构化查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#join"><span class="nav-number">2.6.</span> <span class="nav-text">join</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复合查询"><span class="nav-number">2.7.</span> <span class="nav-text">复合查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全文检索"><span class="nav-number">2.8.</span> <span class="nav-text">全文检索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地理信息查询"><span class="nav-number">2.9.</span> <span class="nav-text">地理信息查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制相关度"><span class="nav-number">2.10.</span> <span class="nav-text">控制相关度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mapping"><span class="nav-number">3.</span> <span class="nav-text">Mapping</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Mapping-1"><span class="nav-number">3.1.</span> <span class="nav-text">Mapping</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型差异"><span class="nav-number">3.1.1.</span> <span class="nav-text">数据类型差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型与字段信息"><span class="nav-number">3.1.2.</span> <span class="nav-text">数据类型与字段信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义字段映射"><span class="nav-number">3.1.3.</span> <span class="nav-text">自定义字段映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新mapping"><span class="nav-number">3.1.4.</span> <span class="nav-text">更新mapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复合核心字段类型"><span class="nav-number">3.1.5.</span> <span class="nav-text">复合核心字段类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对数据建模"><span class="nav-number">3.2.</span> <span class="nav-text">对数据建模</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#确切值与全文文本"><span class="nav-number">3.2.1.</span> <span class="nav-text">确切值与全文文本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对索引建模"><span class="nav-number">3.2.2.</span> <span class="nav-text">对索引建模</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对文档建模"><span class="nav-number">3.2.3.</span> <span class="nav-text">对文档建模</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mapping-amp-Setting"><span class="nav-number">3.2.4.</span> <span class="nav-text">Mapping &amp; Setting</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#倒排索引"><span class="nav-number">3.3.</span> <span class="nav-text">倒排索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#修复数据"><span class="nav-number">3.4.</span> <span class="nav-text">修复数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文本Analysis"><span class="nav-number">3.5.</span> <span class="nav-text">文本Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引管理"><span class="nav-number">3.6.</span> <span class="nav-text">索引管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Search运行机制"><span class="nav-number">4.</span> <span class="nav-text">Search运行机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式搜索方式"><span class="nav-number">4.1.</span> <span class="nav-text">分布式搜索方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查询"><span class="nav-number">4.1.1.</span> <span class="nav-text">查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取回"><span class="nav-number">4.1.2.</span> <span class="nav-text">取回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深分页"><span class="nav-number">4.1.3.</span> <span class="nav-text">深分页</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索选项"><span class="nav-number">4.2.</span> <span class="nav-text">搜索选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#preference"><span class="nav-number">4.2.1.</span> <span class="nav-text">preference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timeout"><span class="nav-number">4.2.2.</span> <span class="nav-text">timeout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#routing"><span class="nav-number">4.2.3.</span> <span class="nav-text">routing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search-type"><span class="nav-number">4.2.4.</span> <span class="nav-text">search_type</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扫描与滚屏"><span class="nav-number">4.3.</span> <span class="nav-text">扫描与滚屏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#scroll"><span class="nav-number">4.3.1.</span> <span class="nav-text">scroll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scan"><span class="nav-number">4.3.2.</span> <span class="nav-text">scan</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式特性"><span class="nav-number">5.</span> <span class="nav-text">分布式特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#集群和节点"><span class="nav-number">5.1.</span> <span class="nav-text">集群和节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#天然分布式"><span class="nav-number">5.1.1.</span> <span class="nav-text">天然分布式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">5.2.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#空集群"><span class="nav-number">5.2.1.</span> <span class="nav-text">空集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shard"><span class="nav-number">5.2.2.</span> <span class="nav-text">Shard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群健康"><span class="nav-number">5.2.3.</span> <span class="nav-text">集群健康</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障转移"><span class="nav-number">5.2.4.</span> <span class="nav-text">故障转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#横向扩展"><span class="nav-number">5.2.5.</span> <span class="nav-text">横向扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应对故障"><span class="nav-number">5.2.6.</span> <span class="nav-text">应对故障</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式增删改查"><span class="nav-number">5.3.</span> <span class="nav-text">分布式增删改查</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#路由"><span class="nav-number">5.3.1.</span> <span class="nav-text">路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分片交互"><span class="nav-number">5.3.2.</span> <span class="nav-text">分片交互</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新建、索引和删除"><span class="nav-number">5.3.3.</span> <span class="nav-text">新建、索引和删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检索"><span class="nav-number">5.3.4.</span> <span class="nav-text">检索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#批量更新"><span class="nav-number">5.3.5.</span> <span class="nav-text">批量更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入分片"><span class="nav-number">5.4.</span> <span class="nav-text">深入分片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使文本可以被搜索"><span class="nav-number">5.4.1.</span> <span class="nav-text">使文本可以被搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态索引"><span class="nav-number">5.4.2.</span> <span class="nav-text">动态索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#近实时搜索"><span class="nav-number">5.4.3.</span> <span class="nav-text">近实时搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化变更"><span class="nav-number">5.4.4.</span> <span class="nav-text">持久化变更</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合并段"><span class="nav-number">5.4.5.</span> <span class="nav-text">合并段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心"><span class="nav-number">5.5.</span> <span class="nav-text">核心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#架构"><span class="nav-number">5.6.</span> <span class="nav-text">架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索引擎"><span class="nav-number">5.7.</span> <span class="nav-text">搜索引擎</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#聚合"><span class="nav-number">6.</span> <span class="nav-text">聚合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#聚合-1"><span class="nav-number">6.1.</span> <span class="nav-text">聚合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bucket-Aggregation"><span class="nav-number">6.1.1.</span> <span class="nav-text">Bucket Aggregation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#聚合分析"><span class="nav-number">6.2.</span> <span class="nav-text">聚合分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">1.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">40:17</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        




  <script>
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=66458302";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  























  <script src="/js/local-search.js?v=7.2.0"></script>














</body>
</html>
