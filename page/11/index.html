<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: 'OZTK1BY156',
      apiKey: '',
      indexName: 'BlogIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Kopieren',
      copy_success: 'Kopiert',
      copy_failure: 'Kopieren fehlgeschlagen'
    }
  };
</script>

  <meta name="description" content="To be awesome">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="To be awesome">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="To be awesome">
  <link rel="canonical" href="http://yoursite.com/page/11/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>Über</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Schlagwörter</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Kategorien</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>Zeitplan</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Suche</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="algolia-popup popup search-popup">
  <div class="algolia-search">
    <div class="algolia-search-input-icon">
      <i class="fa fa-search"></i>
    </div>
    <div class="algolia-search-input" id="algolia-search-input"></div>
  </div>

  <div class="algolia-results">
    <div id="algolia-stats"></div>
    <div id="algolia-hits"></div>
    <div id="algolia-pagination" class="algolia-pagination"></div>
  </div>

  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>



    </div>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/Java/base/JavaBase：反射/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/Java/base/JavaBase：反射/" class="post-title-link" itemprop="url">JavaBase：反射</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-28 11:26:09" itemprop="dateCreated datePublished" datetime="2019-03-28T11:26:09+08:00">2019-03-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-07-24 08:17:55" itemprop="dateModified" datetime="2019-07-24T08:17:55+08:00">2019-07-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/28/Java/base/JavaBase：反射/" class="post-meta-item leancloud_visitors" data-flag-title="JavaBase：反射">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/28/Java/base/JavaBase：反射/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/28/Java/base/JavaBase：反射/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          Java反射技术，运行时获得类信息。
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/03/28/Java/base/JavaBase：反射/">
                Weiterlesen &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/26/Java/设计模式/设计模式：代理模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/26/Java/设计模式/设计模式：代理模式/" class="post-title-link" itemprop="url">设计模式：代理模式</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-26 23:33:22" itemprop="dateCreated datePublished" datetime="2019-03-26T23:33:22+08:00">2019-03-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-07-26 10:13:24" itemprop="dateModified" datetime="2019-07-26T10:13:24+08:00">2019-07-26</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/26/Java/设计模式/设计模式：代理模式/" class="post-meta-item leancloud_visitors" data-flag-title="设计模式：代理模式">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/26/Java/设计模式/设计模式：代理模式/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/26/Java/设计模式/设计模式：代理模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><ul>
<li>为了只有在我们确实需要这个对象时才对它进行初始化</li>
<li>我们在写一个功能函数时，经常需要在其中写入与功能不是直接相关但很有必要的代码</li>
</ul>
<h3 id="问题案例1"><a href="#问题案例1" class="headerlink" title="问题案例1"></a>问题案例1</h3><p>考虑一个数据库查询场景，需要将公司的所有员工显示出来，而且不要翻页，在显示全部员工时，只需要显示名称即可，但是必要时也可以查看某位员工的具体信息。</p>
<p>该查询查询的数据条很多，并且每条数据的数据量也很大，则会消耗很大的内存。从用户角度看，y用户可能访问一条数据，也可能不访问等等。而从程序角度则应该减少内存的消耗</p>
<h3 id="问题案例2"><a href="#问题案例2" class="headerlink" title="问题案例2"></a>问题案例2</h3><p>如日志记录，信息发送，安全和事务支持等，这些枝节性代码虽然是必要的，但它会带来以下麻烦：</p>
<ul>
<li>枝节性代码游离在功能性代码之外，它不是函数的目的，这是对OO是一种破坏</li>
<li>枝节性代码会造成功能性代码对其它类的依赖，加深类之间的耦合，可重用性降低</li>
<li>从法理上说，枝节性代码应该监视着功能性代码，然后采取行动，而不是功能性代码通知枝节性代码采取行动，这好比吟游诗人应该是主动记录骑士的功绩而不是骑士主动要求诗人记录自己的功绩</li>
</ul>
<h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>代理(Proxy)是一种设计模式,定义：为其他对象提供一个代理以控制对某个对象的访问，即通过代理对象访问目标对象.</p>
</blockquote>
<ul>
<li>这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.</li>
</ul>
<blockquote>
<p>这里使用到编程中的一个思想:</p>
<p>不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法</p>
</blockquote>
<p>所以说代理模式就是：<strong>当前对象不愿意干的，没法干的东西委托给别的对象来做</strong>，我只要做好本分的东西就好了！</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据实现方式分类</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p>根据目的分类</p>
<ul>
<li>远程代理。隐藏一个对象存在于不同地址空间的事实，一般用于RMI等</li>
<li>虚代理。可以进行最优化，根据要求创建对象。即根据需要创建开销很大的对象， 该对象只有在真正需要的时候才会被创建。</li>
<li>保护代理。提供不同的访问权限，允许在访问一个对象时有一些附加处理</li>
<li>智能指引。允许在访问一个对象时有一些附加处理</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>很明显的是：</p>
<ul>
<li>静态代理需要自己写代理类–&gt;代理类需要实现与目标对象相同的接口</li>
<li>而动态代理不需要自己编写代理类—&gt;(是动态生成的)</li>
</ul>
<p><strong>使用静态代理时：</strong></p>
<ul>
<li>如果目标对象的接口有<strong>很多方法</strong>的话，那我们还是得一一实现，这样就会比较麻烦</li>
</ul>
<p><strong>使用动态代理时：</strong></p>
<ul>
<li>代理对象的生成，是利用JDK API，<strong>动态地在内存中构建代理对象</strong>(需要我们指定创建 代理对象/目标对象 实现的接口的类型)，并且会<strong>默认实现接口的全部方法</strong>。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>远程代理，为一个对象在不同的地址空间提供局部代表</li>
<li>虚代理，根据需要创建开销很大的对象</li>
<li>保护代理，控制对原始对象的访问，用于对象应该有不同的访问权限的时候</li>
<li>智能指引，取代了简单的指针，在访问对象时执行一些附加操作<ul>
<li>对指向实际对象的引用计数，当对象没有用时，可以自动释放</li>
<li>在访问一个对象时，对它进行事务、日志等操作</li>
</ul>
</li>
</ul>
<h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>CopyOnWrite的优化方式，拷贝是一个开销很大的操作，如果拷贝没有被修改，则代理延迟这一拷贝过程，保证只有在这个对象被修改时才进行拷贝</p>
<h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="assets/1563931488048.png" alt="1563931488048"></p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li>Proxy<ul>
<li>保护一个引用使得代理可以访问实体，如果RealSubject与Subject的接口相同，Proxy会引用Subject</li>
<li>提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体</li>
<li>控制对实体的存取，并可能负责创建和删除它</li>
<li>其他功能依赖于代理的类型<ul>
<li>Remote Proxy负责对请求及其参数进行编码，并向不同地址空间的实体发送已编码的请求</li>
<li>Virtual Proxy可以缓存实体的附加信息，以便延迟对它的访问</li>
<li>Protection Proxy检查调用者是否具有实现一个请求所必须的访问权限</li>
</ul>
</li>
</ul>
</li>
<li>Subject<ul>
<li>定义RealSubject与Proxy的公共接口，可以在任何使用RealSubject的地方都可以使用Proxy</li>
</ul>
</li>
<li>RealSubject<ul>
<li>定义Proxy所代表的实体</li>
</ul>
</li>
</ul>
<h3 id="协作-1"><a href="#协作-1" class="headerlink" title="协作"></a>协作</h3><ul>
<li>类关系</li>
<li>逻辑关系<ul>
<li>代理根据其种类，在适当的时候向RealSubject转发请求。</li>
</ul>
</li>
</ul>
<h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><h2 id="效果（优缺）"><a href="#效果（优缺）" class="headerlink" title="效果（优缺）"></a>效果（优缺）</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h3 id="案例1-1"><a href="#案例1-1" class="headerlink" title="案例1"></a>案例1</h3><p>这里有一个Subject接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现RealSubject</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Im Real"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Proxy扩展原有的RealSubject的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject realSubject ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealSubjectProxy</span><span class="params">(Subject real)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realSubject = real;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upvote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"扩展RealSubject无法做的功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        realSubject.coding();<span class="comment">//将操作转发给原有对象</span></span><br><span class="line">        upvote();<span class="comment">//扩展功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口功能还是由RealSubject来实现，但每次实现后会有一些扩展功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RealSubject real = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        SubjectProxy programmer = <span class="keyword">new</span> RealSubjectProxy(real);</span><br><span class="line">        programmer.coding();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题案例1-1"><a href="#问题案例1-1" class="headerlink" title="问题案例1"></a>问题案例1</h3><p>实现一个代理对象，持有用户对象，并拥有查询用户姓名等基础信息的方法，当要查询某一个具体的用户全部信息时，进行reload加载该用户的信息。</p>
<h2 id="透明代理-普通代理"><a href="#透明代理-普通代理" class="headerlink" title="透明代理(普通代理)"></a>透明代理(普通代理)</h2><p>让真实对象(RealSubject)对外界来说是透明的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubjectProxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定具体的代理对象</span></span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只做针对单个的目标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealSubjectProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realSubject = <span class="keyword">new</span> RealSubect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upvote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"扩展"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        java3y.coding();</span><br><span class="line">        upvote();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是乎，程序员大V想要赚点零花钱的时候直接让Java3y发文章就好了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 受委托代理</span></span><br><span class="line">        RealSubjectProxy programmer = <span class="keyword">new</span> RealSubjectProxy();</span><br><span class="line">        programmer.coding();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h2><h2 id="效果（优缺）-1"><a href="#效果（优缺）-1" class="headerlink" title="效果（优缺）"></a>效果（优缺）</h2><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><h3 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h3><h3 id="案例1-2"><a href="#案例1-2" class="headerlink" title="案例1"></a>案例1</h3><p>利用动态代理自动生成代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args1)</span> </span>&#123;</span><br><span class="line">        RealSubject real = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        Programmer proxy = (Programmer) Proxy.newProxyInstance(real.getClass().getClassLoader(), real.getClass().getInterfaces(), (proxy, method, args) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果是调用coding方法，那么执行代理</span></span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(<span class="string">"coding"</span>)) &#123;</span><br><span class="line">                method.invoke(real, args);</span><br><span class="line">                System.out.println(<span class="string">"扩展"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是调用coding方法，那么调用原对象的方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(real, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        proxy.coding();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当Java3y发文章的时候，水军都会点赞。</p>
<h1 id="Java动态代理Proxy"><a href="#Java动态代理Proxy" class="headerlink" title="Java动态代理Proxy"></a>Java动态代理Proxy</h1><h2 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">//简化上述(2)(3)(4)步骤Object o = Proxy.newProxyInstance(Stub.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Subject.class&#125;, client.handler);`</span></span><br></pre></td></tr></table></figure>

<p>整体的过程可以拆解为以下过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StubClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//(2)通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类</span></span><br><span class="line">        Class&lt;?&gt; proxyClass = Proxy.getProxyClass(RealSubject.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Subject.class&#125;);</span><br><span class="line">        <span class="comment">//(3)通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型</span></span><br><span class="line">        Constructor&lt;?&gt; proxyClassConstructor = proxyClass.getConstructor(<span class="keyword">new</span> Class&lt;?&gt;[]&#123;InvocationHandler.class&#125;);</span><br><span class="line">        <span class="comment">//(4)通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入</span></span><br><span class="line">        Object o = proxyClassConstructor.newInstance(<span class="keyword">new</span> StubClient().handler);</span><br><span class="line">        <span class="comment">//(5)通过动态代理对象调用</span></span><br><span class="line">        Subject subject = (Subject) o;</span><br><span class="line">        <span class="comment">//(6)输出委托类的结果</span></span><br><span class="line">        subject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(1)通过实现 InvocationHandler 接口创建自己的调用处理器</span></span><br><span class="line">    <span class="keyword">private</span> InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="comment">//创建委托类对象实例</span></span><br><span class="line">        <span class="keyword">private</span> RealSubject real = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(real, args);<span class="comment">//调用委托类的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态代理类的属性"><a href="#动态代理类的属性" class="headerlink" title="动态代理类的属性"></a>动态代理类的属性</h2><ul>
<li>如果所有的代理接口都是public的，那么代理类就是public、final的，切不是abstract的</li>
<li>动态代理类的名称以”$ProxyN”开头,N是代理类的唯一编号.</li>
<li>动态代理类都继承于java.lang.reflect.Proxy</li>
<li>动态代理类实现了其创建时指定的接口，且保持接口指定的顺序</li>
<li>如果动态代理类实现了一个非public接口，那么它将定义和接口相同的包名；否则代理类的包是不确定的，默认是com.sun.proxy,运行时，包密封性不防止特定包成功定义代理类；如果都不是，动态代理类将由同一个类加载器和相同的包与特定签名定义.</li>
<li>动态代理类实现了其创建时指定的所有接口，调用代理类Class对象的getInterfaces将返回和创建时指定接口顺序相同的列表，调用 getMethods方法返回所有接口方法的数组对象，调用getMethod会返回代理类接口中期望的method.</li>
<li>调用Proxy.isProxyClass方法时,传入Proxy.getProxyClass返回的Class或者Proxy.newProxyInstance返回对象的Class，都会返回true，否则返回false.</li>
<li>代理类的java.security.ProtectionDomain是由系统根类加载器加载的，代理类的代码也是系统信任的代码生成的，此保护域通常被授予java.security.AllPermission</li>
<li>每一个代理类都有一个public的，含有一个InvocationHandler实现为参数的构造方法，设置了调用处理器接口，就不必使用反射api访问构造方法，通过Proxy.newProxyInstance可以产生和Proxy.getProxyClass和调用句柄相同的调用构造函数行为.</li>
</ul>
<h2 id="动态代理实例的属性"><a href="#动态代理实例的属性" class="headerlink" title="动态代理实例的属性"></a>动态代理实例的属性</h2><ul>
<li>给定一个代理实例proxy，Foo实现的接口之一，表达式 proxy instanceof Foo 返回true,(Foo) proxy能成功转换.</li>
<li>每个代理实例都关联一个InvocationHandler， 通过Proxy.getInvocationHandler方法，将返回代理类关联的InvocationHandler.</li>
<li>代理类实例调用其代理接口中所声明的方法时，这些方法将被编码，并最终由调用处理器(InvocationHandler)的invoke方法执行.</li>
<li>代理类根类java.lang.Object中的hashCode,equals和toString方法，也会被分派到调用处理其的invoke方法执行；可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖；二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到委托类执行。</li>
<li>当代理的一组接口有重复声明的方法且该方法被调用时，代理类总是从排在最前面的接口中获取方法对象并分派给调用处理器，而无论代理类实例是否正在以该接口（或继承于该接口的某子接口）的形式被外部引用，因为在代理类内部无法区分其当前的被引用类型。</li>
</ul>
<h2 id="获取动态代理类时需要注意哪些？"><a href="#获取动态代理类时需要注意哪些？" class="headerlink" title="获取动态代理类时需要注意哪些？"></a>获取动态代理类时需要注意哪些？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</span><br></pre></td></tr></table></figure>

<p>通过指定的ClassLoader loader和有序的interfaces，ClassLoader将动态生成实现有序interfaces的代理类，如果这个ClassLoader已经定义过相同有序接口实现的代理类，那么将不在重复定义.</p>
<ul>
<li>所有interfaces中的对象必须都是接口，否则会抛出异常</li>
<li>interfaces中的接口不能重复</li>
<li>所有接口相对指定的ClassLoader必须是可见的</li>
<li>所有的非public接口必须在同一个包中，否这不能成功生成实现所有接口的代理类.</li>
<li>代理类的接口数目不能超过65535，这个是JVM所限定的</li>
</ul>
<p>当不满足上述限定中的一条或多条时，将会抛出IllegalArgumentException异常，如果interfaces中的接口对象一个或多个是null，也将抛出NullPointerException.<br><strong>注意：</strong>代理类指定的接口的顺序是很重要的，否则不通顺序的相同接口数组将会导致生成不同的代理类</p>
<h1 id="从源码中理解动态代理类的生成"><a href="#从源码中理解动态代理类的生成" class="headerlink" title="从源码中理解动态代理类的生成"></a>从源码中理解动态代理类的生成</h1><p>上面我们讲述了动态代理的使用，动态代理类的属性，动态代理实例的属性，以及获取动态代理类时需要注意的事项，下面我们从源码角度去观察这些东西</p>
<h3 id="Proxy的重要变量"><a href="#Proxy的重要变量" class="headerlink" title="Proxy的重要变量"></a>Proxy的重要变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器参数类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;;</span><br><span class="line"><span class="comment">//代理类缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"><span class="comment">//关联的调用处理器</span></span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br></pre></td></tr></table></figure>

<h3 id="Proxy的构造方法"><a href="#Proxy的构造方法" class="headerlink" title="Proxy的构造方法"></a>Proxy的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//私有构造函数，禁止外部调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 通过子类指定一个调用处理器接口</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    doNewInstanceCheck();</span><br><span class="line">    <span class="keyword">this</span>.h = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Proxy-newProxyInstance函数分析"><a href="#Proxy-newProxyInstance函数分析" class="headerlink" title="Proxy.newProxyInstance函数分析"></a>Proxy.newProxyInstance函数分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span><span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//(1)权限检查和校验</span></span><br><span class="line">    checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//(2)查找已经存在的或动态生成生成代理类</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//(3)通过反射调用含有调用处理器参数的构造函数生成动态代理类的实例对象并返回</span></span><br><span class="line">    <span class="keyword">return</span> newInstance(cons, ih);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Proxy-getProxyClass函数分析"><a href="#Proxy-getProxyClass函数分析" class="headerlink" title="Proxy.getProxyClass函数分析"></a>Proxy.getProxyClass函数分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader,</span><br><span class="line">                                     Class&lt;?&gt;... interfaces)<span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//(1)权限检查和校验</span></span><br><span class="line">    checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//(2)返回查找已经存在的或动态生成生成代理类</span></span><br><span class="line">    <span class="keyword">return</span> getProxyClass0(loader, intfs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Proxy-checkProxyAccess函数分析"><a href="#Proxy-checkProxyAccess函数分析" class="headerlink" title="Proxy.checkProxyAccess函数分析"></a>Proxy.checkProxyAccess函数分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">caller 调用Proxy.getProxyClass或Proxy.newProxyInstance接口的类</span></span><br><span class="line"><span class="comment">loader 调用接口时传入的ClassLoader</span></span><br><span class="line"><span class="comment">interfaces 调用接口时传入的接口列表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkProxyAccess</span><span class="params">(Class&lt;?&gt; caller,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Class&lt;?&gt;... interfaces)</span> </span>&#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassLoader ccl = caller.getClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span> &amp;&amp; ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ProxyAccessHelper.allowNullLoader) &#123;</span><br><span class="line">                    <span class="comment">//如果传入的ClassLoader是null，则要检查"getClassLoader"权限</span></span><br><span class="line">                    sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果接口列表中有一个接口不是public的，那么代理类应该由该接口的ClassLoader加载定义，如果caller的ClassLoader和接口的ClassLoader不相同，那么虚拟机将在</span></span><br><span class="line"><span class="comment">            生成代理类的defineClass0方法(参见java虚拟机类加载机制)中抛出IllegalAccessError</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            ReflectUtil.checkProxyPackageAccess(ccl, interfaces);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Proxy-getProxyClass0函数分析"><a href="#Proxy-getProxyClass0函数分析" class="headerlink" title="Proxy.getProxyClass0函数分析"></a>Proxy.getProxyClass0函数分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数作用是返回代理类的Class对象，在调用这个方法之前必须要调用checkProxyAccess方法来检查相应的权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123; <span class="comment">//接口列表大小的限制</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果通过指定的loader定义实现有序接口列表的代理类已经存在于缓存，那么返回缓存中的拷贝，否则通过ProxyClassFactory创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是代理类从缓存中获取代理类，jdk1.7中的缓存机制略显复杂，没有去深入研究，后期如有可能再补上跳过如下流程代码分析</p>
<ul>
<li>通过WeakCache的get方法获得代理类的Class对象</li>
<li>删除无效缓存，弱key和强subkey的缓存等（略过…）</li>
<li>通过WeakCache的内部类Factory的get方法调用Proxy.ProxyClassFactory的apply方法得到代理类的Class对象</li>
</ul>
<h3 id="ProxyClassFactory分析"><a href="#ProxyClassFactory分析" class="headerlink" title="ProxyClassFactory分析"></a>ProxyClassFactory分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// 所有代理类的前缀</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成代理类名称下一个唯一的编号，如$ProxyN</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 校验代理接口对指定的ClassLoader是否可见，不可见抛出异常</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 校验interface Class是否是接口，不是则抛出异常.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 校验接口类是否重复，如果重复则抛出异常.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// 声明代理类的包名</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 记录是否所有的非public接口是否在相同的包下，如果是则代理类的包名是非public接口的包名，否则抛出异常.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">                <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">                <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                    String name = intf.getName();</span><br><span class="line">                    <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                    String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        proxyPkg = pkg;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有非public的代理接口，包名就用com.sun.proxy</span></span><br><span class="line">                proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 生成选定的代理类名称,如$ProxyN.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *通过ProxyGenerator类生成指定的代理类字节数组.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//通过指定ClassLoader生成代理类的Class对象</span></span><br><span class="line">                <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                    proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 一些其他参数方面影响了代理类的创建异常.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至此，动态代理的Class对象生成进入结尾，Proxy的isProxyClass方法和getInvocationHandler方法就比较清晰明显了，请读者自行分析.</p>
<h1 id="动态代理类生成"><a href="#动态代理类生成" class="headerlink" title="动态代理类生成"></a>动态代理类生成</h1><p>事物往往不像其看起来的复杂，需要的是我们能够化繁为简，这样也许就能有更多拨云见日的机会.</p>
<p>代理类中方法调用的分派转发推演实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>$0 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">reflect</span>.<span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">thinkdevos</span>.<span class="title">java</span>.<span class="title">dynamicproxy</span>.<span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0; <span class="comment">//为了代理调用高效，这里缓存了接口方法的实例</span></span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method mN; <span class="comment">//同上还需要缓存hashCode,toString,equals方法实例</span></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//给静态变量mN赋值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; subClass = Class.forName(<span class="string">"com.thinkdevos.java.dynamicproxy.Subject"</span>);</span><br><span class="line">            Method m0 = subClass.getMethod(<span class="string">"doSomething"</span>);</span><br><span class="line">            ....</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Proxy$<span class="number">0</span>(java.lang.reflect.InvocationHandler handler) &#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过调用处理器调用</span></span><br><span class="line">            handler.invode(<span class="keyword">this</span>, mN, <span class="keyword">new</span> Object[] &#123;...&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler.invode(<span class="keyword">this</span>, mN, <span class="keyword">new</span> Object[] &#123;...&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用调用处理器调用方法时，在捕获方法本身抛出的异常后，还有可能有未知异常抛出，对于不支持的异常，必须抛 UndeclaredThrowableException 运行时异常.</p>
<p>代理类中方法调用的分派转发推演实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过调用处理器调用</span></span><br><span class="line">        handler.invode(<span class="keyword">this</span>, mN, <span class="keyword">new</span> Object[] &#123;...&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable thr) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就完成了对动态代理类的推演实现。<br>下面我们就实例验证一番，通过如下代码生成字节码文件<br><strong>工具类：</strong> 通过ProxyGenerator.generateProxyClass生成代理类字节数组并保存到文件中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Save proxy class to path</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path           path to save proxy class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxyClassName name of proxy class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces     interfaces of proxy class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">saveProxyClass</span><span class="params">(String path, String proxyClassName, Class[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (proxyClassName == <span class="keyword">null</span> || path == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get byte of proxy class</span></span><br><span class="line">        <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(proxyClassName, interfaces);</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">            out.write(classFile);</span><br><span class="line">            out.flush();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行生成Proxy$0.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyUtils.saveProxyClass(<span class="string">"/home/borney/tmp/Proxy$0.class"</span>, <span class="string">"Proxy$0"</span>,</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Subject.class&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <strong>javap -p Proxy$0</strong> 查看字节码文件基本信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>$0 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">reflect</span>.<span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">thinkdevos</span>.<span class="title">java</span>.<span class="title">dynamicproxy</span>.<span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.reflect.Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.reflect.Method m0;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> Proxy$<span class="number">0</span>(java.lang.reflect.InvocationHandler) <span class="keyword">throws</span> ;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> </span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125; <span class="keyword">throws</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <strong>javap -v Proxy$0</strong> 查看详细信息，我们主要看下调用处理器对doSomething调用和异常捕获处理(注释是自己加的，字节码文件中没有注释)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public final void doSomething() throws ;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_FINAL</span><br><span class="line">    Code:</span><br><span class="line">      stack=10, locals=2, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #16                 // Field java/lang/reflect/Proxy.h:Ljava/lang/reflect/InvocationHandler;</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: getstatic     #60                 // Field m3:Ljava/lang/reflect/Method;</span><br><span class="line">         8: aconst_null</span><br><span class="line">         /*</span><br><span class="line">         通过调用处理器调用方法</span><br><span class="line">         */</span><br><span class="line">         9: invokeinterface #28,  4           // InterfaceMethod java/lang/reflect/InvocationHandler.invoke:(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">        14: pop</span><br><span class="line">        15: return</span><br><span class="line">        16: athrow</span><br><span class="line">        17: astore_1</span><br><span class="line">        /*</span><br><span class="line">        抛出UndeclaredThrowableException异常</span><br><span class="line">        */</span><br><span class="line">        18: new           #42                 // class java/lang/reflect/UndeclaredThrowableException</span><br><span class="line">        21: dup</span><br><span class="line">        22: aload_1</span><br><span class="line">        23: invokespecial #45                 // Method java/lang/reflect/UndeclaredThrowableException.&quot;&lt;init&gt;&quot;:(Ljava/lang/Throwable;)V</span><br><span class="line">        26: athrow</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             0    16    16   Class java/lang/Error</span><br><span class="line">             0    16    16   Class java/lang/RuntimeException</span><br><span class="line">             0    16    17   Class java/lang/Throwable</span><br><span class="line">    Exceptions:</span><br><span class="line">      throws</span><br></pre></td></tr></table></figure>

<h1 id="动态代理的不足之处"><a href="#动态代理的不足之处" class="headerlink" title="动态代理的不足之处"></a>动态代理的不足之处</h1><p>动态代理只能支持接口的代理，这也是因为java的继承性本质所限制的，因为所有的动态代理类都继承了Proxy类，所以再也无法同时继承其他类.然而，我们不可否认动态代理设计的伟大之处，世上所有的事物都不可能完美.</p>
<h3 id="动态代理调用过程"><a href="#动态代理调用过程" class="headerlink" title="动态代理调用过程"></a>动态代理调用过程</h3><p>我们来看看究竟是怎么请水军的：</p>
<p><strong>Java提供了一个Proxy类，调用它的newInstance方法可以生成某个对象的代理对象,该方法需要三个参数：</strong></p>
<p><img src="../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/assets/1633a48b000a225c" alt="这里写图片描述"></p>
<ul>
<li>参数一：生成代理对象使用哪个类装载器【一般我们使用的是被代理类的装载器】</li>
<li>参数二：生成哪个对象的代理对象，通过接口指定【指定要被代理类的接口】</li>
<li>参数三：生成的代理对象的方法里干什么事【实现handler接口，我们想怎么实现就怎么实现】</li>
</ul>
<p>在编写动态代理之前，要明确几个概念：</p>
<ul>
<li><strong>代理对象拥有目标对象相同的方法【因为参数二指定了对象的接口，代理对象会实现接口的所有方法</strong></li>
<li><strong>用户调用代理对象的什么方法，都是在调用处理器的invoke方法。【被拦截】</strong></li>
<li><strong>使用JDK动态代理必须要有接口【参数二需要接口】</strong></li>
</ul>
<p>上面也说了：代理对象会实现接口的所有方法，这些实现的方法交由我们的<strong>handler</strong>来处理！</p>
<ul>
<li>所有通过动态代理<strong>实现的方法全部</strong>通过<code>invoke()</code>调用</li>
</ul>
<p><img src="../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/assets/1633a48b0016f799.webp" alt="img"></p>
<p>所以<strong>动态代理调用过程</strong>是这样子的：</p>
<p><img src="../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/assets/1633a48b00289f19" alt="img"></p>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>Adapter适配器为它所适配的对象提供了一个不同的接口，代理提供了与它的实体相同的接口。然而用于访问保护的代理可能会拒绝执行实体会执行的操作，因此它的接口可能只是实体的一个自己</li>
<li>Decorator，他们的实现类似，但是目的不同，Decorator是为对象添加一个或多个功能，而代理是控制对对象的访问。</li>
</ul>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h2 id="反省总结"><a href="#反省总结" class="headerlink" title="反省总结"></a>反省总结</h2><h1 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h1><p>我们之前写中文过滤器的时候，需要使用包装设计模式来设计一个request类。如果不是Servlet提供了实现类给我们，我们使用包装设计模式会比较麻烦。</p>
<p>现在我们学习了动态代理了，动态代理就是<strong>拦截直接访问对象，可以给对象进行增强的一项技能</strong></p>
<h2 id="中文过滤器"><a href="#中文过滤器" class="headerlink" title="中文过滤器"></a>中文过滤器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(<span class="keyword">final</span> ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">    HttpServletResponse response = (HttpServletResponse) resp;</span><br><span class="line"></span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//放出去的是代理对象</span></span><br><span class="line">    chain.doFilter((ServletRequest) Proxy.newProxyInstance(CharacterEncodingFilter.class.getClassLoader(), request.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是不是getParameter方法</span></span><br><span class="line">            <span class="keyword">if</span> (!method.getName().equals(<span class="string">"getParameter"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//不是就使用request调用</span></span><br><span class="line">               <span class="keyword">return</span> method.invoke(request, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否是get类型的</span></span><br><span class="line">            <span class="keyword">if</span> (!request.getMethod().equalsIgnoreCase(<span class="string">"get"</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span> method.invoke(request, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行到这里，只能是get类型的getParameter方法了。</span></span><br><span class="line">            String value = (String) method.invoke(request, args);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(value.getBytes(<span class="string">"ISO8859-1"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;), response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要讲解了代理模式的几个要点，其实还有一些细节的：比如“强制代理”(只能通过被代理对象找到代理对象，不能绕过代理对象直接访问被代理对象)。只是用得比较少，我就不说了~~</p>
<p>要实现动态代理必须要有接口的，<strong>动态代理是基于接口来代理的</strong>(实现接口的所有方法)，如果没有接口的话我们可以考虑cglib代理。</p>
<p>cglib代理也叫子类代理，<strong>从内存中构建出一个子类来扩展目标对象的功能</strong>！</p>
<p>这里我就不再贴出代码来了，因为cglib的代理教程也很多，与动态代理实现差不多<del>~</del></p>
<p>总的来说：代理模式是我们写代码中用得很多的一种模式了，Spring的AOP底层其实就是<strong>动态代理来实现</strong>的–&gt;面向切面编程。具体可参考我之前写的那篇文章：</p>
<p>其实只要记住一点：<strong>原有的对象需要额外的功能，想想动态代理这项技术</strong>！</p>
<h1 id="Java-Proxy"><a href="#Java-Proxy" class="headerlink" title="Java Proxy"></a>Java Proxy</h1><h2 id="newProxyInstance"><a href="#newProxyInstance" class="headerlink" title="newProxyInstance"></a>newProxyInstance</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/26/Java/框架/Spring：MVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/26/Java/框架/Spring：MVC/" class="post-title-link" itemprop="url">Spring：MVC</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-26 21:00:39" itemprop="dateCreated datePublished" datetime="2019-03-26T21:00:39+08:00">2019-03-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-05-09 20:44:14" itemprop="dateModified" datetime="2019-05-09T20:44:14+08:00">2019-05-09</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/26/Java/框架/Spring：MVC/" class="post-meta-item leancloud_visitors" data-flag-title="Spring：MVC">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/26/Java/框架/Spring：MVC/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/26/Java/框架/Spring：MVC/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="Spring-MVC原理"><a href="#Spring-MVC原理" class="headerlink" title="Spring MVC原理"></a>Spring MVC原理</h2><ul>
<li>客户端的所有请求都交给前端控制器DispatcherServlet处理，它会负责调用系统的其他模块来真正处理用户的请求</li>
<li>DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）</li>
<li>在这个地方，spring会通过HandlerAdapter对该处理进行封装</li>
<li>HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用</li>
<li>Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView包含了数据模型以及相应的视图的信息</li>
<li>ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作</li>
<li>当得到真正的视图对象后，DispatcherServlet会利用对象对模型数据进行渲染</li>
<li>客户端得到响应，可能是一个HTML或json或图片</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1. </p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/26/Java/框架/Spring：AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/26/Java/框架/Spring：AOP/" class="post-title-link" itemprop="url">Spring：AOP</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-26 21:00:39" itemprop="dateCreated datePublished" datetime="2019-03-26T21:00:39+08:00">2019-03-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-05-09 20:38:00" itemprop="dateModified" datetime="2019-05-09T20:38:00+08:00">2019-05-09</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/26/Java/框架/Spring：AOP/" class="post-meta-item leancloud_visitors" data-flag-title="Spring：AOP">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/26/Java/框架/Spring：AOP/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/26/Java/框架/Spring：AOP/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="AOP产生的背景"><a href="#AOP产生的背景" class="headerlink" title="AOP产生的背景"></a>AOP产生的背景</h1><p>为了能够更好地将系统级别的代码抽离出来，去掉与对象的耦合，就产生了面向AOP（面向切面）。如上图所示，OOP属于一种横向扩展，AOP是一种纵向扩展。AOP依托于OOP，进一步将系统级别的代码抽象出来，进行纵向排列，实现低耦合。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>日志、安全性、事务等</li>
</ul>
<h2 id="AOP-的家庭成员"><a href="#AOP-的家庭成员" class="headerlink" title="AOP 的家庭成员"></a>AOP 的家庭成员</h2><h3 id="PointCut"><a href="#PointCut" class="headerlink" title="PointCut"></a>PointCut</h3><p>即在哪个地方进行切入,它可以指定某一个点，也可以指定多个点。</p>
<p>比如类A的methord函数，当然一般的AOP与语言（AOL）会采用多用方式来定义PointCut,比如说利用正则表达式，可以同时指定多个类的多个函数。</p>
<h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><p>在切入点干什么，指定在PointCut地方做什么事情（增强），打日志、执行缓存、处理异常等等。</p>
<h3 id="Advisor-Aspect"><a href="#Advisor-Aspect" class="headerlink" title="Advisor/Aspect"></a>Advisor/Aspect</h3><p>PointCut + Advice 形成了切面Aspect，这个概念本身即代表切面的所有元素。但到这一地步并不是完整的，因为还不知道如何将切面植入到代码中，解决此问题的技术就是PROXY</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 即代理，其不能算做AOP的家庭成员，更相当于一个管理部门，它管理 了AOP的如何融入OOP。之所以将其放在这里，是因为Aspect虽然是面向切面核心思想的重要组成部分，但其思想的践行者却是Proxy,也是实现AOP的难点与核心据在。</p>
<h1 id="AOP的技术实现"><a href="#AOP的技术实现" class="headerlink" title="AOP的技术实现"></a>AOP的技术实现</h1><p>AOP仅仅是一种思想，那为了让这种思想发光，必然脱离语言本身的技术支持，Java在实现该技术时就是采用的代理Proxy,那我们就去了解一下，如何通过代理实现面向切面。</p>
<ul>
<li><strong>由于静态代理需要实现目标对象的相同接口，那么可能会导致代理类会非常非常多….不好维护</strong>—-&gt;因此出现了动态代理</li>
<li>动态代理也有个约束：<strong>目标对象一定是要有接口的，没有接口就不能实现动态代理</strong>…..—–&gt;因此出现了cglib代理</li>
<li>cglib代理也叫子类代理，<strong>从内存中构建出一个子类来扩展目标对象的功能！</strong><ul>
<li><strong>CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。</strong></li>
</ul>
</li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>就像我们去买二手房要经过中介一样，房主将房源委托给中介，中介将房源推荐给买方。中间的任何手续的承办都由中介来处理，不需要我们和房主直接打交道。无论对买方还是卖房都都省了很多事情，但同时也要付出代价，对于买房当然是中介费，对于代码的话就是性能。下面我们来介绍实现AOP的三种代理方式。</p>
<p>下面我就以买房的过程中需要打日志为例介绍三种代理方式</p>
<p>静态和动态是由代理产生的时间段来决定的。静态代理产生于代码编译阶段，即一旦代码运行就不可变了。下面我们来看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I want wo sell this house"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IPerson iPerson;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(PersonProxy.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PersonProxy</span><span class="params">(IPerson iPerson)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.iPerson = iPerson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Before Proxy"</span>);</span><br><span class="line">    iPerson.doSomething();</span><br><span class="line">    logger.info(<span class="string">"After Proxy"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PersonProxy personProxy = <span class="keyword">new</span> PersonProxy(<span class="keyword">new</span> Person());</span><br><span class="line">    personProxy.doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代理类我们实现了将日志代码集成到了目标类，但从上面我们可以看出它具有很大的局限性：需要固定的类编写接口（或许还可以接受，毕竟有提倡面向接口编程），需要实现接口的每一个函数（不可接受），同样会造成代码的大量重复，将会使代码更加混乱。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>那能否通过实现一次代码即可将logger织入到所有函数中呢，答案当然是可以的，此时就要用到java中的反射机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object delegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(delegate.getClass().getClassLoader(), delegate.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"Before Proxy"</span>);</span><br><span class="line">            result = method.invoke(delegate, args);</span><br><span class="line">            logger.info(<span class="string">"After Proxy"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PersonProxy personProxy = <span class="keyword">new</span> PersonProxy();</span><br><span class="line">        IPerson iperson = (IPerson) personProxy.bind(<span class="keyword">new</span> Person());</span><br><span class="line">        iperson.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的好处理时可以为我们生成任何一个接口的代理类，并将需要增强的方法织入到任意目标函数。但它仍然具有一个局限性，就是只有实现了接口的类，才能为其实现代理。</p>
<h2 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h2><p>CGLIB解决了动态代理的难题，它通过生成目标类子类的方式来实现来实现代理，而不是接口，规避了接口的局限性。<br>CGLIB是一个强大的高性能代码生成包，其在运行时期（非编译时期）生成被 代理对象的子类，并重写了被代理对象的所有方法，从而作为代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object delegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args,  MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Before Proxy"</span>);</span><br><span class="line">        Object result = methodProxy.invokeSuper(method, args);</span><br><span class="line">        logger.info(<span class="string">"After Proxy"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Person.class);</span><br><span class="line"></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> PersonProxy());</span><br><span class="line">        <span class="keyword">return</span> (Person) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure>

<p>当然CGLIB也具有局限性，对于无法生成子类的类（final类），肯定是没有办法生成代理子类的。</p>
<p>以上就是三种代理的实现方式，但千成别被迷惑了，在Spring AOP中这些东西已经被封装了，不需要我们自己实现。要不然得累死，但了解AOP的实现原理（即基于代理）还是很有必要的。</p>
<h1 id="Spring-AOP全面认知"><a href="#Spring-AOP全面认知" class="headerlink" title="Spring AOP全面认知"></a>Spring AOP全面认知</h1><h2 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h2><p>AOP称为面向切面编程，那我们怎么理解面向切面编程？？</p>
<p>我们可以先看看下面这段代码：</p>
<p><img src="assets/1639259ea5e927d8" alt="img"></p>
<p>我们学Java面向对象的时候，如果代码重复了怎么办啊？？可以分成下面几个步骤：</p>
<ul>
<li>1：抽取成方法</li>
<li>2：抽取类</li>
</ul>
<p>抽取成类的方式我们称之为：<strong>纵向抽取</strong></p>
<ul>
<li>通过继承的方式实现纵向抽取</li>
</ul>
<p>但是，我们现在的办法不行：即使抽取成类还是会出现重复的代码，因为这些逻辑(开始、结束、提交事务)<strong>依附在我们业务类的方法逻辑中</strong>！</p>
<p><img src="assets/1639259ea399586b" alt="img"></p>
<p>现在纵向抽取的方式不行了，AOP的理念：就是将<strong>分散在各个业务逻辑代码中相同的代码通过横向切割的方式</strong>抽取到一个独立的模块中！</p>
<p><img src="assets/1639259ea3e1fbcf" alt="img"></p>
<p>上面的图也很清晰了，将重复性的逻辑代码横切出来其实很容易(我们简单可认为就是封装成一个类就好了)，但我们要将这些<strong>被我们横切出来的逻辑代码融合到业务逻辑中</strong>，来完成和之前(没抽取前)一样的功能！这就是AOP首要解决的问题了！</p>
<h2 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h2><blockquote>
<p>被我们横切出来的逻辑代码融合到业务逻辑中，来完成和之前(没抽取前)一样的功能</p>
</blockquote>
<p>没有学Spring AOP之前，我们就可以使用代理来完成。</p>
<ul>
<li>代理能干嘛？代理可以帮我们<strong>增强对象的行为</strong>！</li>
<li>使用动态代理实质上就是<strong>调用时拦截对象方法，对方法进行改造、增强</strong>！</li>
</ul>
<p>其实Spring AOP的底层原理就是<strong>动态代理</strong>！</p>
<p>来源《精通Spring4.x 企业应用开发实战》一段话：</p>
<blockquote>
<p>Spring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器，它在<strong>运行期通过代理方式向目标类织入增强代码</strong>。在Spring中可以无缝地将Spring AOP、IoC和AspectJ整合在一起。</p>
</blockquote>
<p>来源《Spring 实战 (第4版)》一句话：</p>
<blockquote>
<p>Spring AOP构建在动态代理基础之上，因此，<strong>Spring对AOP的支持局限于方法拦截</strong>。</p>
</blockquote>
<p>在Java中动态代理有<strong>两种</strong>方式：</p>
<ul>
<li>JDK动态代理</li>
<li>CGLib动态代理</li>
</ul>
<p><img src="assets/1639259ea4fdea1d" alt="img"></p>
<p>JDK动态代理是需要实现某个接口了，而我们类未必全部会有接口，于是CGLib代理就有了~~</p>
<ul>
<li>CGLib代理其生成的动态代理对象是目标类的子类</li>
<li>Spring AOP<strong>默认是使用JDK动态代理</strong>，如果代理的类<strong>没有接口则会使用CGLib代理</strong>。</li>
</ul>
<p>那么JDK代理和CGLib代理我们该用哪个呢？？在《精通Spring4.x 企业应用开发实战》给出了建议：</p>
<ul>
<li>如果是<strong>单例的我们最好使用CGLib代理</strong>，如果是多例的我们最好使用JDK代理</li>
</ul>
<p>原因：</p>
<ul>
<li>JDK在创建代理对象时的性能要高于CGLib代理，而生成代理对象的运行性能却比CGLib的低。</li>
<li>如果是单例的代理，推荐使用CGLib</li>
</ul>
<p>看到这里我们就应该知道什么是Spring AOP(面向切面编程)了：<strong>将相同逻辑的重复代码横向抽取出来，使用动态代理技术将这些重复代码织入到目标对象方法中，实现和原来一样的功能</strong>。</p>
<ul>
<li>这样一来，我们就在<strong>写业务时只关心业务代码</strong>，而不用关心与业务无关的代码</li>
</ul>
<h2 id="AOP的实现者"><a href="#AOP的实现者" class="headerlink" title="AOP的实现者"></a>AOP的实现者</h2><p>AOP除了有Spring AOP实现外，还有著名的AOP实现者：AspectJ，也有可能大家没听说过的实现者：JBoss AOP~~</p>
<p>我们下面来说说AspectJ扩展一下知识面：</p>
<blockquote>
<p>AspectJ是<strong>语言级别</strong>的AOP实现，扩展了Java语言，定义了AOP语法，能够在<strong>编译期</strong>提供横切代码的织入，所以它有<strong>专门的编译器</strong>用来生成遵守Java字节码规范的Class文件。</p>
</blockquote>
<p>而Spring借鉴了AspectJ很多非常有用的做法，<strong>融合了AspectJ实现AOP的功能</strong>。但Spring AOP本质上<strong>底层还是动态代理</strong>，所以Spring AOP是不需要有专门的编辑器的~</p>
<h2 id="AOP的术语"><a href="#AOP的术语" class="headerlink" title="AOP的术语"></a>AOP的术语</h2><p>嗯，AOP搞了好几个术语出来~~两本书都有讲解这些术语，我会尽量让大家看得明白的：</p>
<p><strong>连接点</strong>(Join point)：</p>
<ul>
<li><strong>能够被拦截的地方</strong>：Spring AOP是基于动态代理的，所以是方法拦截的。每个成员方法都可以称之为连接点~</li>
</ul>
<p><strong>切点</strong>(Poincut)：</p>
<ul>
<li><strong>具体定位的连接点</strong>：上面也说了，每个方法都可以称之为连接点，我们<strong>具体定位到某一个方法就成为切点</strong>。</li>
</ul>
<p><strong>增强/通知</strong>(Advice)：</p>
<ul>
<li>表示添加到切点的一段逻辑代码，并定位连接点的方位信息。 <ul>
<li>简单来说就定义了是干什么的，具体是在哪干</li>
<li>Spring AOP提供了5种Advice类型给我们：前置、后置、返回、异常、环绕给我们使用！</li>
</ul>
</li>
</ul>
<p><strong>织入</strong>(Weaving)：</p>
<ul>
<li>将<code>增强/通知</code>添加到目标类的具体连接点上的过程。</li>
</ul>
<p><strong>引入/引介</strong>(Introduction)：</p>
<ul>
<li><code>引入/引介</code>允许我们<strong>向现有的类添加新方法或属性</strong>。是一种<strong>特殊</strong>的增强！</li>
</ul>
<p><strong>切面</strong>(Aspect)：</p>
<ul>
<li>切面由切点和<code>增强/通知</code>组成，它既包括了横切逻辑的定义、也包括了连接点的定义。</li>
</ul>
<p>在《Spring 实战 (第4版)》给出的总结是这样子的：</p>
<blockquote>
<p>通知/增强包含了需要用于多个应用对象的横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知/增强被应用的具体位置。其中关键的是切点定义了哪些连接点会得到通知/增强。</p>
</blockquote>
<p>总的来说：</p>
<ul>
<li>这些术语可能翻译过来不太好理解，但对我们正常使用AOP的话<strong>影响并没有那么大</strong>~~看多了就知道它是什么意思了。</li>
</ul>
<h2 id="Spring对AOP的支持"><a href="#Spring对AOP的支持" class="headerlink" title="Spring对AOP的支持"></a>Spring对AOP的支持</h2><p>Spring提供了3种类型的AOP支持：</p>
<ul>
<li><p>基于代理的经典SpringAOP </p>
<ul>
<li>需要实现接口，手动创建代理</li>
</ul>
</li>
<li><p>纯POJO切面 </p>
<ul>
<li>使用XML配置，aop命名空间</li>
</ul>
</li>
<li><p>@AspectJ</p>
<p>注解驱动的切面 </p>
<ul>
<li>使用注解的方式，这是最简洁和最方便的！</li>
</ul>
</li>
</ul>
<h1 id="基于代理的经典SpringAOP"><a href="#基于代理的经典SpringAOP" class="headerlink" title="基于代理的经典SpringAOP"></a>基于代理的经典SpringAOP</h1><p>这部分配置比较麻烦，用起来也很麻烦，这里我就主要整理一下书上的内容，大家看看了解一下吧，我们实际上使用Spring AOP基本不用这种方式了！</p>
<p>首先，我们来看一下增强接口的继承关系图：</p>
<p><img src="assets/1639259edfbea6f0" alt="img"></p>
<p>可以分成<strong>五类</strong>增强的方式：</p>
<p><img src="assets/1639259ea8ffc354" alt="img"></p>
<p>Spring提供了<strong>六种的切点类型</strong>：</p>
<p><img src="assets/163925a0307e7c6e" alt="img"></p>
<p><strong>切面类型主要分成了三种</strong>：</p>
<ul>
<li><strong>一般切面</strong></li>
<li><strong>切点切面</strong></li>
<li><strong>引介/引入切面</strong></li>
</ul>
<p><img src="assets/1639259f25f81c96" alt="img"></p>
<p>一般切面，切点切面，引介/引入切面介绍：</p>
<p><img src="assets/1639259f27c9deaf" alt="img"></p>
<p><img src="assets/1639259f334512f0" alt="img"></p>
<p>对于切点切面我们一般都是直接用就好了，我们来看看引介/引入切面是怎么一回事：</p>
<ul>
<li>引介/引入切面是引介/引入增强的封装器，通过引介/引入切面，<strong>可以更容易地为现有对象添加任何接口的实现</strong>！</li>
</ul>
<p>继承关系图：</p>
<p><img src="assets/1639259f3be5cbb2" alt="img"></p>
<p>引介/引入切面有两个实现类：</p>
<ul>
<li>DefaultIntroductionAdvisor：常用的实现类</li>
<li>DeclareParentsAdvisor：用于实现AspectJ语言的DeclareParent注解表示的引介/引入切面</li>
</ul>
<p>实际上，我们使用AOP往往是<strong>Spring内部使用BeanPostProcessor帮我们创建代理</strong>。</p>
<p>这些代理的创建器可以分成三类：</p>
<ul>
<li>基于Bean配置名规则的自动代理创建器：BeanNameAutoProxyCreator</li>
<li>基于Advisor匹配机制的自动代理创建器：它会对容器所有的Advisor进行扫描，实现类为DefaultAdvisorAutoProxyCreator</li>
<li>基于Bean中的AspectJ注解标签的自动代理创建器：AnnotationAwareAspectJAutoProxyCreator</li>
</ul>
<p>对应的类继承图：</p>
<p><img src="assets/1639259f48e7ef5a" alt="img"></p>
<p>嗯，基于代理的经典SpringAOP就讲到这里吧，其实我是不太愿意去写这个的，因为已经几乎不用了，在《Spring 实战 第4版》也没有这部分的知识点了。</p>
<ul>
<li>但是通过这部分的知识点可以<strong>更加全面地认识Spring AOP的各种接口</strong>吧~</li>
</ul>
<h1 id="拥抱基于注解和命名空的AOP编程"><a href="#拥抱基于注解和命名空的AOP编程" class="headerlink" title="拥抱基于注解和命名空的AOP编程"></a>拥抱基于注解和命名空的AOP编程</h1><p>Spring在新版本中对AOP功能进行了增强，体现在这么几个方面：</p>
<ul>
<li>在XML配置文件中为AOP提供了aop命名空间</li>
<li>增加了AspectJ切点表达式语言的支持</li>
<li>可以无缝地集成AspectJ</li>
</ul>
<p>那我们使用<code>@AspectJ</code>来玩AOP的话，学什么？？其实也就是上面的内容，学如何设置切点、创建切面、增强的内容是什么…</p>
<p><img src="assets/1639259f3916db2c" alt="img"></p>
<p>具体的切点表达式使用还是前往：<a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4Njg5MDA5NA%3D%3D%26mid%3D2247483954%26idx%3D1%26sn%3Db34e385ed716edf6f58998ec329f9867%26chksm%3Debd74333dca0ca257a77c02ab458300ef982adff3cf37eb6d8d2f985f11df5cc07ef17f659d4%23rd" target="_blank" rel="noopener">Spring【AOP模块】就这么简单</a>看吧~~</p>
<p>对应的增强注解：</p>
<p><img src="assets/1639259f856b96ea" alt="img"></p>
<p><img src="assets/1639259f85f3f536" alt="img"></p>
<h2 id="使用引介-引入功能实现为Bean引入新方法"><a href="#使用引介-引入功能实现为Bean引入新方法" class="headerlink" title="使用引介/引入功能实现为Bean引入新方法"></a>使用引介/引入功能实现为Bean引入新方法</h2><p>其实前置啊、后置啊这些很容易就理解了，整篇文章看下来就只有这个引介/引入切面有点搞头。于是我们就来玩玩吧~</p>
<p>我们来看一下具体的用法吧，现在我有个服务员的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Waiter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向客人打招呼</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greetTo</span><span class="params">(String clientName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serveTo</span><span class="params">(String clientName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一位年轻服务员实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NaiveWaiter</span> <span class="keyword">implements</span> <span class="title">Waiter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetTo</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"NaiveWaiter:greet to "</span> + clientName + <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NeedTest</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serveTo</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"NaiveWaiter:serving "</span> + clientName + <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我想做的就是：<strong>想这个服务员可以充当售货员的角色，可以卖东西</strong>！当然了，我肯定不会加一个卖东西的方法到Waiter接口上啦，因为这个是暂时的~</p>
<p>所以，我搞了一个售货员接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Seller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 卖东西</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sell</span><span class="params">(String goods, String clientName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个售货员实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartSeller</span> <span class="keyword">implements</span> <span class="title">Seller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 卖东西</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sell</span><span class="params">(String goods,String clientName)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"SmartSeller: sell "</span>+goods +<span class="string">" to "</span>+clientName+<span class="string">"..."</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们的类图是这样子的：</p>
<p><img src="assets/1639259f88bcecc8" alt="img"></p>
<p>现在我想干的就是：<strong>借助AOP的引入/引介切面，来让我们的服务员也可以卖东西</strong>！</p>
<p>我们的引入/引介切面具体是这样干的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableSellerAspect</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@DeclareParents</span>(value = <span class="string">"com.smart.NaiveWaiter"</span>,  <span class="comment">// 指定服务员具体的实现</span></span><br><span class="line">            defaultImpl = SmartSeller.class) <span class="comment">// 售货员具体的实现</span></span><br><span class="line">    <span class="keyword">public</span> Seller seller; <span class="comment">// 要实现的目标接口</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写了这个切面类会发生什么？？</p>
<ul>
<li>切面技术将SmartSeller融合到NaiveWaiter中，这样<strong>NaiveWaiter就实现了Seller接口</strong>！！！！</li>
</ul>
<p>是不是很神奇？？我也觉得很神奇啊，我们来测试一下：</p>
<p>我们的<code>bean.xml</code>文件很简单：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">	xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">	xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">	xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd"</span>&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy/&gt;</span><br><span class="line">	&lt;bean id=<span class="string">"waiter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.NaiveWaiter"</span>/&gt;</span><br><span class="line">	&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.aspectj.basic.EnableSellerAspect"</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/smart/aspectj/basic/beans.xml"</span>);</span><br><span class="line">        Waiter waiter = (Waiter) ctx.getBean(<span class="string">"waiter"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用服务员原有的方法</span></span><br><span class="line">        waiter.greetTo(<span class="string">"Java3y"</span>);</span><br><span class="line">        waiter.serveTo(<span class="string">"Java3y"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过引介/引入切面已经将waiter服务员实现了Seller接口，所以可以强制转换</span></span><br><span class="line">        Seller seller = (Seller) waiter;</span><br><span class="line">        seller.sell(<span class="string">"水军"</span>, <span class="string">"Java3y"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="assets/1639259fa6f87c3a" alt="img"></p>
<p>具体的调用过程是这样子的：</p>
<blockquote>
<p>当引入接口方法被调用时，代理对象会把此调用委托给实现了新接口的某个其他对象。实际上，一个Bean的实现被拆分到多个类中</p>
</blockquote>
<p><img src="assets/1639259faa1e4069" alt="img"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看起来AOP有很多很多的知识点，其实我们只要记住AOP的核心概念就行啦。</p>
<p>下面是我的简要总结AOP：</p>
<ul>
<li>AOP的底层实际上是动态代理，动态代理分成了JDK动态代理和CGLib动态代理。如果被代理对象没有接口，那么就使用的是CGLIB代理(也可以直接配置使用CBLib代理)</li>
<li>如果是单例的话，那我们最好使用CGLib代理，因为CGLib代理对象运行速度要比JDK的代理对象要快</li>
<li>AOP既然是基于动态代理的，那么它只能对方法进行拦截，它的层面上是方法级别的</li>
<li>无论经典的方式、注解方式还是XML配置方式使用Spring AOP的原理都是一样的，只不过形式变了而已。一般我们使用注解的方式使用AOP就好了。</li>
<li>注解的方式使用Spring AOP就了解几个切点表达式，几个增强/通知的注解就完事了，是不是贼简单…使用XML的方式和注解其实没有很大的区别，很快就可以上手啦。</li>
<li>引介/引入切面也算是一个比较亮的地方，可以用代理的方式为某个对象实现接口，从而能够使用借口下的方法。这种方式是非侵入式的~</li>
<li>要增强的方法还可以接收与被代理方法一样的参数、绑定被代理方法的返回值这些功能…</li>
</ul>
<p>最后，将我们上一次IOC的思维导图补充AOP的知识点上去吧<del>~</del></p>
<p><img src="assets/163925ac9488dccf" alt="img"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://juejin.im/post/5aa8edf06fb9a028d0432584" target="_blank" rel="noopener">Spring【AOP模块】就是这么简单</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/26/Java/框架/Spring：IOC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/26/Java/框架/Spring：IOC/" class="post-title-link" itemprop="url">Unbenannt</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-26 21:00:29" itemprop="dateCreated datePublished" datetime="2019-03-26T21:00:29+08:00">2019-03-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-05-10 15:54:06" itemprop="dateModified" datetime="2019-05-10T15:54:06+08:00">2019-05-10</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/26/Java/框架/Spring：IOC/" class="post-meta-item leancloud_visitors" data-flag-title="">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/26/Java/框架/Spring：IOC/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/26/Java/框架/Spring：IOC/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p><strong><em>IOC的理论背景</em></strong></p>
<p>我们知道在面向对象设计的软件系统中，它的底层都是由N个对象构成的，各个对象之间通过相互合作，最终实现系统地业务逻辑。</p>
<p><img src="../%E6%A1%86%E6%9E%B6/assets/30130748-488045b61d354b019a088b9cb7fc2d73.png" alt="img"></p>
<p>　　                            图1 软件系统中耦合的对象</p>
<p>如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。</p>
<p>齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。</p>
<p><img src="../%E6%A1%86%E6%9E%B6/assets/30131157-f547678cffaf421b89373e3bb308757d.png" alt="img"></p>
<p>　　                                    图2 对象之间的依赖关系</p>
<p>耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson 1996年提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中。</p>
<h2 id="为什么要用（作用）"><a href="#为什么要用（作用）" class="headerlink" title="为什么要用（作用）"></a>为什么要用（作用）</h2><p>IOC使得对象只需要发挥自己的特长即可</p>
<p>让你脱离对依赖对象的维护，只需要随用随取，不需要关心依赖对象的任何过程。（是不是感觉特别简单）</p>
<p><img src="assets/a38f263e5e9ed2725b03" alt="img"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><h3 id="什么是IOC-1"><a href="#什么是IOC-1" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</p>
<p>1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p>
<p>IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：</p>
<p><img src="../%E6%A1%86%E6%9E%B6/assets/30131727-a8268fe6370049028078e6b8a1cbc88f.png" alt="img"></p>
<p>​                                    图3 IOC解耦过程</p>
<p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p>
<p>我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：</p>
<p><img src="../%E6%A1%86%E6%9E%B6/assets/30132051-58562511cc6541fdb2636081e455d808.png" alt="img"></p>
<p>​                                图4 拿掉IOC容器后的系统</p>
<p>我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！</p>
<p>我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：</p>
<p>软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p>
<p>软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p>
<p>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p>
<h4 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h4><p>IOC为控制反转，把传统意义上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。由容器动态地将某种依赖关系注入到组件中</p>
<h4 id="什么是IOC容器"><a href="#什么是IOC容器" class="headerlink" title="什么是IOC容器"></a>什么是IOC容器</h4><p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p>
<p>IOC容器支持加载服务时的饿汉式初始化和懒加载。</p>
<h4 id="Spring实现"><a href="#Spring实现" class="headerlink" title="Spring实现"></a>Spring实现</h4><p>spring的IOC容器种类</p>
<ul>
<li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li>
<li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li>
</ul>
<table>
<thead>
<tr>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td>它使用懒加载</td>
<td>它使用即时加载</td>
</tr>
<tr>
<td>它使用语法显式提供资源对象</td>
<td>它自己创建和管理资源对象</td>
</tr>
<tr>
<td>不支持国际化</td>
<td>支持国际化</td>
</tr>
<tr>
<td>不支持基于依赖的注解</td>
<td>支持基于依赖的注解</td>
</tr>
</tbody></table>
<h4 id="IOC也叫依赖注入-DI"><a href="#IOC也叫依赖注入-DI" class="headerlink" title="IOC也叫依赖注入(DI)"></a>IOC也叫依赖注入(DI)</h4><p>2004年，Martin Fowler探讨了同一个问题，既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p>
<p>学过IOC的人可能都看过Martin Fowler(老马,2004年post)的这篇文章：Inversion of Control Containers and the Dependency Injection pattern[2]。</p>
<p>博客园的园友EagleFish(邢瑜琨)的文章： <a href="http://www.cnblogs.com/xingyukun/archive/2007/10/20/931331.html" target="_blank" rel="noopener">深度理解依赖注入（Dependence Injection）</a>[3]对老马那篇经典文章进行了解读。</p>
<p>CSDN黄忠成的<a href="http://blog.csdn.net/Code6421/article/details/1282139" target="_blank" rel="noopener">Inside ObjectBuilder</a>[4]也是，不过他应该来自台湾省，用的是繁体，看不管繁体中文的，可以看园中的吕震宇博友的简体中文版<a href="http://www.cnblogs.com/zhenyulu/articles/641728.html" target="_blank" rel="noopener">[转]Object Builder Application Block</a>[5] 。</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="优缺"><a href="#优缺" class="headerlink" title="优缺"></a>优缺</h2><p><strong><em>优点</em></strong></p>
<ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载服务。</li>
</ul>
<p><strong><em>缺点</em></strong></p>
<p>使用IOC框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架[1]。</p>
<ol>
<li>软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。</li>
<li>由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。</li>
<li>具体到IOC框架产品(比如：Spring)来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。</li>
<li>IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。</li>
</ol>
<p>我们大体可以得出这样的结论：</p>
<ul>
<li>一些工作量不大的项目或者产品，不太适合使用IOC框架产品。</li>
<li>如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。</li>
<li>最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，像WEB2.0网站就是这种情况。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>IOC的技术实现方式</strong></p>
<ul>
<li>构造函数注入</li>
<li>setter注入</li>
<li>接口注入</li>
</ul>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p>
<ul>
<li>通过反射创造实例</li>
<li>获取需要注入的接口实现类并将其赋值给该接口</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span> </span>&#123;</span><br><span class="line">        Fruit f=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">"io.github.dunwu.spring.Apple"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>Spring 中的 IOC的实现原理就是工厂模式加反射机制。</p>
<p>IOC中最基本的技术就是“<strong>反射(Reflection)</strong>”编程，目前.Net C#、Java和PHP5等语言均支持，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。反射的应用是很广泛的，很多的成熟的框架，比如象Java中的Hibernate、Spring框架，.Net中 NHibernate、Spring.Net框架都是把“反射”做为最基本的技术手段。</p>
<h3 id="IOC容器的实现"><a href="#IOC容器的实现" class="headerlink" title="IOC容器的实现"></a>IOC容器的实现</h3><p>需要实现的两个关键技术， 以明确服务的对象是谁、需要为服务对象提供什么样的服务</p>
<ul>
<li>对象的构建</li>
<li>对象的绑定</li>
</ul>
<p>实现方式</p>
<ul>
<li>硬编码</li>
<li>配置文件</li>
<li>注解</li>
</ul>
<h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a><strong><em>BeanFactory</em></strong></h4><p>如果没有特殊指定，默认采用<strong>延迟初始化策略</strong>(lazy-load)。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需 要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的 IoC容器选择。</p>
<p>我们先来看一下BeanFactory类的关系图（如下所示）</p>
<p><img src="assets/3333737d8fe878650122" alt="img"></p>
<ul>
<li>BeanDefinition 实现Bean的定义（即对象的定义）,且完成了对依赖的定义</li>
<li>BeanDefinitionRegistry ，将定义好的bean，注册到容器中（此时会生成一个注册码）</li>
<li>BeanFactory 是一个bean工厂类，从中可以取到任意定义过的bean</li>
</ul>
<p>最重要的部分就是BeanDefinition,它完成了Bean的生成过程。一般情况下我们都是通过配置文件（xml,properties）的方式对bean进行配置，每种文件都需要实现BeanDefinitionReader，因此是reader本身现了配置文字 到bean对象的转换过程。当然我们自己也可以实现任意格式的配置文件，只需要自己来实现reader即可。</p>
<p>Bean的生成大致可以分为两个阶段：容器启动阶段和bean实例化阶段</p>
<p><img src="assets/6f0b054681ea42090ded" alt="img"></p>
<p><strong>容器启动阶段：</strong></p>
<p>只完成bean的定义</p>
<ul>
<li>加载配置文件（通常是xml文件）</li>
<li>通过reader生成beandefinition</li>
<li>beanDefinition注册到beanDefinitionRegistry</li>
</ul>
<p><strong>bean实例化阶段：</strong></p>
<p>完成bean的初始化</p>
<ul>
<li>当某个bean 被 getBean()调用时</li>
<li>bean需要完成初时化，以及其依赖对象的初始化</li>
<li>如果bean本身有回调，还需要调用其相应的回调函数</li>
</ul>
<p>Spring Ioc在初始化完成之后，给了我们提供一些方法，让我们来改变一些bean的定义org.springframework.beans.factory.config.PropertyPlaceholderConfigurer：使我们可能通过配置文件的形式，配置一些参数</p>
<ul>
<li>PropertyOverrideConfigurer ：则可以覆盖原本的bean参数</li>
<li>CustomEditorConfigurer ：则提供类型转换支持（配置文件都是string,它需要知道转换成何种类型）</li>
</ul>
<p><strong>Bean的初始化过程：</strong></p>
<p><img src="assets/06ebc4a3c94e5662382d" alt="img"></p>
<p>如果你认为实例化的对象就是通过我们定义的类new 出来的，那就大错特错了，其实这里用到了AOP机制，生成了其代理对象（<strong>通过反射机制生成接口对象，或者是通过CGLIB生成子对象</strong>）</p>
<ul>
<li>bean的具体装载过程是由beanWrapper实现的，它继承了PropertyAccessor （可以对属性进行访问）、PropertyEditorRegistry 和TypeConverter接口 （实现类型转换，就上前面说的）。</li>
<li>完成设置对象属性之后，则会检查是否实现了Aware类型的接口，如果实现了，则主动加载</li>
<li>BeanPostprocessor 可以帮助完成在初始化bean之前或之后 帮我们完成一些必要工作，比如我们在连接数据库之前将密码存放在一个加密文件，当我们连接数据库之前，需要将密码进行加载解密。只要实现 相应的接口即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean</span></span><br><span class="line"><span class="comment">    * initialization callbacks (like InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment">    * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class="line"><span class="comment">    * The returned bean instance may be a wrapper around the original.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bean the new bean instance</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the bean instance to use, either the original or a wrapped one; if</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean</span></span><br><span class="line"><span class="comment">    * initialization callbacks (like InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment">    * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class="line"><span class="comment">    * The returned bean instance may be a wrapper around the original.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean</span></span><br><span class="line"><span class="comment">    * instance and the objects created by the FactoryBean (as of Spring 2.0). The</span></span><br><span class="line"><span class="comment">    * post-processor can decide whether to apply to either the FactoryBean or created</span></span><br><span class="line"><span class="comment">    * objects or both through corresponding &#123;<span class="doctag">@code</span> bean instanceof FactoryBean&#125; checks.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&#125; method,</span></span><br><span class="line"><span class="comment">    * in contrast to all other BeanPostProcessor callbacks.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bean the new bean instance</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the bean instance to use, either the original or a wrapped one; if</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> org.springframework.beans.factory.FactoryBean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在完成postProcessor之后，则会看对象是否定义了InitializingBean 接口，如果是，则会调用其afterProper- tiesSet()方法进一步调整对象实例的状态 ，这种方式并不常见。spring还提供了另外一种指定初始化的方式，即在bean定义中指定init-method 。</li>
<li>当这一切完成之后，还可以指定对象销毁 的一些回调，比如数据库的连接池的配置，则销毁前需要关闭连接等。相应的可以实现DisposableBean 接口或指定destroy-method</li>
</ul>
<h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a><strong><em>ApplicationContext</em></strong></h4><p>ApplicationContext 容器建立BeanFactory之上，拥有BeanFactory的所有功能，但在实现上会有所差别。</p>
<p>我认为<strong>差别</strong>主要体现在两个方面：</p>
<ul>
<li>bean的生成方式；</li>
<li>扩展了BeanFactory的功能，提供了更多企业级功能的支持。</li>
<li>ApplicationContext采用的非懒加载方式。它会在启动阶段完成所有的初始化，并不会等到getBean()才执行<ul>
<li>所以，相对于BeanFactory来 说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容 器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中， ApplicationContext类型的容器是比较合适的选择。</li>
</ul>
</li>
</ul>
<p><strong><em>bean的加载方式</em></strong></p>
<p>BeanFactory提供BeanReader来从配置文件中读取bean配置。相应的ApplicationContext也提供几个读取配置文件的方式：</p>
<ul>
<li><p>FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径</p>
</li>
<li><p>ClassPathXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。</p>
</li>
<li><p>WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。</p>
</li>
<li><p>AnnotationConfigApplicationContext</p>
</li>
<li><p>ConfigurableWebApplicationContext</p>
<p><img src="assets/d30db7f74094dfcb7889" alt="img"></p>
<p>ApplicationContext 还额外增加了三个历能：</p>
</li>
<li><p>ApplicationEventPublisher</p>
</li>
<li><p>ResourceLoader</p>
</li>
<li><p>MessageResource</p>
</li>
</ul>
<h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a><strong><em>ResourceLoader</em></strong></h3><p>ResourceLoader并不能将其看成是Spring独有的功能，spring Ioc只是借助于ResourceLoader来实现资源加载。也提供了各种各样的资源加载方式：</p>
<ul>
<li><p>DefaultResourceLoader 首先检查资源路径是否以classpath:前缀打头，如果是，则尝试构造ClassPathResource类 型资源并返回。否则， 尝试通过URL，根据资源路径来定位资源 </p>
</li>
<li><p>FileSystemResourceLoader 它继承自Default-ResourceLoader，但覆写了getResourceByPath(String)方法，使之从文件系统加载资源并以 FileSystemResource类型返回 </p>
<ul>
<li><p>ResourcePatternResolver  批量查找的ResourceLoader</p>
<p><img src="assets/efb2c685e23f1028dca6" alt="img"></p>
<p>spring与ResourceLoader之间的关系</p>
<p><img src="assets/a9a3d098dbaf18b3f343" alt="img"></p>
<p>所有ApplicationContext的具体实现类都会直接或者间接地实现AbstractApplicationContext,AbstactApplicationContext 依赖了了DeffaultResourceLoader, ApplicationContext 继承了ResourcePatternResolver,所到头来ApplicationContext的具体实现类都会具有DefaultResourceLoader 和 PathMatchingResourcePatterResolver的功能。这也就是会什么ApplicationContext可以实现统一资源定位。</p>
</li>
</ul>
</li>
</ul>
<p><strong><em>ApplicationEventPublisher（在介绍spring事件的时候再详细讲）</em></strong></p>
<ol>
<li>ApplicationEvent：继承自EventObject，同时是spring的application中事件的父类，需要被自定义的事件继承。 </li>
<li>ApplicationListener：继承自EventListener，spring的application中的监听器必须实现的接口，需要被自定义的监听器实现其onApplicationEvent方法 </li>
<li>ApplicationEventPublisherAware：在spring的context中希望能发布事件的类必须实现的接口，该接口中定义了设置ApplicationEventPublisher的方法，由ApplicationContext调用并设置。在自己实现的ApplicationEventPublisherAware子类中，需要有ApplicationEventPublisher属性的定义。 </li>
<li>ApplicationEventPublisher：spring的事件发布者接口，定义了发布事件的接口方法publishEvent。因为ApplicationContext实现了该接口，因此spring的ApplicationContext实例具有发布事件的功能(publishEvent方法在AbstractApplicationContext中有实现)。在使用的时候，只需要把ApplicationEventPublisher的引用定义到ApplicationEventPublisherAware的实现中，spring容器会完成对ApplicationEventPublisher的注入。</li>
</ol>
<p><strong><em>MessageSource</em></strong></p>
<p>提供国际化支持，不讲了，有需要请转至：<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.sina.com.cn%2Fs%2Fblog_85d71fb70101cyp5.html" target="_blank" rel="noopener">blog.sina.com.cn/s/blog_85d7…</a></p>
<p># 四、最佳实践<br>注解扫描</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-2.5.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.spring21"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>component/service/controller注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Food food;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFood</span><span class="params">(Food food)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.food = food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bean的前置后置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Food food;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">setFood</span><span class="params">(Food food)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.food = food;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"饭前洗手"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"饭后刷牙"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IOC容器的初始化过程"><a href="#IOC容器的初始化过程" class="headerlink" title="IOC容器的初始化过程"></a>IOC容器的初始化过程</h4><p>Resource 定位：我们一般使用外部资源来描述 Bean 对象，所以 IOC 容器第一步就是需要定位 Resource 外部资源 。Resource 的定位其实就是 BeanDefinition 的资源定位，它是由 ResourceLoader 通过统一的 Resource 接口来完成的，这个 Resource 对各种形式的 BeanDefinition 的使用都提供了统一接口 。</p>
<p>载入：第二个过程就是 BeanDefinition 的载入 ,BeanDefinitionReader 读取 , 解析 Resource 定位的资源，也就是将用户定义好的 Bean 表示成 IOC 容器的内部数据结构也就是 BeanDefinition, 在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，通过这样的数据结构， IOC 容器能够对 Bean 进行更好的管理 。 在配置文件中每一个都对应着一个 BeanDefinition 对象 。</p>
<p>注册：第三个过程则是注册，即向 IOC 容器注册这些 BeanDefinition ，这个过程是通过 BeanDefinitionRegistery 接口来实现的 。</p>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="深度理解依赖注入（Dependence-Injection）"><a href="#深度理解依赖注入（Dependence-Injection）" class="headerlink" title="深度理解依赖注入（Dependence Injection）"></a>深度理解依赖注入（Dependence Injection）</h3><h4 id="依赖在哪里"><a href="#依赖在哪里" class="headerlink" title="依赖在哪里"></a>依赖在哪里</h4><p>  老马举了一个小例子，是开发一个电影列举器（MovieList），这个电影列举器需要使用一个电影查找器（MovieFinder）提供的服务，伪码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*服务的接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">  <span class="function">ArrayList <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*服务的消费者*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Movie[] moviesDirectedBy(String arg) &#123;</span><br><span class="line">      List allMovies = finder.findAll();</span><br><span class="line">    <span class="keyword">for</span> (Iterator it = allMovies.iterator(); it.hasNext();) &#123;</span><br><span class="line">         Movie movie = (Movie) it.next();</span><br><span class="line">         <span class="keyword">if</span> (!movie.getDirector().equals(arg)) it.remove();</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> (Movie[]) allMovies.toArray(<span class="keyword">new</span> Movie[allMovies.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*消费者内部包含一个将指向具体服务类型的实体对象*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> MovieFinder finder;</span><br><span class="line">    <span class="comment">/*消费者需要在某一个时刻去实例化具体的服务。这是我们要解耦的关键所在，</span></span><br><span class="line"><span class="comment">    *因为这样的处理方式造成了服务消费者和服务提供者的强耦合关系（这种耦合是在编译期就确定下来的）。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieLister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finder = <span class="keyword">new</span> ColonDelimitedMovieFinder(<span class="string">"movies1.txt"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码的注释中可以看到，MovieLister和ColonDelimitedMovieFinder（这可以使任意一个实现了MovieFinder接口的类型）之间存在强耦合关系，如下图所示：</p>
<p><img src="../%E6%A1%86%E6%9E%B6/assets/dependency.gif" alt="img"></p>
<p>这使得MovieList很难作为一个成熟的组件去发布，因为在不同的应用环境中（包括同一套软件系统被不同用户使用的时候），它所要依赖的电影查找器可能是千差万别的。所以，为了能实现真正的基于组件的开发，必须有一种机制能同时满足下面两个要求：</p>
<p> （1）解除MovieList对具体MoveFinder类型的强依赖（编译期依赖）。</p>
<p> （2）在运行的时候为MovieList提供正确的MovieFinder类型的实例。</p>
<p>换句话说，就是在运行的时候才产生MovieList和MovieFinder之间的依赖关系（把这种依赖关系在一个合适的时候“注入”运行时），这恐怕就是Dependency Injection这个术语的由来。再换句话说，我们提到过解除强依赖，这并不是说MovieList和MovieFinder之间的依赖关系不存在了，事实上MovieList无论如何也需要某类MovieFinder提供的服务，我们只是把这种依赖的建立时间推后了，从编译器推迟到运行时了。</p>
<p>依赖关系在OO程序中是广泛存在的，只要A类型中用到了B类型实例，A就依赖于B。前面笔者谈到的内容是把概念抽象到了服务使用者和服务提供者的角度，这也符合现在SOA的设计思路。从另一种抽象方式上来看，可以把MovieList看成我们要构建的主系统，而MovieFinder是系统中的plugin，主系统并不强依赖于任何一个插件，但一旦插件被加载，主系统就应该可以准确调用适当插件的功能。</p>
<p>其实不管是面向服务的编程模式，还是基于插件的框架式编程，为了实现松耦合（服务调用者和提供者之间的or框架和插件之间的），都需要在必要的位置实现面向接口编程，在此基础之上，还应该有一种方便的机制实现具体类型之间的运行时绑定，这就是DI所要解决的问题。</p>
<h4 id="DI的实现方式"><a href="#DI的实现方式" class="headerlink" title="DI的实现方式"></a>DI的实现方式</h4><p>和上面的图1对应的是，如果我们的系统实现了依赖注入，组件间的依赖关系就变成了图2：</p>
<p><img src="../%E6%A1%86%E6%9E%B6/assets/injector.gif" alt="img"></p>
<p>说白了，就是要提供一个容器，由容器来完成（1）具体ServiceProvider的创建（2）ServiceUser和ServiceProvider的运行时绑定。下面我们就依次来看一下三种典型的依赖注入方式的实现。特别要说明的是，要理解依赖注入的机制，关键是理解容器的实现方式。本文后面给出的容器参考实现，均为黄忠成老师的代码，笔者仅在其中加上了一些关键注释而已。</p>
<p><strong><em>Constructor Injection（构造器注入）</em></strong></p>
<p> 我们可以看到，在整个依赖注入的数据结构中，涉及到的重要的类型就是ServiceUser, ServiceProvider和Assembler三者，而这里所说的构造器，指的是ServiceUser的构造器。也就是说，在构造ServiceUser实例的时候，才把真正的ServiceProvider传给他：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  	<span class="comment">//其他内容，省略</span></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="title">MovieLister</span><span class="params">(MovieFinder finder)</span></span></span><br><span class="line"><span class="function">   	</span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.finder = finder;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看看Assembler应该如何构建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MutablePicoContainer <span class="title">configureContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	MutablePicoContainer pico = <span class="keyword">new</span> DefaultPicoContainer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面就是把ServiceProvider和ServiceUser都放入容器的过程，以后就由容器来提供ServiceUser的已完成依赖注入实例，</span></span><br><span class="line"><span class="comment">//其中用到的实例参数和类型参数一般是从配置档中读取的，这里是个简单的写法。</span></span><br><span class="line"><span class="comment">//所有的依赖注入方法都会有类似的容器初始化过程，本文在后面的小节中就不再重复这一段代码了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   	Parameter[] finderParams =  &#123;<span class="keyword">new</span> ConstantParameter(<span class="string">"movies1.txt"</span>)&#125;;</span><br><span class="line">    pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams);</span><br><span class="line">  	pico.registerComponentImplementation(MovieLister.class);</span><br><span class="line">    <span class="comment">//至此，容器里面装入了两个类型，其中没给出构造参数的那一个（MovieLister）将依靠其在构造器中定义的传入参数类型，在容器中</span></span><br><span class="line">    <span class="comment">//进行查找，找到一个类型匹配项即可进行构造初始化。</span></span><br><span class="line">   	<span class="keyword">return</span> pico;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在强调一下的是，依赖并未消失，只是延后到了容器被构建的时刻。所以正如图2中您已经看到的，容器本身（更准确的说，是一个容器运行实例的构建过程）对ServiceUser和ServiceProvoder都是存在依赖关系的。所以，在这样的体系结构里，ServiceUser、ServiceProvider和容器都是稳定的，互相之间也没有任何依赖关系；所有的依赖关系、所有的变化都被封装进了容器实例的创建过程里，符合我们对服务应用的理解。而且，在实际开发中我们一般会采用配置文件来辅助容器实例的创建，将这种变化性排斥到编译期之外。</p>
<p>即使还没给出后面的代码，你也一定猜得到，这个container类一定有一个GetInstance(Type t)这样的方法，这个方法会为我们返回一个已经注入完毕的MovieLister。 一个简单的应用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithPico</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	MutablePicoContainer pico = configureContainer();</span><br><span class="line">   	MovieLister lister = (MovieLister) pico.getComponentInstance(MovieLister.class);</span><br><span class="line">   	Movie[] movies = lister.moviesDirectedBy(<span class="string">"Sergio Leone"</span>);</span><br><span class="line">    assertEquals(<span class="string">"Once Upon a Time in the West"</span>, movies[<span class="number">0</span>].getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面最关键的就是对pico.getComponentInstance的调用。Assembler会在这个时候调用MovieLister的构造器，构造器的参数就是当时通过pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams)设置进去的实际的ServiceProvider–ColonMovieFinder。下面请看这个容器的参考代码：</p>
<p><strong><em>Setter Injection（设值注入）</em></strong></p>
<p>这种注入方式和构造注入实在很类似，唯一的区别就是前者在构造函数的调用过程中进行注入，而它是通过给属性赋值来进行注入。无怪乎PicoContainer和Spring都是同时支持这两种注入方式。Spring对通过XML进行配置有比较好的支持，也使得Spring中更常使用设值注入的方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &lt;beans&gt;</span><br><span class="line">     &lt;bean id=<span class="string">"MovieLister"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"spring.MovieLister"</span>&gt;</span><br><span class="line">         &lt;property name=<span class="string">"finder"</span>&gt;</span><br><span class="line">             &lt;ref local=<span class="string">"MovieFinder"</span>/&gt;</span><br><span class="line">         &lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line">     &lt;bean id=<span class="string">"MovieFinder"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"spring.ColonMovieFinder"</span>&gt;</span><br><span class="line">         &lt;property name=<span class="string">"filename"</span>&gt;</span><br><span class="line">             &lt;value&gt;movies1.txt&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>下面也给出支持设值注入的容器参考实现，大家可以和构造器注入的容器对照起来看，里面的差别很小，主要的差别就在于，在获取对象实例（GetInstance）的时候，前者是通过反射得到待创建类型的构造器信息，然后根据构造器传入参数的类型在容器中进行查找，并构造出合适的实例；而后者是通过反射得到待创建类型的所有属性，然后根据属性的类型在容器中查找相应类型的实例。</p>
<p><strong><em>Interface Injection (接口注入)</em></strong></p>
<p>   这是笔者认为最不够优雅的一种依赖注入方式。要实现接口注入，首先ServiceProvider要给出一个接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InjectFinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">injectFinder</span><span class="params">(MovieFinder finder)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，ServiceUser必须实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MovieLister: InjectFinder</span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectFinder</span><span class="params">(MovieFinder finder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.finder = finder;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容器所要做的，就是根据接口定义调用其中的inject方法完成注入过程，这里就不在赘述了，总的原理和上面两种依赖注入模式没有太多区别。</p>
<h4 id="除了DI，还有Service-Locator"><a href="#除了DI，还有Service-Locator" class="headerlink" title="除了DI，还有Service Locator"></a>除了DI，还有Service Locator</h4><p>上面提到的依赖注入只是消除ServiceUser和ServiceProvider之间的依赖关系的一种方法，还有另一种方法：服务定位器（Service Locator）。也就是说，由ServiceLocator来专门负责提供具体的ServiceProvider。当然，这样的话ServiceUser不仅要依赖于服务的接口，还依赖于ServiceContract。仍然是最早提到过的电影列举器的例子，如果使用Service Locator来解除依赖的话，整个依赖关系应当如下图所示：<br><img src="../%E6%A1%86%E6%9E%B6/assets/locator.gif" alt="img"></p>
<p>用起来也很简单，在一个适当的位置（比如在一组相关服务即将被调用之前）对ServiceLocator进行初始化，用到的时候就直接用ServiceLocator返回ServiceProvider实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务定位器的初始化</span></span><br><span class="line">ServiceLocator locator = <span class="keyword">new</span> ServiceLocator();</span><br><span class="line">locator.loadService(<span class="string">"MovieFinder"</span>, <span class="keyword">new</span> ColonMovieFinder(<span class="string">"movies1.txt"</span>));</span><br><span class="line">ServiceLocator.load(locator);</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务定义器的使用</span></span><br><span class="line"><span class="comment">//其实这个使用方式体现了服务定位器和依赖注入模式的最大差别：ServiceUser需要显示的调用ServiceLocator，从而获取自己需要的服务对象；</span></span><br><span class="line"><span class="comment">//而依赖注入则是隐式的由容器完成了这一切。</span></span><br><span class="line">MovieFinder finder = (MovieFinder) ServiceLocator.getService(<span class="string">"MovieFinder"</span>);</span><br></pre></td></tr></table></figure>

<p>正因为上面提到过的ServiceUser对ServiceLocator的依赖性，从提高模块的独立性（比如说，你可能把你构造的ServiceUser或者ServiceProvider给第三方使用）上来说，依赖注入可能更好一些，这恐怕也是为什么大多数的IOC框架都选用了DI的原因。ServiceLocator最大的优点可能在于实现起来非常简单，如果您开发的应用没有复杂到需要采用一个IOC框架的程度，也许您可以试着采用它。</p>
<p><strong>3.广义的服务</strong><br>文中很多地方提到服务使用者（ServiceUser）和服务提供者（ServiceProvider）的概念，这里的“服务”是一种非常广义的概念，在语法层面就是指最普通的依赖关系（类型A中有一个B类型的变量，则A依赖于B）。如果您把服务理解为WCF或者Web Service中的那种服务概念，您会发现上面所说的所有技术手段都是没有意义的。以WCF而论，其客户端和服务器端本就是依赖于Contract的松耦合关系，其实这也从另一个角度说明了SOA应用的优势所在。</p>
<h2 id="反省总结"><a href="#反省总结" class="headerlink" title="反省总结"></a>反省总结</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/xingyukun/archive/2007/10/20/931331.html" target="_blank" rel="noopener">深度理解依赖注入（Dependence Injection）</a></li>
<li><a href="https://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html" target="_blank" rel="noopener">浅谈IOC–说清楚IOC是什么</a></li>
<li><a href="https://www.imooc.com/article/256370" target="_blank" rel="noopener">JAVA关于Spring 面试题汇总</a></li>
<li><a href="https://juejin.im/post/593386ca2f301e00584f8036#heading-4" target="_blank" rel="noopener">IoC-spring 的灵魂(带你轻松理解IOC思想及bean对象的生成过程)</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/26/Java/框架/Spring：入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/26/Java/框架/Spring：入门/" class="post-title-link" itemprop="url">Spring：入门</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-26 20:59:40" itemprop="dateCreated datePublished" datetime="2019-03-26T20:59:40+08:00">2019-03-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-04-20 16:50:58" itemprop="dateModified" datetime="2019-04-20T16:50:58+08:00">2019-04-20</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/26/Java/框架/Spring：入门/" class="post-meta-item leancloud_visitors" data-flag-title="Spring：入门">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/26/Java/框架/Spring：入门/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/26/Java/框架/Spring：入门/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="Spring介绍"><a href="#Spring介绍" class="headerlink" title="Spring介绍"></a>Spring介绍</h1><p>Spring诞生：</p>
<ul>
<li>创建Spring的目的就是用来<strong>替代更加重量级的的企业级Java技术</strong></li>
<li>简化Java的开发<ul>
<li>基于POJO轻量级和<strong>最小侵入式开发</strong></li>
<li>通过依赖注入和面向接口实现<strong>松耦合</strong></li>
<li><strong>基于切面</strong>和惯例进行声明式编程</li>
<li>通过切面和模板*<em>减少样板式代码 *</em></li>
</ul>
</li>
</ul>
<p><strong><em>侵入式概念</em></strong></p>
<p><strong>侵入式框架</strong></p>
<ul>
<li><p>对于EJB、Struts2等一些传统的框架，</p>
<p>通常是要实现特定的接口，继承特定的类才能增强功能</p>
<ul>
<li><strong>改变了java类的结构</strong></li>
</ul>
</li>
</ul>
<p><strong>非侵入式</strong></p>
<ul>
<li>对于Hibernate、Spring等框架，<strong>对现有的类结构没有影响，就能够增强JavaBean的功能</strong></li>
</ul>
<p><strong><em>松耦合</em></strong></p>
<p>前面我们在写程序的时候，都是<strong>面向接口编程，通过DaoFactroy等方法来实现松耦合</strong></p>
<p><img src="assets/1621e4da347ed640" alt="这里写图片描述"></p>
<p>DAO层和Service层<strong>通过DaoFactory来实现松耦合</strong></p>
<ul>
<li>如果Serivce层直接new DaoBook()，那么DAO和Service就紧耦合了【Service层依赖紧紧依赖于Dao】</li>
</ul>
<p>而Spring给我们更加合适的方法来实现松耦合，并且更加灵活、功能更加强大！—-&gt;<strong>IOC控制反转</strong></p>
<p><strong><em>切面编程</em></strong></p>
<p>切面编程也就是AOP编程，其实我们在之前也接触过…<strong>动态代理就是一种切面编程了</strong>…</p>
<p>当时我们使用<strong>动态代理+注解的方式给Service层的方法添加权限</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@permission</span>(<span class="string">"添加分类"</span>)</span><br><span class="line"><span class="comment">/*添加分类*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCategory</span><span class="params">(Category category)</span> </span>&#123;</span><br><span class="line">    categoryDao.addCategory(category);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*查找分类*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findCategory</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    categoryDao.findCategory(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@permission</span>(<span class="string">"查找分类"</span>)</span><br><span class="line"><span class="comment">/*查看分类*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Category&gt; <span class="title">getAllCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> categoryDao.getAllCategory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加图书*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    bookDao.addBook(book);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Controller调用Service的时候，Service返回的是一个代理对象</li>
<li>代理对象得到Controller想要调用的方法，通过反射来看看该方法上有没有注解</li>
<li>如果有注解的话，那么就判断该用户是否有权限来调用 此方法，如果没有权限，就抛出异常给Controller，Controller接收到异常，就可以提示用户没有权限了。</li>
</ul>
<p>AOP编程可以简单理解成：<strong>在执行某些代码前，执行另外的代码</strong></p>
<ul>
<li>Struts2的拦截器也是面向切面编程【在执行Action业务方法之前执行拦截器】</li>
</ul>
<p>Spring也为我们<strong>提供更好地方式来实现面向切面编程</strong>！</p>
<h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。</p>
<h3 id="spring优点"><a href="#spring优点" class="headerlink" title="spring优点"></a>spring优点</h3><ul>
<li><strong>轻量：</strong>Spring 是轻量的，基本的版本大约2MB。</li>
<li><strong>控制反转：</strong>Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li>
<li><strong>面向切面的编程(AOP)：</strong>Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li>
<li><strong>容器：</strong>Spring 包含并管理应用中对象的生命周期和配置。</li>
<li><strong>MVC框架</strong>：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li>
<li><strong>事务管理：</strong>Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li>
<li><strong>异常处理：</strong>Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li>
</ul>
<h3 id="Spring模块组成"><a href="#Spring模块组成" class="headerlink" title="Spring模块组成"></a>Spring模块组成</h3><ul>
<li>核心容器<ul>
<li>Core module</li>
<li>Bean module</li>
<li>Context module</li>
<li>Expression Language module</li>
</ul>
</li>
<li>数据集成/访问。提供与数据库交互的支持<ul>
<li>JDBC module</li>
<li>ORM module</li>
<li>OXM module</li>
<li>Java Messaging Service(JMS) module</li>
<li>Transaction module</li>
</ul>
</li>
<li>Web应用程序的支持<ul>
<li>Web module</li>
<li>Web-Servlet module</li>
<li>Web-Struts module</li>
<li>Web-Portlet module</li>
</ul>
</li>
<li>AOP</li>
<li>Instrumentation：类检测和类加载器支持</li>
<li>Test</li>
<li>杂项<ul>
<li>Messaging</li>
<li>Aspects</li>
</ul>
</li>
</ul>
<h3 id="什么是-Spring-配置文件？"><a href="#什么是-Spring-配置文件？" class="headerlink" title="什么是 Spring 配置文件？"></a>什么是 Spring 配置文件？</h3><p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p>
<h3 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>
<ul>
<li><strong>接口</strong> - 定义功能。</li>
<li><strong>Bean 类</strong> - 它包含属性，setter 和 getter 方法，函数等。</li>
<li><strong>Spring 面向切面编程（AOP）</strong> - 提供面向切面编程的功能。</li>
<li><strong>Bean 配置文件</strong> - 包含类的信息以及如何配置它们。</li>
<li><strong>用户程序</strong> - 它使用接口。</li>
</ul>
<h3 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h3><p>使用 Spring 有以下方式：</p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>用于远程使用。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
</ul>
<h1 id="引出Spring"><a href="#引出Spring" class="headerlink" title="引出Spring"></a>引出Spring</h1><p>我们试着回顾一下没学Spring的时候，是怎么开发Web项目的</p>
<ul>
<li><ol>
<li><strong>实体类</strong>—&gt;class User{ }</li>
</ol>
</li>
<li><ol start="2">
<li><strong>daoclass</strong>–&gt;  UserDao{  .. 访问**db}</li>
</ol>
</li>
<li><ol start="3">
<li><strong>service</strong>—&gt;class  UserService{  UserDao userDao = new UserDao();}</li>
</ol>
</li>
<li><ol start="4">
<li><strong>actionclass</strong>  UserAction{UserService userService = new UserService();}</li>
</ol>
</li>
</ul>
<p><strong>用户访问：</strong></p>
<ul>
<li><strong>Tomcat-&gt;action-&gt;service-&gt;dao</strong></li>
</ul>
<p>我们来思考几个问题：</p>
<ul>
<li><p>①：<strong>对象创建创建能否写死？</strong></p>
</li>
<li><p>②：对象创建细节 </p>
<ul>
<li><p>对象数量</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action  多个   【维护成员变量】</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service 一个   【不需要维护公共变量】</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dao     一个   【不需要维护公共变量】</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>创建时间</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action    访问时候创建</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service   启动时候创建</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dao       启动时候创建</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>③：对象的依赖关系 </p>
<ul>
<li><strong>action 依赖 service</strong></li>
<li><strong>service依赖 dao</strong></li>
</ul>
</li>
</ul>
<p>对于第一个问题和第三个问题，<strong>我们可以通过DaoFactory解决掉(虽然不是比较好的解决方法)</strong></p>
<p>对于第二个问题，我们要<strong>控制对象的数量和创建事件就有点麻烦了</strong>….</p>
<p>而<strong>Spring框架通过IOC就很好地可以解决上面的问题</strong>….</p>
<h2 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h2><p>Spring的核心思想之一：<strong>Inversion of Control , 控制反转 IOC</strong></p>
<p>那么控制反转是什么意思呢？？？<strong>对象的创建交给外部容器完成，这个就做控制反转。</strong></p>
<ul>
<li>Spring使用控制反转来实现对象不用在程序中写死</li>
<li>控制反转解决对象处理问题【把对象交给别人创建】</li>
</ul>
<p>那么对象的对象之间的依赖关系Spring是怎么做的呢？？<strong>依赖注入，dependency injection.即DI</strong></p>
<ul>
<li>Spring使用依赖注入来实现对象之间的依赖关系</li>
<li>在创建完对象之后，对象的关系处理就是依赖注入</li>
</ul>
<p>上面已经说了，控制反转是通过外部容器完成的，<strong>而Spring又为我们提供了这么一个容器，我们一般将这个容器叫做：IOC容器.</strong></p>
<p>无论是创建对象、处理对象之间的依赖关系、对象创建的时间还是对象的数量，我们都是在Spring为我们提供的IOC容器上配置对象的信息就好了。</p>
<p>那么使用<strong>IOC控制反转这一思想有什么作用呢</strong>？？？我们来看看一些优秀的回答…</p>
<p>来自知乎：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F23277575%2Fanswer%2F24259844" target="_blank" rel="noopener">www.zhihu.com/question/23…</a></p>
<p>我摘取一下核心的部分：</p>
<blockquote>
<p>ioc的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。<strong>第一，资源集中管理，实现资源的可配置和易管理</strong>。<strong>第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度</strong>。</p>
<p>也就是说，甲方要达成某种目的不需要直接依赖乙方，它只需要达到的目的告诉第三方机构就可以了，比如甲方需要一双袜子，而乙方它卖一双袜子，它要把袜子卖出去，并不需要自己去直接找到一个卖家来完成袜子的卖出。它也只需要找第三方，告诉别人我要卖一双袜子。这下好了，甲乙双方进行交易活动，都不需要自己直接去找卖家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。这样做什么好处么呢，甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。<strong>因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了</strong>。这就是ioc的核心思想。生活中这种例子比比皆是，支付宝在整个淘宝体系里就是庞大的ioc容器，交易双方之外的第三方，提供可靠性可依赖可灵活变更交易方的资源管理中心。另外人事代理也是，雇佣机构和个人之外的第三方。 ==========================update===========================</p>
<p>在以上的描述中，诞生了两个专业词汇，依赖注入和控制反转所谓的依赖注入，则是，甲方开放接口，在它需要的时候，能够将乙方传递进来(注入)所谓的控制反转，甲乙双方不相互依赖，交易活动的进行不依赖于甲乙任何一方，整个活动的进行由第三方负责管理。</p>
</blockquote>
<p>参考优秀的博文①：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.tianmaying.com%2Ftutorial%2Fspring-ioc" target="_blank" rel="noopener">www.tianmaying.com/tutorial/sp…</a></p>
<p>参考优秀的博文②：<a href="https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzAxOTc0NzExNg%3D%3D%26mid%3D2665513179%26idx%3D1%26sn%3D772226a5be436a0d08197c335ddb52b8%23rd" target="_blank" rel="noopener">这里写链接内容</a></p>
<p><strong>知乎@Intopass的回答：</strong></p>
<ol>
<li>不用自己组装，拿来就用。</li>
<li>享受单例的好处，效率高，不浪费空间。</li>
<li>便于单元测试，方便切换mock组件。</li>
<li>便于进行AOP操作，对于使用者是透明的。</li>
<li>统一配置，便于修改。</li>
</ol>
<hr>
<h2 id="Spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h2><p><strong>Spring可以分为6大模块：</strong></p>
<ul>
<li><p>Spring Core  spring的核心功能： IOC容器, 解决对象创建及依赖关系</p>
</li>
<li><p>Spring Web  Spring对web模块的支持。 </p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以与struts整合,让struts的action创建交给spring</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring mvc模式</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Spring DAO  Spring 对jdbc操作的支持  【JdbcTemplate模板工具类】</p>
</li>
<li><p>Spring ORM  spring对orm的支持： </p>
<ul>
<li>既可以与hibernate整合，【session】</li>
<li>也可以使用spring的对hibernate操作的封装</li>
</ul>
</li>
<li><p>Spring AOP  切面编程</p>
</li>
<li><p>SpringEE   spring 对javaEE其他模块的支持</p>
</li>
</ul>
<p><img src="assets/1621e4da3492d633" alt="这里写图片描述"></p>
<p>上面文主要引出了为啥我们需要使用Spring框架，以及大致了解了Spring是分为六大模块的….<strong>下面主要讲解Spring的core模块！</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/26/Java/设计模式/设计模式：工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/26/Java/设计模式/设计模式：工厂模式/" class="post-title-link" itemprop="url">设计模式：工厂模式</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-26 20:14:16" itemprop="dateCreated datePublished" datetime="2019-03-26T20:14:16+08:00">2019-03-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-07-29 09:01:15" itemprop="dateModified" datetime="2019-07-29T09:01:15+08:00">2019-07-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/26/Java/设计模式/设计模式：工厂模式/" class="post-meta-item leancloud_visitors" data-flag-title="设计模式：工厂模式">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/26/Java/设计模式/设计模式：工厂模式/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/26/Java/设计模式/设计模式：工厂模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><h3 id="问题案例"><a href="#问题案例" class="headerlink" title="问题案例"></a>问题案例</h3><h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>工厂模式的好处就是<strong>解耦</strong>。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>简单/静态工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ol>
<li>需要准备一个对象要做很多工作，而耦合在具体业务类当中并不恰当</li>
</ol>
<p>当进行文件IO时，需要创建一个对象BufferedReader对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 创建一个BufferedReader对象</span></span><br><span class="line">    BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"aa.txt"</span>)));</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 也可能是这样的</span></span><br><span class="line">	File file = <span class="keyword">new</span> File(<span class="string">"aa.txt"</span>);</span><br><span class="line">	FileReader fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">	BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br></pre></td></tr></table></figure>

<ul>
<li>当需要在很多地方使用到这个对象时，就会略显臃肿</li>
<li>同时，如果需要更换IO读写的类，如<strong>LineNumberReader</strong>，那么工作量相对很大</li>
</ul>
<ol start="2">
<li>有时候需要判断具体new一个什么样的类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">orderPizza</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">	Pizza pizza;</span><br><span class="line">    <span class="comment">//在业务类当中如此做会使得代码很脆弱而且很繁琐。</span></span><br><span class="line">    <span class="comment">//并且如果出现了新的变化，需要反复修改。</span></span><br><span class="line">    <span class="comment">//无法让类对修改关闭。</span></span><br><span class="line">    <span class="keyword">if</span>(type.equals(<span class="string">"cheese"</span>))&#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"greek"</span>))&#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">    &#125;....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此使用工厂模式，将对象创建委托给工厂</p>
<h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><h3 id="协作-1"><a href="#协作-1" class="headerlink" title="协作"></a>协作</h3><ul>
<li>类关系</li>
<li>逻辑关系</li>
</ul>
<h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><h1 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h1><h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><h2 id="效果（优缺）"><a href="#效果（优缺）" class="headerlink" title="效果（优缺）"></a>效果（优缺）</h2><h2 id="使用工厂模式的好处"><a href="#使用工厂模式的好处" class="headerlink" title="使用工厂模式的好处"></a>使用工厂模式的好处</h2><ul>
<li>让<strong>创建对象变得简单</strong>而且<strong>修改对象时能很方便</strong>呢</li>
<li>从<strong>面向对象的角度来看</strong>：我一个操作文件的类还要我会创建BufferReader是不是有点过分了？(职责没有分工好)，交给工厂来创建对象这就很面向对象了！</li>
</ul>
<p>专业一些即：</p>
<ul>
<li>我们修改了具体的实现类，对客户端(调用方)而言是<strong>完全不用修改的</strong>。</li>
<li>如果我们使用new的方式来创建对象的话，那么我们就说：new出来的这个对象和当前客户端(调用方)耦合了！<ul>
<li>也就是，当前客户端(调用方)<strong>依赖着</strong>这个<code>new</code>出来的对象！</li>
</ul>
</li>
</ul>
<p>即使得<strong>解耦，低耦合</strong></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h3 id="案例1-1"><a href="#案例1-1" class="headerlink" title="案例1"></a>案例1</h3><h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="使用Lambda"><a href="#使用Lambda" class="headerlink" title="使用Lambda"></a>使用Lambda</h3><h2 id="反省总结"><a href="#反省总结" class="headerlink" title="反省总结"></a>反省总结</h2><h1 id="如何使用工厂模式"><a href="#如何使用工厂模式" class="headerlink" title="如何使用工厂模式"></a>如何使用工厂模式</h1><ul>
<li>简单/静态工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<p>简单/静态工厂模式是在工厂方法模式上<strong>缩减</strong>，抽象工厂模式是在工厂方法模式上再<strong>增强</strong>。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>Java3y每天写代码很无聊，想要买只宠物来陪陪自己。于是乎就<strong>去宠物店看宠物啦</strong><del>~</del></p>
<p>作为一间宠物店，号称什么宠物都有！于是乎，店主宣传的时候就说：我的宠物店<strong>什么宠物都有</strong>！</p>
<p>于是构建宠物的工厂就诞生了~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 号称什么宠物都有</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 可以获取任何的宠物</span></span><br><span class="line">	<span class="function">Animal <span class="title">createAnimal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，主流的宠物得进货一些先放在店里充充门面，一些特殊的宠物就告诉顾客要时间进货~</p>
<ul>
<li>所以，我们就有了构建猫和狗的工厂(继承着所有宠物的工厂)</li>
</ul>
<p>猫工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承着宠物工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span> <span class="keyword">implements</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 创建猫</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">createAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>狗工厂也是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承着宠物工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span> <span class="keyword">implements</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建狗</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Animal <span class="title">createAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，还有我们的实体类：猫、狗、动物(多态：猫和狗都是动物，可以直接用动物来表示了)</p>
<p>动物实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 所有的动物都会吃东西</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猫实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;	</span><br><span class="line">	<span class="comment">// 猫喜欢吃鱼</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>狗实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 狗喜欢吃肉</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"狗吃肉"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么现在Java3y想要一只狗，跟了宠物店老板说，宠物店老板就去找狗回来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去找狗工厂拿一只狗过来</span></span><br><span class="line">AnimalFactory f = <span class="keyword">new</span> DogFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 店主就拿到了一只狗给Java3y</span></span><br><span class="line">Animal a = f.createAnimal();</span><br><span class="line">a.eat();</span><br></pre></td></tr></table></figure>

<p>那么现在Java3y想要一只猫，跟了宠物店老板说，宠物店老板就去找猫回来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 去找猫工厂拿一只猫过来</span></span><br><span class="line">   AnimalFactory ff = <span class="keyword">new</span> CatFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 店主就拿到了一只猫给Java3y</span></span><br><span class="line">   Animal aa = ff.createAnimal();</span><br><span class="line">   aa.eat();</span><br></pre></td></tr></table></figure>

<p>如果这个时候Java3y说想要一只蜥蜴怎么办啊？没问题啊，店主<strong>搞个蜥蜴工厂</strong>就好了~~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要买蜥蜴..</span></span><br><span class="line">AnimalFactory fff = <span class="keyword">new</span> LizardFactory();</span><br><span class="line">Animal aaa = ff.createAnimal();</span><br><span class="line">aaa.eat();</span><br></pre></td></tr></table></figure>

<p>优点:</p>
<ul>
<li>1:客户端不需要在负责对象的创建,<strong>明确了各个类的职责</strong></li>
<li>2:如果有<strong>新的对象增加</strong>，只需要<strong>增加一个具体的类和具体的工厂类</strong>即可</li>
<li>3:<strong>不会影响已有的代码</strong>，后期维护容易,增强系统的扩展性</li>
</ul>
<p>缺点:</p>
<ul>
<li>1:需要额外的编写代码,增加了工作量</li>
</ul>
<p>工厂方法类图：</p>
<p><img src="assets/1638090cf6b8b892" alt="img"></p>
<h2 id="简单-静态工厂模式"><a href="#简单-静态工厂模式" class="headerlink" title="简单/静态工厂模式"></a>简单/静态工厂模式</h2><p>现在宠物店生意不好做啊，号称“什么宠物都有”,这吹过头了~~于是店主<strong>只卖两种常见的宠物</strong>了。</p>
<ul>
<li>既然就只有两种宠物的话，那就没必要有”猫厂“、”狗厂“了，一个猫狗厂就行了！</li>
</ul>
<p>所以我们的工厂是这样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title">createDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title">createCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外界想要猫要狗，这里创建就好了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">createAnimal</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"dog"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"cat"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个实体还是没变(动物、猫、狗)….</p>
<p>那么Java3y去宠物店买猫狗的时候，告诉老板我要猫、我要狗：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到狗</span></span><br><span class="line">      Animal A = AnimalFactory.createAnimal(<span class="string">"dog"</span>);</span><br><span class="line">      A.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到猫</span></span><br><span class="line">      Animal C = AnimalFactory.createAnimal(<span class="string">"cat"</span>);</span><br><span class="line">      C.eat();</span><br></pre></td></tr></table></figure>

<p>现在问题来了:</p>
<ul>
<li>1:我想要一个猪,<strong>可是我的工厂类没有猪</strong></li>
<li>2:我就去<strong>改</strong>代码,写可以创建猪对象的</li>
<li>3:接着,我又要其他的动物</li>
<li>4:我还是得<strong>改</strong>代码</li>
<li>5……………….</li>
<li>6:这就是简单工厂类的缺点：<strong>当需求改变了,我就要改代码</strong>.</li>
</ul>
<p>简单工厂类的优点也很明显：我<strong>就一个具体的工厂来创建对象</strong>，代码量少。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式就比较复杂了，我们<strong>一般的应用都写不到</strong>。我首先来简述一下需求吧：</p>
<ul>
<li>现在非常流行在猫狗届也吹起了一股“性别风” <ul>
<li>有的喜欢公的</li>
<li>有的喜欢母的</li>
</ul>
</li>
</ul>
<p>那我们的猫和狗都是有性别的，不是公的就是母的~~</p>
<ul>
<li>我们之前在工厂方法模式下是每个动物都开一个工厂，如果动物过多的话，那么就有很多的工厂~</li>
<li>那现在我们可以<strong>抽取出来</strong>：每个动物不是公的就是母的~</li>
<li>所以我们有两个工厂就足够了！</li>
</ul>
<p>具体的代码是这样的：</p>
<p>我们的最大工厂还是定义了创建什么动物</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line">	<span class="function">Animal <span class="title">createDog</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Animal <span class="title">createCat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建母猫和母狗的工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FemaleAnimalFactory</span> <span class="keyword">implements</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生产母狗和母猫</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">createDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> FemaleDog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">createCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FemaleCat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建公猫和公狗的工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaleAnimalFactory</span> <span class="keyword">implements</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生产公狗和公猫</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">createDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaleDog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">createCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MaleCat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是<strong>所有动物都拥有的普遍行为</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 所有的动物都会吃东西</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有的动物都有性别</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">gender</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是猫都拥有的普遍行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 猫喜欢吃鱼</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是狗都拥有的普遍行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 狗喜欢吃肉</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"狗吃肉"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猫分为公猫、母猫。狗分为公狗和母狗：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FemaleCat</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am a female Cat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…..</p>
<p>简单来说：工厂方法模式的工厂是创建出<strong>一种</strong>产品，而抽象工厂是创建出<strong>一类</strong>产品。</p>
<ul>
<li>一类的产品我们称之为产品族<ul>
<li>猫是一类的，狗也是一类的。所以AnimalFactory定义了两类产品—&gt;<code>Animal createDog();</code>和<code>Animal createCat();</code></li>
</ul>
</li>
<li>产品的继承结构称之为产品等级<ul>
<li>所有的动物都是会吃东西的，它们都是有性别的，这是最普遍的。所以Animal定义了两个抽象方法：<code>public abstract void eat();</code>和<code>public abstract void gender();</code></li>
<li>所有的狗都是会吃肉的，所以Dog实现了eat()方法 <ul>
<li>狗又分成了公狗和母狗，所以定义了两个类FemaleDog和MaleDog继承了Dog，实现了<code>gender()</code>方法</li>
</ul>
</li>
<li>所有的猫都是会吃鱼的，所以Cat实现了eat()方法 <ul>
<li>猫又分成了公猫和母猫，所以定义了两个类FemaleCat和MaleCat继承了Cat，实现了<code>gender()</code>方法</li>
</ul>
</li>
</ul>
</li>
<li>具体的工厂是面向多个产品等级结构进行生产。 <ul>
<li>所以FemaleAnimalFactory定义了<code>createDog()</code>和<code>createCat()</code>生产母狗和母猫</li>
<li>所以MaleAnimalFactory定义了<code>createDog()</code>和<code>createCat()</code>生产公狗和共猫</li>
</ul>
</li>
<li>找到母工厂就可以创建母猫和母狗，找到公工厂就可以创建公猫和公狗</li>
</ul>
<p>抽象工厂模式说到底就是<strong>多了一层抽象，减少了工厂的数量</strong>。</p>
<p>抽象工厂缺点也很明显：</p>
<ul>
<li>难以扩展产品族—&gt;如果我再要宠物猪的话<ul>
<li>那我要修改AnimalFactory、FemaleAnimalFactory、MaleAnimalFactory这些类了~</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说我们<strong>用简单工厂模式比较多</strong>，工厂方式模式的话代码量会比较大，抽象工厂模式的话需要业务比较大的情况下才会用到</p>
<ul>
<li>工厂模式将初始化一个类所需要的繁杂操作，包装在了一个工厂的方法当中。如考虑声明一个缓冲区，缓冲区有不同的类型，封装在不同的工厂方法当中</li>
<li>工厂模式配合反射来使用也是极好的~</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://juejin.im/post/5b0231746fb9a07aaf35813c" target="_blank" rel="noopener">工厂模式理解了没有？</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/22/面试/面经/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/22/面试/面经/" class="post-title-link" itemprop="url">面经</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-22 16:58:29" itemprop="dateCreated datePublished" datetime="2019-03-22T16:58:29+08:00">2019-03-22</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-06-15 16:33:20" itemprop="dateModified" datetime="2019-06-15T16:33:20+08:00">2019-06-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/22/面试/面经/" class="post-meta-item leancloud_visitors" data-flag-title="面经">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/22/面试/面经/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/22/面试/面经/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h1><ul>
<li>是什么</li>
<li>为什么存在（解决了什么问题）</li>
<li>基本原理</li>
<li>使用场景</li>
<li>和其它相比有什么不同</li>
<li>一些细节（如果使用过的话）</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>TCP/IP五层结构及其相应的功能</li>
<li>浏览器输入URL发生了什么(浏览器输入网址后的全过程 )，分析其中哪些部分用到缓存</li>
<li>浏览器输入网址后，如果把http换成https需要测试什么？</li>
<li>讲一下CDN</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul>
<li>应用层有哪些常见协议</li>
<li>DNS解析过程</li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li>HTTP状态码类型有哪些，及其作用</li>
<li>HTTP方法有哪些，及其作用</li>
<li>幂等性了解过吗，有哪些HTTP方法是幂等性的，为什么（PUT、POST…）</li>
<li>GET和POST的区别 </li>
<li>HTTP1.0 HTTP1.1 HTTP2.0，这三个有什么区别及其改进</li>
<li>HTTP如何实现状态化，cookie被禁用了怎么办（URL重写）</li>
<li>cookie和session</li>
<li>HTTP有哪些问题，加密算法有哪些，针对不同加密方式可能产生的问题，及其HTTPS是如何保证安全传输的（对称加密+非对称加密+数字证书）</li>
<li>HTTP缓存</li>
</ul>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><ul>
<li>TCP如何保证可靠传输</li>
<li>TCP/IP的握手过程</li>
<li>TCP的流量控制，当接收方的接收窗口为0的时候该怎么办</li>
<li>TCP的拥塞控制（慢启动，拥塞避免，超时间间隔传输及其快速重传，快速恢复）</li>
<li>流量控制和拥塞控制有什么区别</li>
<li>TCP的连接管理中可能出现的攻击漏洞（洪泛攻击，自顶向下那本书有讲到）</li>
<li>TCP和UDP区别</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul>
<li>网络层的路由算法有哪些，简述RIP，OSPF过程</li>
<li>简述ARP协议过程，是如何通过IP地址获取MAC地址的</li>
<li>arp会进行广播，会造成网络风暴，那应该怎么解决</li>
<li>某地区，无法访问某网址，可能的问题</li>
<li>ping命令所使用的协议是什么（ICMP），简述其过程</li>
</ul>
<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><ul>
<li>交换机是几层设备</li>
<li>链路层通过什么访问主机</li>
<li>链路层的差错检测有哪措施</li>
</ul>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul>
<li>加密解密</li>
</ul>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul>
<li>操作系统的内存管理机制</li>
<li>并发和并行的区别</li>
<li>线程间通信</li>
<li>操作系统的竞态？自旋锁说一下</li>
<li>系统如何知道线程池里哪些线程在执行，哪些线程资源是空的</li>
<li>设计一个线程池</li>
<li>实现读写锁</li>
<li>怎么等一个线程做完</li>
<li>内存溢出，泄漏概念</li>
<li>分页式的页表放在哪</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li>进程和线程的区别</li>
<li>实现线程的同步？线程的上下文有哪些东西</li>
<li>线程同步的方法。</li>
<li>进程的PCB里还有哪些东西</li>
<li>线程是怎么被执行的</li>
<li>进程线程，信号量</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul>
<li>造成死锁的原因有哪些，如何预防？</li>
</ul>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><p>链表和数组的区别及其相应的复杂度</p>
</li>
<li><p>队列和栈的区别</p>
</li>
<li><p>二叉搜索树和平衡二叉树有什么关系，强平衡二叉树（AVL树）和弱平衡二叉树（红黑树）有什么区别，及其代表数据结构</p>
</li>
<li><p>跳表怎么实现的</p>
</li>
<li><p>哈夫曼编码是怎么回事</p>
</li>
</ul>
<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><ul>
<li>图的遍历算法（dfs，bfs），最小生成树的算法，最短路径的算法及简述其思想</li>
<li>非递归且不用额外空间（不用栈），如何遍历二叉树</li>
</ul>
<h1 id="web框架"><a href="#web框架" class="headerlink" title="web框架"></a>web框架</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul>
<li>Spring的IOC和AOP</li>
<li>Spring bean的生存范围</li>
<li>Spring IOC容器生命周期</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li><p>设计模式有哪些大类，及熟悉其中哪些设计模式</p>
</li>
<li><p>在平时看源码过程中有哪些源码使用到了设计模式（这个问题范围很广，我从并发、IO、集合框架、SSM方面一个个答，答到Spring的时候被面试官打住，说可以了…）</p>
</li>
<li><p>项目中用到哪些设计模式，简述代理模式，策略模式和状态模式</p>
</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ul>
<li>数据库引擎</li>
<li>MySQL的MyISAM和Innodb的区别（从事务，锁，B+树索引，读写性能方面分析）</li>
<li>Innodb的B+树索引和MyISAM的B+树索引的结构区别</li>
<li>为什么索引能够提升性能（可以从B+树结构方面分析）</li>
<li>B树和B+树的区别，为什么MySQL要使用B+树（磁盘和树高方面答）</li>
<li>count(*)和count(1)的区别</li>
<li>MySQL的主备模式</li>
<li>事务隔离级别</li>
<li>悲观锁和乐观锁</li>
<li>ACID</li>
<li>MVVC</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>聊一聊多进程多线程，各自的优势，一个服务器大量的请求怎么同步等等</li>
<li>解释下线程和协程区别，协程库中yield干嘛用的</li>
<li>CAS操作，及其可能带来问题和可以怎么解决（ABA问题用版本号来解决，自旋时n间过长问题可以通过上次自旋时间来进行判断）</li>
<li>中断机制，interrupt和interrupted的区别，哪些状态可以中断并抛出InterruptedException</li>
<li>sleep和wait的区别<ul>
<li>wait底层原理</li>
</ul>
</li>
<li>sychronized、Lock<ul>
<li>sychronized和ReentrantLock的区别（其中有个异常机制的区别没答上来）</li>
<li>为什么ReentrantLock的锁粒度小，sychronized不是也可以用方法块来降低锁粒度</li>
<li>公平锁和非公平锁的定义，及其优缺点、以及实现，ReentrantLock和synchronized使用公平还是非公平锁</li>
<li>sychronized的自旋锁、偏向锁、轻量级锁、重量级锁，分别介绍和联系（膨胀）</li>
</ul>
</li>
<li>volatile</li>
<li>final关键字怎么用</li>
</ul>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2><ul>
<li>怎样实现反射，作用是什么</li>
<li>说一下map的分类和常见的情况 </li>
<li>Object若不重写hashCode()的话，hashCode()如何计算出来的？比较的是什么？ </li>
<li>若对一个类不重写，它的equals()方法是如何比较的？ </li>
<li>Java8新特性 </li>
<li>说说Lamda表达式的优缺点。 </li>
<li>一个十进制的数在内存中是怎么存的？ </li>
<li>为啥有时会出现4.0-3.6=0.40000001这种现象？ </li>
<li>Java支持的数据类型有哪些？什么是自动拆装箱？ </li>
<li>什么是值传递和引用传递？ </li>
<li>数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？ </li>
<li>你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？ </li>
<li>String是最基本的数据类型吗? </li>
<li>int 和 Integer 有什么区别 </li>
<li>String 和StringBuffer的区别 </li>
<li>我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？ </li>
<li>int和Integer有什么区别？ </li>
<li>&amp;和&amp;&amp;的区别？ </li>
<li>在Java中，如何跳出当前的多重嵌套循环？ </li>
<li>你能比较一下Java和JavaSciprt吗？ </li>
<li>简述正则表达式及其用途。 </li>
<li>Java中是如何支持正则表达式操作的？ </li>
<li>请你说说Java和PHP的区别？</li>
</ul>
<h1 id="其他人"><a href="#其他人" class="headerlink" title="其他人"></a>其他人</h1><p>作者：宋欣建</p>
<p>链接：<a href="https://www.zhihu.com/question/266086679/answer/303789485" target="_blank" rel="noopener">https://www.zhihu.com/question/266086679/answer/303789485</a></p>
<p>来源：知乎</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>***Java&amp;JVM&amp;设计模式&amp;UML</p>
<p>jvm，jre以及jdk三者之间的关系？<br>序列化原理；类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样？哪些类有serialVersionUID属性，作用<br>synchronized原理 synchronized修饰静态变量和普通变量的区别 修饰普通方法和类方法的区别：和Lock对比着说，说到各自的优缺点，synchronized从最初性能差到jdk高版本后的锁膨胀机制，大大提高性能，再说底层实现，Lock的乐观锁机制，通过AQS队列同步器，调用了unsafe的CAS操作，CAS函数的参数及意义；同时可以说说synchronized底层原理，jvm层的moniter监视器，对于方法级和代码块级，互斥原理的不同，+1-1可重入的原理等<br>lock的原理和实现，lock和synchronize的区别<br>int范围（基础数据类型） 基本数据类型，长度<br>concurrenthashmap分段锁（1.7 1.8区别）<br>字节与字符的区别<br>JDK动态代理与CGLIB动态代理原理<br>List接口和Set接口的区别<br>Collections的同步集合的包装 synchronizedMap  与ConcurrentHashMap区别；Collections.sort在jdk1.6以前是用的归并排序，1.7后变成了TimSort排序（归并优化）<br>线程池原理 线程运行完后会消失吗？线程运行完后处于什么状态？怎么知道线程处于什么状态？线程池的构造类的方法的5个参数的具体意义？IO密集和CPU密集两种情况下，线程池里的线程数应该怎么设置<br>自己设计一个线程池<br>类加载机制（双亲委派、加载过程） 反双亲设计，类隔离<br>JVM 分区、GC算法：分代 分代又包含标记清除、标记整理、复制、GC对象存活、GC垃圾收集器（尤其是CMS、G1）年轻代为什么分为8比1<br>Serial 与 Parallel GC之间的不同之处<br>OOM ；方法区OOM时的异常；查看dump 文件，怎么查看，具体命令记得吗，答jstack  具体怎么用的<br>四种引用<br>finalize方法<br>final关键字用法<br>Condion await signal<br>hashcode和equals区别 如果重写equals不重写hashcode会出现什么问题<br>生产者消费者模式的几种实现<br>Java同步机制有哪几种<br>equals与==区别<br>Java内存模型  JMM<br>volatile happens-before 内存屏障 指令重排 内存可见性<br>线程的状态<br>Error、Exception，Java异常体系，常见RuntimeException，受检异常和运行时异常的区别；受检异常的JVM实现原理<br>泛型；泛型擦除<br>String常量池 intern<br>StringBuilder与StringBuffer<br>四种内部类<br>对象初始化顺序<br>JVM的内存参数；xmx,xms,xmn,xss参数你有调优过吗，设置大小和原则你能介绍一下吗？；Xss默认大小，在实际项目中你一般会设置多大<br>ThreadLocal<br>try-finally-return<br>JVM锁的几种状态（轻量级锁、重量级锁）<br>自旋锁 自旋锁会死锁吗<br>list和set的区别<br>JVM 逃逸分析<br>Integer的valueOf；为什么需要基础数据类型的包装类型<br>JUC的几种并发工具，用法和原理<br>BIO、NIO、AIO  重点NIO实现原理 NIO并不是严格意义上的非阻塞IO而应该属于多路复用IO；nio堆外内存<br>AIO在工程中如何实现的？（大概说了下ajax的回调函数），又问回调函数具体是怎么实现的（传递函数指针）<br>CAS 原理 底层是JNI；ABA问题； JNI下cpu和寄存器层面是怎么实现的<br>JVM中对象组成<br>原子操作 AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的<br>JVM指令（尤其是与并发有关的）<br>Iterator与ListIterator，Iterator实现原理<br>排他锁与共享锁<br>读写锁<br>竟态条件<br>Java8新特性<br>自动装箱、自动拆箱 int和Integer的区别<br>抽象类与接口 区别，使用场景<br>static关键字； static修饰的变量并发下怎么保证变量的安全；出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满意<br>ArrayList和LinkedList的使用场景<br>switch实现原理<br>ReentrantLock底层的实现原理；lock和trylock的区别<br>HashMap的实现原理 为何按位与而不是取摸 hashmap的iterator读取时是否会读到另一个线程put的数据 红黑树；hashmap报ConcurrentModificationException的情况<br>手写HashMap的实现，set get方法，不要求线程安全<br>hashset的实现原理 因为别人知道源码怎么实现的，故意构造相同的hash的字符串进行攻击，怎么处理 如果要去除后还要有序<br>面向对象的三个特性<br>内存泄漏发生在哪 用过哪些调试java内存工具；非静态内部类会导致内存泄露，说了内存泄露的解决<br>AQS<br>公平锁非公平锁介绍<br>方法栈<br>hashmap，hashtable区别<br>arraylist linkedlist vector的区别<br>热加载的原理 osgi实现, 也就是自己实现classloader, 还是来自周志明的那本jvm<br>重写和重载<br>线程的几种实现方式<br>String有重写Object的hashcode和toString吗;String类添加功能，如何设计，可否继承<br>三个线程轮流打印ABC十次<br>对象深拷贝与浅拷贝<br>Java的反射原理<br>队列 set  map 区别<br>abstract 等关键字的作用，什么时候用<br>子类中如何调用父类的构造器，如果不用super关键字呢？有其他的方式吗？<br>如果两个线程都使用一个ByteBuf  怎么保证它的安全<br>java中所有类的父类是什么？他都有什么方法<br>wait()和sleep()的区别<br>解析XML的几种方式的原理与特点：DOM、SAX、PULL；Dom4J以及SAX的区别，什么时候用，怎么用<br>Minor GC与Full GC分别在什么时候发生； 如何手动触发全量回收垃圾，如何立即触发垃圾回收；minor gc回收新生代，major gc回收老年代，full gc是全堆回收，老年代+新生代。<br>分派：静态分派与动态分派<br>for each和正常for的用在不同数据结构（ArrayList、set、hashmap）上的效率区别<br>static class和non-static class的区别<br>一个大文件几个GB，怎么实现复制<br>如何把java内存的数据全部dump出来<br>jstack jmap、jconsole 等工具 可视化工具使用；如何线上排查JVM的相关问题？<br>String s=new String(“abc”)分别在堆栈上新建了哪些对象<br>线程的各种状态<br>Java 集合的快速失败机制 “fail-fast”<br>手写一个ArrayList类，实现add，remove，等基本的方法；对这个ArrayList进行改进，使之可以应对并发的场景<br>Collections.sort函数jdk7 和 jdk8 分别怎么实现的<br>ForkJoinPool ForkJoin框架<br>为什么匿名内部类的变量必须用final修饰，编译器为什么要这么做，否则会出现什么问题；如何访问在其外面定义的变量？<br>PriorityQueue实现原理 替代：用TreeMap复杂度太高，有没有更好的方法。hash方法，但是队列不是定长的，如果改变了大小要rehash代价太大，还有什么方法？用堆实现，那每次get put复杂度是多少（lgN）<br>判断线程是否销毁<br>如果一个接口调用很慢，原因是，如何定位，没有日志的话：假设一下，复现问题，dump查看内存，查看监控日志<br>SimpleDateFormat 线程安全<br>StackOverFlow 栈溢出如何解决<br>设计模式分类<br>各个设计模式的UML<br>代理模式和装饰区别<br>JDK中的设计模式实例有哪些<br>面向接口编程 优点<br>流程图和时序图<br>适配器和代理模式的区别<br>单例模式的几种实现<br>各种设计原则<br>单例模式的静态内部类式，为什么静态内部类式是线程安全的<br>抽象工厂和工厂方法模式的区别<br>Java代码编译过程<br>JKD1.8的JVM指令集上有什么更新吗对比1.7<br>JDK1.8 lambda表达式、HashMap升级、ConcurrentHashMap升级、synchronized升级<br>yield功能<br>JVM如何确立每个类在JVM的唯一性；类的全限定名和加载这个类的类加载器的ID<br>给定三个线程t1,t2,t3，如何保证他们依次执行<br>Java8 stream迭代的优势和区别；lambda表达式？为什么要引入它<br>在生产线Dump堆分析程序是否有内存及性能问题<br>comparable接口和comparator接口实现比较的区别和用法<br>Arrays.sort<br>protected权限能否被包外访问；几种访问权限<br>ArrayBlockingQueue和LinkedBlockingQueue 原理<br>java是如何实现跨平台的<br>字节码的编译过程<br>JVM线程死锁，你该如何判断是因为什么？如果用VisualVM，dump线程信息出来，会有哪些信息？<br>查看jvm虚拟机里面堆、线程的信息，你用过什么命令？<br>NIO DirectMemory是否了解</p>
<p>-—————————————————————————–<br>***JavaWeb&amp;安全</p>
<p>三层模型 MVC<br>如何过滤敏感评论<br>AJAX<br>DNS；底层用的什么协议<br>Forward和redirect的区别<br>tomcat集群会话怎么保证同步<br>部署项目时tomcat 的参数<br>如果运行的web项目突然停掉了，该怎么解决<br>有哪些服务器<br>HTTPS 公钥能用公钥解吗？在客户端抓包，看到的是加密的还是没加密 是没加密的<br>https ssl tcp三者关系，其中哪些用到了对称加密，哪些用到了非对称加密，非对称加密密钥是如何实现的<br>加密的私钥和公钥各自如何分配（客户端拿公钥，服务器拿私钥）<br>客户端是如何认证服务器的真实身份，详细说明一下过程，包括公钥如何申请，哪一层加密哪一层解密<br>怎么攻击https<br>什么是对称加密，什么是非对称加密，知道的加密算法有哪些<br>TLS改进，如果session ticket被偷听到会怎样，如何防止中间人攻击<br>Servlet 容器启动过程 生命周期 doPost，doGet，一些内置对象<br>httpServlet和genericServlet的区别<br>servlet过滤器和监听器所用到的设计模式<br>servlet,filter,listener的作用;生命周期<br>每一个 request 对应的 Servlet 是直接 new 出来还是只是用同一个<br>JDBC  JDBC的桥接设计模式 jdbc的详细链接过程；底层源码；在Java中调用存储过程的方法<br>Session与Cookie，Session实现原理，如果服务器的负载量很高内存负荷不住要怎么办；session默认过期时间，过长会怎么样<br>分布式Session的几种实现方式；session一致性问题；如何防止session被别人伪造cookie得到<br>Cookie如果我不想js或http读，应该设置什么属性？里面有个属性httpOnly，这个属性你了解吗？<br>URL编码解码<br>WebService SOAP协议<br>HTTP 协议内容 get和post有什么区别？url中的host是什么意思？content-type是什么意思？如何获取http的状态码？状态码301和302有什么区别？http req、resp头有哪些字段？user-agent表示什么？<br>GET,POST等HTTP Method<br>url有最大长度限制，就问长度有限制是get的原因还是url的原因，为什么长度会有限制，是http数据包的头的字段原因还是内容字段的原因<br>怎么保证http的安全性，幂等性，回调同一个会话怎么标识不同请求，不同会话怎么区分<br>幂等性是http层面的问题吗，还是服务器要处理和解决的内容。（就是看你对幂等性的定性是怎么理解的）<br>http的缺点，无状态，明文传输。<br>Git常用命令  git rebase git rebase和git merge区别<br>HTTP 的无状态<br>xss攻击<br>csrf攻击<br>301状态码和302状态码的区别  搜索引擎碰到301状态码和302状态码会怎么做<br>sql注入<br>HTTP的短连接和长连接；长连接与短连接的区别（LVS是通过长连接作负载均衡）<br>HTTP2.0 特性 原理<br>对称加密和非对称加密<br>进程和Java虚拟机的关系<br>linkedhashmap和hashmap，treemap的区别<br>数字签名，MD5<br>Wireshark抓包<br>了解BCrypt算法<br>前端？HTML的DOM对象说几个，Document的对象和方法</p>
<p>-—————————————————————————–<br>***OS网络数据库Linux</p>
<p>进程调度<br>文件系统；文件描述符是共享的还是私有的；文件系统（ext4）超级块<br>cp/mv的区别<br>软硬连接（inode这块，ln / ln -s）<br>32位系统的最大寻址空间<br>cache 替换算法（LRU是重点）<br>OS中的CAS<br>信号量<br>内存分页、分段 段页式调度 页面替换算法 ；段式与页式内存管理的优缺点<br>进程间的通信方式<br>进程的几种状态<br>软链接硬链接<br>大小端问题<br>什么是虚拟内存；虚拟内存机制<br>虚拟地址、逻辑地址、线性地址、物理地址的区别<br>什么是内存碎片？内碎片和外碎片的区别<br>OS死锁 死锁的必要条件，怎么处理死锁<br>共享内存原理<br>中断<br>进程与线程 怎么保证进程间数据的安全？线程呢？<br>进程的调度算法<br>乐观锁vs悲观锁；如果现在只有一张火车票，怎么让所有人都看见但是只有一个人能购买成功<br>访问网站的过程  输入<a href="https://link.zhihu.com/?target=http%3A//www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>后每一层的作用 DNS、HTTP、TCP、OSPF、IP、<br>ARP协议<br>Ping的整个过程。ICMP报文是什么<br>IP地址分类<br>路由器与交换机区别；路由协议（RIP/OPSF）<br>b树，b+树，b*树 B树叶子节点个数、非叶子节点子树个数 磁盘IO次数<br>b 树和 hash 索引应用场合 区别<br>堆和栈的区别<br>TCP三次握手、四次挥手  挥手时客户端和服务器1s内发生5000次短连接，会发生什么问题 两次握手行不行 如果客户端不断的发送请求连接会怎样 那怎么知道连接是恶意的呢？可能是正常连接<br>TCP包的结构<br>四次挥手 为什么要有time_wait，以及如何避免<br>mysql索引底层 行级锁表级锁； sql语句写select *时如何加行级锁； mysql的行级锁加在哪个位置<br>mysql引擎<br>TCP可靠是如何保证<br>事务ACID；主键外键；视图与表<br>基于TCP的协议<br>索引失效，最佳左前缀法则<br>主键索引和普通索引的区别<br>各种join<br>事务隔离级别，mysql事务实现原理（redo log和undo log）<br>索引分类（unique、cluster、primary）  unique唯一索引的使用，索引字段若相同则更新，不同则插入<br>聚集索引在底层怎么实现的，数据和关键字是怎么存的<br>TCP长连接与短连接<br>explain SQL分析 每个列代表什么含义（关于优化级别 ref 和 all，什么时候应该用到index却没用到，关于extra列出现了usetempory 和 filesort分别的原因和如何着手优化等）<br>show profile 怎么使用<br>数据库范式，反范式<br>两军问题<br>TCP与UDP区别 udp怎么实现可靠传输<br>TCP 流量控制 拥塞处理 TCP滑动窗口与回退N针协议<br>Tcp连接状态如何查看<br>复合索引 复合索引要把那个字段放最前，为什么<br>计算机网络层次结构，每层内容（协议等）<br>TCP的数据包格式<br>数据库连接池； mysql数据库连接池的驱动参数 ；数据库连接池如何防止失效；数据库连接池代码<br>mysql 实现层级树形结构<br>sql 查询优化 mysql<br>linux 查看文件内容的命令<br>linux netstat top ipconfig ps<br>linux的显示文件夹大小 ls -al； Linux命令查看文件大小<br>linux的查看端口状态 natstat加参数<br>linux的查看进程的启动时间 ；查看一个进程具体信息，打开了哪些文件描述符，打开的端口，上一次占用CPU率<br>linux 显示文件属性 杀死进程 找出出现次数最多的ip linux指令<br>linux性能监测和调优<br>linux 查看磁盘读写吞吐量<br>linux 查看80端口连接数<br>mysql通信前端到sql解析到sql优化到数据库引擎<br>mysql cluster 实现原理 ；主从复制（架构/错误恢复/MHA）；读写分离 原理；<br>linux awk ；用awk统计一个ip文件中top10<br>linux 如果不知道tomcat的端口号，也不知道服务器的名称，如何查看服务器占用的哪个端口<br>如果确定查询的结果只有一行，在没有使用索引的情况下，怎么加速<br>mysql 数据类型 知道text和blob吗？text和blob有什么区别？ text中能存放图片吗？项目中图片是怎么存的？为什么不直接存成blob? text和varchar有什么区别？ int占多少位？<br>视图和存储过程<br>like%..%为什么会扫描全表？遵循什么原则？<br>TCP 四次挥手 TIME_WAIT 等待两个 MSL作用 如果在 TIME_WAIT等待时客户端手动指定该端口再次发起连接，那么可以建立连接吗？<br>TCP 三次握手 服务端回复时可以将 ACK 和SYN分开发送吗 ；最后一次没有握手成功会，连接会建立吗<br>客户端收到一个窗口为 0 的包怎么处理<br>linux select、epoll；什么是IO多路复用；epoll 水平触发和边缘触发 ；direct io和buffer io区别<br>给定一个图片 URL，讲一下获取这张图片的整个过程<br>为什么要设计进程 可以从进程演化历史、批处理、多道程序设计、进程间通信考虑<br>linux lsof、tcpdump、gdb<br>Linux 如何抓包<br>Linux管道机制，什么原理<br>linux vmstat命令<br>静态链接库和动态链接库的区别<br>TCP洪水攻击<br>32位系统的内存寻址空间多大,<br>具体分为哪几种形态?库函数和系统调用有什么区别<br>一个进程的内存分段以及对应的作用<br>linux实时查看打印的 log 日志内容； 实时查看日志命令<br>linux系统日志在哪里看<br>mysql的binlog<br>sql语句各种条件的执行顺序，如select， where， order by， group by<br>linux Java 中怎么获取一份线程 dump 文件：你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件<br>写sql 查询带日期<br>mysql批量操作<br>mysql容灾备份 ；数据库挂了怎么办？除了热备份还有什么方法<br>mysql存储底层实现<br>MySQL存放地理信息位置<br>Mysql要加上nextkey锁，语句该怎么写<br>linux Cpu load的参数如果为4，描述一下现在系统处于什么情况<br>Linux 查找磁盘上最大的文件的命令<br>什么是elf头文件<br>linux sendfile<br>为啥mysql索引要用B+树而MongoDB用B树？<br>编译原理 LL1 ；语法解析词法解析；编译步骤分几个部分；编译程序常用表达方法<br>数据库死锁以及解决<br>Linux文件权限<br>shell编程<br>网络 连接重置<br>网络通信中管道选取异常什么情况下会出现<br>chmod、chown、chgrp<br>查看网络带宽的命令<br>替换文本字符串的命令 sed<br>将当前目录下所有以“.txt”结尾的文件打印出来，再追问，除了“.txt”再加上“.abc”结尾的也打印出来。</p>
<p>-—————————————————————————–<br>***分布式理论与设计</p>
<p>网站并发量是多少？<br>用手机扫二维码登录是怎么实现的？<br>一台机器可以能宕机怎么办？<br>影响单台服务器的并发量的因素有哪些？如何优化？<br>考虑如何设计一个高并发量高吞吐量的服务器？如果是分布式的怎么设计？<br>分布式服务器会出现哪些问题<br>项目中超卖问题解决 1）乐观锁 2）队列<br>抢购怎么实现？为什么用Redis? 具体该怎么做？一台Redis肯定是不行的，该怎么办？了解集群吗？<br>设计一个系统，解决抢购时所需要的大量的短链接的功能，如何保证高并发，如何设计短链接<br>一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁<br>一致性hash；一致性hash增加减少cache时，是怎样做的<br>正向代理、反向代理<br>发布订阅模式 与 观察者模式<br>分布式数据库<br>分布式文件系统 分布式存储系统（GFS、HDFS、fastDFS）、存储模型（skipList、LSM等）<br>微信红包的设计<br>大型网站架构：《大型网站技术架构》中起码有哪些个方面<br>map reduce过程<br>SOA<br>项目中的1G左右的文件 如何实现断点续传和多线程上传<br>负载均衡方式<br>CAP+Base<br>PAXOS协议 RAFT协议<br>分布式锁 zk实现分布式锁的方式；redis实现；数据库乐观锁<br>分布式事务<br>Reactive backpressure<br>分布式接口的幂等性设计<br>缓存穿透<br>分库分表<br>RPC框架（包括整体的一些框架理论，通信的netty，序列化协议thrift，protobuff等）<br>分布式生成唯一序列号<br>负载均衡（DNS/nginx/LVS/vipserver）<br>高可用集群（heardbead/keepalived ）<br>heardbead与keepalived的区别，脑裂问题的解决，高可用方案的优劣<br>LVS四种模式</p>
<p>-—————————————————————————–<br>***开源项目</p>
<p>Tomcat 实现原理<br>JSON类库实现原理，给你一个json字符串, 你要怎么把它变成一个java对象?<br>websocket 原理<br>SpringIOC、AOP 优点，原理，常用注解介绍，AOP应用场景，Spring依赖注入方式；bean容器初始化bean之前之后要加入aop如何实现<br>Spring 初始化 @PostConstruct注解方式，init-method的XML配置方式，InitializingBean接口方式，三种实现上有什么区别<br>autowire和resourse关键字的区别<br>Spring 处理 XML 用的是什么库吗</p>
<p>自己实现Spring：每一步用什么数据结构, 存什么<br>map的key存name有问题吗？<br>value存什么?class<br>那我要实例怎么办? forName<br>单例多例分别怎么解决?<br>内存泄露要考虑吗, 或者说怎么考虑生命周期和引用</p>
<p>Spring事务传播行为<br>SpringMVC  原理，常用注解介绍<br>springmvc想要用HttpServlet的对象怎么用（在方法参数上加），那是怎么注入进去的，怎么实现的你知道嘛<br>MyBatis/Hibernate 原理，源码，区别；批量操作；MyBatis缓存（一级、二级）； mybatis的#和$号区别 ；mybatis一级缓存及可能存在的问题，两个机器能否共用同一个SqlSession实现一级缓存；mybatis如何映射表结构<br>在Hibernate中java的对象状态有哪些；hibernate主键生成策略<br>mybatis和hibernate各自的缓存原理和比较，hibernate的一级二级和查询缓存，还有针对缓存的miss率，置换策略，容量设置和性能的平衡<br>mybatis和ibatis的区别<br>怎么保证redis和db中的数据一致<br>redis实现原理 ；持久化；redis cluster实现原理 ；redis数据类型 string和list都有什么适用场景 ；Codis相关<br>redis与memcached区别 memcache如何保持缓存一致性<br>redis中SortedSet结果<br>redis主从复制过程，同步还是异步等； redis主从是怎么选取的<br>redis插槽的分配；redis主节点宕机了怎么办，还有没有同步的数据怎么办？<br>redis集群的话数据分片怎么分，然后就是如果并发很高，几十万并发，可以做哪些优化<br>Nginx配置（如果项目使用到了的话），负载均衡机制  ；nginx的请求转发算法，如何配置根据权重转发<br>Log4j 输出至数据库<br>Dubbo 通信原理；序列化原理；超时重试；负载均衡；<br>文件上传原理<br>Netty原理 ；心跳；线程模型；尝试看源码；优点；Netty零拷贝, 怎么实现<br>RocketMQ原理 可靠消息原理 尝试看一下源码；优点<br>Druid原理，数据源/数据库连接池原理；连接池中的连接是长连接还是短连接？为什么？；连接池中的连接是基于什么协议的连接？为什么？<br>zookeeper的Leader选举过程，实现机制，有缓存，如何存储注册服务的；事务，结点，服务提供方挂了如何告知消费方；3 个节点挂掉一个能正常工作吗？<br>jmeter、ab等性能测试工具<br>maven生命周期，常用maven命令；Maven包冲突怎么解决？Maven有什么命令可以解决包冲突？Maven怎么把所有包打包<br>Spring Boot实现原理<br>SSO JWT token原理<br>etcd 类似于Zookeeper，基于Raft协议<br>Jedis源码<br>-—————————————————————————–<br>***数据结构与算法</p>
<p>求a的b次方，考虑负数<br>字符串全排列<br>两个大文件找重复行<br>汉诺塔<br>atoi 要考虑负数和溢出;itoa<br>手写BlockingQueue<br>怎么判断一个二叉树是否是平衡二叉树<br>斐波那契数列<br>冒泡排序优化<br>选择排序<br>求任意二叉树第k层结点个数<br>平衡二叉搜索树；平衡二叉树插入删除查找<br>手写快排，快排改进 归并排序和快速排序的思想和区别，不用递归实现快排、<br>归并排序<br>求质数最好的方法<br>手写链表<br>链表翻转 要O(1)<br>各种排序的时间复杂度、空间复杂度，是否稳定<br>平衡二叉树，使用一维数组存储<br>数组的最大子序列和；最长递增子序列，一个dp数组一个max数组，最优情况；一个数组，有正有负，不改变顺序的情况下，求和最大的最长子序列<br>二分查找<br>二叉树的遍历  二叉树非递归遍历 二叉树的层序遍历 查找复杂度、最差时间复杂度、最好时间复杂度<br>n<em>n 的矩阵，按副对角线打印 ；矩阵旋转打印；之字形打印矩阵；45度斜线打印矩阵<br>图的遍历（深度优先、广度优先）<br>背包问题<br>链表倒数第 k个节点<br>一个无序数组找第K大的元素<br>数组与链表区别<br>判断链表是否有环<br>Hash 冲突<br>不用自带库的情况下，如何求根号3，精度在0.00001以内，保留两位小数<br>前缀树<br>判断两个链表是否相交<br>两个栈实现队列<br>找出数组两个数的和等于给定的数；一个先减后增的数组，查找目标值<br>无序数组找中位数<br>两个有序数组找中位数<br>大数据去重问题<br>top K ；找到第k大的数 ；100000个数找出最小或最大的10个 ；有一个很长的链表，找出倒数第k个元素  ；单机版 Top K：给 N 个数，找出第 K 大的数（快排的 partition，最小堆），如果用堆的话，算法时间复杂度；海量数据（不能在单机完成）：分布式 Top K？（面试官说考察 map-reduce 思想）<br>维护一个堆；堆排序的原理；堆排序大概是怎么实现的？堆排序你使用过吗，是用的怎样的底层存储，数据结构；底层是用的数组，逻辑上是怎样的结构<br>字符串匹配 KMP 正则中用的改进后的BM算法；搜索算法PN<br>使用一个数组实现一个链表，i存自己下标，i+1存下一个结点下标，i+2存值 要求使用移位操作<br>找出一个数组里面重复的数：用hash方法，建一个2的32次方个bit的hash数组，每取一个int数，可hash下2的32次方找到它在hash数组中的位置，然后将bit置1表示已存在<br>单链表奇偶位反转<br>一堆数字里面去重<br>如果要你做一个防火墙，有10万个黑名单，有可能会增长达20万个，一个数据包过来，如何匹配<br>求一个集合的所有可能子集 给定字母集合(a-z), 求出由集合中这些字母组成的所有非空子集<br>合并两个有序链表的时间复杂度<br>翻转单词顺序<br><a href="https://link.zhihu.com/?target=https%3A//leetcode.com/problems/2-keys-keyboard/description/" target="_blank" rel="noopener">https://leetcode.com/problems/2-keys-keyboard/description/</a><br><a href="https://link.zhihu.com/?target=https%3A//leetcode.com/problems/fraction-to-recurring-decimal/description/" target="_blank" rel="noopener">https://leetcode.com/problems/fraction-to-recurring-decimal/description/</a><br>3L桶一个，5L桶一个，无限水，怎么倒腾出4L来<br>爬n层楼梯，一次只能上一层或两层，输出所有情况的路径； 爬楼梯，写出状态转移方程<br>跳阶问题<br>列出一个目录下所有文件，包括子目录<br>对整数分解质因数，90=2</em>3<em>3</em>5<br>找出只出现一次的数字<br>给单链表排序，时间复杂度O(nlogn),空间复杂度O(1)<br>判断一个字符串能否被字典完全分词(dp)<br>m乘n的格子，求正方形数<br>约瑟夫环<br>给定一个数组, 里面放置任意数量的随机数, 如何快速统计出数组中重复的数字以及出现次数<br>AVL树的概念, 四种旋转方式, AVL树左右旋转的例子<br>QQ每天都会产生大量的在线日志记录, 假设每天的在线日志记录有十亿条, 请设计一个算法快速找出今天的在线人数 ；3亿条IP中，怎么找到次数出现最多的5000条IP<br>扑克牌模拟题<br>每行一个单词，有很多行，统计出现频率最高前 10 个单词<br>最小生成树prim算法与最短路径Dijkstra算法<br>找素数<br>递归求阶层<br>把一个数组中奇数放前面，偶数放后面<br>统计一个整数的二进制表示中bit为1的个数<br>1000个苹果放10个篮子，怎么放，能让我拿到所有可能的个数<br>动态规划（笔试回回有。。）、贪心<br>二叉树的最长距离；二叉树最近相同父节点<br>旋转数组中查找某一个值<br>识别2的n次方:n&amp;(n-1)可以去掉二进制最右的1，那2的n次幂&amp;之后便为0<br>手写字符串的正则匹配，实现*和.的功能，用的递归<br>两个大数求和，要按高到低位的输入，实时输出结果的对应位，空间O，时间O(n)，不借助工具类。（要考虑实时的进位标识，以及多个9之后的连续进位标识）<br>int范围的随机数的阶乘编码实现<br>存储十万条数据(键值对)到内存如何实现<br>求一个不完全三叉树叶子最多的层，求深度；找出一个三叉树节点数最多的层<br>数组实现一个循环队列<br>红黑树的插入删除搜索效率，最坏插入删除搜索效率<br>给定一个字符串，找出只出现了一次的两个字符<br>找出连续数中缺失的数字<br>找出一个数在有序数组中的位置，不行就找出下一个<br>升降数组中的最大值<br>桶排序<br>链表删除倒数第K个节点<br>多路有序链表合并 改进<br>树的下一个节点<br>找出数组中n/2的数<br>找出链表环的头部<br>跳表和红黑树的区别<br>烧绳子<br>扔骰子，1-2对方赢，3-5 自己赢，6重新仍，问自己赢的概率<br>O(n) 合并两个二叉查找树<br>给跳跃步数求最短路径<br>Trie树 Implement Trie(Prefix Tree) 最长匹配；淘宝存着一个包含10w个敏感词的词库，紧接着需要从多个商品标题中随机抽查3个有没有包含敏感词的商品。<br>二分搜索变形：找第一个target<br>最长上升子序列<br>一个无序数组，其中一个数字出现的次数大于其他数字之和，求这个数字 （主元素）<br>一棵二叉排序树，给定一个数，找到与给定数差值最小的数<br>两个排序的数组A和B分别含有m和n个数，找到两个排序数组的中位数<br>Generate Parentheses<br>最小公倍数和最大公约数<br>如何判断一个树是不是另一颗树的子树<br>判断一个IP是否在黑名单列表中<br>将一个只含有1~n的乱序数组(不重复)的第一个数变成-1，求哪个数被变成了-1<br>二叉树高度(递归，非递归)<br>一个数组只有一个数不重复，找出这个数<br>一个数组有两个不重复，找出这两个数<br>如何判断一个数是2的次幂<br>图存储<br>两个数据集求并集<br>二进制文本切割，文本中前两个字节是要给字符串的长度，然后将整个文本进行切割换行放入另一个文本<br>现在有一个特别大的文件，大概1T，现在要从服务端拖拽到客户端，有什么思路？<br>最长回文子串的程序<br>有序链表构建平衡搜索二叉树<br>2Sum，然后引申Nsum<br>如何实现用户热搜关键词提示（字典树）<br>计算一个树中两叶子节点间最大路径和<br>一段字符序列，求每个字符出现的次数，要求时间复杂度和空间复杂度最优<br>给定一个数，要求求出比这个数稍大的一个数，该数是2的幂。时间复杂度O(1)<br>把 “<a href="https://link.zhihu.com/?target=http%3A//www.zhidao.baidu.com" target="_blank" rel="noopener">http://www.zhidao.baidu.com</a>“ 这样的字符串改成 “com/baidu/zhidao/www”。——老题目了，剑指 offer 的，两次逆序排列即可。<br>长为N的数组，元素范围是0-N-1，其中只有一个数是重复的，找出这个重复元素<br>矩阵从左上角向右下角走，每次只能向右或者向下移动，求经过最大的路径<br>数n可以由完全平方数构成，求最小的完全平方数构成数。<br>多叉树实现，并层次遍历的代码<br>找到最大子数组的 start, 和 end 下标<br>找出一串字符中第一个不重复字符的下标<br>如何求二叉树中两个节点的最短路径<br>一个无限长的数组实现一个类似hashmap的结构</p>
<p>-—————————————————————————–<br>***技术无关问题</p>
<p>自我介绍：最好背熟</p>
<p>项目到底是做什么的，有哪些功能</p>
<p>项目中遇到的困难？怎么解决</p>
<p>项目的整体架构，在面试的时候能够清楚地画给面试官看并且清楚地指出从哪里调用到哪里、使用什么方式调用</p>
<p>用到了哪些技术</p>
<p>合作项目如何分工？</p>
<p>曾遇到的挫折？</p>
<p>项目画图；画一下项目的数据库表</p>
<p>用三个词语描述下自己</p>
<p>看过什么书</p>
<p>对简历上的每一个字负责, 而且最好简洁明朗, 拒绝啰嗦, 让面试官的所有问题都针对你的简历进行提问</p>
<p>带成绩单</p>
<p>举出一个例子说明你的自学能力</p>
<p>说一件大学难忘的事</p>
<p>对方公司跟之前的offer比优势在哪，比如平台更大？专业技能栈更match？工作更有挑战力？地点更合适？有机会留用？</p>
<p> 一定不要在没有面试经验的情况下先面大厂，或者是你想去的公司。</p>
<p> 对于简历上的每一条一定要熟悉，做足准备，并且遇到简历上没有都扯到的方面，要想办法转移，不要在这耗着</p>
<p> 给你印象深刻的事情</p>
<p> 你有什么问题吗？</p>
<p> 除了java还有学过其他语言吗？</p>
<p> 技术难点有哪些？说大概三个</p>
<p> 哪些专业课学的比较好？</p>
<p> 是否会读研？为什么？</p>
<p> 你身边同学如何评价你、老师呢</p>
<p> 如果与同事发生了意见的不一致，你会如何解决呢</p>
<h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://xiaozhuanlan.com/topic/7205893164" target="_blank" rel="noopener">面试过程全解析</a></li>
<li><a href="https://www.nowcoder.com/discuss/179560?type=0&order=0&pos=27&page=1" target="_blank" rel="noopener">快手Java开发实习面经（口头offer）</a></li>
<li><a href="https://blog.csdn.net/qq_34337272/article/details/88376891" target="_blank" rel="noopener">5面阿里,终获offer(Java后端)</a></li>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/22/OS/计算机操作系统：协程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/22/OS/计算机操作系统：协程/" class="post-title-link" itemprop="url">计算机操作系统：协程</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-22 15:00:11" itemprop="dateCreated datePublished" datetime="2019-03-22T15:00:11+08:00">2019-03-22</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-04-08 16:12:26" itemprop="dateModified" datetime="2019-04-08T16:12:26+08:00">2019-04-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/22/OS/计算机操作系统：协程/" class="post-meta-item leancloud_visitors" data-flag-title="计算机操作系统：协程">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/22/OS/计算机操作系统：协程/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/22/OS/计算机操作系统：协程/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><p>1.定义了一个生产者类，一个消费者类。</p>
<p>2.生产者类循环100次，向同步队列当中插入数据。</p>
<p>3.消费者循环监听同步队列，当队列有数据时拉取数据。</p>
<p>4.如果队列满了（达到5个元素），生产者阻塞。</p>
<p>5.如果队列空了，消费者阻塞。</p>
<p>该生产者/消费者模式，但是却并不是一个高性能的实现。为什么性能不高呢？原因如下：</p>
<p>1.涉及到同步锁。</p>
<p>2.涉及到线程阻塞状态和可运行状态之间的切换。</p>
<p>3.涉及到线程上下文的切换。</p>
<p>以上涉及到的任何一点，都是非常耗费性能的操作。</p>
<h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a><strong>什么是协程</strong></h2><p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<ul>
<li>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。<ul>
<li>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</li>
<li>子程序调用总是一个入口，一次返回，调用顺序是明确的。</li>
</ul>
</li>
<li>而协程的调用和子程序不同。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。<ul>
<li>但是子程序之间不相互调用，而是类似线程，在并行执行</li>
</ul>
</li>
</ul>
<p><img src="assets/1529501501760106.jpg" alt="img"></p>
<p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p>
<p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<ul>
<li>子例程（函数）的起始处是惟一的入口点，一旦退出即完成了子例程的执行，子例程的一个实例只会返回一次。</li>
<li>协程的起始处是第一个入口点，在协程里，返回点之后是接下来的入口点。子例程的生命期遵循后进先出（最后一个被调用的子例程最先返回）；相反，协程的生命期完全由他们的使用的需要决定。</li>
</ul>
<p>由于Java的原生语法中并没有实现协程（某些开源框架实现了协程，但是很少被使用），所以我们来看一看python当中对协程的实现案例，同样以生产者消费者模式为例：</p>
<p><img src="assets/1529501501404928.png" alt="img"></p>
<p>这段代码十分简单，即使没用过python的小伙伴应该也能基本看懂。</p>
<p>代码中创建了一个叫做consumer的协程，并且在主线程中生产数据，协程中消费数据。</p>
<p>其中 <strong>yield</strong> 是python当中的语法。当协程执行到yield关键字时，会暂停在那一行，等到主线程调用send方法发送了数据，协程才会接到数据继续执行。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>协程的开销远远小于线程的开销。<ul>
<li>yield让协程暂停，和线程的阻塞是有本质区别的。协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。</li>
</ul>
</li>
<li>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/21/算法/数据结构：Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/21/算法/数据结构：Map/" class="post-title-link" itemprop="url">数据结构：Map</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-21 22:14:15 / Geändert am: 22:37:17" itemprop="dateCreated datePublished" datetime="2019-03-21T22:14:15+08:00">2019-03-21</time>
            </span>
          
            

            
          

          
            <span id="/2019/03/21/算法/数据结构：Map/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构：Map">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/21/算法/数据结构：Map/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/21/算法/数据结构：Map/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=%e5%89%8d%e8%a8%80" target="_blank" rel="noopener">前言</a></h1><p>符号表（Symbol Table）是一种存储键值对的数据结构，可以支持快速查找操作。</p>
<p>符号表分为有序和无序两种，有序符号表主要指支持 min()、max() 等根据键的大小关系来实现的操作。</p>
<p>有序符号表的键需要实现 Comparable 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnorderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Value <span class="title">get</span><span class="params">(Key key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderedST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Value <span class="title">get</span><span class="params">(Key key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Key <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Key <span class="title">max</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Key&gt; <span class="title">keys</span><span class="params">(Key l, Key h)</span></span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h1 id="初级实现"><a href="#初级实现" class="headerlink" title="初级实现"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=%e5%88%9d%e7%ba%a7%e5%ae%9e%e7%8e%b0" target="_blank" rel="noopener">初级实现</a></h1><h2 id="1-链表实现无序符号表"><a href="#1-链表实现无序符号表" class="headerlink" title="1. 链表实现无序符号表"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_1-%e9%93%be%e8%a1%a8%e5%ae%9e%e7%8e%b0%e6%97%a0%e5%ba%8f%e7%ac%a6%e5%8f%b7%e8%a1%a8" target="_blank" rel="noopener">1. 链表实现无序符号表</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUnorderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; <span class="keyword">implements</span> <span class="title">UnorderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(Key key, Value value, Node next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        Node cur = first;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        Node cur = first;</span><br><span class="line">        <span class="comment">// 如果在链表中找到节点的键等于 key 就更新这个节点的值为 value</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.key.equals(key)) &#123;</span><br><span class="line">                cur.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则使用头插法插入一个新节点</span></span><br><span class="line">        first = <span class="keyword">new</span> Node(key, value, first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (first.key.equals(key))</span><br><span class="line">            first = first.next;</span><br><span class="line">        Node pre = first, cur = first.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.key.equals(key)) &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        Node cur = first;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.key.equals(key))</span><br><span class="line">                <span class="keyword">return</span> cur.value;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="2-二分查找实现有序符号表"><a href="#2-二分查找实现有序符号表" class="headerlink" title="2. 二分查找实现有序符号表"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_2-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e5%ae%9e%e7%8e%b0%e6%9c%89%e5%ba%8f%e7%ac%a6%e5%8f%b7%e8%a1%a8" target="_blank" rel="noopener">2. 二分查找实现有序符号表</a></h2><p>使用一对平行数组，一个存储键一个存储值。</p>
<p>二分查找的 rank() 方法至关重要，当键在表中时，它能够知道该键的位置；当键不在表中时，它也能知道在何处插入新键。</p>
<p>二分查找最多需要 logN+1 次比较，使用二分查找实现的符号表的查找操作所需要的时间最多是对数级别的。但是插入操作需要移动数组元素，是线性级别的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchOrderedST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; <span class="keyword">implements</span> <span class="title">OrderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchOrderedST</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">        values = (Value[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, h = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(keys[m]);</span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                h = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Key&gt; <span class="title">keys</span><span class="params">(Key l, Key h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = rank(l);</span><br><span class="line">        List&lt;Key&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (keys[index].compareTo(h) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(keys[index]);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = rank(key);</span><br><span class="line">        <span class="comment">// 如果找到已经存在的节点键为 key，就更新这个节点的值为 value</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; N &amp;&amp; keys[index].compareTo(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            values[index] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则在数组中插入新的节点，需要先将插入位置之后的元素都向后移动一个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N; j &gt; index; j--) &#123;</span><br><span class="line">            keys[j] = keys[j - <span class="number">1</span>];</span><br><span class="line">            values[j] = values[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[index] = key;</span><br><span class="line">        values[index] = value;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (index &lt; N &amp;&amp; keys[index].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> values[index];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91" target="_blank" rel="noopener">二叉查找树</a></h1><p><strong>二叉树</strong> 是一个空链接，或者是一个有左右两个链接的节点，每个链接都指向一颗子二叉树。</p>
<p><img src="assets/f9f9f993-8ece-4da7-b848-af9b438fad76-1553179026062.png" alt="img"></p>
<p><strong>二叉查找树</strong> （BST）是一颗二叉树，并且每个节点的值都大于等于其左子树中的所有节点的值而小于等于右子树的所有节点的值。</p>
<p><img src="assets/8ae4550b-f0cb-4e4d-9e2b-c550538bf230-1553179026073.png" alt="img"></p>
<p>BST 有一个重要性质，就是它的中序遍历结果递增排序。</p>
<p><img src="assets/fbe54203-c005-48f0-8883-b05e564a3173-1553179026080.png" alt="img"></p>
<p>基本数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; <span class="keyword">implements</span> <span class="title">OrderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value val;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="comment">// 以该节点为根的子树节点总数</span></span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="comment">// 红黑树中使用</span></span><br><span class="line">        <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        Node(Key key, Value val, <span class="keyword">int</span> N) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.N = N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> x.N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">recalculateSize</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>为了方便绘图，下文中二叉树的空链接不画出来。</p>
<h2 id="1-get"><a href="#1-get" class="headerlink" title="1. get()"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_1-get" target="_blank" rel="noopener">1. get()</a></h2><ul>
<li>如果树是空的，则查找未命中；</li>
<li>如果被查找的键和根节点的键相等，查找命中；</li>
<li>否则递归地在子树中查找：如果被查找的键较小就在左子树中查找，较大就在右子树中查找。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> get(x.left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> get(x.right, key);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="2-put"><a href="#2-put" class="headerlink" title="2. put()"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_2-put" target="_blank" rel="noopener">2. put()</a></h2><p>当插入的键不存在于树中，需要创建一个新节点，并且更新上层节点的链接指向该节点，使得该节点正确地链接到树中。</p>
<p><img src="assets/107a6a2b-f15b-4cad-bced-b7fb95258c9c-1553179026092.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">    root = put(root, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">        x.val = value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        x.left = put(x.left, key, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x.right = put(x.right, key, value);</span><br><span class="line">    recalculateSize(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="3-分析"><a href="#3-分析" class="headerlink" title="3. 分析"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_3-%e5%88%86%e6%9e%90" target="_blank" rel="noopener">3. 分析</a></h2><p>二叉查找树的算法运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。</p>
<p>最好的情况下树是完全平衡的，每条空链接和根节点的距离都为 logN。</p>
<p><img src="assets/4d741402-344d-4b7c-be01-e57184bcad0e-1553179026098.png" alt="img"></p>
<p>在最坏的情况下，树的高度为 N。</p>
<p><img src="assets/be7dca03-12ec-456b-8b54-b1b3161f5531-1553179026121.png" alt="img"></p>
<h2 id="4-floor"><a href="#4-floor" class="headerlink" title="4. floor()"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_4-floor" target="_blank" rel="noopener">4. floor()</a></h2><p>floor(key)：小于等于键的最大键</p>
<ul>
<li>如果键小于根节点的键，那么 floor(key) 一定在左子树中；</li>
<li>如果键大于根节点的键，需要先判断右子树中是否存在 floor(key)，如果存在就返回，否则根节点就是 floor(key)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    Node x = floor(root, key);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> floor(x.left, key);</span><br><span class="line">    Node t = floor(x.right, key);</span><br><span class="line">    <span class="keyword">return</span> t != <span class="keyword">null</span> ? t : x;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="5-rank"><a href="#5-rank" class="headerlink" title="5. rank()"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_5-rank" target="_blank" rel="noopener">5. rank()</a></h2><p>rank(key) 返回 key 的排名。</p>
<ul>
<li>如果键和根节点的键相等，返回左子树的节点数；</li>
<li>如果小于，递归计算在左子树中的排名；</li>
<li>如果大于，递归计算在右子树中的排名，加上左子树的节点数，再加上 1（根节点）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rank(key, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key, Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> size(x.left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> rank(key, x.left);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + size(x.left) + rank(key, x.right);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="6-min"><a href="#6-min" class="headerlink" title="6. min()"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_6-min" target="_blank" rel="noopener">6. min()</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min(root).key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> min(x.left);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="7-deleteMin"><a href="#7-deleteMin" class="headerlink" title="7. deleteMin()"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_7-deletemin" target="_blank" rel="noopener">7. deleteMin()</a></h2><p>令指向最小节点的链接指向最小节点的右子树。</p>
<p><img src="assets/dd15a984-e977-4644-b127-708cddb8ca99-1553179026139.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    root = deleteMin(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">deleteMin</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x.right;</span><br><span class="line">    x.left = deleteMin(x.left);</span><br><span class="line">    recalculateSize(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="8-delete"><a href="#8-delete" class="headerlink" title="8. delete()"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_8-delete" target="_blank" rel="noopener">8. delete()</a></h2><ul>
<li>如果待删除的节点只有一个子树， 那么只需要让指向待删除节点的链接指向唯一的子树即可；</li>
<li>否则，让右子树的最小节点替换该节点。</li>
</ul>
<p><img src="assets/fa568fac-ac58-48dd-a9bb-23b3065bf2dc-1553179026152.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    root = delete(root, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        x.left = delete(x.left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        x.right = delete(x.right, key);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> x.left;</span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> x.right;</span><br><span class="line">        Node t = x;</span><br><span class="line">        x = min(t.right);</span><br><span class="line">        x.right = deleteMin(t.right);</span><br><span class="line">        x.left = t.left;</span><br><span class="line">    &#125;</span><br><span class="line">    recalculateSize(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="9-keys"><a href="#9-keys" class="headerlink" title="9. keys()"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_9-keys" target="_blank" rel="noopener">9. keys()</a></h2><p>利用二叉查找树中序遍历的结果为递增的特点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Key&gt; <span class="title">keys</span><span class="params">(Key l, Key h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys(root, l, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Key&gt; <span class="title">keys</span><span class="params">(Node x, Key l, Key h)</span> </span>&#123;</span><br><span class="line">    List&lt;Key&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    <span class="keyword">int</span> cmpL = l.compareTo(x.key);</span><br><span class="line">    <span class="keyword">int</span> cmpH = h.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmpL &lt; <span class="number">0</span>)</span><br><span class="line">        list.addAll(keys(x.left, l, h));</span><br><span class="line">    <span class="keyword">if</span> (cmpL &lt;= <span class="number">0</span> &amp;&amp; cmpH &gt;= <span class="number">0</span>)</span><br><span class="line">        list.add(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmpH &gt; <span class="number">0</span>)</span><br><span class="line">        list.addAll(keys(x.right, l, h));</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="10-分析"><a href="#10-分析" class="headerlink" title="10. 分析"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_10-%e5%88%86%e6%9e%90" target="_blank" rel="noopener">10. 分析</a></h2><p>二叉查找树所有操作在最坏的情况下所需要的时间都和树的高度成正比。</p>
<h1 id="2-3-查找树"><a href="#2-3-查找树" class="headerlink" title="2-3 查找树"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_2-3-%e6%9f%a5%e6%89%be%e6%a0%91" target="_blank" rel="noopener">2-3 查找树</a></h1><p>2-3 查找树引入了 2- 节点和 3- 节点，目的是为了让树平衡。一颗完美平衡的 2-3 查找树的所有空链接到根节点的距离应该是相同的。</p>
<p><img src="assets/ff396233-1bb1-4e74-8bc2-d7c90146f5dd-1553179026162.png" alt="img"></p>
<h2 id="1-插入操作"><a href="#1-插入操作" class="headerlink" title="1. 插入操作"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_1-%e6%8f%92%e5%85%a5%e6%93%8d%e4%bd%9c" target="_blank" rel="noopener">1. 插入操作</a></h2><p>插入操作和 BST 的插入操作有很大区别，BST 的插入操作是先进行一次未命中的查找，然后再将节点插入到对应的空链接上。但是 2-3 查找树如果也这么做的话，那么就会破坏了平衡性。它是将新节点插入到叶子节点上。</p>
<p>根据叶子节点的类型不同，有不同的处理方式：</p>
<ul>
<li>如果插入到 2- 节点上，那么直接将新节点和原来的节点组成 3- 节点即可。</li>
</ul>
<p><img src="assets/7f38a583-2f2e-4738-97af-510e6fb403a7-1553179026194.png" alt="img"></p>
<ul>
<li>如果是插入到 3- 节点上，就会产生一个临时 4- 节点时，需要将 4- 节点分裂成 3 个 2- 节点，并将中间的 2- 节点移到上层节点中。如果上移操作继续产生临时 4- 节点则一直进行分裂上移，直到不存在临时 4- 节点。</li>
</ul>
<p><img src="assets/ef280699-da36-4b38-9735-9b048a3c7fe0-1553179026218.png" alt="img"></p>
<h2 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_2-%e6%80%a7%e8%b4%a8" target="_blank" rel="noopener">2. 性质</a></h2><p>2-3 查找树插入操作的变换都是局部的，除了相关的节点和链接之外不必修改或者检查树的其它部分，而这些局部变换不会影响树的全局有序性和平衡性。</p>
<p>2-3 查找树的查找和插入操作复杂度和插入顺序无关，在最坏的情况下查找和插入操作访问的节点必然不超过 logN 个，含有 10 亿个节点的 2-3 查找树最多只需要访问 30 个节点就能进行任意的查找和插入操作。</p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=%e7%ba%a2%e9%bb%91%e6%a0%91" target="_blank" rel="noopener">红黑树</a></h1><p>红黑树是 2-3 查找树，但它不需要分别定义 2- 节点和 3- 节点，而是在普通的二叉查找树之上，为节点添加颜色。指向一个节点的链接颜色如果为红色，那么这个节点和上层节点表示的是一个 3- 节点，而黑色则是普通链接。</p>
<p><img src="assets/4f48e806-f90b-4c09-a55f-ac0cd641c047-1553179026237.png" alt="img"></p>
<p>红黑树具有以下性质：</p>
<ul>
<li>红链接都为左链接；</li>
<li>完美黑色平衡，即任意空链接到根节点的路径上的黑链接数量相同。</li>
</ul>
<p>画红黑树时可以将红链接画平。</p>
<p><img src="assets/3086c248-b552-499e-b101-9cffe5c2773e-1553179026261.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackBST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; <span class="keyword">extends</span> <span class="title">BST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> x.color == RED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="1-左旋转"><a href="#1-左旋转" class="headerlink" title="1. 左旋转"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_1-%e5%b7%a6%e6%97%8b%e8%bd%ac" target="_blank" rel="noopener">1. 左旋转</a></h2><p>因为合法的红链接都为左链接，如果出现右链接为红链接，那么就需要进行左旋转操作。</p>
<p><img src="assets/9110c1a0-8a54-4145-a814-2477d0128114-1553179026273.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    Node x = h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    recalculateSize(h);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="2-右旋转"><a href="#2-右旋转" class="headerlink" title="2. 右旋转"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_2-%e5%8f%b3%e6%97%8b%e8%bd%ac" target="_blank" rel="noopener">2. 右旋转</a></h2><p>进行右旋转是为了转换两个连续的左红链接，这会在之后的插入过程中探讨。</p>
<p><img src="assets/e2f0d889-2330-424c-8193-198edebecff7-1553179026316.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    Node x = h.left;</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    recalculateSize(h);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="3-颜色转换"><a href="#3-颜色转换" class="headerlink" title="3. 颜色转换"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_3-%e9%a2%9c%e8%89%b2%e8%bd%ac%e6%8d%a2" target="_blank" rel="noopener">3. 颜色转换</a></h2><p>一个 4- 节点在红黑树中表现为一个节点的左右子节点都是红色的。分裂 4- 节点除了需要将子节点的颜色由红变黑之外，同时需要将父节点的颜色由黑变红，从 2-3 树的角度看就是将中间节点移到上层节点。</p>
<p><img src="assets/af4639f9-af54-4400-aaf5-4e261d96ace7-1553179026335.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    h.left.color = BLACK;</span><br><span class="line">    h.right.color = BLACK;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="4-插入"><a href="#4-插入" class="headerlink" title="4. 插入"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_4-%e6%8f%92%e5%85%a5" target="_blank" rel="noopener">4. 插入</a></h2><p>先将一个节点按二叉查找树的方法插入到正确位置，然后再进行如下颜色操作：</p>
<ul>
<li>如果右子节点是红色的而左子节点是黑色的，进行左旋转；</li>
<li>如果左子节点是红色的，而且左子节点的左子节点也是红色的，进行右旋转；</li>
<li>如果左右子节点均为红色的，进行颜色转换。</li>
</ul>
<p><img src="assets/08427d38-8df1-49a1-8990-e0ce5ee36ca2-1553179026371.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">    root = put(root, key, value);</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key, value, <span class="number">1</span>);</span><br><span class="line">        node.color = RED;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">        x.val = value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        x.left = put(x.left, key, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x.right = put(x.right, key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRed(x.right) &amp;&amp; !isRed(x.left))</span><br><span class="line">        x = rotateLeft(x);</span><br><span class="line">    <span class="keyword">if</span> (isRed(x.left) &amp;&amp; isRed(x.left.left))</span><br><span class="line">        x = rotateRight(x);</span><br><span class="line">    <span class="keyword">if</span> (isRed(x.left) &amp;&amp; isRed(x.right))</span><br><span class="line">        flipColors(x);</span><br><span class="line"></span><br><span class="line">    recalculateSize(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>可以看到该插入操作和二叉查找树的插入操作类似，只是在最后加入了旋转和颜色变换操作即可。</p>
<p>根节点一定为黑色，因为根节点没有上层节点，也就没有上层节点的左链接指向根节点。flipColors() 有可能会使得根节点的颜色变为红色，每当根节点由红色变成黑色时树的黑链接高度加 1.</p>
<h2 id="5-分析"><a href="#5-分析" class="headerlink" title="5. 分析"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_5-%e5%88%86%e6%9e%90" target="_blank" rel="noopener">5. 分析</a></h2><p>一颗大小为 N 的红黑树的高度不会超过 2logN。最坏的情况下是它所对应的 2-3 树，构成最左边的路径节点全部都是 3- 节点而其余都是 2- 节点。</p>
<p>红黑树大多数的操作所需要的时间都是对数级别的。</p>
<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=%e6%95%a3%e5%88%97%e8%a1%a8" target="_blank" rel="noopener">散列表</a></h1><p>散列表类似于数组，可以把散列表的散列值看成数组的索引值。访问散列表和访问数组元素一样快速，它可以在常数时间内实现查找和插入操作。</p>
<p>由于无法通过散列值知道键的大小关系，因此散列表无法实现有序性操作。</p>
<h2 id="1-散列函数"><a href="#1-散列函数" class="headerlink" title="1. 散列函数"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_1-%e6%95%a3%e5%88%97%e5%87%bd%e6%95%b0" target="_blank" rel="noopener">1. 散列函数</a></h2><p>对于一个大小为 M 的散列表，散列函数能够把任意键转换为 [0, M-1] 内的正整数，该正整数即为 hash 值。</p>
<p>散列表存在冲突，也就是两个不同的键可能有相同的 hash 值。</p>
<p>散列函数应该满足以下三个条件：</p>
<ul>
<li>一致性：相等的键应当有相等的 hash 值，两个键相等表示调用 equals() 返回的值相等。</li>
<li>高效性：计算应当简便，有必要的话可以把 hash 值缓存起来，在调用 hash 函数时直接返回。</li>
<li>均匀性：所有键的 hash 值应当均匀地分布到 [0, M-1] 之间，如果不能满足这个条件，有可能产生很多冲突，从而导致散列表的性能下降。</li>
</ul>
<p>除留余数法可以将整数散列到 [0, M-1] 之间，例如一个正整数 k，计算 k%M 既可得到一个 [0, M-1] 之间的 hash 值。注意 M 最好是一个素数，否则无法利用键包含的所有信息。例如 M 为 10k，那么只能利用键的后 k 位。</p>
<p>对于其它数，可以将其转换成整数的形式，然后利用除留余数法。例如对于浮点数，可以将其的二进制形式转换成整数。</p>
<p>对于多部分组合的类型，每个部分都需要计算 hash 值，这些 hash 值都具有同等重要的地位。为了达到这个目的，可以将该类型看成 R 进制的整数，每个部分都具有不同的权值。</p>
<p>例如，字符串的散列函数实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">    hash = (R * hash + s.charAt(i)) % M;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>再比如，拥有多个成员的自定义类的哈希函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = (((day * R + month) % M) * R + year) % M;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>R 通常取 31。</p>
<p>Java 中的 hashCode() 实现了哈希函数，但是默认使用对象的内存地址值。在使用 hashCode() 时，应当结合除留余数法来使用。因为内存地址是 32 位整数，我们只需要 31 位的非负整数，因此应当屏蔽符号位之后再使用除留余数法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = (x.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>使用 Java 的 HashMap 等自带的哈希表实现时，只需要去实现 Key 类型的 hashCode() 函数即可。Java 规定 hashCode() 能够将键均匀分布于所有的 32 位整数，Java 中的 String、Integer 等对象的 hashCode() 都能实现这一点。以下展示了自定义类型如何实现 hashCode()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String who;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date when;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(String who, Date when, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.who = who;</span><br><span class="line">        <span class="keyword">this</span>.when = when;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">17</span>;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">31</span>;</span><br><span class="line">        hash = R * hash + who.hashCode();</span><br><span class="line">        hash = R * hash + when.hashCode();</span><br><span class="line">        hash = R * hash + ((Double) amount).hashCode();</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="2-拉链法"><a href="#2-拉链法" class="headerlink" title="2. 拉链法"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_2-%e6%8b%89%e9%93%be%e6%b3%95" target="_blank" rel="noopener">2. 拉链法</a></h2><p>拉链法使用链表来存储 hash 值相同的键，从而解决冲突。</p>
<p>查找需要分两步，首先查找 Key 所在的链表，然后在链表中顺序查找。</p>
<p>对于 N 个键，M 条链表 (N&gt;M)，如果哈希函数能够满足均匀性的条件，每条链表的大小趋向于 N/M，因此未命中的查找和插入操作所需要的比较次数为 ~N/M。</p>
<p><img src="assets/9_200.png" alt="img"></p>
<h2 id="3-线性探测法"><a href="#3-线性探测法" class="headerlink" title="3. 线性探测法"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_3-%e7%ba%bf%e6%80%a7%e6%8e%a2%e6%b5%8b%e6%b3%95" target="_blank" rel="noopener">3. 线性探测法</a></h2><p>线性探测法使用空位来解决冲突，当冲突发生时，向前探测一个空位来存储冲突的键。</p>
<p>使用线性探测法，数组的大小 M 应当大于键的个数 N（M&gt;N)。</p>
<p><img src="assets/121550407878282.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; <span class="keyword">implements</span> <span class="title">UnorderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">(<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = M;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">        values = (Value[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h4 id="3-1-查找"><a href="#3-1-查找" class="headerlink" title="3.1 查找"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_31-%e6%9f%a5%e6%89%be" target="_blank" rel="noopener">3.1 查找</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % M)</span><br><span class="line">        <span class="keyword">if</span> (keys[i].equals(key))</span><br><span class="line">            <span class="keyword">return</span> values[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h4 id="3-2-插入"><a href="#3-2-插入" class="headerlink" title="3.2 插入"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_32-%e6%8f%92%e5%85%a5" target="_blank" rel="noopener">3.2 插入</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">    resize();</span><br><span class="line">    putInternal(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putInternal</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % M)</span><br><span class="line">        <span class="keyword">if</span> (keys[i].equals(key)) &#123;</span><br><span class="line">            values[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    keys[i] = key;</span><br><span class="line">    values[i] = value;</span><br><span class="line">    N++;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h4 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_33-%e5%88%a0%e9%99%a4" target="_blank" rel="noopener">3.3 删除</a></h4><p>删除操作应当将右侧所有相邻的键值对重新插入散列表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = hash(key);</span><br><span class="line">    <span class="keyword">while</span> (keys[i] != <span class="keyword">null</span> &amp;&amp; !key.equals(keys[i]))</span><br><span class="line">        i = (i + <span class="number">1</span>) % M;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (keys[i] == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    keys[i] = <span class="keyword">null</span>;</span><br><span class="line">    values[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将之后相连的键值对重新插入</span></span><br><span class="line">    i = (i + <span class="number">1</span>) % M;</span><br><span class="line">    <span class="keyword">while</span> (keys[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Key keyToRedo = keys[i];</span><br><span class="line">        Value valToRedo = values[i];</span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        values[i] = <span class="keyword">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        putInternal(keyToRedo, valToRedo);</span><br><span class="line">        i = (i + <span class="number">1</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    N--;</span><br><span class="line">    resize();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h4 id="3-5-调整数组大小"><a href="#3-5-调整数组大小" class="headerlink" title="3.5 调整数组大小"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_35-%e8%b0%83%e6%95%b4%e6%95%b0%e7%bb%84%e5%a4%a7%e5%b0%8f" target="_blank" rel="noopener">3.5 调整数组大小</a></h4><p>线性探测法的成本取决于连续条目的长度，连续条目也叫聚簇。当聚簇很长时，在查找和插入时也需要进行很多次探测。例如下图中 2~5 位置就是一个聚簇。</p>
<p><img src="assets/11_200.png" alt="img"></p>
<p>α = N/M，把 α 称为使用率。理论证明，当 α 小于 1/2 时探测的预计次数只在 1.5 到 2.5 之间。为了保证散列表的性能，应当调整数组的大小，使得 α 在 [1/4, 1/2] 之间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &gt;= M / <span class="number">2</span>)</span><br><span class="line">        resize(<span class="number">2</span> * M);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (N &lt;= M / <span class="number">8</span>)</span><br><span class="line">        resize(M / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    LinearProbingHashST&lt;Key, Value&gt; t = <span class="keyword">new</span> LinearProbingHashST&lt;Key, Value&gt;(cap);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        <span class="keyword">if</span> (keys[i] != <span class="keyword">null</span>)</span><br><span class="line">            t.putInternal(keys[i], values[i]);</span><br><span class="line"></span><br><span class="line">    keys = t.keys;</span><br><span class="line">    values = t.values;</span><br><span class="line">    M = t.M;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=%e5%b0%8f%e7%bb%93" target="_blank" rel="noopener">小结</a></h1><h2 id="1-符号表算法比较"><a href="#1-符号表算法比较" class="headerlink" title="1. 符号表算法比较"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_1-%e7%ac%a6%e5%8f%b7%e8%a1%a8%e7%ae%97%e6%b3%95%e6%af%94%e8%be%83" target="_blank" rel="noopener">1. 符号表算法比较</a></h2><table>
<thead>
<tr>
<th>算法</th>
<th>插入</th>
<th>查找</th>
<th>是否有序</th>
</tr>
</thead>
<tbody><tr>
<td>链表实现的无序符号表</td>
<td>N</td>
<td>N</td>
<td>yes</td>
</tr>
<tr>
<td>二分查找实现的有序符号表</td>
<td>N</td>
<td>logN</td>
<td>yes</td>
</tr>
<tr>
<td>二叉查找树</td>
<td>logN</td>
<td>logN</td>
<td>yes</td>
</tr>
<tr>
<td>2-3 查找树</td>
<td>logN</td>
<td>logN</td>
<td>yes</td>
</tr>
<tr>
<td>拉链法实现的散列表</td>
<td>N/M</td>
<td>N/M</td>
<td>no</td>
</tr>
<tr>
<td>线性探测法实现的散列表</td>
<td>1</td>
<td>1</td>
<td>no</td>
</tr>
</tbody></table>
<p>应当优先考虑散列表，当需要有序性操作时使用红黑树。</p>
<h2 id="2-Java-的符号表实现"><a href="#2-Java-的符号表实现" class="headerlink" title="2. Java 的符号表实现"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_2-java-%e7%9a%84%e7%ac%a6%e5%8f%b7%e8%a1%a8%e5%ae%9e%e7%8e%b0" target="_blank" rel="noopener">2. Java 的符号表实现</a></h2><ul>
<li>java.util.TreeMap：红黑树</li>
<li>java.util.HashMap：拉链法的散列表</li>
</ul>
<h2 id="3-稀疏向量乘法"><a href="#3-稀疏向量乘法" class="headerlink" title="3. 稀疏向量乘法"></a><a href="http://zhangchangle.com/#/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8?id=_3-%e7%a8%80%e7%96%8f%e5%90%91%e9%87%8f%e4%b9%98%e6%b3%95" target="_blank" rel="noopener">3. 稀疏向量乘法</a></h2><p>当向量为稀疏向量时，可以使用符号表来存储向量中的非 0 索引和值，使得乘法运算只需要对那些非 0 元素进行即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Double&gt; hashMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SparseVector</span><span class="params">(<span class="keyword">double</span>[] vector)</span> </span>&#123;</span><br><span class="line">        hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (vector[i] != <span class="number">0</span>)</span><br><span class="line">                hashMap.put(i, vector[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hashMap.getOrDefault(i, <span class="number">0.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(SparseVector other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : hashMap.keySet())</span><br><span class="line">            sum += <span class="keyword">this</span>.get(i) * other.get(i);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Vorherige Seite"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">219</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">Kategorien</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">schlagwörter</span>
        
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  











  
  <script>
    function showTime(Counter) {
      var entries = [];
      var $visitors = $('.leancloud_visitors');

      $visitors.each(function() {
        entries.push( $(this).attr('id').trim() );
      });

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url: { '$in': entries } }) })
        .done(function({ results }) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if (countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function ({ responseJSON }) {
          console.log(`LeanCloud Counter Error: ${responseJSON.code} ${responseJSON.error}`);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
                'X-LC-Key': 'uTVcNIWdMCGpicrhTKygpKXi',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
            if ($('.post-title-link').length >= 1) {
              showTime(Counter);
            }
          
        });
    });
  </script>












  
<link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">
<script src="/lib/algolia-instant-search/instantsearch.min.js"></script>


<script src="/js/algolia-search.js?v=7.2.0"></script>














    
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
    appKey: 'uTVcNIWdMCGpicrhTKygpKXi',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn'
  });
</script>


</body>
</html>
