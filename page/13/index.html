<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: 'OZTK1BY156',
      apiKey: '',
      indexName: 'BlogIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Kopieren',
      copy_success: 'Kopiert',
      copy_failure: 'Kopieren fehlgeschlagen'
    }
  };
</script>

  <meta name="description" content="To be awesome">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="To be awesome">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="To be awesome">
  <link rel="canonical" href="http://yoursite.com/page/13/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>Über</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Schlagwörter</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Kategorien</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>Zeitplan</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Suche</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="algolia-popup popup search-popup">
  <div class="algolia-search">
    <div class="algolia-search-input-icon">
      <i class="fa fa-search"></i>
    </div>
    <div class="algolia-search-input" id="algolia-search-input"></div>
  </div>

  <div class="algolia-results">
    <div id="algolia-stats"></div>
    <div id="algolia-hits"></div>
    <div id="algolia-pagination" class="algolia-pagination"></div>
  </div>

  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>



    </div>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/Java/base/Java并发：Java实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/05/Java/base/Java并发：Java实现/" class="post-title-link" itemprop="url">Java并发：Java实现</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-05 19:31:00" itemprop="dateCreated datePublished" datetime="2019-03-05T19:31:00+08:00">2019-03-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-05-16 08:43:49" itemprop="dateModified" datetime="2019-05-16T08:43:49+08:00">2019-05-16</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/05/Java/base/Java并发：Java实现/" class="post-meta-item leancloud_visitors" data-flag-title="Java并发：Java实现">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/05/Java/base/Java并发：Java实现/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/05/Java/base/Java并发：Java实现/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h1><h2 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h2><p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
<h3 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h3><p>线程可以驱动任务，因此需要一种描述任务的方式。</p>
<p>通过Runnable接口提供，只需要实现接口，并编写run方法。但是该方法并不产生任何内在的线程能力。</p>
<p>要实现线程行为，必须显式地将一个任务附着到线程上，通过Thread的start方法启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> countDown = <span class="number">10</span>; <span class="comment">// Default</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = taskCount++;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">(<span class="keyword">int</span> countDown)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.countDown = countDown;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"#"</span> + id + <span class="string">"("</span> + (countDown &gt; <span class="number">0</span> ? countDown : <span class="string">"Liftoff!"</span>) + <span class="string">"), "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//实现run方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(countDown-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.print(status());</span><br><span class="line">        </span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<h3 id="Callable-从任务中返回值"><a href="#Callable-从任务中返回值" class="headerlink" title="Callable 从任务中返回值"></a>Callable 从任务中返回值</h3><p><strong>Runable与Callable</strong></p>
<ul>
<li>Runnable是执行工作的独立任务，但是不返回任何值<ul>
<li>使用ExecutorService.execute()调用</li>
</ul>
</li>
<li>Callable在完成任务的时候，可以返回一个值<ul>
<li>使用ExecutorService.sumbit()调用</li>
<li>返回的对象是Future对象<ul>
<li>isDone方法查询是否完成，任务完成时具有结果</li>
<li>get方法会获取结果<ul>
<li>如果没有结果，则会阻塞，直至结果就绪</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Callable是一种具有类型参数的泛型，它的类型参数表示从方法call()当中返回的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//执行的方法  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"result of TaskWithResult "</span> + id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    ArrayList&lt;Future&lt;String&gt;&gt; results =</span><br><span class="line">      <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">    <span class="keyword">for</span>(Future&lt;String&gt; fs : results)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//get方法会阻塞，直至产生结果</span></span><br><span class="line">        <span class="comment">// get() blocks until completion:</span></span><br><span class="line">        System.out.println(fs.get());</span><br><span class="line">      &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(ExecutionException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">result of TaskWithResult 0</span></span><br><span class="line"><span class="comment">result of TaskWithResult 1</span></span><br><span class="line"><span class="comment">result of TaskWithResult 2</span></span><br><span class="line"><span class="comment">result of TaskWithResult 3</span></span><br><span class="line"><span class="comment">result of TaskWithResult 4</span></span><br><span class="line"><span class="comment">result of TaskWithResult 5</span></span><br><span class="line"><span class="comment">result of TaskWithResult 6</span></span><br><span class="line"><span class="comment">result of TaskWithResult 7</span></span><br><span class="line"><span class="comment">result of TaskWithResult 8</span></span><br><span class="line"><span class="comment">result of TaskWithResult 9</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p>
<p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>将Runnable对象转变为工作任务的传统方式，是将它提交给一个Thread构造器</p>
<p>从输出中可以看到，start方法很快就返回了，是先于run方法执行的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicThreads</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//构造器需要一个runnable对象</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff());</span><br><span class="line">      <span class="comment">//start方法为该线程执行必要的初始化操作</span></span><br><span class="line">      <span class="comment">//调用runnable的run方法，启动任务</span></span><br><span class="line">    t.start();</span><br><span class="line">    System.out.println(<span class="string">"Waiting for LiftOff"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (90% match)</span></span><br><span class="line"><span class="comment">Waiting for LiftOff</span></span><br><span class="line"><span class="comment">#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p><strong>生命周期</strong></p>
<p>main函数创建Thread时，没有捕获这些对象的引用。但是每个Thread都<strong>注册</strong>了它自己，因此确实存在一个对它的引用，而且在它的任务退出run且死亡前，垃圾回收器无法清除它。因此一个线程会创建一个单独的执行线程，在对start调用完成后，它仍旧会继续存在。</p>
<h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p>
<p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>线程的优先级将该线程的重要性传递给了调度器。调度器倾向于让优先级最高的线程执行。（通常不要设置）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getPriority()<span class="comment">//获取当前线程优先级</span></span><br><span class="line">setPriority()<span class="comment">//修改优先级</span></span><br></pre></td></tr></table></figure>

<h3 id="让步Thread-yield"><a href="#让步Thread-yield" class="headerlink" title="让步Thread.yield()"></a>让步Thread.yield()</h3><p>静态方法Thread.yield()的调用</p>
<ul>
<li>是对线程调度器（Java线程机制的一部分，可以将CPU从一个线程转移给另一个线程）的一种建议</li>
<li>在声明：我已经执行完生命周期中最重要的部分，现在是切换给其他任务执行一段时间的大好时机</li>
</ul>
<p>当一件完成了run中一次工作，可以给线程调度机制一个暗示，即可以让别的线程使用CPU了。但是，<strong>这只是一个暗示，没有任何机制保证它将会被采纳</strong>。因此在重要的控制中，不能依赖yield</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加入一个线程"><a href="#加入一个线程" class="headerlink" title="加入一个线程"></a>加入一个线程</h3><p>join()方法</p>
<ul>
<li>一个线程可以在其他线程上调用join()方法<ul>
<li>等待一段时间，直到第二个线程结束才继续执行</li>
<li>如果某个线程在另一个线程t上调用t.join()，此线程将被挂起，直到t结束才恢复</li>
<li>或者为join添加一个超时参数</li>
<li>对join的调用可以被中断，在调用线程上调用interrupt()方法（try -catch）</li>
</ul>
</li>
</ul>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>指在程序运行的时候，在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分，</p>
<p>当所有的非后台线程结束时，程序就会终止，同时杀死进程所有后台线程。只要存在非后台线程，程序就不会终止。</p>
<p>在线程启动前调用setDaemon()方法，设置为后台线程。main属于非后台线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>线程组持有一个线程集合</p>
<blockquote>
<p>是一次不成功的尝试，忽略即可</p>
</blockquote>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>主要有三种 Executor：</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<p>java.util.concurrent包当中的执行器（excutor）帮助管理Thread对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//Executors.newFixedThreadPool(15);则可以预先进行现场分配，固定现场池大小</span></span><br><span class="line">      <span class="comment">//newCachedThreadPool是首选，会创建与所需数量相同的线程，在它回收旧线程时停止创建新线程</span></span><br><span class="line">      <span class="comment">//SingleThreadExecutor是数量为1的线程池，用于在一个线程中连续运行任何事物（长期存活的任务），例如监听进入的套接字连接</span></span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">      <span class="comment">//该方法防止新任务提交给executor</span></span><br><span class="line">      <span class="comment">//将继续运行已经提交过的任务，并且程序在所有任务完成后尽快推出</span></span><br><span class="line">    exec.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">#0(9), #0(8), #1(9), #2(9), #3(9), #4(9), #0(7), #1(8), #2(8), #3(8), #4(8), #0(6), #1(7), #2(7), #3(7), #4(7), #0(5), #1(6), #2(6), #3(6), #4(6), #0(4), #1(5), #2(5), #3(5), #4(5), #0(3), #1(4), #2(4), #3(4), #4(4), #0(2), #1(3), #2(3), #3(3), #4(3), #0(1), #1(2), #2(2), #3(2), #4(2), #0(Liftoff!), #1(1), #2(1), #3(1), #4(1), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>由于线程的本质特性，使得你<strong>不能捕获从线程中逃逸的异常</strong>。一旦逃逸出任务的run()方法，就会向外传播到控制台，除非采用<strong>特殊的步骤</strong>进行捕获。</p>
<p>Executor可以解决这个问题</p>
<p>修改产生线程的方式，Thread.UncaughtExceptionHandler是一个新的接口，允许在每个thread对象上附着一个异常处理器。</p>
<h2 id="任务的多种启动"><a href="#任务的多种启动" class="headerlink" title="任务的多种启动"></a>任务的多种启动</h2><p>任务类的实现方式：</p>
<ul>
<li>实现runnable或callable</li>
<li>从thread继承</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Store the thread name:</span></span><br><span class="line">    <span class="keyword">super</span>(Integer.toString(++threadCount));</span><br><span class="line">    start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"#"</span> + getName() + <span class="string">"("</span> + countDown + <span class="string">"), "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      System.out.print(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span>(--countDown == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      <span class="keyword">new</span> SimpleThread();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">#1(5), #1(4), #1(3), #1(2), #1(1), #2(5), #2(4), #2(3), #2(2), #2(1), #3(5), #3(4), #3(3), #3(2), #3(1), #4(5), #4(4), #4(3), #4(2), #4(1), #5(5), #5(4), #5(3), #5(2), #5(1),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>自管理的runnable</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfManaged</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//定义了一个thread，并以对象本身进行初始化</span></span><br><span class="line">  <span class="keyword">private</span> Thread t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//在构造器当中，进行线程启动</span></span><br><span class="line">    <span class="comment">//但可能不处于不稳定状态，因为在构造器当中使用线程</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SelfManaged</span><span class="params">()</span> </span>&#123; t.start(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName() +</span><br><span class="line">      <span class="string">"("</span> + countDown + <span class="string">"), "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      System.out.print(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span>(--countDown == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      <span class="keyword">new</span> SelfManaged();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Thread-0(5), Thread-0(4), Thread-0(3), Thread-0(2), Thread-0(1), Thread-1(5), Thread-1(4), Thread-1(3), Thread-1(2), Thread-1(1), Thread-2(5), Thread-2(4), Thread-2(3), Thread-2(2), Thread-2(1), Thread-3(5), Thread-3(4), Thread-3(3), Thread-3(2), Thread-3(1), Thread-4(5), Thread-4(4), Thread-4(3), Thread-4(2), Thread-4(1),</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用内部类将线程代码隐藏在类中</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>任务与线程是相互分离的</p>
<ul>
<li>执行的任务<ul>
<li>Runnable</li>
</ul>
</li>
<li>驱动任务的线程<ul>
<li>对于线程Thread类无实际的控制权</li>
<li>将一个线程附着到任务上，以使得这个线程可以驱动任务</li>
</ul>
</li>
</ul>
<h1 id="共享受限资源"><a href="#共享受限资源" class="headerlink" title="共享受限资源"></a>共享受限资源</h1><p>两个线程试图同时使用一个资源。如在一个地方停车。</p>
<h2 id="解决共享资源竞争"><a href="#解决共享资源竞争" class="headerlink" title="解决共享资源竞争"></a>解决共享资源竞争</h2><p>永远不知道一个线程何时运行</p>
<p>解决冲突的方法：在资源被一个任务使用时，在其上加锁。</p>
<p><strong>采用序列化访问共享资源</strong>的方案解决线程冲突问题，在给定时刻只允许一个任务访问共享资源。</p>
<p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>java采用synchronized关键字提供锁，当任务执行该关键字保护的片段时</p>
<p>流程</p>
<ul>
<li><p>检查锁是否可用</p>
</li>
<li><p>可用</p>
<ul>
<li><p>获取锁，执行代码</p>
</li>
<li><p>释放锁</p>
</li>
</ul>
</li>
<li><p>不可用</p>
<ul>
<li>阻塞，直至锁释放</li>
</ul>
</li>
</ul>
<p>synchronized是可重入锁，即同一个对象可以重复获得该方法的锁。</p>
<ul>
<li>只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li>同步代码块</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同步方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它和同步代码块一样，作用于同一个对象。</p>
<ul>
<li>同步类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同步静态方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于整个类。</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><ul>
<li>一种显式的互斥机制</li>
<li>Lock对象必须被<strong>显式地创建、锁定和释放</strong>。</li>
<li>因此相比于内建的锁形式相比，代码缺乏优雅性。</li>
<li>对于解决某些类型问题，更加灵活</li>
</ul>
<p><strong>锁的使用</strong></p>
<p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReentrantLock允许尝试着获取但最终未获取锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptLocking</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">//如果其他人已经获取了锁，那么你就可以决定离开去执行其他一些事情，而不是等待直至这个锁被释放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">untimed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> captured = lock.tryLock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"tryLock(): "</span> + captured);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(captured)</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//尝试去获取锁，该尝试可以在2s后失败</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> captured = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      captured = lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"tryLock(2, TimeUnit.SECONDS): "</span> +</span><br><span class="line">        captured);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(captured)</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttemptLocking al = <span class="keyword">new</span> AttemptLocking();</span><br><span class="line">    al.untimed(); <span class="comment">// True -- lock is available</span></span><br><span class="line">    al.timed();   <span class="comment">// True -- lock is available</span></span><br><span class="line">    <span class="comment">// Now create a separate task to grab the lock:</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      &#123; setDaemon(<span class="keyword">true</span>); &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        al.lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"acquired"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    Thread.yield(); <span class="comment">// Give the 2nd task a chance</span></span><br><span class="line">    al.untimed(); <span class="comment">// False -- lock grabbed by task</span></span><br><span class="line">    al.timed();   <span class="comment">// False -- lock grabbed by task</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">tryLock(): true</span></span><br><span class="line"><span class="comment">tryLock(2, TimeUnit.SECONDS): true</span></span><br><span class="line"><span class="comment">acquired</span></span><br><span class="line"><span class="comment">tryLock(): false</span></span><br><span class="line"><span class="comment">tryLock(2, TimeUnit.SECONDS): false</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="Lock与synchronized比较"><a href="#Lock与synchronized比较" class="headerlink" title="Lock与synchronized比较"></a>Lock与synchronized比较</h3><blockquote>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
</blockquote>
<ul>
<li><p>锁的实现</p>
<ul>
<li>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</li>
</ul>
</li>
<li><p>错误处理</p>
<ul>
<li>使用synchronized，某些事物失败了，就会抛出异常，无法去做任何清理工作，维护系统处于良好</li>
<li>Lock对象可以使用finally子句将系统维护在正确状态</li>
</ul>
</li>
<li><p>代码量</p>
<ul>
<li>synchronized代码量较少，出现错误可能性较低</li>
</ul>
</li>
<li><p>等待可中断</p>
<ul>
<li><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
</li>
<li><p>ReentrantLock 可中断，而 synchronized 不行。</p>
</li>
</ul>
</li>
<li><p>公平锁</p>
<ul>
<li><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
</li>
<li><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
</li>
</ul>
</li>
<li><p>锁绑定多个条件</p>
<ul>
<li>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</li>
</ul>
</li>
<li><p>适用场景</p>
<ul>
<li>synchronized不能尝试获取锁，且最终获取锁会失败，或者尝试获取锁一段时间，然后放弃它</li>
<li>Lock对于锁具有更细力度的控制力，对于实现专有同步结构是有效的</li>
</ul>
</li>
</ul>
<h3 id="何时进行同步"><a href="#何时进行同步" class="headerlink" title="何时进行同步"></a>何时进行同步</h3><blockquote>
<p>如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用系统的监视器锁同步</p>
</blockquote>
<h2 id="原子性与易变性"><a href="#原子性与易变性" class="headerlink" title="原子性与易变性"></a>原子性与易变性</h2><p>原子操作：不能被线程调度机制中断的操作。一旦操作开始，那么它一定可以在可能发生的“上下文切换”前执行完毕</p>
<blockquote>
<p>原子操作需要进行同步控制</p>
</blockquote>
<p>原子性可以应用于除long和double之外所有基本类型上的“简单操作”，对于这些操作可以保证它们会被当成原子操作来操作内存。</p>
<p>对于64位的long与double进行读与写操作会被JVM当做两个分离的32位操作，因此可能会出现上下文切换。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>一个任务做出的修改，即使在不中断的意义上讲是原子性的，对于其他任务也可能是不可视的。</p>
<ul>
<li>修改可能只是暂时地存储在本地处理器的缓存时</li>
</ul>
<p>因此不同的任务对于应用的状态有不同的视图。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>保证了应用的可视性，如果一个域为volatile的，那么只要对这个域进行了写操作，所有的读操作就都可以看到这个修改。</p>
<p>如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则这个域就只能由同步来访问。</p>
<p>如果一个域定义为volatile的，那么就会告知编译器不要只想任何一处读取和写入操作的优化。目的是用线程中的局部变量维护对这个域的精确同步。</p>
<p><strong>意外</strong></p>
<p>volatile无法工作的情况</p>
<ul>
<li>如果一个域的值依赖于它之前的值</li>
<li>如果域的值受到其他域的值现在</li>
</ul>
<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>AtomicInteger、AtomicLong、AtomicReference等原子性变量类</p>
<h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>原子性更新操作CAS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(expectedValue，updateValue)</span>；</span></span><br></pre></td></tr></table></figure>

<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>同步控制块</p>
<p>希望防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法，通过这种方式分离出来的代码段被称为<strong>临界区</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（syncObjet）&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在其他对象上同步"><a href="#在其他对象上同步" class="headerlink" title="在其他对象上同步"></a>在其他对象上同步</h2><p>synchronized块需要给定一个在其上进行同步的对象，使用synchronized（this）会使得该对象其他的synchronized方法无法被调用。</p>
<p>如果必须在另一个对象上进行同步，则必须确保所有相关的任务都在同一个对象上同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualSynch</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object syncObject = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      print(<span class="string">"f()"</span>);</span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(syncObject) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        print(<span class="string">"g()"</span>);</span><br><span class="line">        Thread.yield();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个任务同时进入了同时一个对象</span></span><br><span class="line"><span class="comment">//对象上的方法是在不同的锁上进行同步</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncObject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DualSynch ds = <span class="keyword">new</span> DualSynch();</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ds.f();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    ds.g();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h2><ul>
<li>根除对变量的共享而防止任务在共享资源上产生冲突。</li>
<li>通过为使用相同变量的每个不同的线程都创建不同的存储</li>
<li>Global 意思是在当前线程中，任何一个点都可以访问到ThreadLocal的值。</li>
<li>Local 意思是该线程的ThreadLocal只能被该线程访问，一般情况下其他线程访问不到。</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>为变量生成新的存储，并将状态与线程关联起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Accessor</span><span class="params">(<span class="keyword">int</span> idn)</span> </span>&#123; id = idn; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">      ThreadLocalVariableHolder.increment();</span><br><span class="line">      System.out.println(<span class="keyword">this</span>);</span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"#"</span> + id + <span class="string">": "</span> +</span><br><span class="line">      ThreadLocalVariableHolder.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalVariableHolder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value =</span><br><span class="line">    <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(<span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    value.set(value.get() + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value.get(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> Accessor(i));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);  <span class="comment">// Run for a while</span></span><br><span class="line">    exec.shutdownNow();         <span class="comment">// All Accessors will quit</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">#0: 9259</span></span><br><span class="line"><span class="comment">#1: 556</span></span><br><span class="line"><span class="comment">#2: 6694</span></span><br><span class="line"><span class="comment">#3: 1862</span></span><br><span class="line"><span class="comment">#4: 962</span></span><br><span class="line"><span class="comment">#0: 9260</span></span><br><span class="line"><span class="comment">#1: 557</span></span><br><span class="line"><span class="comment">#2: 6695</span></span><br><span class="line"><span class="comment">#3: 1863</span></span><br><span class="line"><span class="comment">#4: 963</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h1 id="终结任务"><a href="#终结任务" class="headerlink" title="终结任务"></a>终结任务</h1><p>某些情况下，任务必须更加突然地终止</p>
<p>方法</p>
<ul>
<li>在程序当中设置一个标志位，在程序的某一点当中检查标志，以决定是否跳出循环</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul>
<li>新建</li>
<li>就绪</li>
<li>阻塞<ul>
<li>一个任务进入阻塞状态的原因<ul>
<li>调用sleep()方法</li>
<li>调用wait()使得线程挂起，直到线程得到了notify()或notifyAll()，任务才会进入就绪</li>
<li>任务在等待某个输入、输出完成</li>
<li>任务视图在某个对象上调用其同步方法，但是对象锁不可用</li>
</ul>
</li>
</ul>
</li>
<li>死亡</li>
</ul>
<h2 id="在阻塞时终结"><a href="#在阻塞时终结" class="headerlink" title="在阻塞时终结"></a>在阻塞时终结</h2><p>对于处于阻塞状态的任务，不能等待其到达代码中可以检查状态值的某一点，因而决定让它主动终止，就必须强制这个任务跳出阻塞</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<p>打断被阻塞的任务，可能需要清理资源，因此类似于抛出异常。</p>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p>Thread类的一个方法，终止被阻塞的任务。</p>
<p>这个方法将设置线程的中断状态</p>
<p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Thread end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">Thread end</span><br></pre></td></tr></table></figure>

<h3 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h3><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$<span class="number">0</span>(InterruptExample.java:<span class="number">5</span>)</span><br><span class="line">    at InterruptExample$$Lambda$<span class="number">1</span>/<span class="number">713338599</span>.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure>

<h3 id="被互斥所阻塞"><a href="#被互斥所阻塞" class="headerlink" title="被互斥所阻塞"></a>被互斥所阻塞</h3><p>试图在一个对象上调用synchronized方法，而这个对象的锁已经被其他任务获得，那么调用任务将被挂起（阻塞），直至这个锁可获得</p>
<h3 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h3><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p>
<p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$<span class="number">0</span>(ExecutorInterruptExample.java:<span class="number">9</span>)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$<span class="number">1</span>/<span class="number">1160460865</span>.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1142</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure>

<p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="检查中断"><a href="#检查中断" class="headerlink" title="检查中断"></a>检查中断</h2><h1 id="线程间协作"><a href="#线程间协作" class="headerlink" title="线程间协作"></a>线程间协作</h1><p>线程间相互协调，某些部分必须在其他部分被解决前解决。即存在前置条件</p>
<p>任务协作时，关键问题是这些任务间的握手，为了实现握手，使用了<strong>互斥</strong>。互斥确保只有一个任务可以响应某个信号，以消除任何困难的竞争条件。</p>
<p>在互斥上，为任务添加了一种途径，可以将自身挂起，直至某些外部条件发生变化。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample example = <span class="keyword">new</span> JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>

<h2 id="wait-与notifyAll"><a href="#wait-与notifyAll" class="headerlink" title="wait()与notifyAll()"></a>wait()与notifyAll()</h2><p><strong>wait</strong>：</p>
<ul>
<li>表示等待某个条件发生变化，而改变这个条件超出了当前方法的控制能力，通常需要另一个任务来改变</li>
<li>wait需要notify、notifyAll、或者令时间到期从而恢复执行</li>
<li>wait期间，对象锁是释放的，当wait时，即在声明：我已经做完能做的所有事情，因此等待，并且希望其他的synchronized操作在条件合适情况下执行<ul>
<li>sleep方法不释放对象的锁</li>
</ul>
</li>
<li>需要用一个检查感兴趣的条件的while循环包围wait。需要检查锁感兴趣的特定条件，在不满足条件下重新wait<ul>
<li>可能有多个任务出于相同原因等待同一个锁，而第一个唤醒任务可能改变状态，此时应该再次通过调用wait以重新挂起</li>
<li>在这个任务从其wait被唤醒的时刻，可能有其他的任务已经做出改变，使得这个任务此时不能执行。此时应该再次调用wait以挂起</li>
<li>任务出于不同的原因在等待你的对象上的锁，需要检查是否已经由正确的原因唤醒，如果不是，再次调用wait</li>
</ul>
</li>
<li>只能用在同步方法或者同步控制块中使用<ul>
<li>如果在非同步控制块中，可以通过编译，但如果任务（线程）没有持有对象的锁，则会抛出异常 IllegalMonitorStateException。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<p><strong>wait与sleep</strong></p>
<ul>
<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li>
<li>wait() 会释放锁，sleep() 不会。</li>
</ul>
<p><strong>notify</strong></p>
<ul>
<li>唤醒wait调用而被挂起的任务</li>
<li>任务首先获取当它进入wait时释放的锁<ul>
<li>锁不可用，则继续挂起</li>
<li>锁可用，并获取，任务被唤醒</li>
</ul>
</li>
</ul>
<p><strong>调用区域</strong></p>
<p>wait与notify是Object对象的一部分，因为这些方法操作的锁也是所有对象的一部分，因此他们不是Thread类中。</p>
<p>方法只能再同步控制块里进行调用，如果在非同步控制块中，可以通过编译，但如果任务（线程）没有持有对象的锁，则会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> waxOn = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waxed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    waxOn = <span class="keyword">true</span>; <span class="comment">// Ready to buff</span></span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buffed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    waxOn = <span class="keyword">false</span>; <span class="comment">// Ready for another coat of wax</span></span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitForWaxing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(waxOn == <span class="keyword">false</span>)</span><br><span class="line">      wait();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitForBuffing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(waxOn == <span class="keyword">true</span>)</span><br><span class="line">      wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaxOn</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WaxOn</span><span class="params">(Car c)</span> </span>&#123; car = c; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        printnb(<span class="string">"Wax On! "</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.waxed();</span><br><span class="line">        car.waitForBuffing();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">"Exiting via interrupt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">"Ending Wax On task"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaxOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WaxOff</span><span class="params">(Car c)</span> </span>&#123; car = c; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        car.waitForWaxing();</span><br><span class="line">        printnb(<span class="string">"Wax Off! "</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        car.buffed();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">"Exiting via interrupt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">"Ending Wax Off task"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaxOMatic</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">new</span> Car();</span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(<span class="keyword">new</span> WaxOff(car));</span><br><span class="line">    exec.execute(<span class="keyword">new</span> WaxOn(car));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// Run for a while...</span></span><br><span class="line">    exec.shutdownNow(); <span class="comment">// Interrupt all tasks</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>错失的信号</strong></p>
<ul>
<li>假设T2获得someCondition的值为true</li>
<li>而此时调度器切换到T1，T1执行notify</li>
<li>T2继续执行，进行wait，notify已经错失，进入死锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">T1:</span><br><span class="line"><span class="keyword">synchronized</span>（sharedMonitor）&#123;</span><br><span class="line">	<span class="comment">//防止T2调用wait的动作</span></span><br><span class="line">    &lt;setup condition <span class="keyword">for</span> T2&gt;</span><br><span class="line">    sharedMonitor.notify();</span><br><span class="line">&#125;</span><br><span class="line">T2:</span><br><span class="line"><span class="keyword">while</span>(someCondition)&#123;</span><br><span class="line">	<span class="comment">//point1</span></span><br><span class="line">	<span class="keyword">synchronized</span>(sharedMonitor)&#123;</span><br><span class="line">        sharedMonitor.wait();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消除竞争条件</span></span><br><span class="line"><span class="keyword">while</span>(someCondition)&#123;</span><br><span class="line">	<span class="comment">//point1</span></span><br><span class="line">	<span class="keyword">synchronized</span>(sharedMonitor)&#123;</span><br><span class="line">	<span class="keyword">while</span>(someCondition)&#123;</span><br><span class="line">        sharedMonitor.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="notify-与notifyAll"><a href="#notify-与notifyAll" class="headerlink" title="notify()与notifyAll()"></a>notify()与notifyAll()</h2><p>使用notify的条件</p>
<ul>
<li>使用notify而不是notifyAll是一种优化</li>
<li>使用notify，则必须保证被唤醒的是恰当的任务</li>
<li>使用notify则所有任务必须等待相同的条件</li>
<li>如果有多个任务在等待不同的条件，则不知道是否唤醒了恰当的任务</li>
<li>使用notify则条件变化时，必须只有一个任务从中受益</li>
<li>这些限制对所有可能存在的子类都必须总是起作用的</li>
</ul>
<p><strong>否则就必须使用</strong>notifyAll</p>
<p>notifyAll</p>
<ul>
<li>当notifyAll因某个特定锁而被调用时，只有等待<strong>这个锁</strong>的任务才会被唤醒</li>
<li>因为notifyAll语句是需要在一个同步控制块里面的，所以也清楚是哪个锁</li>
</ul>
<h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h2><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p>
<p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>使用 Lock 来获取一个 Condition 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<h2 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h2><p>任务协作的模型：</p>
<ul>
<li>生产者<ul>
<li>厨师，准备膳食，在准备好之后，通知服务员</li>
</ul>
</li>
<li>消费者<ul>
<li>服务员，等待厨师准备膳食</li>
<li>接到通知，上菜，返回继续等待</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> orderNum;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Meal</span><span class="params">(<span class="keyword">int</span> orderNum)</span> </span>&#123; <span class="keyword">this</span>.orderNum = orderNum; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Meal "</span> + orderNum; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitPerson</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Restaurant restaurant;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WaitPerson</span><span class="params">(Restaurant r)</span> </span>&#123; restaurant = r; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span>(restaurant.meal == <span class="keyword">null</span>)</span><br><span class="line">            wait(); <span class="comment">// ... for the chef to produce a meal</span></span><br><span class="line">        &#125;</span><br><span class="line">        print(<span class="string">"Waitperson got "</span> + restaurant.meal);</span><br><span class="line">          <span class="comment">//在消费者取走的动作当中，防止生产者写入数据</span></span><br><span class="line">        <span class="keyword">synchronized</span>(restaurant.chef) &#123;</span><br><span class="line">          restaurant.meal = <span class="keyword">null</span>;</span><br><span class="line">          restaurant.chef.notifyAll(); <span class="comment">// Ready for another</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">"WaitPerson interrupted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chef</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Restaurant restaurant;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Chef</span><span class="params">(Restaurant r)</span> </span>&#123; restaurant = r; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span>(restaurant.meal != <span class="keyword">null</span>)</span><br><span class="line">            wait(); <span class="comment">// ... for the meal to be taken</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++count == <span class="number">10</span>) &#123;</span><br><span class="line">          print(<span class="string">"Out of food, closing"</span>);</span><br><span class="line">          restaurant.exec.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">        printnb(<span class="string">"Order up! "</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(restaurant.waitPerson) &#123;</span><br><span class="line">          restaurant.meal = <span class="keyword">new</span> Meal(count);</span><br><span class="line">          restaurant.waitPerson.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">"Chef interrupted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">  Meal meal;</span><br><span class="line">  ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">  WaitPerson waitPerson = <span class="keyword">new</span> WaitPerson(<span class="keyword">this</span>);</span><br><span class="line">  Chef chef = <span class="keyword">new</span> Chef(<span class="keyword">this</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Restaurant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    exec.execute(chef);</span><br><span class="line">    exec.execute(waitPerson);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Restaurant();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 1</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 2</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 3</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 4</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 5</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 6</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 7</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 8</span></span><br><span class="line"><span class="comment">Order up! Waitperson got Meal 9</span></span><br><span class="line"><span class="comment">Out of food, closing</span></span><br><span class="line"><span class="comment">WaitPerson interrupted</span></span><br><span class="line"><span class="comment">Order up! Chef interrupted</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="生产者-消费者与队列"><a href="#生产者-消费者与队列" class="headerlink" title="生产者-消费者与队列"></a>生产者-消费者与队列</h2><p>基于同步队列来解决任务协作问题，同步队列在任何时刻只允许一个任务插入或移除数据</p>
<p>java.util.concurrent.（Linked/Array）BlockingQueue</p>
<ul>
<li>当消费者任务试图从队列中获取对象，而此时队列为空，队列可挂起消费者</li>
<li>当有更多的元素可用，恢复消费者</li>
<li>相比于wait与notifyAll，简单并且可靠</li>
<li>解决了wait等存在的类之间的耦合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiftOffRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个blockingQueue</span></span><br><span class="line">  <span class="keyword">private</span> BlockingQueue&lt;LiftOff&gt; rockets;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LiftOffRunner</span><span class="params">(BlockingQueue&lt;LiftOff&gt; queue)</span> </span>&#123;</span><br><span class="line">    rockets = queue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(LiftOff lo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      rockets.put(lo);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">"Interrupted during put()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">        LiftOff rocket = rockets.take();</span><br><span class="line">        rocket.run(); <span class="comment">// Use this thread</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">"Waking from take()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">"Exiting LiftOffRunner"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBlockingQueues</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getkey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Compensate for Windows/Linux difference in the</span></span><br><span class="line">      <span class="comment">// length of the result produced by the Enter key:</span></span><br><span class="line">      <span class="keyword">new</span> BufferedReader(</span><br><span class="line">        <span class="keyword">new</span> InputStreamReader(System.in)).readLine();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(java.io.IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getkey</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    print(message);</span><br><span class="line">    getkey();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">  test(String msg, BlockingQueue&lt;LiftOff&gt; queue) &#123;</span><br><span class="line">    print(msg);</span><br><span class="line">    LiftOffRunner runner = <span class="keyword">new</span> LiftOffRunner(queue);</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      runner.add(<span class="keyword">new</span> LiftOff(<span class="number">5</span>));</span><br><span class="line">    getkey(<span class="string">"Press 'Enter' ("</span> + msg + <span class="string">")"</span>);</span><br><span class="line">    t.interrupt();</span><br><span class="line">    print(<span class="string">"Finished "</span> + msg + <span class="string">" test"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test(<span class="string">"LinkedBlockingQueue"</span>, <span class="comment">// Unlimited size</span></span><br><span class="line">      <span class="keyword">new</span> LinkedBlockingQueue&lt;LiftOff&gt;());</span><br><span class="line">    test(<span class="string">"ArrayBlockingQueue"</span>, <span class="comment">// Fixed size</span></span><br><span class="line">      <span class="keyword">new</span> ArrayBlockingQueue&lt;LiftOff&gt;(<span class="number">3</span>));</span><br><span class="line">    test(<span class="string">"SynchronousQueue"</span>, <span class="comment">// Size of 1</span></span><br><span class="line">      <span class="keyword">new</span> SynchronousQueue&lt;LiftOff&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<h2 id="任务间使用管道进行输入-输出"><a href="#任务间使用管道进行输入-输出" class="headerlink" title="任务间使用管道进行输入/输出"></a>任务间使用管道进行输入/输出</h2><p>管道:</p>
<ul>
<li>PipedWriter允许任务向管道写</li>
<li>PipedReader允许不同任务从同一个管道中读取</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sender</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  <span class="keyword">private</span> PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> PipedWriter <span class="title">getPipedWriter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> out; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'A'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">          out.write(c);</span><br><span class="line">          TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      print(e + <span class="string">" Sender write exception"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(e + <span class="string">" Sender sleep interrupted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> PipedReader in;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Receiver</span><span class="params">(Sender sender)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    in = <span class="keyword">new</span> PipedReader(sender.getPipedWriter());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// Blocks until characters are there:</span></span><br><span class="line">          <span class="comment">//如果没有数据,管道将阻塞</span></span><br><span class="line">        printnb(<span class="string">"Read: "</span> + (<span class="keyword">char</span>)in.read() + <span class="string">", "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      print(e + <span class="string">" Receiver read exception"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedIO</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Sender sender = <span class="keyword">new</span> Sender();</span><br><span class="line">    Receiver receiver = <span class="keyword">new</span> Receiver(sender);</span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    exec.execute(sender);</span><br><span class="line">    exec.execute(receiver);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    exec.shutdownNow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (65% match)</span></span><br><span class="line"><span class="comment">Read: A, Read: B, Read: C, Read: D, Read: E, Read: F, Read: G, Read: H, Read: I, Read: J, Read: K, Read: L, Read: M, java.lang.InterruptedException: sleep interrupted Sender sleep interrupted</span></span><br><span class="line"><span class="comment">java.io.InterruptedIOException Receiver read exception</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><p>辨认在java.util.concurrent类库当中哪些类适用于常规应用，哪些类只适用于提高性能</p>
<h2 id="比较各类互斥技术"><a href="#比较各类互斥技术" class="headerlink" title="比较各类互斥技术"></a>比较各类互斥技术</h2><p>在互斥方法体很大时候，进入和退出互斥的开销可能很小，提高互斥速度可能对整体速度影响较小</p>
<ul>
<li>Lock<ul>
<li>在高并发下表现稳定</li>
</ul>
</li>
<li>synchronized<ul>
<li>高并发下非常不稳定</li>
<li>在数量较小下表现更高效</li>
<li>可读性好</li>
</ul>
</li>
<li>Atomic<ul>
<li>当一个对象的临界更新被限制为只涉及单个变量</li>
<li>高并发下稳定</li>
</ul>
</li>
</ul>
<h2 id="免锁容器"><a href="#免锁容器" class="headerlink" title="免锁容器"></a>免锁容器</h2><ul>
<li>基于synchronized<ul>
<li>vector</li>
<li>hashTable</li>
</ul>
</li>
<li>免锁<ul>
<li>策略<ul>
<li>对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可。</li>
<li>修改时容器数据结构的某个部分的一个单独的副本，并且在修改过程中是不可视的，只有当修改完成时，被修改的结构才会自动与主数据结构交换</li>
</ul>
</li>
<li>CopyOnWriteArrayList：整个数组复制</li>
<li>concurrentHashMap：部分内容可以复制和修改</li>
</ul>
</li>
</ul>
<p>乐观锁</p>
<ul>
<li>只要你主要是从免锁容器中读取，就会比其synchronized对应物快很多。</li>
<li>如果需要向免锁容器中执行少量写入，情况依然如此</li>
</ul>
<h2 id="乐观加锁"><a href="#乐观加锁" class="headerlink" title="乐观加锁"></a>乐观加锁</h2><p>CAS操作</p>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><ul>
<li>对象数据结构相对不频繁地写入，但是有多个任务要经常读取的情况进行优化</li>
<li>如果写锁已经被其他任务持有，则如何读者都不能访问</li>
</ul>
<h1 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h1><p>替换多线程模型的一种并发模型</p>
<ul>
<li>对象是活动的，每个对象都维护着它自己的工作器线程和消息队列</li>
<li>有了活动对象，就可以串行化消息而不是方法。即不再需要防备一个任务在其循环的中间被中断</li>
<li>当向一个活动对象发送消息时，消息会被转换为一个任务，插入到足够对象的队列中，等待在以后的某个时刻运行</li>
</ul>
<p>实现</p>
<p>java的<strong><em>Future</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveObjectDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ExecutorService ex =</span><br><span class="line">    Executors.newSingleThreadExecutor();</span><br><span class="line">  <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  <span class="comment">// Insert a random delay to produce the effect</span></span><br><span class="line">  <span class="comment">// of a calculation time:</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">(<span class="keyword">int</span> factor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(</span><br><span class="line">        <span class="number">100</span> + rand.nextInt(factor));</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      print(<span class="string">"sleep() interrupted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Future&lt;Integer&gt;</span><br><span class="line">  calculateInt(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> ex.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"starting "</span> + x + <span class="string">" + "</span> + y);</span><br><span class="line">        pause(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Future&lt;Float&gt;</span><br><span class="line">  calculateFloat(<span class="keyword">final</span> <span class="keyword">float</span> x, <span class="keyword">final</span> <span class="keyword">float</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> ex.submit(<span class="keyword">new</span> Callable&lt;Float&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Float <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"starting "</span> + x + <span class="string">" + "</span> + y);</span><br><span class="line">        pause(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; ex.shutdown(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ActiveObjectDemo d1 = <span class="keyword">new</span> ActiveObjectDemo();</span><br><span class="line">    <span class="comment">// Prevents ConcurrentModificationException:</span></span><br><span class="line">    List&lt;Future&lt;?&gt;&gt; results =</span><br><span class="line">      <span class="keyword">new</span> CopyOnWriteArrayList&lt;Future&lt;?&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> f = <span class="number">0.0f</span>; f &lt; <span class="number">1.0f</span>; f += <span class="number">0.2f</span>)</span><br><span class="line">      results.add(d1.calculateFloat(f, f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      results.add(d1.calculateInt(i, i));</span><br><span class="line">    print(<span class="string">"All asynch calls made"</span>);</span><br><span class="line">    <span class="keyword">while</span>(results.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(Future&lt;?&gt; f : results)</span><br><span class="line">        <span class="keyword">if</span>(f.isDone()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            print(f.get());</span><br><span class="line">          &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">          &#125;</span><br><span class="line">          results.remove(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d1.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (85% match)</span></span><br><span class="line"><span class="comment">All asynch calls made</span></span><br><span class="line"><span class="comment">starting 0.0 + 0.0</span></span><br><span class="line"><span class="comment">starting 0.2 + 0.2</span></span><br><span class="line"><span class="comment">0.0</span></span><br><span class="line"><span class="comment">starting 0.4 + 0.4</span></span><br><span class="line"><span class="comment">0.4</span></span><br><span class="line"><span class="comment">starting 0.6 + 0.6</span></span><br><span class="line"><span class="comment">0.8</span></span><br><span class="line"><span class="comment">starting 0.8 + 0.8</span></span><br><span class="line"><span class="comment">1.2</span></span><br><span class="line"><span class="comment">starting 0 + 0</span></span><br><span class="line"><span class="comment">1.6</span></span><br><span class="line"><span class="comment">starting 1 + 1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">starting 2 + 2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">starting 3 + 3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">starting 4 + 4</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>活动对象的优势</p>
<ul>
<li>每个对象都可以用于自己的工作区线程</li>
<li>每个对象都将维护对它自己的域的全部控制权</li>
<li>所有在活动对象间的通信都将以在这些对象间的消息形式发生</li>
<li>活动对象间的所有消息都要排队</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>Java编程思想</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/OS/计算机操作系统：进程通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/05/OS/计算机操作系统：进程通信/" class="post-title-link" itemprop="url">计算机操作系统：进程通信</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-05 17:53:14" itemprop="dateCreated datePublished" datetime="2019-03-05T17:53:14+08:00">2019-03-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-07-22 13:15:44" itemprop="dateModified" datetime="2019-07-22T13:15:44+08:00">2019-07-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/05/OS/计算机操作系统：进程通信/" class="post-meta-item leancloud_visitors" data-flag-title="计算机操作系统：进程通信">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/05/OS/计算机操作系统：进程通信/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/05/OS/计算机操作系统：进程通信/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p>进程间通信是为了进程间进行协作。这样做的<strong><em>原因</em></strong>有</p>
<ul>
<li>信息共享。多个用户可能对同样的信息感兴趣</li>
<li>提高运算速度。</li>
<li>模块化。</li>
<li>方便。单个用户可以同时执行很多任务</li>
</ul>
<h2 id="进程通信机制IPC"><a href="#进程通信机制IPC" class="headerlink" title="进程通信机制IPC"></a>进程通信机制IPC</h2><ul>
<li>低级通信<ul>
<li>进程互斥与同步交换的信息量小，每次通信传递的信息量固定且效率较低</li>
<li>如：信号量</li>
</ul>
</li>
<li>高级通信<ul>
<li>进程之间以较高的效率传送大量数据的通信方式。</li>
<li>高级通信方式可分为三大类：共享存储器系统、消息传递系统以及管道通信系统。</li>
</ul>
</li>
</ul>
<p>进程间通信的两种基本模式。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>建立起一块供协作进程共享的内存区域，进程通过向此共享区域读或写入数据来交换信息。</p>
<p><strong>优点</strong></p>
<ul>
<li>允许以最快的速度进行方便地通信，可以达到内存的速度。</li>
</ul>
<p><strong>概述</strong></p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>通过在协作进程间交换信息来实现通信。通常借助于系统调用来实现。</p>
<p><strong>优点</strong></p>
<ul>
<li>在交换较少数量的数据很有用，因为不需要避免冲突。</li>
<li>更容易实现。</li>
<li>在分布式环境当中非常有用。</li>
</ul>
<p>消息传递工具必须至少支持两种操作：发送和接受（消息）。</p>
<p>如果两个进程P与Q需要通信，则他们间必须要有通信线路。线路有多种实现方法，在不考虑线路的物理实现下，只关心逻辑实现。</p>
<ul>
<li>直接或间接通信</li>
<li>同步或异步通信</li>
<li>自动或显式缓冲</li>
</ul>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>需要通信的进程必须有一个办法以互相引用，它们可使用直接或间接通信。</p>
<p><strong>直接通信</strong></p>
<p>直接通信：需要通信的每个进程都必须直接指明通信的接收方或发送方。</p>
<ul>
<li>send(P,message)：发送消息到进程P</li>
<li>receive(Q,message)：接受来自进程Q的消息。</li>
</ul>
<p>这种方案的通信线路具有如下属性：</p>
<ul>
<li>在需要通信的每对进程之间自动建立线路。进程只需要知道相互通信的标识符</li>
<li>一个线路只和两个进程相关</li>
<li>每对进程之间只有一个线路。</li>
<li>链路可以是单向也可以是双向</li>
</ul>
<p>这种方案为对称寻址，即双方进程必须命名对方以便通信。方案变种为非对称寻址，即只需要命名接受者，接受者不需要命名发送者。</p>
<ul>
<li>send(P,message)：发送消息到进程P</li>
<li>receive(id,message)：接受来自任何进程的消息，变量ID设置成与其通信的进程名称。</li>
</ul>
<p><em>对称寻址与非对称寻址缺陷</em>：限制了进程定义的模块化，因为一旦修改进程名称，需要修改其他进程的定义，修改为新名称。</p>
<p><strong>间接通信</strong></p>
<p>通过邮箱或端口来发送和接受消息。邮箱可以抽象为一个对象，进程向其中存放、删除消息。每个抽象具有一个标识符。</p>
<ul>
<li>send(A,message)：发送一个消息到邮箱A</li>
<li>receive(A,message)：接受来自邮箱A的消息</li>
</ul>
<p>通信链路的属性为：</p>
<ul>
<li>只有在两个进程共享一个邮箱时，才能建立通信线路</li>
<li>一个线路可以与两个或更多的进程相关联</li>
<li>两个通信进程间可以有多个不同的线路，每个线路对应于一个邮箱</li>
</ul>
<p>通信流程</p>
<ul>
<li>创建一个新的消息队列</li>
<li>通过消息队列发送和接受消息</li>
<li>销毁消息队列</li>
</ul>
<p><img src="assets/1551950132700.png" alt="1551950132700"></p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>消息传递可以是阻塞或者非阻塞的，即同步或异步</p>
<ul>
<li>阻塞send：发送进程阻塞，直到消息被接收进程或邮箱所接收</li>
<li>非阻塞send：发送进程发送消息并再继续操作</li>
<li>阻塞receive：接受者阻塞，直到有消息可用</li>
<li>非阻塞receive：接受者收到一个有效消息或空消息</li>
</ul>
<h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>不管通信是直接还是间接，交换的信息都驻留在临时队列中。简单队列实现有三种方法</p>
<ul>
<li>0容量，即无缓冲。发送方必须等待接收方</li>
<li>有限容量。通信链路缓冲队列满时，发送方必须等待</li>
<li>无限容量。发送方不需要等待</li>
</ul>
<h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>操作系统提供，一种快速地通信机制</p>
<ul>
<li>进程间的软件中断通知和处理机制</li>
</ul>
<p>信号的接受处理</p>
<ul>
<li>捕获：执行进程制定的信号处理函数被调用(软件定义)</li>
<li>忽略：执行操作系统制定的缺省处理（进程注册时，操作系统注册处理函数）<ul>
<li>Ctrl C</li>
</ul>
</li>
<li>屏蔽：禁止进程接受和处理信号<ul>
<li>可能是暂时的</li>
</ul>
</li>
</ul>
<p>不足：传递的信息量小，只有一个信号类型</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>操作系统提供</p>
<ul>
<li>进程间基于内存文件的通信机制<ul>
<li>子进程从父进程继承文件描述符</li>
<li>缺省文件描述符：0 stdin 1 stdout 2stderr</li>
</ul>
</li>
<li>进程不关心另一端<ul>
<li>可能从键盘、文件、程序读取</li>
<li>可能写入到终端、文件、程序</li>
</ul>
</li>
<li>读管道：read（）,scanf（）</li>
<li>写管道：write(),printf（）</li>
<li>创建管道 pipe</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul>
<li>消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制<ul>
<li>每个消息是一个字节序列</li>
<li>相同标识的消息组成按先进先出顺序组成一个消息队列</li>
</ul>
</li>
<li>消息队列的系统调用<ul>
<li>msgget获得消息队列标识</li>
<li>msgsnd发送消息</li>
<li>msgrcv接受消息</li>
<li>msgctl消息队列控制</li>
</ul>
</li>
</ul>
<h3 id="共享内存-1"><a href="#共享内存-1" class="headerlink" title="共享内存"></a>共享内存</h3><ul>
<li>共享内存是把同一个物理内存区域同时映射到多个进程的内存地址的通信机制</li>
<li>进程<ul>
<li>每个进程都有私有内存地址空间</li>
<li>每个进程的内存地址空间需要明确设置共享内存段</li>
</ul>
</li>
<li>线程：同一进程中的线程总是共享相同的内存地址空间</li>
<li>优点：快速、方便地共享数据</li>
<li>缺点：必须用额外的同步机制</li>
</ul>
<p>依据页表项进行映射</p>
<ul>
<li>最快的方法</li>
<li>一个进程写，另一个进程立即可见</li>
<li>没有系统调用干预</li>
<li>没有数据复制</li>
<li>不提供同步，需要程序员进行同步</li>
</ul>
<h3 id="TCP-IP套接字"><a href="#TCP-IP套接字" class="headerlink" title="TCP/IP套接字"></a>TCP/IP套接字</h3><h3 id="UNIX域套接字"><a href="#UNIX域套接字" class="headerlink" title="UNIX域套接字"></a>UNIX域套接字</h3><h3 id="信号量通信"><a href="#信号量通信" class="headerlink" title="信号量通信"></a>信号量通信</h3><h1 id="客户机-服务器系统通信"><a href="#客户机-服务器系统通信" class="headerlink" title="客户机-服务器系统通信"></a>客户机-服务器系统通信</h1><p>客户机-服务器系统通信方法：socket（较低级）、RPC（高级）、RMI（高级）</p>
<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>socket（套接字）可定义为通信的端点。</p>
<p>socket组成：IP地址、一个端口号。</p>
<h3 id="优缺"><a href="#优缺" class="headerlink" title="优缺"></a>优缺</h3><ul>
<li>常用、高效</li>
<li>低级的分布式进程通信。只允许通信线程间交换无结构的字节流。需要客户机或服务器负责加上数据结构</li>
</ul>
<h3 id="socket通信机制"><a href="#socket通信机制" class="headerlink" title="socket通信机制"></a>socket通信机制</h3><ul>
<li>一对通过网络通信的进程需要使用一对Socket，即每个进程各有一个。</li>
<li>Socket通常采用客户机-服务器结构。<ul>
<li>服务器监听指定端口来等待进来的客户请求。一旦收到请求，服务器就接受来自客户Socket的连接从而完成连接。</li>
<li>服务器实现的特定服务是通过监听众所周知的端口来进行的。低于1024的端口认为是众所周知的，用于实现标准服务，如FTP、telnet等。</li>
<li>客户机进程发出连接请求，被主机赋予一个端口（大于1024）。</li>
<li>每一对连接都有唯一的一对socket。</li>
</ul>
</li>
</ul>
<h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><p>Java提供3种不同类型的socket。</p>
<ul>
<li>TCP的Socket，由Socket类实现</li>
<li>UDP的socket，由DatagramSocket</li>
<li>多点传送的socket，允许数据发送给多个接受者，MulticastSocket</li>
</ul>
<p>以TCP的socket实现日期服务器。</p>
<ul>
<li>允许客户机从服务器请求当前的日期和时间</li>
<li>服务器监听端口6013（任意&gt;1024）。接受到连接，服务器将日期与时间返回客户机。</li>
</ul>
<p>服务器代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//监听端口6013</span></span><br><span class="line">            ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">6013</span>);</span><br><span class="line">            <span class="comment">//轮询监听</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞在方法上，等待客户请求连接</span></span><br><span class="line">                <span class="comment">//获得Socket与客户端进行通信</span></span><br><span class="line">                Socket client = socket.accept();</span><br><span class="line">                <span class="comment">//服务器通过PrintWriter向客户端进行写操作。</span></span><br><span class="line">                PrintWriter pout = <span class="keyword">new</span> PrintWriter(client.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">                pout.println(<span class="keyword">new</span> java.util.Date().toString());</span><br><span class="line">                <span class="comment">//关闭socket，重新监听其他请求。</span></span><br><span class="line">                client.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//请求的IP地址为127.0.0.1，端口为6013</span></span><br><span class="line">            Socket sock = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">6013</span>);</span><br><span class="line">            <span class="comment">//向socket写入</span></span><br><span class="line">            InputStream in = sock.getInputStream();</span><br><span class="line">            <span class="comment">//写入到缓冲区当中</span></span><br><span class="line">            BufferedReader bin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bin.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            sock.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC（远程过程调用），用于通过网络连接系统。最为普通的远程服务，尽量使远程过程调用具有与本地调用相同的形式。</p>
<p>因为在所处理的环境中，进程在不同系统上执行，所以必须提供基于消息的通信方案来提供远程服务。</p>
<h3 id="优缺-1"><a href="#优缺-1" class="headerlink" title="优缺"></a>优缺</h3><ul>
<li>RPC消息有很好的结构，不仅仅是数据包。</li>
<li>对于实现分布式文件系统非常有用</li>
<li>程序员可以使用过程调用语义来调用远程函数并获取响应</li>
<li>简化了编写分布式应用程序的难度,因为 RPC 隐藏了所有的网络代码存根函数。应用程序不必担心一些细节,比如 socket、端口号以及数据的转换和解析。在 OSI 参考模型,RPC 跨越了会话层和表示层。</li>
</ul>
<h3 id="本地过程调用"><a href="#本地过程调用" class="headerlink" title="本地过程调用"></a>本地过程调用</h3><p>考虑C语言的调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fd：一个整形数，表示一个文件</span></span><br><span class="line"><span class="comment">//buf：一个字符数组，用于存储读入的数据</span></span><br><span class="line"><span class="comment">//nbytes：另一个整形数，记录实际读入的字节数，即数组长度</span></span><br><span class="line">count = read(fd , buf , nbytes);</span><br></pre></td></tr></table></figure>

<p>在主程序中进行调用该函数，则调用之前堆栈的状态如图2(a)所示。为了进行调用，调用方首先把参数反序压入堆栈，即为最后一个参数先压入，如图2(b)所示。在 read 操作运行完毕后，它将返回值放在某个寄存器中，移出返回地址，并将控制权交回给调用方。调用方随后将参数从堆栈中移出，使堆栈还原到最初的状态。</p>
<p><img src="assets/20160630-lpc.png" alt></p>
<p>一般为阻塞send，因为如同本地方法调用一般，需要先执行完需要执行的函数，才执行之后的</p>
<h3 id="RPC通信机制"><a href="#RPC通信机制" class="headerlink" title="RPC通信机制"></a>RPC通信机制</h3><ul>
<li>客户过程以正常的方式调用客户存根；</li>
<li>客户存根生成一个消息，然后调用本地操作系统；</li>
<li>客户端操作系统将消息发送给远程操作系统；</li>
<li>远程操作系统将消息交给服务器存根；</li>
<li>服务器存根调将参数提取出来，而后调用服务器；</li>
<li>服务器执行要求的操作，操作完成后将结果返回给服务器存根；</li>
<li>服务器存根将结果打包成一个消息，而后调用本地操作系统；</li>
<li>服务器操作系统将含有结果的消息发送给客户端操作系统；</li>
<li>客户端操作系统将消息交给客户存根；</li>
<li>客户存根将结果从消息中提取出来，返回给调用它的客户存根。</li>
</ul>
<h4 id="存根"><a href="#存根" class="headerlink" title="存根"></a>存根</h4><p>在传统系统当中，read例程由链接器从库中提取出来，然后插入到目标程序当中。</p>
<p>而在RPC当中，当read实际上是一个远程过程时（位于文件服务器所在机器上运行的过程），库中就放入read的另一个版本，即<strong>客户存根</strong></p>
<p><strong>服务器存根</strong>：客户存根的等价物</p>
<p>RPC语义允许客户机调用位于远程主机上的过程，就如同调用本地过程一样。原理为：</p>
<ul>
<li>通过在客户端提供<strong>存根</strong>，RPC系统隐藏了允许通信发生的必要细节<ul>
<li>对于每个独立的远程过程都有一个存根。当客户机调用原厂过程时，RPC系统调用合适的存根，并传递远程过程的参数</li>
<li>该存根位于服务器的端口，并编组参数（涉及将参数打包成可通过网络传输的形式），接着存根使用消息传递向服务器发送一个消息。</li>
<li>服务器的一个类似存根接收这一消息，并调用服务器上的过程。如有必要，返回值可通过同样的技术返回客户机</li>
</ul>
</li>
</ul>
<h4 id="XDR"><a href="#XDR" class="headerlink" title="XDR"></a>XDR</h4><p>如何处理客户机和服务器的数据表示的差别：</p>
<ul>
<li>对于一个32位整数的表示，有的系统使用高内存地址以存储高字节，有的系统使用高内存地址以存储低字节</li>
<li>许多RPC系统定义了数据的机器无关表示，称为外部数据表示（XDR）<ul>
<li>在客户机端，参数编组涉及将机器有关数据在被发送到服务器前编组成XDR</li>
<li>在服务器端，XDR数据将重新转换为服务器所用的机器有关表示</li>
</ul>
</li>
</ul>
<h4 id="确保执行"><a href="#确保执行" class="headerlink" title="确保执行"></a>确保执行</h4><p>调用的语义问题</p>
<ul>
<li>本地过程调用只有在极端情况下才可能失败。而由于普通网络错误，RPC可能会失败或重复多次执行。</li>
<li>利用操作系统确保一个消息刚好执行一次，而不是最多只执行一次。<ul>
<li>最多一次：为每个消息附加时间戳来做到。服务器对其处理的消息，必须有一个完整的或足够长的时间戳历史，以便能确保检测到重复消息</li>
<li>刚好一次：需要消除服务器从未收到请求的风险。服务器首先执行“最多一次”协议，并且通知客户端已经接收到RPC且执行，利用ACK进行确认</li>
</ul>
</li>
</ul>
<h4 id="通信绑定"><a href="#通信绑定" class="headerlink" title="通信绑定"></a>通信绑定</h4><p>服务器与客户机的通信问题</p>
<ul>
<li>对于标准过程调用，在连接、装入或执行时会出现一定形式的绑定，从而使过程名称被过程的内存地址所代替。</li>
<li>RPC方案要求一个类似客户机和服务器端口的绑定，但是客户机如何知道服务器上的端口呢<ul>
<li>绑定信息以固定端口地址形式预先固定。<ul>
<li>编译时，RPC调用一个相应的固定端口，一旦编译后，服务器就不能改变请求服务的端口号。</li>
</ul>
</li>
<li>绑定通过集合点机制动态地进行。<ul>
<li>操作系统在一个固定RPC端口上提供集合点服务程序。客户机发送一个包括RPC的名称的消息给集合点服务程序，以请求它所需要执行的RPC端口地址。</li>
<li>该端口号返回，RPC调用可发送到这一端口号直到进程终止。</li>
<li><img src="assets/1555300771928.png" alt="1555300771928"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h2><p>RMI（Java的远程方法调用）</p>
<p>RMI允许线程调用远程对象的方法，如果对象位于不同的JVM上，那么就认为它是远程的。</p>
<h3 id="RMI与RPC的不同"><a href="#RMI与RPC的不同" class="headerlink" title="RMI与RPC的不同"></a>RMI与RPC的不同</h3><ul>
<li>RPC支持子程序编程，即只能调用远程的子程序或函数RMI是基于对象的，支持调用远程对象的方法</li>
<li>RPC中远程过程的参数是普通数据结构，而RMI可以将对象作为参数传递给远程方法。</li>
</ul>
<h3 id="优缺-2"><a href="#优缺-2" class="headerlink" title="优缺"></a>优缺</h3><ul>
<li>RMI通过允许Java程序调用远程对象的方法，使得用户能够开发分布在网络上的Java应用程序。</li>
</ul>
<h3 id="RMI通信机制"><a href="#RMI通信机制" class="headerlink" title="RMI通信机制"></a>RMI通信机制</h3><p>RMI采用<strong>存根</strong>和<strong>骨干</strong>实现远程对象。</p>
<ul>
<li>存根为原厂对象的代理，驻留在客户机中。<ul>
<li>当客户机调用原厂方法时，远程对象的存根被调用。客户端存根负责创建一个包，具有服务器上要调用方法的名称和用于该方法的编排参数。</li>
<li>存根将该包发送给服务器</li>
</ul>
</li>
<li>远程对象的骨干负责接收包<ul>
<li>重新编排参数并调用服务器上所要执行的方法。</li>
<li>骨干接着编排返回值（或异常），然后打包，将包返回给客户机</li>
</ul>
</li>
<li>存根重新编排返回值，并传递给客户机</li>
</ul>
<h4 id="参数传递规则"><a href="#参数传递规则" class="headerlink" title="参数传递规则"></a>参数传递规则</h4><ul>
<li>如果编排参数是本地（非远程）对象，那么通过对象串行化的技术来复制传递。如果参数也是远程对象，那么可通过引用传递</li>
<li>如果本地对象需要作为参数传递给远程对象，那么必须实现Serializable接口</li>
</ul>
<h3 id="Java实现-1"><a href="#Java实现-1" class="headerlink" title="Java实现"></a>Java实现</h3><ul>
<li><strong>IService接口：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明服务器端必须提供的服务</span></span><br><span class="line">    <span class="function">String <span class="title">service</span><span class="params">(String content)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ServiceImpl实现类：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnicastRemoteObject用于导出的远程对象和获得与该远程对象通信的存根。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceImpl</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">service</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"server &gt;&gt; "</span> + content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Server类：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化实现了IService接口的远程服务ServiceImpl对象</span></span><br><span class="line">            IService service02 = <span class="keyword">new</span> ServiceImpl(<span class="string">"service02"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 本地主机上的远程对象注册表Registry的实例，并指定端口为8888，这一步必不可少（Java默认端口是1099），必不可缺的一步，缺少注册表创建，则无法绑定对象到远程注册表上</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把远程对象注册到RMI注册服务器上，并命名为service02</span></span><br><span class="line">            <span class="comment">//绑定的URL标准格式为：rmi://host:port/name(其中协议名可以省略，下面两种写法都是正确的）</span></span><br><span class="line">            Naming.bind(<span class="string">"rmi://localhost:8888/service02"</span>,service02);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器向命名表注册了1个远程服务对象！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Client类：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String url = <span class="string">"rmi://localhost:8888/"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在RMI服务注册表中查找名称为service02的对象，并调用其上的方法</span></span><br><span class="line">            IService service02 =(IService) Naming.lookup(url + <span class="string">"service02"</span>);</span><br><span class="line"></span><br><span class="line">            Class stubClass = service02.getClass();</span><br><span class="line">            System.out.println(service02 + <span class="string">" 是 "</span> + stubClass.getName() + <span class="string">" 的实例！"</span>);</span><br><span class="line">            <span class="comment">// 获得本底存根已实现的接口类型</span></span><br><span class="line">            Class[] interfaces = stubClass.getInterfaces();</span><br><span class="line">            <span class="keyword">for</span> (Class c : interfaces) &#123;</span><br><span class="line">                System.out.println(<span class="string">"存根类实现了 "</span> + c.getName() + <span class="string">" 接口！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(service02.service(<span class="string">"你好！"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各个类的交互时序如下图：</p>
<p><img src="assets/11100535_h8xr.jpg" alt></p>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="同步互斥"><a href="#同步互斥" class="headerlink" title="同步互斥"></a>同步互斥</h2><p>同步互斥是OS当中协调进程之间动作和相互关系之间的机制。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>并发基础的正确性</p>
<ul>
<li>独立进程<ul>
<li>不和其他进程共享资源或状态</li>
<li>确定性：输入状态决定结果</li>
<li>可重现：能够重现其实条件</li>
<li>调度顺序不重要</li>
</ul>
</li>
<li>并发进程<ul>
<li>在多个进程间有资源共享</li>
<li>不确定性</li>
<li>不可重现</li>
</ul>
</li>
<li>并发进程的正确性<ul>
<li>执行过程是不确定性和不可重现的</li>
<li>程序错误可能是间歇性发生的</li>
</ul>
</li>
</ul>
<p>进程并发执行的好处</p>
<ul>
<li>进程需要与计算机中的其他进程和设备进行协作</li>
<li>好处1：共享资源<ul>
<li>多个用户使用同一台计算机</li>
<li>银行账户存款余额在多ATM上操作</li>
</ul>
</li>
<li>好处2：加速<ul>
<li>IO操作与CPU计算并行</li>
<li>程序可以划分为多个模块放在多个处理器上并行执行</li>
</ul>
</li>
<li>好处3：模块化<ul>
<li>将大程序分解为小程序</li>
<li>使系统易于复用与扩展</li>
</ul>
</li>
</ul>
<p>并发创建新进程时的标识分配</p>
<ul>
<li>程序可以调用函数fork来创建一个新的进程<ul>
<li>操作系统需要分配一个新的并且唯一的进程PID</li>
<li>new_pid=next_pid++;<ul>
<li>读取值</li>
<li>写入值</li>
<li>即不是原子操作</li>
<li><img src="assets/1551865407070.png" alt="1551865407070"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><ul>
<li>原子操作时指一次不存在任何中断或失败的操作<ul>
<li>要么操作成功执行</li>
<li>要么操作没有执行</li>
<li>不会出现部分执行的状态</li>
</ul>
</li>
<li>操作系统需要利用同步机制在并发执行的同时，保证一些操作时原子操作</li>
</ul>
<h2 id="现实生活的同步问题"><a href="#现实生活的同步问题" class="headerlink" title="现实生活的同步问题"></a>现实生活的同步问题</h2><p>进程间的交互关系：相互感知程度</p>
<p><img src="assets/1551866855340.png" alt="1551866855340"></p>
<p>三种关系：</p>
<ul>
<li>互斥<ul>
<li>一个进程占用资源，其他进程不能使用</li>
</ul>
</li>
<li>死锁<ul>
<li>多个进程各自占用部分资源，形成循环等待</li>
</ul>
</li>
<li>饥饿<ul>
<li>其他进程可能轮流占用资源，一个进程一直得不到资源</li>
</ul>
</li>
</ul>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>临界区：进程中访问临界资源的一端需要互斥执行的代码</p>
<p>进入区：</p>
<ul>
<li>检查可否进入临界区的一段代码</li>
<li>如可进入，则设置正在访问临界区标志</li>
</ul>
<p>退出区：清除正在访问临界区标志</p>
<p><strong>临界区的访问规则</strong></p>
<ul>
<li>空闲则入<ul>
<li>没有进程在临界区时，任何进程可进入</li>
</ul>
</li>
<li>忙则等待<ul>
<li>与进程在临界区时，则其他进程均不能进入临界区</li>
</ul>
</li>
<li>有限等待<ul>
<li>等待进入临界区的进程不能无限制等待</li>
</ul>
</li>
<li>让权等待<ul>
<li>不能进入临界区的进程，应当释放CPU</li>
</ul>
</li>
</ul>
<p>不同临界区实现机制的比较</p>
<ul>
<li>性能：并发级别</li>
</ul>
<h3 id="禁用硬件中断的同步方法"><a href="#禁用硬件中断的同步方法" class="headerlink" title="禁用硬件中断的同步方法"></a>禁用硬件中断的同步方法</h3><ul>
<li>没有中断，没有上下文切换，因此没有切换<ul>
<li>硬件将中断处理延迟到中断被启用之后</li>
<li>现代OS都提供指令来实现禁用中断</li>
</ul>
</li>
<li>进入临界区<ul>
<li>禁止所有中断，并保存标志</li>
</ul>
</li>
<li>退出临界区<ul>
<li>使能中断</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>禁用中断后，进程无法被停止<ul>
<li>整个系统都会为此停下来</li>
<li>可能导致其他进程处于饥饿状态</li>
</ul>
</li>
<li>临界区可能很长<ul>
<li>无法确定响应中断所需的时间</li>
</ul>
</li>
<li>要小心使用，只在不用的时候才用</li>
</ul>
<h3 id="基于软件的同步方法"><a href="#基于软件的同步方法" class="headerlink" title="基于软件的同步方法"></a>基于软件的同步方法</h3><p>在两个进程间，通过对共享变量的访问实现同步</p>
<p><img src="assets/1551883847062.png" alt="1551883847062"></p>
<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><ul>
<li>满足线程T0与T1之间互斥的经典的基于软件的解决方案</li>
<li>共享变量<ul>
<li><img src="assets/1551884119551.png" alt="1551884119551"></li>
</ul>
</li>
<li>进入区代码<ul>
<li><img src="assets/1551884131451.png" alt="1551884131451"></li>
<li>turn=，是写操作，是原子性的</li>
</ul>
</li>
<li>退出区代码<ul>
<li>flag[i]=false</li>
</ul>
</li>
</ul>
<p>基于软件的解决方法分析</p>
<ul>
<li>复杂<ul>
<li>需要两个进程间共享数据</li>
</ul>
</li>
<li>需要忙等待<ul>
<li>浪费CPU时间</li>
</ul>
</li>
</ul>
<h3 id="高级抽象的同步方法"><a href="#高级抽象的同步方法" class="headerlink" title="高级抽象的同步方法"></a>高级抽象的同步方法</h3><p>基于硬件的同步原语</p>
<ul>
<li>硬件提供了一些同步原语<ul>
<li>中断禁用、原子操作指令等</li>
</ul>
</li>
<li>操作系统提供更高级的编程抽象来简化进程同步<ul>
<li>锁、信号量等</li>
<li>使用硬件原语来构建</li>
<li>简化进程同步</li>
</ul>
</li>
</ul>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁是一个抽象的数据结构</p>
<ul>
<li>一个二进制变量（锁定、解锁）</li>
<li>Lock::Acquire()<ul>
<li>锁被释放前一直等待，然后得到锁</li>
</ul>
</li>
<li>Lock::Release<ul>
<li>释放锁，唤醒任何等待的进程</li>
</ul>
</li>
</ul>
<h4 id="原子操作指令"><a href="#原子操作指令" class="headerlink" title="原子操作指令"></a>原子操作指令</h4><ul>
<li>现代CPU体系结构当中都提供一些特殊的原子操作指令<ul>
<li>这些指令将若干个操作合成一个原子操作</li>
</ul>
</li>
<li>测试和置位（Test and Set）TS指令<ul>
<li>从内存单元中读取值</li>
<li>测试该值是否为1（然后返回真或假）</li>
<li>内存单元设置为1</li>
<li><img src="assets/1551884687997.png" alt="1551884687997"></li>
</ul>
</li>
<li>交换指令<ul>
<li>交换内存中的两个值</li>
<li><img src="assets/1551884710140.png" alt="1551884710140"></li>
</ul>
</li>
</ul>
<p><strong>使用TS指令实现自旋锁</strong></p>
<p><img src="assets/1551884818239.png" alt="1551884818239"></p>
<p>线程在等待的时候消耗CPU时间</p>
<p><strong>无忙等待锁</strong></p>
<p>增加一个等待队列</p>
<p><img src="assets/1551884886453.png" alt="1551884886453"></p>
<p>原子操作指令锁的<strong>特征</strong></p>
<ul>
<li>优点<ul>
<li>适用于单处理器或者共享主存的多处理器中任意数量的进程同步</li>
<li>简单且容易证明</li>
<li>支持多临界区</li>
</ul>
</li>
<li>缺点<ul>
<li>忙等待消耗CPU时间</li>
<li>可能导致饥饿<ul>
<li>进程离开临界区时有多个等待进程的情况</li>
</ul>
</li>
<li>死锁<ul>
<li>用于临界区的低优先级进程</li>
<li>请求访问临界区的高优先级进程获得处理器并等待临界区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="同步方法总结"><a href="#同步方法总结" class="headerlink" title="同步方法总结"></a>同步方法总结</h3><ul>
<li>锁是一种高级的同步抽象方法<ul>
<li>互斥可以使用锁来实现</li>
<li>需要硬件支持</li>
</ul>
</li>
<li>常用的三种同步实现方法<ul>
<li>禁用中断。仅限于单处理器</li>
<li>软件。复杂</li>
<li>原子操作指令。使用最多，容易验证。</li>
</ul>
</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><ul>
<li>信号量是操作系统提供的一种协调共享资源访问的方法<ul>
<li>软件同步是平等线程间的一种同步协商机制</li>
<li>OS是管理者，地位高于进程，即一个仲裁者</li>
<li>用信号量表示系统资源的数量</li>
</ul>
</li>
<li>早期的操作系统的主要同步机制</li>
</ul>
<p>信号量</p>
<ul>
<li>是一种抽象数据结构<ul>
<li>由一个整数变量sem和两个原子操作组成</li>
<li>P操作<ul>
<li>sem-1</li>
<li>如sem&lt;0，进入等待，否则在继续</li>
</ul>
</li>
<li>V操作<ul>
<li>sem+1</li>
<li>如sem&lt;=0，唤醒一个等待进程</li>
</ul>
</li>
</ul>
</li>
<li>是被保护的整数变量<ul>
<li>初始化完成后，只能通过P和V操作修改</li>
<li>由操作系统保证，PV操作是原子操作<ul>
<li>OS高于进程，是管理者，不会受到进程干扰</li>
</ul>
</li>
</ul>
</li>
<li>P可能阻塞，V不会阻塞</li>
<li>通常假定信号量是个屁的<ul>
<li>线程不会被无限期阻塞在P操作</li>
<li>假定信号量等待按先进先出排队</li>
</ul>
</li>
</ul>
<p>实现</p>
<p><img src="assets/1551940418870.png" alt="1551940418870"></p>
<p>信号量分类</p>
<ul>
<li>二进制信号量：资源数目为0或1</li>
<li>资源信号量：资源数目为任何非负值</li>
<li>两者等价<ul>
<li>基于一个可以实现另一个</li>
</ul>
</li>
</ul>
<h3 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h3><ul>
<li>互斥访问<ul>
<li>临界区的互斥访问控制</li>
</ul>
</li>
<li>条件同步<ul>
<li>线程间的事件等待</li>
</ul>
</li>
</ul>
<p><strong>互斥访问</strong></p>
<p>每类资源设置一个信号量，其初值为1.</p>
<ul>
<li>必须成对使用P操作与V操作</li>
</ul>
<p><strong>条件同步</strong></p>
<p>条件同步设置一个信号量，其初值为0</p>
<p>一个线程进行V操作，一个线程进行P操作实现同步协作。</p>
<p><strong>信号量的困难</strong></p>
<ul>
<li>读/开发代码比较困难</li>
<li>容易出错<ul>
<li>使用的信号量已经被另一个线程占用等</li>
</ul>
</li>
<li>不能处理死锁问题，在写程序中解决</li>
</ul>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>改进信号量在处理临界区的一些麻烦，解决PV操作的配对</p>
<ul>
<li>管程是一种用于多线程互斥访问共享资源的程序结果<ul>
<li>采用面向对象方法，简化了线程间的同步控制</li>
<li>任一时刻最多只有一个线程执行管程代码</li>
<li>正在管程中的线程可以临时放弃管程的互斥访问，等待事件出现时恢复。<ul>
<li>一个赛道上，只有一辆赛车可以跑，赛车加燃料期间，可以让另一辆车进场</li>
</ul>
</li>
</ul>
</li>
<li>管程的使用<ul>
<li>在对象/模块中，收集相关共享数据</li>
<li>定义访问共享数据的方法</li>
</ul>
</li>
<li>管程的组成<ul>
<li>一个锁<ul>
<li>控制管程代码的互斥访问</li>
</ul>
</li>
<li>0或多个条件变量<ul>
<li>管理共享数据的并发访问</li>
</ul>
</li>
<li>条件变量：<ul>
<li>是管程内的等待机制</li>
<li>进入管程的线程因资源被占用而进入等待状态</li>
<li>每个条件变量表示一种等待原因，对应一个等待队列</li>
</ul>
</li>
<li>wait操作<ul>
<li>将自己阻塞在等待队列中</li>
<li>唤醒一个等待者或释放管程的互斥访问</li>
</ul>
</li>
<li>signal操作<ul>
<li>将等待队列中的一个县城唤醒</li>
<li>如果等待队列为空，则等于空操作</li>
</ul>
</li>
<li><img src="assets/1551943339583.png" alt="1551943339583"></li>
</ul>
</li>
</ul>
<p>两种不同的管程</p>
<p>真实系统中常用hansen管程（当前执行的管程更具有优先权，要在当前执行管程放弃使用权后，才转移），少一次切换。</p>
<p>Hoare管程行为确定性更好</p>
<p><img src="assets/1551943635198.png" alt="1551943635198"></p>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p>有界缓冲区的生产者-消费者问题</p>
<ul>
<li>一个或多个生产者在生成数据后放在一个缓冲区里</li>
<li>单个消费者从缓冲区取出数据处理</li>
<li>任何时刻只能有一个生产者或消费者进入缓冲区</li>
</ul>
<p>问题分析</p>
<ul>
<li>任何时刻只能有一个线程操作缓冲区 ： 互斥访问</li>
<li>缓冲区空时，消费者必须等待生产者 ： 条件同步</li>
<li>缓冲区满时，生产者必须等待消费者 ： 条件同步</li>
</ul>
<p><img src="assets/1551940987820.png" alt="1551940987820"></p>
<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>问题描述：</p>
<ul>
<li>5个哲学家围绕一张圆桌而坐<ul>
<li>桌子上放着5支叉子</li>
<li>每两个哲学家之间放一支</li>
</ul>
</li>
<li>哲学家的动作包括思考和进餐<ul>
<li>进餐时需同时拿到左右两边的叉子</li>
<li>思考时将两支叉子放回原处</li>
</ul>
</li>
</ul>
<p><strong>信号量</strong></p>
<p>偶数号先右后左，奇数先左后右，因此不会构成环路</p>
<p><img src="assets/1551945115548.png" alt="1551945115548"></p>
<h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p>问题描述：</p>
<ul>
<li>共享数据的两类使用者<ul>
<li>读者：只读取数据，不修改</li>
<li>写者：读取和修改数据</li>
</ul>
</li>
<li>问题描述：对共享数据的读-写<ul>
<li>读 - 读 允许<ul>
<li>同一时刻运行有多个读者同时读</li>
</ul>
</li>
<li>读-写 互斥<ul>
<li>没有写者时读者才能读</li>
<li>没有读者时，写者才能写</li>
</ul>
</li>
<li>写-写 互斥</li>
</ul>
</li>
</ul>
<p><strong>信号量</strong></p>
<ul>
<li>用信号量描述每个约束<ul>
<li>信号量WriteMutex<ul>
<li>控制读写操作的互斥</li>
<li>初始化为1</li>
</ul>
</li>
<li>读者计数Rcount<ul>
<li>正在进行读操作的读者数目</li>
</ul>
</li>
<li>信号量CountMutex<ul>
<li>控制对读者计数的互斥修改</li>
<li>初始为1</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="assets/1551945496464.png" alt="1551945496464"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://waylau.com/remote-procedure-calls/" target="_blank" rel="noopener">远程过程调用(RPC)详解</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/数据库/Redis（4）：独立功能的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/04/数据库/Redis（4）：独立功能的实现/" class="post-title-link" itemprop="url">Redis（4）：独立功能的实现</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-04 18:37:23" itemprop="dateCreated datePublished" datetime="2019-03-04T18:37:23+08:00">2019-03-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-04-08 23:44:10" itemprop="dateModified" datetime="2019-04-08T23:44:10+08:00">2019-04-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/04/数据库/Redis（4）：独立功能的实现/" class="post-meta-item leancloud_visitors" data-flag-title="Redis（4）：独立功能的实现">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/04/数据库/Redis（4）：独立功能的实现/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/04/数据库/Redis（4）：独立功能的实现/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis通过MULTI（开始）、EXEC（提交）、WATCH等实现事务功能</p>
<p>事务提供将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，在事务执行期间，服务器不会中断事务执行其他客户端的命令请求。</p>
<p>事务的原子性、一致性、隔离性、持久性 ACID</p>
<ul>
<li><strong>Atomicity（原子性）</strong>：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被<a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BB%9A_(%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86)" target="_blank" rel="noopener">回滚</a>（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>Consistency（一致性）</strong>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7" target="_blank" rel="noopener">约束</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)" target="_blank" rel="noopener">触发器</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A&action=edit&redlink=1" target="_blank" rel="noopener">级联回滚</a>等。</li>
<li><strong>Isolation（隔离性）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>Durability（持久性）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>事务的三个阶段</p>
<ul>
<li>事务开始<ul>
<li>MULTI命令</li>
</ul>
</li>
<li>命令入队</li>
<li>事务执行</li>
</ul>
<h2 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h2><p>乐观锁，在EXEC命令执行前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改，如果是，则拒绝执行事务，并返回代表事务执行失败的空回复</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/数据库/Redis（3）：单机数据库的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/04/数据库/Redis（3）：单机数据库的实现/" class="post-title-link" itemprop="url">Redis（3）：单机数据库的实现</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-04 18:37:09" itemprop="dateCreated datePublished" datetime="2019-03-04T18:37:09+08:00">2019-03-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-04-08 23:40:43" itemprop="dateModified" datetime="2019-04-08T23:40:43+08:00">2019-04-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/04/数据库/Redis（3）：单机数据库的实现/" class="post-meta-item leancloud_visitors" data-flag-title="Redis（3）：单机数据库的实现">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/04/数据库/Redis（3）：单机数据库的实现/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/04/数据库/Redis（3）：单机数据库的实现/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul>
<li>Redis服务器的数据库实现<ul>
<li>服务器保存数据库的方法</li>
<li>客户端切换数据库的方法</li>
<li>数据库保存键值对的方法</li>
<li>数据库的增删改查的实现方法</li>
<li>服务器保存键的过期时间的方法</li>
<li>服务器自动删除过期键的方法</li>
<li>Redis2.8数据库通知功能的实现</li>
</ul>
</li>
</ul>
<h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis服务器奖所有数据库保存在服务器状态中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//一个数组，保存着服务器中所有的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">//服务器中的数据库数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>每个redis客户端都有自己的目标数据库，即写命令的操作对象，默认为0号数据库</p>
<p>执行select 2（需要转换到的数据库，即db[2]）命令可切换目标数据库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>;</span>&#123;</span><br><span class="line">    <span class="comment">//记录客户端当前使用的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure>

<h2 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h2><p>Redis是一个键值对数据库服务器，服务器每一个数据库都是由一个redisDb表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//数据库键空间，保存着数据库中所有的键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure>

<p>键空间与用户所见的数据库是直接对应的。键空间的键就是数据库的键，键空间的值就是数据库的值</p>
<p><strong>添加新键</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="built_in">date</span> <span class="string">"222"</span></span><br></pre></td></tr></table></figure>

<p><strong>删除键</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del date</span><br></pre></td></tr></table></figure>

<p><strong>更新键</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="built_in">date</span> <span class="string">"balst"</span></span><br></pre></td></tr></table></figure>

<p><strong>取值</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get date</span><br></pre></td></tr></table></figure>

<p>等命令</p>
<p><strong>读写键空间的维护操作</strong></p>
<p>当使用Redis命令对数据库进行读写，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作</p>
<ul>
<li>读取一个键后，服务器会根据键是否存在来更新服务器的键空间命中次数或不明智次数</li>
<li>读取一个键后，服务器会更新键LRU时间，用于计算键的闲置时间</li>
<li>服务器在读取一个键时发现该键已经过期，服务器会先删除这个过期键，然后才执行余下的其他操作</li>
<li>如果有客户端使用Watch监视了某个键，服务器在对该键进行修改后，会将这个键标记为脏，从而让事务注意到这个键已经被修改</li>
<li>服务器每次修改一个键后，都会对脏键计数器++，这个计数器会触发服务器的持久化以及复制操作</li>
<li>如果服务器开启了数据库通知功能，那么在对键进行修改后，服务器将按配置发送给相应的数据库通知</li>
</ul>
<h2 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h2><p>使用EXPIRE命令或者PEXPIRE，以毫秒或秒的精度为数据库的某个键设置生存时间。在经过指定的时间，服务器会自动删除生存时间为0的键。</p>
<p>以Expireat或PExpireat为键设置过期时间，当过期时间来临，自动删除该键。</p>
<p><strong>保存过期时间</strong></p>
<p>redisDb结构中的expires字典保存了数据库中所有键的过期时间，称为过期字典</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict *expires;<span class="comment">//值是long long类型的整数，保存这个键指向的数据库键的过期时间</span></span><br></pre></td></tr></table></figure>

<h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>如果一个键过期了，那么它什么时候会被删除呢</p>
<ul>
<li>定时删除<ul>
<li>在设置键的过期时间的同时，创建一个定时器，让定时器在过期时间来临时，立即执行对键的删除操作</li>
</ul>
</li>
<li>惰性删除<ul>
<li>放任键过期不管，每次从键空间获取键时，都检查获得的键是否过期</li>
</ul>
</li>
<li>定期删除<ul>
<li>每隔一段时间，就对数据库进行一次检查，删除里面的过期键。删除的数量以及检查多少数据库由算法决定</li>
</ul>
</li>
</ul>
<h2 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h2><p>采用惰性删除与定期删除两种策略</p>
<h2 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h2><p>过期键对Redis服务器中其他模块的影响</p>
<p><strong>生成RDB文件</strong></p>
<p>SAVE命令或BGSAVE命令创建一个新的RDB文件时，已过期的键不会被保存到新创建的RDB文件中</p>
<p><strong>载入RDB文件</strong></p>
<p>在启动Redis服务器，如果开启了RDB功能，服务器会对RDB文件载入</p>
<ul>
<li>如果服务器以主服务器模式允许，那么载入RDB文件时，过期键将会忽略</li>
<li>如果以从服务器允许，文件中所有键，不管是否过期，都会载入到数据库中。<ul>
<li>主从服务器进行数据同步时，从服务器的数据库就会被清空，因此过期键对从服务器也不会造成影响</li>
</ul>
</li>
</ul>
<p><strong>AOF文件写入</strong></p>
<p>当服务器以AOF持久化模式运行时，如果键已经过期，但没有删除，那么AOF文件不会因为这个过期键产生任何影响。</p>
<p>当过期键被删除后，程序会向AOF文件追加DEL命令，以显式记录该键已经被删除。</p>
<p><strong>AOF重写</strong></p>
<p>已过期的键不会被保存到重写后的AOF文件中</p>
<p><strong>复制</strong></p>
<p>当服务器允许在复制模式下，从服务器的过期键删除动作由主服务器控制</p>
<ul>
<li>主服务器在删除一个过期键后，会显式向所有从服务器发送一个DEL命令</li>
<li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将其删除，而是继续像处理未过期键一样处理</li>
<li>从服务器只有在接到主服务器的DEL命令才会删除过期键</li>
</ul>
<h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>Redis2.8，可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况</p>
<h1 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h1><p>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，每个非空数据库又可以包含任意个键值对。</p>
<p>数据库状态：服务器中的非空数据库以及它们的键值对。</p>
<p>Redis是内存数据库，将数据库状态存储在内存当中，如果服务器进程一旦退出，则数据库状态也会消失不见。</p>
<p>因此提供了RDB持久化功能，<strong>将Redis在内存当中的数据库状态保存到磁盘当中</strong>。</p>
<ul>
<li>RDB持久化既可以手动，也可以根据服务器配置定期执行。将某个时间点上的数据库状态保存到一个RDB文件中</li>
<li>RDB持久化功能生成的RDB文件是一个压缩的二进制文件。</li>
</ul>
<h2 id="RDB文件的创建于载入"><a href="#RDB文件的创建于载入" class="headerlink" title="RDB文件的创建于载入"></a>RDB文件的创建于载入</h2><ul>
<li>生成命令：SAVE于BGSAVE<ul>
<li>SAVE会阻塞Redis服务器进程，直到RDB文件创建完毕为止</li>
<li>BGSAVE会派生一个子进程，子进程负责创建RDB文件，服务器进程继续处理命令</li>
</ul>
</li>
</ul>
<p>RDB文件的载入时在服务器启动时自动执行，只要检测到RDB文件，就会自动载入。在载入文件期间，服务器一直处于阻塞状态。</p>
<p>与AOF对比</p>
<ul>
<li>AOF文件的更新频率通常比RDB文件更新频率高，因此</li>
<li>如果服务器开启了AOF持久化功能，服务器会优先使用AOF文件来还原数据库状态</li>
<li>只有在AOF持久化功能处于关闭状态，服务器才会使用RDB文件来还原数据库状态</li>
</ul>
<h2 id="自动间隔保存"><a href="#自动间隔保存" class="headerlink" title="自动间隔保存"></a>自动间隔保存</h2><p>Redis允许用户通过服务器配置save选项，让服务器每隔一段时间自动执行一次BGSAVE</p>
<h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p>结构：</p>
<p><img src="assets%5C1552468398778.png" alt="1552468398778"></p>
<ul>
<li>RDB文件保存的是二进制数据，而不是C字符串</li>
<li>REDIS：长度为5字节，通过检测该字符，快速检查所载入的文件是否为RDB文件</li>
<li>db_version：4字节，是一个字符串表示的整数，记录了RDB文件版本号</li>
<li>database：包含0或任意个数据库，以及各个数据库中的键值对数据</li>
<li>EOF：长度为1字节，表示正文内容结束</li>
<li>check_sum：一个8字节长的无符号整数，保存一个校验和，通过对前4部分计算得出。服务器载入RDB文件时，会将载入数据计算得出的校验和与check_sum进行比较，以检查文件是否出错或损坏</li>
</ul>
<p><strong>database部分</strong></p>
<p>如果0号与3号数据库非空，则：</p>
<p><img src="assets%5C1552468706260.png" alt="1552468706260"></p>
<p>每个非空数据库在RDB文件中的保存：</p>
<p><img src="assets%5C1552468722522.png" alt="1552468722522"></p>
<ul>
<li>SELECTDB：长度为1字节，表示接下来读取的是一个数据库号码</li>
<li>db_number：保存着一个数据库号码，长度1、2、5字节，当读取到的时候，服务器使用select进行数据库切换</li>
<li>key_value_pairs保存所有键值对数据</li>
</ul>
<p><strong>key_value_pairs</strong></p>
<p>如果键值对带有过期时间，则也会保存在内。不带过期时间的表示：</p>
<p><img src="assets%5C1552468871546.png" alt="1552468871546"></p>
<p><img src="assets%5C1552468919035.png" alt="1552468919035"></p>
<ul>
<li>TYPE：对象类型或者底层编码，决定如何读入和解释value数据</li>
<li>key：字符串对象</li>
<li>EXPIRETIME_MS：1字节，表示接下来将读取一个过期时间，以毫秒为单位</li>
<li>ms：8字节带符号整数，记录一个毫秒为单位的UNIX时间戳</li>
</ul>
<p><strong>value的编码</strong></p>
<p>不同类型的值对象在RDB文件中的保存结构</p>
<p>字符串对象</p>
<p>列表对象</p>
<p>集合对象</p>
<p>哈希表对象</p>
<p>有序集合对象</p>
<h2 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h2><h1 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h1><p>通过保存Redis服务器所执行的写命令来记录数据库状态</p>
<p><img src="assets%5C1552469157583.png" alt="1552469157583"></p>
<p>写入的命令都是以Redis的命令请求协议格式保存的。</p>
<h2 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h2><p>功能实现分为：命令追加、文件写入、文件同步三个步骤</p>
<p><strong>命令追加</strong></p>
<p>当服务器执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾</p>
<p><strong>文件写入与同步</strong></p>
<ul>
<li>文件写入：只是写入到了内存缓冲区，可能还没有写到文件所拥有的磁盘数据块上 </li>
<li>文件同步：将缓冲区中的内容冲洗到磁盘上</li>
</ul>
<p>Redis服务器进程就是一个事件循环，在循环中的</p>
<ul>
<li>文件事件负责接收客户端的命令请求，以及向客户端发送命令恢复</li>
<li>时间事件负责执行像serverCron函数这样需要定时运行的函数</li>
</ul>
<p>服务器在处理文件事件时可能执行写命令，使得一些内容被追加到aof_buf缓冲区，因此服务器每次结束一个事件循环前，都会调用函数，考虑是否将aof_buf缓冲区里的内容写入和保存到AOF文件中。</p>
<p><img src="assets%5C1552470569474.png" alt="1552470569474"></p>
<p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值决定</p>
<ul>
<li>值为always，将缓冲区内所有内容写入并同步到AOF文件</li>
<li>默认为everysec，将缓冲区内所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过1S，则再次对AOF文件进行同步</li>
<li>no，将缓冲区内所有内容写入并同步到AOF文件，但并不进行同步，何时同步由操作系统决定</li>
</ul>
<h2 id="AOF文件载入与数据还原"><a href="#AOF文件载入与数据还原" class="headerlink" title="AOF文件载入与数据还原"></a>AOF文件载入与数据还原</h2><p><img src="assets%5C1552470819774.png" alt="1552470819774"></p>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>随着服务器允许，AOF文件内容与体积会越来越大，可能会对服务器造成影响，并且文件太大会使得AOF文件进行数据还原时间太长。</p>
<p>AOF文件重写：创建一个新的AOF文件替代现有的AOF文件，新旧的AOF保存的数据库状态相同，但是新的AOF文件不包含任何浪费空间的冗余指令。</p>
<p>冗余指令：</p>
<p><img src="assets%5C1552470946418.png" alt="1552470946418"></p>
<p><strong>AOF文件重写的实现</strong></p>
<p>通过读取服务器当前数据的状态来实现</p>
<p><strong>AOF后台重写</strong></p>
<p>因为Redis使用单个线程处理命令请求，如果由服务器调用重写，则会无法处理客户端命令请求</p>
<p>使用子进程进行重写。</p>
<ul>
<li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以避免在使用锁的情况下，保证数据的安全性</li>
<li>在AOF重写期间，可能会出现对现有数据库状态的修改<ul>
<li>设置AOF重写缓冲区，当Redis执行完一个写命令，会将命令同时发送给AOF缓冲区与AOF重写缓冲区</li>
<li>当子进程完成AOF后，向父进程发送信号，将AOF重写缓冲区所有内容写入新AOF文件</li>
<li>替换原有的AOF文件</li>
</ul>
</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>Redis服务器是一个事件驱动程序，需要处理一下两类事件</p>
<ul>
<li>文件事件：Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，服务器通过监听并处理这些事件完成一系列的网络通信操作</li>
<li>时间事件：需要在给定的时间点执行的操作</li>
</ul>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>Redis服务器是典型的一对多服务器程序：一个程序可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器接收并处理客户端发送的命令请求，并向客户端返回命令回复。</p>
<p>通过使用由IO多路复用技术实现的文件事件处理器，Redis使用单线程单进程处理命令，并与多个客户端进行网络通信</p>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/数据库/Redis（2）：数据结构与对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/04/数据库/Redis（2）：数据结构与对象/" class="post-title-link" itemprop="url">Redis（2）：数据结构与对象</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-04 18:34:18" itemprop="dateCreated datePublished" datetime="2019-03-04T18:34:18+08:00">2019-03-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-04-08 23:39:24" itemprop="dateModified" datetime="2019-04-08T23:39:24+08:00">2019-04-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/04/数据库/Redis（2）：数据结构与对象/" class="post-meta-item leancloud_visitors" data-flag-title="Redis（2）：数据结构与对象">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/04/数据库/Redis（2）：数据结构与对象/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/04/数据库/Redis（2）：数据结构与对象/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h1><p>Redis数据库里面的每个键值对都是由对象组成的</p>
<ul>
<li>数据库键总是一个字符串对象</li>
<li>数据库值可以是<ul>
<li>字符串对象</li>
<li>列表对象</li>
<li>哈希对象</li>
<li>集合对象（set）</li>
<li>有序集合对象</li>
</ul>
</li>
</ul>
<h1 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h1><p>Redis的字符串与传统字符串（以空字符结尾的字符数组，C字符串）不同，Redis自己构建了一种简单动态字符串（SDS）的抽象类型，并用作默认字符串表示。</p>
<ul>
<li>传统字符串在Redis当中只会作为字符串字面量用在一些无须对字符串进行修改的地方。</li>
<li>当需要一个可以被修改的字符串值时，就会使用SDS来表示字符串值</li>
</ul>
<p>SDS使用</p>
<ul>
<li>保存数据库的字符串值</li>
<li>用作缓冲区<ul>
<li>AOF模块中的AOF缓冲区</li>
<li>客户端状态中的输入缓冲区</li>
</ul>
</li>
</ul>
<h2 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"><span class="comment">//记录buf数组已经使用的字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">//记录未被使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//保存字符串</span></span><br><span class="line">    <span class="comment">//最后一个字节保存空字符'\0'，不记在len当中</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与C字符串的区别"><a href="#与C字符串的区别" class="headerlink" title="与C字符串的区别"></a>与C字符串的区别</h2><p>C字符串：以长度N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空元素’\0’</p>
<p>C字符串的字符串表示方法不能满足Redis对字符串在安全性、效率以及功能方面的要求</p>
<ul>
<li>C字符串需要常数复杂度获取字符串长度。<ul>
<li>它不记录自身长度，程序必须遍历整个字符串才能获取长度</li>
</ul>
</li>
<li>C字符串容易造成缓冲区溢出。<ul>
<li>C语言字符串拼接函数strcat，假定用户在执行函数时分字符串分配了足够多的内存，如果内存不够，则会缓冲区溢出<ul>
<li>这是因为字符串本身不记录其本身的内存信息</li>
</ul>
</li>
<li>SDS有free与len，可以知道自身剩余内存大小</li>
</ul>
</li>
<li>减少修改字符串时带来的内存重分配次数<ul>
<li>C字符串每次修改时，都要对保存字符串的数组进行一次内存重分配操作<ul>
<li>如果扩展字符串，则需要先分配内存；如果截断，则需要释放不适用的空间，否则会内存泄露。</li>
<li>也因此需要进行系统调用，较为费时</li>
</ul>
</li>
<li>SDS空间预分配优化策略<ul>
<li>优化字符串增长操作，当需要对SDS进行空间扩展时，程序不仅会为SDS分配必要空间，还会为SDS分配额外的未使用空间<ul>
<li>如果SDS修改后，len&lt;1MB，则程序分配和len同样大小的未使用空间</li>
<li>如果len&gt;=1MB，则分配1MB的未使用空间</li>
</ul>
</li>
</ul>
</li>
<li>SDS惰性空间释放优化策略<ul>
<li>优化缩短操作，程序并不立即使用内存重分配来回收多出来的字节，而是使用free记录下来，等待将来使用</li>
<li>同时提供了相应API，在需要时刻真正释放空间</li>
</ul>
</li>
</ul>
</li>
<li>二进制安全<ul>
<li>C字符串的字符必须包含某种编码，并且不能有空字符。因此只能保存文本，不能保存图片等二进制数据</li>
<li>SDS的API都以处理二进制的方式来处理SDS里的数据</li>
</ul>
</li>
<li>兼容<strong>部分</strong>C字符串函数</li>
</ul>
<h2 id="SDS的主要操作API"><a href="#SDS的主要操作API" class="headerlink" title="SDS的主要操作API"></a>SDS的主要操作API</h2><p><img src="assets%5C1551695057543.png" alt="1551695057543"></p>
<p><img src="assets%5C1551695070215.png" alt="1551695070215"></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>列表键的底层实现之一<ul>
<li>当一个列表键包含了数量较多的元素，或者列表中包含的元素都是比较常的字符串时，会使用链表作为链表键的底层实现</li>
</ul>
</li>
<li>发布与订阅</li>
<li>慢查询</li>
<li>监视器</li>
<li>保存多个客户端的状态信息</li>
<li>构建客户端输出缓冲区</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">	</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">	</span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值赋值函数 dup</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点释放函数 free</span></span><br><span class="line">    <span class="keyword">void</span> *(*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数 match</span></span><br><span class="line">    <span class="keyword">void</span> *(*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);;</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>特性</p>
<ul>
<li>双端</li>
<li>无环<ul>
<li>表头的prev与表尾的next都指向null</li>
</ul>
</li>
<li>表头指针与表尾指针</li>
<li>长度计数器</li>
<li>多态<ul>
<li>void*保存节点值，可以保存各种不同类型的值</li>
<li>使用三个属性可以为节点值设置类型特定函数</li>
</ul>
</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><img src="assets%5C1551695605130.png" alt="1551695605130"></p>
<p><img src="assets%5C1551695615751.png" alt="1551695615751"></p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>map</p>
<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><ul>
<li>哈希键的底层实现之一，当一个哈希键包含的键值对比较多，或者键值对中的元素都是比较长的字符串时。</li>
<li>当字典用作数据库底层实现或哈希键的底层实现时，使用MurmurHash2算法计算键的哈希值<ul>
<li>即使输入的键有规律，算法依然能给出一个很好地随机分布性，并且计算速度也很快</li>
</ul>
</li>
</ul>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，每个哈希表节点就保存了字典中的一个键值对</p>
<p><strong>哈希表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字典</span></span><br><span class="line"><span class="comment">//type与privdata属性针对不同类型的键值对，创建动态字典而设置</span></span><br><span class="line"><span class="comment">//dictType保存了一族用于操作特定类型键值对的函数</span></span><br><span class="line"><span class="comment">//privdata保存了需要传给那些类型特定函数的可选参数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    <span class="comment">//一般使用ht[0],ht[1]在rehash时使用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引</span></span><br><span class="line">    <span class="comment">//当rehash不在进行时，值为-1</span></span><br><span class="line">    in trehashidx;</span><br><span class="line">&#125;dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key1,<span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">	<span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于size-1</span></span><br><span class="line">    <span class="comment">//与哈希值一起决定一个键应该放到table的哪个索引上</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//已有节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="comment">//解决冲突</span></span><br><span class="line">    strut dictEntry *next；</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>

<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><ul>
<li>根据键值对的键计算出哈希值和索引值</li>
<li>根据索引值，将包含新键值对的哈希表节点放到哈希表数组的制定索引上</li>
<li>index=hash&amp;dict-&gt;ht[x].sizemask;</li>
</ul>
<h2 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h2><p>链地址法，并且将新节点加到表头，则复杂度为O1</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作不断执行，哈希表的键值对数目变化，为了保持负载因子维持在一个合理范围内，对哈希表进行相应的扩展或者收缩。</p>
<p><strong>步骤</strong></p>
<ul>
<li>为ht[1]哈希表分配空间，大小取决于要执行的操作，以及ht[0]当前包含的键值对数量，即used值<ul>
<li>如果扩展，则大小为第一个&gt;=ht[0].used*2的2^n</li>
<li>如果收缩，则大小为第一个&gt;=ht[0].used的2^n</li>
</ul>
</li>
<li>将保存在ht[0]的所有键值对rehash到ht[1]上。<ul>
<li>rehash指重新计算键的哈希值与索引值</li>
</ul>
</li>
<li>释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]创建一个空白哈希表</li>
</ul>
<p>扩展：</p>
<ul>
<li>服务器没有执行BGSAVE或BGREWRITEAOF命令，并且哈希表负载因子&gt;=1</li>
<li>服务器在执行BGSAVE或BGREWRITEAOF命令，并且哈希表负载因子&gt;=5<ul>
<li>执行命令过程中，Redis需创建当前服务器进程的子进程</li>
<li>大多数OS采用<strong>写时复制</strong>技术优化子进程的使用效率<ul>
<li>父进程和子进程共享页面而不是复制页面。然而，只要页面被共享，它们就不能被修改。</li>
<li>无论父进程和子进程何时试图写一个共享的页面，就产生一个错误，这时内核就把这个页复制到一个新的页面中并标记为可写。原来的页面仍然是写保护的：</li>
<li>当其它进程试图写入时，内核检查写进程是否是这个页面的唯一属主；如果是，它把这个页面标记为对这个进程是可写的。</li>
</ul>
</li>
<li>子进程存在期间，服务器会提高负载因子，以尽可能避免在子进程存在期间进行扩展，避免不必要的内存写入操作，节约内存</li>
</ul>
</li>
</ul>
<p>收缩：当负载因子小于0.1时</p>
<h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>在哈希表内保存极大量键值对时，一次性rehash会导致服务器停止服务。因此分多次、渐进式rehash</p>
<ul>
<li>为ht[1]哈希表分配空间</li>
<li>在字典中维持一个索引计数器变量rehashidx标识rehash开始</li>
<li>rehash进行期间，每次对字典执行增删改查操作时，除了执行指定操作，还会将ht[0]在rehashidx索引上的键值对rehas到ht[1]，在rehash完成后，rehashidx自增</li>
<li>全部rehash结束，rehashidx=-1</li>
<li>查找时，会先查ht[0]后查ht[1]。</li>
</ul>
<h2 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h2><p><img src="assets%5C1552026275087.png" alt="1552026275087"></p>
<p><img src="assets%5C1552026286675.png" alt="1552026286675"></p>
<h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><h2 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h2><ul>
<li>一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</li>
<li>支持平均OlgN,最坏ON的节点查找，可以通过顺序性操作批处理节点</li>
<li>大部分情况下，效率与平衡树媲美，并且实现简单。</li>
<li>有序集合键的底层实现之一，如果一个有序集合包含的元素量比较多，或者元素的成员是比较长的字符串时。</li>
<li>集群节点中用作内部数据结构</li>
</ul>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头表尾</span></span><br><span class="line">    structz skiplistNode *header,*tail;</span><br><span class="line">    <span class="comment">//表中节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//层</span></span><br><span class="line">    <span class="comment">//包含多个元素，每个元素都包含一个指向其他节点的指针，可以通过层加快访问其他节点的速度</span></span><br><span class="line">    <span class="comment">//层越多，访问其他节点速度越快</span></span><br><span class="line">    <span class="comment">//创建一个新的节点时，随机生成一个1-32的值，作为层数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">//前进指针</span></span><br><span class="line">        <span class="comment">//用于访问位于表尾方向的其他节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度</span></span><br><span class="line">        <span class="comment">//前进指针所指向节点和当前节点的距离</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125;level[];<span class="comment">//是一个数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后退指针</span></span><br><span class="line">    <span class="comment">//当前节点的前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//分值</span></span><br><span class="line">    <span class="comment">//节点按各自保存的分值从小到大排列</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//成员对象，一个SDS，较小的排前面，较大排后面（表尾）</span></span><br><span class="line">    <span class="comment">//成员对象必须唯一，但是分值可以相同</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><img src="assets%5C1552029291744.png" alt="1552029291744"></p>
<h2 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h2><p><img src="assets%5C1552029490765.png" alt="1552029490765"></p>
<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><h2 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h2><ul>
<li>集合键的底层实现之一。当一个集合只包含整数值元素，并且这个结合数量不多。</li>
</ul>
<h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">	<span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="comment">//从小到大有序排列，并不包含重复项</span></span><br><span class="line">    <span class="comment">//真正类型取决于encoding的值</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>

<p>当向一个int16_t的数组，添加一个int64_t的数值时，所有元素都会被转换为int64_t。</p>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>当要将一个新元素添加到整数集合里，并且新元素的类型比整数集合现有所有元素类型都长时，整数集合需要先进行升级，然后才能添加元素。</p>
<ul>
<li>根据新元素的类型，扩展整数集合底层数组的空间，并为新元素分配空间</li>
<li>将底层数组现有的所有元素转换成新元素的类型，并将转换后的元素放置到正确的位置，且维持有序性</li>
<li>将新元素添加进去</li>
</ul>
<p>不支持降级操作</p>
<p><strong>优势</strong></p>
<ul>
<li>提升灵活性，不担心类型错误</li>
<li>节约内存</li>
</ul>
<h2 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h2><p><img src="assets%5C1552030303322.png" alt="1552030303322"></p>
<h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><h2 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h2><ul>
<li>列表键与哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度较短的字符串</li>
</ul>
<h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><ul>
<li>Redis为了节约内存而开发，由一系列特殊编码的连续内存块组成的顺序性数据结构。</li>
<li>一个压缩列表可以包含多个节点，每个节点可以保存一个字节数或者一个整数值</li>
</ul>
<p><strong>构成</strong></p>
<ul>
<li>zibytes：记录整个压缩列表占用的内存字节数</li>
<li>zltail：记录压缩列表表尾节点距离首部的偏移</li>
<li>zllen：节点数目</li>
<li>entry[]：包含的节点</li>
<li>zlend：特殊值，标记末端</li>
</ul>
<p><strong>节点构成</strong></p>
<ul>
<li>previous_entry_length：记录前一个节点的长度（字节为单位），因此可以从尾部向头部遍历<ul>
<li>长度可能1个字节（上一个结点的长度小于254）或5个字节</li>
</ul>
</li>
<li>encoding：记录content属性所保存数据的类型已经长度</li>
<li>content：保存节点的值</li>
</ul>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>当新插入或删除的节点导致相邻的节点的previous_entry_length属性所占据的空间无法保存正确的数据，而导致需要空间分配。并且出现连锁反应</p>
<ul>
<li>实际触发可能性较低，并且更新的节点一般不会太多，因此不存在性能问题</li>
</ul>
<h2 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h2><p><img src="assets%5C1552033129986.png" alt="1552033129986"></p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><ul>
<li>Redis基于数据结构创建了一个对象系统，而不是直接实现数据库。包括字符串对象、列表对象、哈希对象、集合对象、有序集合对象。</li>
<li>在执行命令前，可以根据对象的类型判断对象是否可以执行给定的命令</li>
<li>可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化使用效率</li>
<li>实现了基于引用计数的内存回收机制、对象共享共享机制（多个数据库键共享同一个对象来节约内存）</li>
<li>对象带有访问时间记录信息，可以用于计算数据库键的空转时长，在服务器启用maxmemory下，空转时长较大的键可能被服务器优先删除</li>
</ul>
<h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h2><p>Redis使用对象来表示数据库中的键和值，每次创建一个键值对，则会至少创建两个对象：键对象、值对象</p>
<p>对象的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">//对象最后一次被命令程序的访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类型</strong></p>
<p><img src="assets%5C1552033987495.png" alt="1552033987495"></p>
<p>键总是一个字符串对象，而值可能是其中一种。</p>
<p>字符串键：则指该键对应的值为字符串对象</p>
<p><strong>编码和底层实现</strong></p>
<p>ptr指向对象的底层实现数据结构，而数据结构由encoding属性决定</p>
<p><img src="assets%5C1552034120684.png" alt="1552034120684"></p>
<ul>
<li>根据不同使用场景为对象设置不同的编码，优化对象效率</li>
<li>在列表对象包含元素较少，则使用压缩列表。更节约内存，在内存中连续块保存更快载入到内存</li>
<li>元素越多时，双端链表更优</li>
</ul>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><ul>
<li>int</li>
<li>raw</li>
<li>embstr<ul>
<li>embstr专门用于保存短字符串的一种优化编码方式。raw编码会调用两次内存分配函数创建redisObject与sdshdr，而embstr调用一次内存分配函数来分配一块连续空间，能更好地利用缓存带来的优势。</li>
</ul>
</li>
</ul>
<h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><ul>
<li>ziplist</li>
<li>linkedlist</li>
</ul>
<h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><ul>
<li>ziplist<ul>
<li>当有新的键值对加入，先将保存了键的压缩列表节点推入到表尾，再将保存了值的节点推入表尾<ul>
<li>两个节点总是紧挨，键节点在前，值节点在后</li>
<li>先添加到哈希对象中的键值对放在表头方向</li>
</ul>
</li>
</ul>
</li>
<li>hashtable<ul>
<li>字典作为底层实现</li>
</ul>
</li>
</ul>
<h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><ul>
<li>intset<ul>
<li>整数集合</li>
</ul>
</li>
<li>hashtable<ul>
<li>字典</li>
</ul>
</li>
</ul>
<h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><ul>
<li>ziplist</li>
<li>skiplist</li>
</ul>
<h2 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h2><p>操作键的命令可分为两种类型</p>
<ul>
<li>可对任何类型的键执行<ul>
<li>DEL、EXPIRE、RENAME、TYPE、OBJECT</li>
</ul>
</li>
<li>只能对特定类型的键执行<ul>
<li>SET、GET等只能对字符串键执行</li>
<li>HDEL、HSET等只能对哈希键执行</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>类型检查的实现</strong></p>
<p>在执行一个类型特定的命令前，Redis会先检查redisObject的type属性</p>
<p><strong>多态命令的实现</strong></p>
<p>根据值对象的编码方式，选择正确的命令实现代码来执行命令</p>
<ul>
<li>根据类型的多态 <ul>
<li>DEL等</li>
</ul>
</li>
<li>根据编码的多态<ul>
<li>SET等，对于一种类型的多种实现编码</li>
</ul>
</li>
</ul>
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>根据redisObject的refcount属性记录</p>
<ul>
<li>当创建一个新对象时，引用计数的值初始化为1</li>
<li>当被一个新程序使用时，引用计数+1</li>
<li>变为0时，占用内存会释放</li>
</ul>
<h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>当键A与键B都创建了一个包含整数值100的字符串对象作为值对象</p>
<ul>
<li>为键B创建一个新的对象</li>
<li>键A与键B共享一个对象<ul>
<li>将键B的指针指向原有的对象</li>
<li>被共享值的对象引用计数+1</li>
</ul>
</li>
</ul>
<p>Redis只对包含整数值的字符串对象进行共享，因为对于包含字符串的话，做一个equal的时间复杂度太高，CPU占用时间太长</p>
<h2 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h2><p>依据对象的lru时间，如果占用内存超出maxmemory则lru较高的部分键会优先被释放</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Redis设计与实现》</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/数据库/Redis（1）：概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/04/数据库/Redis（1）：概述/" class="post-title-link" itemprop="url">Redis（1）：概述</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-04 17:11:51" itemprop="dateCreated datePublished" datetime="2019-03-04T17:11:51+08:00">2019-03-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-04-08 23:32:16" itemprop="dateModified" datetime="2019-04-08T23:32:16+08:00">2019-04-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/04/数据库/Redis（1）：概述/" class="post-meta-item leancloud_visitors" data-flag-title="Redis（1）：概述">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/04/数据库/Redis（1）：概述/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/04/数据库/Redis（1）：概述/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h1><p>Redis数据库里面的每个键值对都是由对象组成的</p>
<ul>
<li>数据库键总是一个字符串对象</li>
<li>数据库键的值可以是<ul>
<li>字符串对象</li>
<li>列表对象</li>
<li>哈希对象</li>
<li>集合对象（set）</li>
<li>有序集合对象</li>
</ul>
</li>
</ul>
<h1 id="单机数据库的实现"><a href="#单机数据库的实现" class="headerlink" title="单机数据库的实现"></a>单机数据库的实现</h1><ul>
<li>数据库<ul>
<li>Redis数据库的实现原理</li>
<li>说明了服务器保存键值对的方法</li>
<li>服务器保存键值对过期时间的方法</li>
<li>服务器自动删除过期键值对的方法</li>
</ul>
</li>
<li>RDB持久化、AOF持久化<ul>
<li>Redis两种持久化方法的实现原理</li>
<li>服务器根据数据库来生成持久化文件的方法</li>
<li>服务器根据持久化文件还原数据库的方法</li>
<li>BGSAVE与BGREWAITEAOF的实现原理</li>
</ul>
</li>
<li>事件<ul>
<li>文件事件<ul>
<li>应答客户端连接请求</li>
<li>接收客户端发送的命令请求</li>
<li>向客户端返回命令回复</li>
</ul>
</li>
<li>时间事件<ul>
<li>执行redis.c/serverCron函数，通过执行常规的维护和管理操作保持Redis服务器的正常运作</li>
<li>触发一些定时操作</li>
</ul>
</li>
</ul>
</li>
<li>客户端</li>
<li>服务器</li>
</ul>
<h1 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h1><p>如何利用有限的资源提供尽可能大的吞吐量</p>
<p>请求直接从缓存中获取数据，直接返回</p>
<p><strong>缓存特征</strong></p>
<ul>
<li>命中率：命中数/（命中数+没有命中数）<ul>
<li>没有命中，缓存过期，需要从数据库当中重新获取</li>
<li>影响因素<ul>
<li>业务场景和业务需求：读多写少，实时性要求越低</li>
<li>缓存的设计（粒度和策略）：粒度越小，命中率越高。如果缓存一个对象与一个组的对象，一个对象的命中率更高。缓存策略，即缓存的更新。</li>
<li>缓存容量和基础设施：多数采用LRU算法。</li>
<li>并发越高，即使过期时间很短，缓存收益也很高</li>
<li>当缓存结点出现故障，需要避免缓存失效，并最大程度降低影响</li>
</ul>
</li>
</ul>
</li>
<li>最大元素（空间）：缓存中可以存放的最大数量</li>
<li>清空策略：FIFO、LFU、LRU，过期时间、随机等</li>
</ul>
<p><strong>缓存分类和应用场景</strong></p>
<p>根据缓存与应用的耦合度</p>
<ul>
<li>本地缓存<ul>
<li>编程实现，成员变量、局部变量、静态变量、Guava Cache</li>
<li>无法共享</li>
</ul>
</li>
<li>分布式缓存<ul>
<li>Memcache、Redis</li>
</ul>
</li>
</ul>
<h1 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h1><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><img src="assets%5C1552978943031.png" alt="1552978943031"></p>
<p>Redis所有操作都是原子性的。</p>
<p>使用场景</p>
<h1 id="高并发场景下缓存常见问题"><a href="#高并发场景下缓存常见问题" class="headerlink" title="高并发场景下缓存常见问题"></a>高并发场景下缓存常见问题</h1><ul>
<li>缓存一致性<ul>
<li>当数据时效要求很高，要保证缓存中的数据与数据库中的数据保持一致。并且缓存结点与副本中的数据也保持一致。</li>
<li>依赖缓存的过期与更新策略。在数据发生更改时，主动更改缓存中的数据，或移除对应的缓存<ul>
<li>更新数据库成功，更新缓存失败，数据不一致</li>
<li>更新缓存成功，更新数据库失败，数据不一致</li>
<li>更新数据库成功，淘汰缓存失败，数据不一致</li>
<li>淘汰缓存成功，更新数据库失败，查询缓存miss</li>
</ul>
</li>
</ul>
</li>
<li>缓存并发问题<ul>
<li>缓存过期后，将尝试从后端数据库获取数据。在高并发下，可能多个请求同时向数据库请求获取</li>
<li><img src="assets%5C1552980709600.png" alt="1552980709600"></li>
</ul>
</li>
<li>缓存穿透问题<ul>
<li>某个key在高并发的访问下没有被命中，出于容错率的情况，尝试去后端数据库中获取，导致大量的请求到达数据库本身。当该key对应的数据本身为空，就会导致数据库中并发执行很多不必要的操作</li>
<li>缓存空对象，对查询结果为空的对象也进行缓存</li>
</ul>
</li>
<li>缓存的雪崩现象<ul>
<li>缓存抖动（颠簸），缓存结点故障，通过一致性哈希算法解决</li>
<li>由于缓存的原因，导致大量请求到达后端数据库，导致数据库崩溃，系统崩溃。</li>
<li>可能由于缓存抖动、缓存并发、或者部分缓存集体失效过期导致</li>
<li>通过限流、降级、熔断手段降低影响，通过多级缓存</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/Java/base/java并发：高并发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/04/Java/base/java并发：高并发/" class="post-title-link" itemprop="url">java并发：高并发</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-04 17:00:02" itemprop="dateCreated datePublished" datetime="2019-03-04T17:00:02+08:00">2019-03-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-07-31 10:55:05" itemprop="dateModified" datetime="2019-07-31T10:55:05+08:00">2019-07-31</time>
              </span>
            
          

          
            <span id="/2019/03/04/Java/base/java并发：高并发/" class="post-meta-item leancloud_visitors" data-flag-title="java并发：高并发">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/04/Java/base/java并发：高并发/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/04/Java/base/java并发：高并发/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h1><ul>
<li>扩容<ul>
<li>水平扩容</li>
<li>垂直扩容</li>
</ul>
</li>
<li>缓存<ul>
<li>redis</li>
<li>memcache</li>
<li>guavaCache</li>
</ul>
</li>
<li>队列<ul>
<li>kafka</li>
<li>rabbitMQ</li>
<li>rocketMQ</li>
</ul>
</li>
<li>拆分<ul>
<li>服务化Dubbo</li>
<li>微服务spring cloud</li>
</ul>
</li>
<li>服务降级与熔断<ul>
<li>hystrix介绍与使用</li>
<li>服务降级的多种选择</li>
</ul>
</li>
<li>数据库切库分库分表<ul>
<li>切库、分表、支持多数据源的原理及实现</li>
</ul>
</li>
<li>高可用的一些手段<ul>
<li>任务调度分布式elastic-job</li>
<li>主备curator的实现</li>
<li>监控报警机制</li>
</ul>
</li>
<li>限流<ul>
<li>guava rateLimiter</li>
<li>常用限流算法</li>
<li>分布式限流</li>
</ul>
</li>
</ul>
<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>占用内存大小取决于工作内存内变量的多少与大小</p>
<p>单个线程占用的内存不会很大，但是很多线程占用内存就会很多</p>
<ul>
<li>垂直扩容：提高系统部件能力（加内存）</li>
<li>水平扩容：增加更多系统成员来实现（加服务器）</li>
</ul>
<h2 id="扩容-数据库"><a href="#扩容-数据库" class="headerlink" title="扩容-数据库"></a>扩容-数据库</h2><p>读操作扩展</p>
<ul>
<li><p>垂直扩容</p>
</li>
<li><p>memcache</p>
</li>
<li><p>redis</p>
</li>
<li><p>CDN等缓存</p>
</li>
</ul>
<p>写操作扩展</p>
<ul>
<li><p>水平扩容</p>
</li>
<li><p>Cassandra</p>
</li>
<li><p>Hbase等</p>
</li>
</ul>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h1 id="应用拆分与限流"><a href="#应用拆分与限流" class="headerlink" title="应用拆分与限流"></a>应用拆分与限流</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/Java/base/java并发：拓展/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/04/Java/base/java并发：拓展/" class="post-title-link" itemprop="url">java并发（9）：拓展</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-04 16:33:26 / Geändert am: 16:45:25" itemprop="dateCreated datePublished" datetime="2019-03-04T16:33:26+08:00">2019-03-04</time>
            </span>
          
            

            
          

          
            <span id="/2019/03/04/Java/base/java并发：拓展/" class="post-meta-item leancloud_visitors" data-flag-title="java并发（9）：拓展">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/04/Java/base/java并发：拓展/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/04/Java/base/java并发：拓展/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁的必要条件</p>
<ul>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ul>
<p>解决锁</p>
<ul>
<li>持有锁一定时间，依然在等待的话，则释放持有的所有锁。</li>
</ul>
<h1 id="多线程并发最佳实践"><a href="#多线程并发最佳实践" class="headerlink" title="多线程并发最佳实践"></a>多线程并发最佳实践</h1><ul>
<li>尽量使用本地变量</li>
<li>使用不可变类</li>
<li>最小化锁的作用域范围</li>
<li>使用线程池的executor，而不是newThread</li>
<li>宁可使用同步也不要使用现场的wait和notify</li>
<li>使用blockingQueue实现生产-消费模式</li>
<li>使用并发集合而不是加了锁的同步集合</li>
<li>使用semaphore创建有界的访问</li>
<li>宁可使用同步代码块，也不使用同步的方法</li>
<li>避免使用静态变量</li>
</ul>
<h1 id="Spring与线程安全"><a href="#Spring与线程安全" class="headerlink" title="Spring与线程安全"></a>Spring与线程安全</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/03/OS/计算机操作系统：处理机调度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/03/OS/计算机操作系统：处理机调度/" class="post-title-link" itemprop="url">计算机操作系统（6）：处理机调度</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-03 23:07:29" itemprop="dateCreated datePublished" datetime="2019-03-03T23:07:29+08:00">2019-03-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-04-08 15:17:05" itemprop="dateModified" datetime="2019-04-08T15:17:05+08:00">2019-04-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/03/OS/计算机操作系统：处理机调度/" class="post-meta-item leancloud_visitors" data-flag-title="计算机操作系统（6）：处理机调度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/03/OS/计算机操作系统：处理机调度/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/03/OS/计算机操作系统：处理机调度/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><p>是OS中用来管理处理机执行能力的这一部分的资源的功能</p>
<p>CPU资源的时分复用</p>
<ul>
<li>进程切换：CPU资源的当前占用者切换<ul>
<li>保存当前进程在PCB中的执行上下文（CPU状态）</li>
<li>恢复下一个进程的CPU状态</li>
</ul>
</li>
<li>处理机调度<ul>
<li>从就绪队列中挑选下一个占用CPU运行的进程</li>
<li>从多个可用CPU中挑选就绪进程可以使用的CPU资源（多处理器）</li>
</ul>
</li>
<li>调度程序：挑选就绪进程的内核函数<ul>
<li>调度策略：依据什么原则挑选进程、线程</li>
<li>调度时机：什么时候进行调度</li>
</ul>
</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>处理机概念</p>
<p><strong>调度时机</strong></p>
<ul>
<li>内核运行调度程序的条件<ul>
<li>进程从运行状态切换到等待状态</li>
<li>进程被终结了</li>
</ul>
</li>
<li>非抢占系统<ul>
<li>当前进程主动放弃CPU</li>
</ul>
</li>
<li>可抢占系统<ul>
<li>中断请求被服务例程响应完成时</li>
<li>当前进程被抢占<ul>
<li>进程时间片用完</li>
<li>进程从等待切换到就绪</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h2><p>调度策略</p>
<ul>
<li>确定如何从就绪队列中选择下一个执行进程</li>
</ul>
<p>调度策略要解决的问题</p>
<ul>
<li>挑选就绪队列的哪一个进程</li>
<li>通过什么样的准则来选择</li>
</ul>
<p>调度算法</p>
<ul>
<li>在调度程序中实现的调度策略</li>
</ul>
<p>比较调度算法的准则</p>
<ul>
<li>哪一个策略、算法比较好</li>
<li>CPU使用率<ul>
<li>CPU处于忙状态的时间百分比</li>
</ul>
</li>
<li>吞吐量<ul>
<li>单位时间内完成的进程数量</li>
</ul>
</li>
<li>周转时间<ul>
<li>进程从初始化到结束的总时间</li>
</ul>
</li>
<li>等待时间<ul>
<li>进程在就绪队列中的总时间</li>
</ul>
</li>
<li>响应时间<ul>
<li>从提交请求到产生响应所花费的时间</li>
</ul>
</li>
</ul>
<p>调度算法的要求</p>
<ul>
<li><p>吞吐量与延迟</p>
</li>
<li><p>希望<strong>更快</strong>地服务</p>
<ul>
<li>传输文件时的高带宽，调度算法的高吞吐量</li>
<li>玩游戏时的低延迟，调度算法的低响应延迟</li>
</ul>
</li>
<li><p>与水管类比</p>
<ul>
<li>低延迟：喝水时要一打开水龙头水就流出</li>
<li>高带宽：给泳池充水，希望从水龙头更快地充满</li>
</ul>
</li>
</ul>
<p>处理机调度策略的<strong>目标</strong></p>
<ul>
<li>响应时间目标<ul>
<li>减少响应时间</li>
<li>减少平均响应时间的波动<ul>
<li>可预测性比高差异低平均更重要</li>
</ul>
</li>
<li>低延迟调度改善了用户的交互体验</li>
<li>响应时间是OS的计算延时</li>
</ul>
</li>
<li>吞吐量目标<ul>
<li>增加吞吐量<ul>
<li>减少开销，OS开销，上下文切换</li>
<li>系统资源的高效利用，CPU与IO设备</li>
</ul>
</li>
<li>减少等待时间<ul>
<li>减少每个进程的等待时间</li>
</ul>
</li>
<li>OS需要保证吞吐量不受用户交互的影响</li>
<li>吞吐量是OS的计算带宽</li>
</ul>
</li>
<li>公平性目标<ul>
<li>公平的定义<ul>
<li>保证每个进程占用相同的CPU时间</li>
<li>保证每个进程的等待时间相同</li>
</ul>
</li>
<li>公平通常会增加平均响应时间</li>
</ul>
</li>
</ul>
<p><strong>处理机资源的使用模式</strong></p>
<ul>
<li>进程在CPU计算和I/O操作间交替<ul>
<li>I/O操作期间，CPU等待</li>
<li>计算大多在8MS以内</li>
<li>在时间片机制下，进程可能在结束当前CPU计算前被迫放弃CPU</li>
</ul>
</li>
</ul>
<p><img src="assets/1551773942678.png" alt="1551773942678"></p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>单处理器</p>
<p>调度算法分类</p>
<ul>
<li>就绪队列如何排列<ul>
<li>先来先服务</li>
<li>短进程优先</li>
<li>最高响应比优先</li>
</ul>
</li>
<li>每一次执行时间长短的控制<ul>
<li>时间片轮转</li>
</ul>
</li>
<li>多种算法如何综合到一起<ul>
<li>多级反馈队列</li>
<li>公平共享调度</li>
</ul>
</li>
</ul>
<h3 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h3><p>依据进程进入就绪状态的先后顺序排列</p>
<ul>
<li>进程进入等待或结束状态时，就绪队列中的下一个进程占用CPU</li>
</ul>
<p>特征</p>
<ul>
<li>简单</li>
<li>平均等待时间波动很大<ul>
<li>短进程可能排在长进程后面</li>
</ul>
</li>
<li>IO资源和CPU资源利用率较低<ul>
<li>CPU密集型进程会导致IO设备空闲时，IO密集型进程也等待</li>
</ul>
</li>
</ul>
<h3 id="短进程优先"><a href="#短进程优先" class="headerlink" title="短进程优先"></a>短进程优先</h3><p><strong>SPN</strong> 短进程优先</p>
<p>选择就绪队列中执行时间最短进程占用CPU进入运行状态</p>
<ul>
<li>就绪队列按预期（只有在执行时刻才真正知道）的执行时间排序</li>
</ul>
<p>特征</p>
<ul>
<li>最优平均周转时间</li>
<li>可能导致饥饿<ul>
<li>连续的短进程流会使得长进程无法获得CPU资源</li>
</ul>
</li>
<li>需要预知未来<ul>
<li>如何预估下一个CPU计算的持续时间</li>
<li>解决：<ul>
<li>询问用户</li>
<li>用历史执行时间预估未来执行时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>SJF</strong> 短作业优先</p>
<p><strong>SRT</strong> 短剩余时间优先：SPN算法的可抢占改进</p>
<h3 id="最高响应比优先"><a href="#最高响应比优先" class="headerlink" title="最高响应比优先"></a>最高响应比优先</h3><p>进程在就绪队列里的等待时间</p>
<p>选择就绪队列中响应比R值最高的进程</p>
<ul>
<li>R=(w+s)/s<ul>
<li>w：等待时间，s：执行时间</li>
</ul>
</li>
<li>在短进程优先算法基础上的改进</li>
<li>不可抢占</li>
<li>关注进程的等待时间</li>
<li>可以避免无限期等待</li>
</ul>
<h3 id="时间片轮转RR"><a href="#时间片轮转RR" class="headerlink" title="时间片轮转RR"></a>时间片轮转RR</h3><p>时间片：分配处理机资源的基本时间单元</p>
<p>算法思想：时间片结束时，按FCFS算法切换到下一个就绪进程</p>
<p>时间片设置</p>
<ul>
<li>RR算法开销<ul>
<li>依靠时钟中断，存在额外的上下文开销</li>
</ul>
</li>
<li>时间片太大<ul>
<li>等待时间太长，极限情况退化为FCFS</li>
</ul>
</li>
<li>时间片太小<ul>
<li>反应迅速，但大量上下文切换，影响系统吞吐量</li>
</ul>
</li>
<li>设置尺度<ul>
<li>经验值：10MS左右，上下文切换开销1%</li>
</ul>
</li>
</ul>
<h3 id="多级反馈队列MLFQ"><a href="#多级反馈队列MLFQ" class="headerlink" title="多级反馈队列MLFQ"></a>多级反馈队列MLFQ</h3><p>多级队列调度算法MQ</p>
<ul>
<li>就绪队列被划分为多个独立的子队列<ul>
<li>前台（交互），后台（批处理）</li>
</ul>
</li>
<li>每个队列用于自己的调度策略</li>
<li>队列间的调度<ul>
<li>固定优先级，则可能出现饥饿</li>
<li>时间片轮转</li>
</ul>
</li>
</ul>
<p>各个队列之间进行交互，则为<strong>多级反馈队列</strong></p>
<ul>
<li>进程可以在不同队列间移动的多级队列算法<ul>
<li>时间片大小随着优先级增加而增加</li>
<li>如进程在当前的时间片没有完成，则降到下一个优先级</li>
</ul>
</li>
<li>MLFQ算法的特征<ul>
<li>CPU密集型进程的优先级下降很快</li>
<li>IO密集型进程停留在高优先级<ul>
<li>使用CPU时间短</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="公平共享调度FSS"><a href="#公平共享调度FSS" class="headerlink" title="公平共享调度FSS"></a>公平共享调度FSS</h3><p>FSS控制用户对系统资源的访问</p>
<ul>
<li>一些用户组比其他用户组更重要</li>
<li>保证不重要的组无法垄断资源</li>
<li>未使用的资源按比例分配</li>
<li>没有达到资源使用率目标的组获得更高的优先级</li>
</ul>
<h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><p>实时操作系统</p>
<ul>
<li>定义：正确性依赖于其时间和功能两方面的操作系统</li>
<li>性能指标<ul>
<li>时间约束的及时性</li>
<li>速度和平均性能相对不重要</li>
</ul>
</li>
<li>特性：时间约束的可预测性</li>
<li>实时任务<ul>
<li>任务（工作单元）<ul>
<li>一次计算，一次文件读写，一次消息传递</li>
</ul>
</li>
<li>任务属性<ul>
<li>完成任务需要的资源</li>
<li>定时参数</li>
</ul>
</li>
<li>周期实时任务：一系列相似的任务</li>
<li>软时限<ul>
<li>通常能满足任务时限，如果有时不能满足，则降低要求</li>
<li>尽力保证满足任务时限</li>
</ul>
</li>
<li>硬时限<ul>
<li>错过时限会导致灾难性的后果</li>
<li>必须验证，在最坏情况下能够满足时限</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可调度性</p>
<ul>
<li>表示一个实时操作系统能够满足任务时限要求</li>
</ul>
<p>实时调度算法</p>
<ul>
<li>静态调度算法：速率单调调度算法RM<ul>
<li>通过周期安排优先级</li>
<li>周期越短优先级越高</li>
<li>执行周期最短的任务</li>
</ul>
</li>
<li>动态调度算法：最早截止时间优先算法EDF<ul>
<li>截止时间越早优先级越高</li>
<li>执行截止时间最早的任务</li>
</ul>
</li>
</ul>
<h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><p>特征</p>
<ul>
<li>多个处理机组成越高多处理机系统</li>
<li>处理机间可负载共享</li>
</ul>
<p>对称多处理器调度SMP</p>
<ul>
<li>每个处理器运行自己的调度程序</li>
<li>调度程序对共享资源的访问需要进行同步</li>
</ul>
<p>SMP进程分配</p>
<ul>
<li>静态进程分配<ul>
<li>进程从开始到结束都被分配到一个固定的处理器上执行</li>
<li>每个处理机有自己的就绪队列</li>
<li>调度开销小</li>
<li>各处理机可能忙闲不均</li>
</ul>
</li>
<li>动态进程分配<ul>
<li>进程在执行中可分配到任意空闲处理机执行</li>
<li>所有处理机共享一个公共的就绪队列</li>
<li>调度开销大</li>
<li>负载是均衡的</li>
</ul>
</li>
</ul>
<h2 id="优先级反置"><a href="#优先级反置" class="headerlink" title="优先级反置"></a>优先级反置</h2><ul>
<li>指操作系统中高优先级进程长时间等待低优先级进程所占用资源的现象</li>
<li>基于优先级的可抢占调度算法存在这种问题</li>
</ul>
<p><img src="assets/1551779306328.png" alt="1551779306328"></p>
<p>解决：</p>
<ul>
<li>优先级继承<ul>
<li>占用资源的低优先级进程继承申请资源的高优先级进程的优先级</li>
</ul>
</li>
<li>优先级天花板协议<ul>
<li>占用资源进程的优先级和所有可能申请该资源的进程的最高优先级相同</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/03/OS/计算机操作系统：进程和线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/03/OS/计算机操作系统：进程和线程/" class="post-title-link" itemprop="url">计算机操作系统：进程和线程</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-03 23:07:10" itemprop="dateCreated datePublished" datetime="2019-03-03T23:07:10+08:00">2019-03-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-05-14 15:51:51" itemprop="dateModified" datetime="2019-05-14T15:51:51+08:00">2019-05-14</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/03/OS/计算机操作系统：进程和线程/" class="post-meta-item leancloud_visitors" data-flag-title="计算机操作系统：进程和线程">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/03/03/OS/计算机操作系统：进程和线程/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/03/OS/计算机操作系统：进程和线程/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p><strong>出现原因</strong></p>
<p>早期OS只允许 一次执行一个程序，现代OS允许将多个程序调入内存并发执行。要求对各种程序提供更为严格的控制和更好地划分。</p>
<p><strong>概述</strong></p>
<p>进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</p>
<ul>
<li>即程序本身不是进程，程序只是被动实体（一个可执行文件），而进程是活动实体，拥有一个程序计数器用来表示下一个要执行的命令和相关资源集合。</li>
<li>当一个可执行文件装入内存，一个程序才能成为进程</li>
</ul>
<p><img src="assets/1551625950390.png" alt="1551625950390"></p>
<p><strong>进程的组成</strong></p>
<ul>
<li>进程包含了正在运行的一个程序的所有状态信息<ul>
<li>程序代码。即可执行文件</li>
<li>数据。进程通常还包括进程堆栈段（临时数据，如函数参数、返回地址和局部变量）和数据段（全局变量等）</li>
<li>可能包括堆，是在进程运行期间动态分配的内存。</li>
<li>当前活动<ul>
<li>状态寄存器。CPU状态CR0、指令指针IP</li>
<li>通用寄存器。AX、BX。。。</li>
</ul>
</li>
<li>进程占用系统资源<ul>
<li>打开文件、已分配内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此即使是运行同一个程序代码两次，也是两个不同的进程。就像打开两个浏览器一样</p>
<p><strong>进程的特点</strong></p>
<ul>
<li>动态性<ul>
<li>可动态地创建、结束进程</li>
</ul>
</li>
<li>并发性<ul>
<li>进程可以被独立调度并占用处理机（CPU）运行</li>
</ul>
</li>
<li>独立性<ul>
<li>不同进程的工作不相互影响</li>
</ul>
</li>
<li>制约性<ul>
<li>因访问共享数据、资源或进程间同步而产生制约</li>
</ul>
</li>
</ul>
<p><strong>进程和程序的联系</strong></p>
<ul>
<li>进程是OS处于执行状态程序的抽象<ul>
<li>程序=文件（静态的可执行文件）</li>
<li>进程=执行的程序=程序+执行状态</li>
</ul>
</li>
<li>同一个程序的多次执行过程对应为不同进程<ul>
<li>如命令ls的多次执行对应多个进程</li>
</ul>
</li>
<li>进程执行所需要的资源<ul>
<li>内存：保存代码和数据</li>
<li>CPU：执行指令</li>
</ul>
</li>
</ul>
<p><strong>进程和程序的区别</strong></p>
<ul>
<li>进程是动态的，程序是静态的<ul>
<li>程序是有序代码的集合</li>
<li>进程是程序的执行，进程有核心态\用户态</li>
</ul>
</li>
<li>进程是暂时的，程序是永久的<ul>
<li>进程是一个状态变化的过程</li>
<li>程序可以长久保存</li>
</ul>
</li>
<li>进程和程序的组成不同<ul>
<li>进程的组成包括程序、数据和PCB</li>
</ul>
</li>
</ul>
<h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h2><p>PCB：操作系统控制进程运行所用的信息集合</p>
<ul>
<li>操作系统用PCB来描述进程的基本情况以及运行变化的过程</li>
<li>PCB是进程存在的唯一标志。每个进程都在OS中有一个对应的PCB</li>
</ul>
<p>进程控制块的<strong>使用</strong></p>
<ul>
<li>进程创建。生成该进程的PCB</li>
<li>进程终止。回收它的PCB</li>
<li>进程的组织管理。通过对PCB的组织管理来实现</li>
</ul>
<p>进程控制块的<strong>内容</strong></p>
<ul>
<li>进程状态。创建、就绪、运行等</li>
<li>进程标识信息。进程编号，PID</li>
<li>程序计数器。进程要执行的下个指令的地址</li>
<li>CPU寄存器。<ul>
<li>与计算机体系结构相关</li>
<li>包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件码信息寄存器。</li>
</ul>
</li>
<li>CPU调度信息。进程优先级、调度队列的指针和其他调度参数</li>
<li>内存管理信息。OS所使用的内存系统，包括基址和界限寄存器的值、页表或段表</li>
<li>记账信息。CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等</li>
<li>IO状态信息。包括分给进程的IO设备列表、打开的文件列表等</li>
</ul>
<p>进程控制块的<strong>组织</strong></p>
<ul>
<li>链表<ul>
<li>同一状态的进程其PCB成一链表，多个状态对应多个不同的链表<ul>
<li>各状态的进程形成不同的链表：就绪链表、阻塞链表</li>
</ul>
</li>
</ul>
</li>
<li>索引表<ul>
<li>同一状态的进程归入一个索引表，由索引指向PCB</li>
</ul>
</li>
</ul>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程生命周期划分</p>
<ul>
<li>进程创建<ul>
<li>导致创建的事件<ul>
<li>系统初始化时</li>
<li>用户请求创建一个新进程</li>
<li>正在运行的进程执行了创建进程的系统调用</li>
</ul>
</li>
</ul>
</li>
<li>进程执行<ul>
<li>内核选择一个就绪的进程，让它占用处理机并执行</li>
<li>依据CPU调度算法</li>
</ul>
</li>
<li>进程等待<ul>
<li>进程进入等待（阻塞）的情况<ul>
<li>请求并等待系统服务，无法马上完成</li>
<li>启动某种操作，无法马上完成</li>
<li>需要的数据没有到达</li>
</ul>
</li>
<li>只有进程自身才能知道何时需要等待某种事件发生<ul>
<li>即是由进程本身内部原因引起的</li>
</ul>
</li>
</ul>
</li>
<li>进程抢占<ul>
<li>被抢占情况<ul>
<li>高优先级进程就绪</li>
<li>进程执行当前时间用完</li>
</ul>
</li>
</ul>
</li>
<li>进程唤醒<ul>
<li>唤醒可能情况<ul>
<li>被阻塞进程需要的资源可被满足</li>
<li>被阻塞进程等待的时间到达</li>
</ul>
</li>
<li>进程只能被别的进程或OS唤醒</li>
</ul>
</li>
<li>进程结束<ul>
<li>结束可能情况<ul>
<li>正常退出（自愿）</li>
<li>错误退出（自愿，进行了相应的处理保存）</li>
<li>致命错误</li>
<li>被其他进程杀死</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>进程切换</p>
<p>IO设备为定时器</p>
<p><img src="assets/1551627626757.png" alt="1551627626757"></p>
<h2 id="三状态进程模型"><a href="#三状态进程模型" class="headerlink" title="三状态进程模型"></a>三状态进程模型</h2><p>与CPU相关</p>
<p>进程状态</p>
<ul>
<li>运行<ul>
<li>进程正在处理机上运行</li>
</ul>
</li>
<li>就绪<ul>
<li>进程获得了除处理机以外所需的资源</li>
</ul>
</li>
<li>等待状态 （阻塞）<ul>
<li>进程正在等待某一时间的出现而暂停运行</li>
</ul>
</li>
<li>创建状态<ul>
<li>进程正在被创建，还没有赚到就绪状态之前的状态</li>
<li>正在分配资源，已经相应数据结构完成初始化</li>
</ul>
</li>
<li>结束<ul>
<li>进程正在从系统中消失的状态</li>
</ul>
</li>
</ul>
<p>状态变迁</p>
<p><img src="assets/1551683110492.png" alt="1551683110492"></p>
<h2 id="挂起进程模型"><a href="#挂起进程模型" class="headerlink" title="挂起进程模型"></a>挂起进程模型</h2><p>与存储相关</p>
<ul>
<li>进程挂起：<ul>
<li>处于挂起状态的进程映像在磁盘上</li>
<li>目的是减少进程占用内存</li>
</ul>
</li>
<li>等待挂起状态<ul>
<li>进程在外存并等待事件的出现</li>
</ul>
</li>
<li>就绪挂起状态<ul>
<li>进程在外存，但只要进入内存即可运行<ul>
<li>内存不够</li>
<li>优先级不够高</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>状态转换</p>
<ul>
<li>挂起：把一个进程从内存转到外存<ul>
<li>等待到等待挂起<ul>
<li>没有进程处于就绪状态或就绪进程要求更多的内存资源</li>
</ul>
</li>
<li>就绪到就绪挂起<ul>
<li>当有高优先级等待进程和低优先级就绪进程</li>
</ul>
</li>
<li>运行到挂起就绪<ul>
<li>对抢先式分时系统，当有高优先级等待挂起进程因时间出现而进入就绪</li>
</ul>
</li>
</ul>
</li>
<li>在外存时的状态转换<ul>
<li>等待挂起到就绪挂起<ul>
<li>当有等待挂起进程因相关事件出现</li>
</ul>
</li>
<li>激活：把一个进程从外存转到内存<ul>
<li>就绪挂起到就绪<ul>
<li>没有就绪进程或挂起就绪进程优先级高于就绪进程</li>
</ul>
</li>
<li>等待挂起到等待<ul>
<li>当一个进程释放足够内存，并有高优先级等待挂起进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="assets/1551684935696.png" alt="1551684935696"></p>
<p>状态队列</p>
<ul>
<li>由操作系统维护一组队列，表示系统中所有进程的当前状态</li>
<li>不同队列表示不同状态<ul>
<li>就绪队列、等待队列等</li>
</ul>
</li>
<li>根据进程状态不同，PCB加入相应队列<ul>
<li>进程状态变化时，PCB会换到另一个队列</li>
</ul>
</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><strong>为什么引入线程</strong></p>
<p>在一个进程当中希望有很好地并发性，多线程解决思路</p>
<ul>
<li>在进程内部增加一类实体，满足一下特性<ul>
<li>实体之间可以并发执行</li>
<li>实体之间共享相同的地址空间</li>
</ul>
</li>
</ul>
<h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>线程是进程的一部分，描述指令流执行状。</p>
<ul>
<li><p>它是<strong>进程中的指令执行流（从进程中剥离）</strong>的最小单元，是CPU调度的基本单位</p>
</li>
<li><p>进程的资源分配角色：进程由一组相关资源构成，包括地址空间，打开的文件等各种资源</p>
</li>
<li><p>线程的处理机调度角色：线程描述在进程资源环境中的指令流执行状态</p>
</li>
<li><p>线程控制块TCB</p>
</li>
</ul>
<p>进程和线程的关系</p>
<p><img src="assets/1551685825565.png" alt="1551685825565"></p>
<p>线程=进程-共享资源</p>
<ul>
<li>线程的优点<ul>
<li>一个进程中可以同时存在多个线程</li>
<li>各个线程间可以并发地执行</li>
<li>各个线程间可以共享地址空间和文件等资源</li>
</ul>
</li>
<li>线程的缺点<ul>
<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>
</ul>
</li>
</ul>
<h2 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h2><p>线程的实现方式</p>
<ul>
<li>用户线程：在用户空间实现</li>
<li>内核线程：在内核中实现</li>
<li>轻量级线程：在内核中实现，支持用户线程</li>
</ul>
<p>用户线程：由一组用户级的线程库函数来完成线程的管理</p>
<p><img src="assets/1551686435770.png" alt="1551686435770"></p>
<p>用户线程的特征</p>
<ul>
<li>不依赖OS的内核<ul>
<li>内核不了解用户线程的存在</li>
<li>可用于不支持线程的多进程操作系统</li>
</ul>
</li>
<li>在用户空间实现的线程机制<ul>
<li>每个进程有私有的线程控制块列表</li>
<li>TCB由线程库函数维护</li>
</ul>
</li>
<li>同一进程内的用户线程切换速度快<ul>
<li>无需用户态-&gt;核心态切换</li>
</ul>
</li>
<li>允许每个进程拥有自己的线程调度算法</li>
</ul>
<p>不足</p>
<ul>
<li>线程发起系统调用而阻塞，则整个进程进入等待</li>
<li>不支持基于线程的处理机抢占<ul>
<li>除非当前允许线程主动放弃，它所在进程的其他线程无法抢占CPU</li>
</ul>
</li>
<li>线程只能按进程分配CPU时间<ul>
<li>多个线程进程中，每个线程的时间片较少</li>
</ul>
</li>
</ul>
<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>由内核通过系统调用实现的线程机制，由内核来完成线程的创建、终止、管理</p>
<p><img src="assets/1551686676855.png" alt="1551686676855"></p>
<p>内核线程的特征</p>
<ul>
<li>由内核维护PCB和TCB</li>
<li>线程执行系统调用而被阻塞不影响其他线程</li>
<li>线程的创建终止、切换开销相对较大<ul>
<li>通过系统调用/内核函数，在内核中实现</li>
<li>要先由用户态转到内核态</li>
</ul>
</li>
<li>以线程为单位进行CPU时间分配<ul>
<li>多线程进程可以获得更多CPU时间</li>
</ul>
</li>
</ul>
<h2 id="轻权进程"><a href="#轻权进程" class="headerlink" title="轻权进程"></a>轻权进程</h2><p>内核支持的用户线程。一个进程可以有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持。</p>
<p>内核线程与用户线程的结合，过于复杂，没体现优势</p>
<h1 id="进程与线程区别"><a href="#进程与线程区别" class="headerlink" title="进程与线程区别"></a>进程与线程区别</h1><h2 id="进程与线程的比较"><a href="#进程与线程的比较" class="headerlink" title="进程与线程的比较"></a>进程与线程的比较</h2><ul>
<li>进程是资源分配的单位，线程是CPU调度单位</li>
<li>进程拥有一个完整的资源平台，线程只独享指令流执行的必要资源，如寄存器和栈</li>
<li>线程具有就绪、等待和运行三种基本状态和状态间的转换关系</li>
<li>线程能减少并发执行的时间和空间开销<ul>
<li>线程的创建时间比进程短</li>
<li>线程的终止时间比进程短</li>
<li>同一进程内的线程切换时间比进程短</li>
<li>由于同一进程的各线程间共享内存和文件资源，可不通过内核进行直接通信</li>
</ul>
</li>
</ul>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>进程调度选择一个可用的进程到CPU上执行。</p>
<p><strong>调度队列</strong></p>
<p>进程进入系统时，会被加到作业队列中，队列中包括系统中的所有进程。</p>
<p>队列通常使用链表来实现，头指针指向链表的第一个和最后一个PCB块的指针，每个PCB包括一个指向就绪队列的下一个PCB的指针域</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>进程上下文由进程PCB表示</p>
<ul>
<li>包括CPU寄存器的值、进程状态、内存管理信息等。</li>
</ul>
<p><strong>上下文切换</strong>：将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程状态，这一个任务称为上下文切换。</p>
<ul>
<li>速度依赖于内存速度、必须复制的寄存器数量、是否有特殊指令（如装入或保存所有寄存器的单个指令）</li>
<li>与硬件支持相关。有的处理器提供了多组寄存器集合，只需要简单地改变当前寄存器组的指针即可。</li>
</ul>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>定义</p>
<ul>
<li>暂停当前运行进程，从运行状态变成其他状态</li>
<li>调度另一个进程从就绪状态变成运行状态</li>
</ul>
<p>进程切换的要求</p>
<ul>
<li>切换前，保存进程上下文</li>
<li>切换后，恢复进程上下文</li>
<li>快速切换</li>
</ul>
<p>进程生命周期的信息</p>
<ul>
<li>寄存器 PC SP</li>
<li>CPU状态</li>
<li>内存地址空间</li>
</ul>
<p>PCB：内核的进程状态记录</p>
<ul>
<li>内核为每个进程维护了相应的进程控制块</li>
<li>内核将相同状态的进程的PCB放置在同一队列</li>
</ul>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>fork复制原有进程</p>
<p>exec进行重写</p>
<h2 id="进程加载"><a href="#进程加载" class="headerlink" title="进程加载"></a>进程加载</h2><p>用户的应用程序通过系统调用加载来完成一个新的可执行文件的加载</p>
<h2 id="进程等待与退出"><a href="#进程等待与退出" class="headerlink" title="进程等待与退出"></a>进程等待与退出</h2><p>父子进程的一种交互</p>
<p>wait()系统调用用于父进程等待子进程的结束</p>
<ul>
<li>子进程结束时，通过exit向父进程返回一个值</li>
<li>父进程通过wait接受并处理返回值</li>
</ul>
<p>wait系统调用的功能</p>
<ul>
<li>有子进程存活时，父进程进入等待状态，等待子进程的返回结果<ul>
<li>当某子进程调用exit时，唤醒父进程，将exit的返回值作为副进程中wait的返回值</li>
</ul>
</li>
<li>有僵尸子进程等待时，wait立即返回其中一个值</li>
<li>无子进程存活，wait立刻返回</li>
</ul>
<p>进程的有序终止exit</p>
<ul>
<li>进程结束执行时调用exit，完成进程资源回收</li>
<li>exit系统调用的功能<ul>
<li>将调用参数作为进程的结果</li>
<li>关闭所有打开的文件等占用资源</li>
<li>释放内存</li>
<li>释放大部分进程相关的内核数据结构</li>
<li>检查释放父进程是存活着的<ul>
<li>如存活，保留结果的值直到父进程需要它，进入僵尸状态</li>
<li>如果没有，释放所有数据结构，进程结束</li>
</ul>
</li>
<li>清理所有等待的僵尸进程</li>
</ul>
</li>
<li>进程终止是最终的垃圾回收（资源回收）</li>
</ul>
<h2 id="其他进程控制系统调用"><a href="#其他进程控制系统调用" class="headerlink" title="其他进程控制系统调用"></a>其他进程控制系统调用</h2><ul>
<li>优先级控制</li>
<li>进程调试支持<ul>
<li>允许一个进程控制另一个进程的执行</li>
<li>设置断点和查看寄存器</li>
</ul>
</li>
<li>定时<ul>
<li>sleep</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Vorherige Seite"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">219</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">Kategorien</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">schlagwörter</span>
        
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  











  
  <script>
    function showTime(Counter) {
      var entries = [];
      var $visitors = $('.leancloud_visitors');

      $visitors.each(function() {
        entries.push( $(this).attr('id').trim() );
      });

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url: { '$in': entries } }) })
        .done(function({ results }) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if (countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function ({ responseJSON }) {
          console.log(`LeanCloud Counter Error: ${responseJSON.code} ${responseJSON.error}`);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
                'X-LC-Key': 'uTVcNIWdMCGpicrhTKygpKXi',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
            if ($('.post-title-link').length >= 1) {
              showTime(Counter);
            }
          
        });
    });
  </script>












  
<link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">
<script src="/lib/algolia-instant-search/instantsearch.min.js"></script>


<script src="/js/algolia-search.js?v=7.2.0"></script>














    
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
    appKey: 'uTVcNIWdMCGpicrhTKygpKXi',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn'
  });
</script>


</body>
</html>
