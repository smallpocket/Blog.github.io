<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: 'OZTK1BY156',
      apiKey: '',
      indexName: 'BlogIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copiar',
      copy_success: 'Copiado',
      copy_failure: 'Copiar falló'
    }
  };
</script>

  <meta name="description" content="To be awesome">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="To be awesome">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="To be awesome">
  <link rel="canonical" href="http://yoursite.com/page/14/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Cambiar a barra de navegación">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Inicio</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>Sobre mi</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Etiquetas</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categorías</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archivo</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>Calendario</a>

  </li>
    </ul>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/OS/计算机操作系统：虚拟内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/02/OS/计算机操作系统：虚拟内存/" class="post-title-link" itemprop="url">计算机操作系统（三）：虚拟内存</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-03-02 16:01:24" itemprop="dateCreated datePublished" datetime="2019-03-02T16:01:24+08:00">2019-03-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-04-08 14:58:00" itemprop="dateModified" datetime="2019-04-08T14:58:00+08:00">2019-04-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/02/OS/计算机操作系统：虚拟内存/" class="post-meta-item leancloud_visitors" data-flag-title="计算机操作系统（三）：虚拟内存">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/03/02/OS/计算机操作系统：虚拟内存/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/02/OS/计算机操作系统：虚拟内存/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="虚拟内存概念"><a href="#虚拟内存概念" class="headerlink" title="虚拟内存概念"></a>虚拟内存概念</h1><p>物理内存的管理：分区、非连续分区等</p>
<p>虚拟内存是非连续内存分配的基础上，把原来要放在内存里的整个进程地址空间的信息，将其中的一部分数据放到外存当中，使得内存空间更大。</p>
<p>具体做法：覆盖与交换。</p>
<p>局部性原理：程序的执行有一定特征，要么是指令顺序执行，要么是跳转（循环，跳转到之前的一个地方）</p>
<p>目标</p>
<ul>
<li>只把部分程序放到内存，从而运行比物理内存大的程序<ul>
<li>由OS完成</li>
</ul>
</li>
<li>实现进程在内存与外存之间的交换，从而获得更多的空闲内存空间<ul>
<li>在内存和外存间只交换进程的部分内容</li>
</ul>
</li>
</ul>
<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><ul>
<li>增长迅速的存储需求，OS当中常出现的内存空间不够用<ul>
<li>解决：覆盖，应用程序手动把需要的指令和数据保存在内存中（将代码分为若干模块，相互独立，在需要的时候加载）</li>
<li>交换，OS自动把暂时不能执行的程序保存到外存当中（一次对换是整个进程）</li>
<li>虚拟存储，在有限容量的内存中，以页为单位自动装入更多更大的程序</li>
</ul>
</li>
</ul>
<p><strong>存储层次结构</strong></p>
<ul>
<li>理想中的存储器<ul>
<li>容量更大，速度更快，价格更便宜、非易失</li>
</ul>
</li>
<li>实际<ul>
<li>寄存器、高速缓存、内存、磁盘、磁带</li>
</ul>
</li>
</ul>
<p><strong>操作系统的存储抽象</strong></p>
<p>地址空间</p>
<p><img src="assets/1551514916600.png" alt="1551514916600"></p>
<h2 id="覆盖和交换"><a href="#覆盖和交换" class="headerlink" title="覆盖和交换"></a>覆盖和交换</h2><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>目标：在较小的可用内存中运行较大的程序（单个大程序无法运行）</p>
<p>方法：</p>
<ul>
<li><p>依据程序的逻辑结构，将程序划分为若干功能相对独立的模块。将不会同时执行的模块共享同一块内存区域</p>
<ul>
<li>必要部分的代码和数据常驻内存</li>
<li>可选部分放在其他程序模块中，只在需要时装入</li>
<li>不存在调用关系的模块相互覆盖，放在同一内存区域</li>
</ul>
</li>
</ul>
<p>覆盖示例：</p>
<p><img src="assets/1551516161820.png" alt="1551516161820"></p>
<p>不足：</p>
<ul>
<li>增加编程困难<ul>
<li>需要划分功能模块</li>
<li>增加复杂度</li>
</ul>
</li>
<li>增加执行时间<ul>
<li>从外存装入</li>
</ul>
</li>
</ul>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>目的：增加正在运行或需要运行的程序的内存（考虑多个程序时候空间不够）</p>
<p>实现方法</p>
<ul>
<li>将暂时不能运行的程序放到外存</li>
<li>换入换出的基本单位<ul>
<li>整个进程的地址空间</li>
</ul>
</li>
<li>换出：将一个进程的整个地址空间保存到外存</li>
<li>换入：将外存中莫进程的地址空间换入内存</li>
</ul>
<p>问题：</p>
<ul>
<li>交换时机：何时需要发生交换<ul>
<li>当内存空间不够或有不够的可能时</li>
</ul>
</li>
<li>交换区的大小<ul>
<li>存放所有用户进程的所有内存映像的拷贝</li>
</ul>
</li>
<li>程序换入时的重定位：换出后再换入要放在原处吗？<ul>
<li>动态地址映射</li>
</ul>
</li>
</ul>
<p><img src="assets/1551516629778.png" alt="1551516629778"></p>
<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>概念：指访问的数据具有很好的集中性</p>
<ul>
<li>程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域<ul>
<li>时间局部性<ul>
<li>一条指令的一次执行与下一次执行，一个数据的一次访问与下次访问都集中在一个较短时期内</li>
</ul>
</li>
<li>空间局部性<ul>
<li>当前指令与邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内</li>
</ul>
</li>
<li>分支局部性<ul>
<li>一条跳转指令的两次执行，很可能跳到相同的内存位置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="虚拟存储概念"><a href="#虚拟存储概念" class="headerlink" title="虚拟存储概念"></a>虚拟存储概念</h2><p>思路：将不常用的部分内存块暂存到外存</p>
<p>原理：</p>
<ul>
<li>加载程序时，只将当前指令执行需要的部分页面或段装入内存</li>
<li>指令执行中需要的指令或数据不在内存（缺页）时<ul>
<li>处理器通知操作系统将相应的页面调入内存</li>
</ul>
</li>
<li>OS将内存中暂时不用的页面保存到外存（置换算法）</li>
</ul>
<p>实现方式：虚拟页式、段式存储</p>
<p>支持技术：</p>
<ul>
<li>硬件<ul>
<li>页式或短时存储中的地址转换机制</li>
</ul>
</li>
<li>操作系统<ul>
<li>管理内存和外存间页面或段的换入或换出</li>
</ul>
</li>
</ul>
<h2 id="虚拟页式存储"><a href="#虚拟页式存储" class="headerlink" title="虚拟页式存储"></a>虚拟页式存储</h2><p>在页式存储管理的基础上，增加请求调页和页面置换</p>
<p>思路</p>
<ul>
<li>在用户程序要装在到内存运行时，只装入部分页面，就启动程序</li>
<li>进程在运行中发现有需要的代码或数据不在内存时，则向系统发出缺页异常请求</li>
<li>操作系统在处理缺页异常时，将外存中相应的页面调入内存</li>
</ul>
<p>页表项结构</p>
<p><img src="assets/1551517783236.png" alt="1551517783236"></p>
<ul>
<li>驻留位，表示该页是否存在内存</li>
<li>修改位：表示在内存中的该页是否被修改过</li>
<li>访问位：表示该页面是否被访问过（读或写）</li>
<li>保护位：表示该页的允许访问方式</li>
</ul>
<h2 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h2><p><img src="assets/1551518146885.png" alt="1551518146885"></p>
<p>虚拟页式存储中的外存管理</p>
<ul>
<li>在何处保存未被映射的页<ul>
<li>应能方便地找到在外存中的页面内容</li>
<li>交换空间（磁盘或者文件）<ul>
<li>采用特殊格式存储未被映射的页面</li>
</ul>
</li>
</ul>
</li>
<li>外存选择<ul>
<li>代码段：可执行二进制文件</li>
<li>动态加载的共享库程序段：动态调用的库文件</li>
<li>其他段：交换空间</li>
</ul>
</li>
</ul>
<p>虚拟页式存储管理的性能</p>
<p>有效存储访问时间</p>
<p>EAT=访存（内存）时间×（1-p）+缺页异常处理时间（远大于访存时间）×缺页率p</p>
<h1 id="虚拟存储页面置换算法"><a href="#虚拟存储页面置换算法" class="headerlink" title="虚拟存储页面置换算法"></a>虚拟存储页面置换算法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>功能</p>
<ul>
<li>当出现缺页异常，需调入新页面而内存已满时，置换算法选择被置换的物理页面</li>
</ul>
<p>设计目标：</p>
<ul>
<li>尽可能减少页面的调入调出此时</li>
<li>把未来不再访问或短期内不访问的页面调出</li>
</ul>
<p>页面锁定：</p>
<ul>
<li>描述必须常驻内存的逻辑页面（OS的关键代码等）</li>
<li>OS的关键部分</li>
<li>要求响应速度的代码和数据</li>
<li>页表中的锁定标志位</li>
</ul>
<p>置换算法的评价</p>
<ul>
<li>记录进程访问内存的页面轨迹<ul>
<li>虚拟地址访问用（页号，位移）表示</li>
</ul>
</li>
<li>评价方法：<ul>
<li>模拟页面置换行为，记录产生缺页的次数</li>
<li>更少的缺页，更好的性能</li>
</ul>
</li>
</ul>
<p>算法分类</p>
<ul>
<li>局部页面置换算法<ul>
<li>分配一个进程的物理页面数是确定的</li>
<li>置换页面的选择范围仅限于当前进程占用的物理页面内</li>
<li>难以实现：最优算法、先进先出算法（性能差）、最近最久未使用算法</li>
<li>常用：时钟算法、最不常用算法</li>
</ul>
</li>
<li>全局页面置换算法<ul>
<li>分配一个进程的物理页面数是确定的</li>
</ul>
</li>
</ul>
<h2 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h2><ul>
<li>分配一个进程的物理页面数是确定的</li>
<li>置换页面的选择范围仅限于当前进程占用的物理页面内</li>
</ul>
<h3 id="最优算法OPT"><a href="#最优算法OPT" class="headerlink" title="最优算法OPT"></a>最优算法OPT</h3><p>预测未来</p>
<p>基本思路</p>
<ul>
<li>置换在<strong>未来</strong>最长时间不访问的页面</li>
</ul>
<p>算法实现</p>
<ul>
<li>缺页时，计算内存中每个逻辑页面的下一次访问时间（假设可以）</li>
<li>选择未来最长时间不访问的页面</li>
</ul>
<p>特征</p>
<ul>
<li>缺页最少，最好</li>
<li>实际系统无法实现</li>
<li>无法预知每个页面在下次访问前的等待时间</li>
<li>作为性能评价依据</li>
</ul>
<h3 id="先进先出算法FIFO"><a href="#先进先出算法FIFO" class="headerlink" title="先进先出算法FIFO"></a>先进先出算法FIFO</h3><p>思路</p>
<ul>
<li>选择在内存中驻留时间最长的页面进行置换</li>
</ul>
<p>实现</p>
<ul>
<li>维护一个记录所有位于内存中的逻辑页面链表</li>
<li>链表元素按驻留内存的时间排序</li>
<li>出现缺页时，选择链首页面进行置换，新页面加到链尾</li>
</ul>
<p>特征</p>
<ul>
<li>实现简单</li>
<li>性能较差</li>
<li>进程分配物理页面数增加时，缺页不一定减少 <strong>belady现象</strong></li>
<li>很少单独使用</li>
</ul>
<h3 id="最近最久未使用算法LRU"><a href="#最近最久未使用算法LRU" class="headerlink" title="最近最久未使用算法LRU"></a>最近最久未使用算法LRU</h3><p>统计过去，实现复杂度较高</p>
<p>思路</p>
<ul>
<li>选择最长时间没有被引用的页面进行置换</li>
<li>依据：如某些页面长时间未被访问，则它们在将来还可能会长时间不会访问</li>
</ul>
<p>实现</p>
<ul>
<li>缺页时，计算内存中每个逻辑页面的上一次访问时间</li>
<li>选择上一次使用到当前时间最长的页面</li>
</ul>
<p>特征</p>
<ul>
<li>最优置换算法的一种近似</li>
<li>非常复杂，不太可能实现</li>
</ul>
<p><strong>LRU算法的可能实现方法</strong></p>
<ul>
<li>页面链表<ul>
<li>系统维护一个按最近一次访问时间排序的页面链表<ul>
<li>链表首节点是最近刚刚使用过的页面</li>
<li>链表尾节点是最久未使用的页面</li>
</ul>
</li>
<li>访问内存时，找到相应的页面，并把它移到链表首</li>
<li>缺页时，置换链表尾部的页面</li>
</ul>
</li>
<li>活动页面栈，相对较优<ul>
<li>访问页面时，将页号压入栈顶，并将栈内相同的页号抽出</li>
<li>缺页时，置换栈底的页面（双端栈）</li>
</ul>
</li>
</ul>
<h3 id="时钟置换算法CLOCK"><a href="#时钟置换算法CLOCK" class="headerlink" title="时钟置换算法CLOCK"></a>时钟置换算法CLOCK</h3><p>思路：</p>
<ul>
<li>仅对页面的访问情况作大致统计</li>
</ul>
<p>数据结构：</p>
<ul>
<li>在页表项中增加<strong>访问位</strong>，描述页面在过去一段时间的内访问情况</li>
<li>各页面组织成环形链表</li>
<li>指针指向最先调入的页面，指针在链表上进行周期性循环</li>
</ul>
<p>算法</p>
<ul>
<li>访问页面时，在页表项纪录页面访问情况</li>
<li>缺页时，从指针处开始顺序查找未被访问的页面进行置换</li>
<li>在LRU与FIFO折中</li>
</ul>
<p>实现</p>
<ul>
<li>页面装入内存时，访问位初始化为0</li>
<li>访问页面时，访问位置1</li>
<li>缺页时，从指针当前位置顺序检查环形链表<ul>
<li>访问位为0，置换该页</li>
<li>访问位为1，则重置为0，指针移动到下一个位置直到找到可置换页面</li>
</ul>
</li>
</ul>
<p><strong>改进的clock算法</strong></p>
<p>思路</p>
<ul>
<li>减少修改页的缺页处理开销（修改的页面要写回外存，因此存在开销）</li>
</ul>
<p>算法</p>
<ul>
<li>在页面中增加修改位，并在访问时进行相应修改</li>
<li>缺页时，修改页面的标志位，以跳过有修改的页面</li>
</ul>
<p>数据写回外存有一定的延迟</p>
<h3 id="最不常用算法LFU"><a href="#最不常用算法LFU" class="headerlink" title="最不常用算法LFU"></a>最不常用算法LFU</h3><p>思路</p>
<ul>
<li>缺页时，置换访问次数最少的页面</li>
</ul>
<p>实现</p>
<ul>
<li>每个页面设置一个访问计数</li>
<li>访问页面，访问计数+1</li>
<li>缺页时，置换计数最小的页面</li>
</ul>
<p>特征</p>
<ul>
<li>算法开销大</li>
<li>开始时频繁使用，但以后不使用的页面很难置换<ul>
<li>解决：计数定期右移</li>
</ul>
</li>
<li>LRU与LFU区别<ul>
<li>LRU关注多久没访问</li>
<li>LFU关注次数</li>
</ul>
</li>
</ul>
<h3 id="belady现象"><a href="#belady现象" class="headerlink" title="belady现象"></a>belady现象</h3><p>局部置换算法的一个特征</p>
<ul>
<li>采用FIFO等算法时，可能会出现分配的物理页面增加，缺页次数反而会升高的异常现象</li>
</ul>
<p>原因</p>
<ul>
<li>FIFO算法的置换特征与进程访问内存的动态特征矛盾（进程的访问特征不同，排序算法与word编辑进程的访问特征完全不同）</li>
<li>被它置换出去的页面并不一定是进程近期不会访问的</li>
</ul>
<p>LRU算法无belady现象</p>
<h3 id="LRU、FIFO、Clock的比较"><a href="#LRU、FIFO、Clock的比较" class="headerlink" title="LRU、FIFO、Clock的比较"></a>LRU、FIFO、Clock的比较</h3><ul>
<li><p>LRU算法与FIFO本质上都是先进先出</p>
<ul>
<li>LRU依据页面的最近访问时间排序</li>
<li>LRU需要动态调整顺序</li>
<li>LRU算法性能好，但是开销大</li>
<li>FIFO依据页面进入内存的时间排序</li>
<li>FIFO顺序固定不变</li>
<li>LRU开销小，但是belady现象</li>
</ul>
</li>
<li><p>LRU可退化为FIFO</p>
<ul>
<li>如果页面进入内存后没有被访问（视频信息等）</li>
</ul>
</li>
<li><p>Clock算法是折中</p>
</li>
<li><p>对于被访问的页面，clock算法不能记录准确访问顺序，而LRU算法可以</p>
</li>
</ul>
<h1 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h1><p>考虑不同进程对于内存需求量的差异</p>
<p>思路</p>
<ul>
<li>给进程分配可变数目的物理页面</li>
</ul>
<p>需要解决的问题</p>
<ul>
<li>进程在不同阶段的内存需求是变化的</li>
<li>分配给进程的内存也需要在不同阶段有所变化</li>
<li>全局置换算法需要确定分配给进程的物理页面数</li>
</ul>
<p><strong>CPU利用率与并发进程数的关系</strong></p>
<p>局部性特征的下降！</p>
<p><img src="assets/1551530291552.png" alt="1551530291552"></p>
<h3 id="工作集置换算法"><a href="#工作集置换算法" class="headerlink" title="工作集置换算法"></a>工作集置换算法</h3><p>最优算法在全局里的一种体现</p>
<p>工作集：一个进程当前正在使用的逻辑页面集合，表示为二元函数W（t,L）</p>
<ul>
<li>t是当前执行时刻</li>
<li>L为工作集窗口，即一个订场的页面访问时间窗口</li>
<li>W指在当前时刻t前的L时间窗口中的所有访问页面所组成的集合</li>
<li>|W|指工作集的大小，即页面数目</li>
</ul>
<p><img src="assets/1551530571188.png" alt="1551530571188"></p>
<p>工作集的变化</p>
<p><img src="assets/1551530646757.png" alt="1551530646757"></p>
<p>常驻集</p>
<ul>
<li>当前时刻，进程实际驻留内存当中的页面集合</li>
</ul>
<p>工作集与常驻集的关系</p>
<ul>
<li>工作集是进程在运行过程中固有的性质</li>
<li>常驻集取决于系统分配给进程的物理页面数目和页面置换算法</li>
</ul>
<p>缺页率与常驻集关系</p>
<ul>
<li>常驻集包含工作集，缺页较少</li>
<li>工作集发生剧烈变动，缺页较多</li>
<li>进程常驻集大小达到一定数目后，缺页率也不会明显下降</li>
</ul>
<p><strong>思路</strong></p>
<ul>
<li>换出不在工作集的页面</li>
<li>窗口大小L，当前时刻前T个内存访问的页引用是工作集</li>
</ul>
<p>实现方法</p>
<ul>
<li>访问链表：维护窗口内的访问页面链表</li>
<li>访存时，换出不在工作集的页面，更新访存链表</li>
<li>缺页时，换入页面，更新访存链表</li>
</ul>
<h3 id="缺页率置换算法PFF"><a href="#缺页率置换算法PFF" class="headerlink" title="缺页率置换算法PFF"></a>缺页率置换算法PFF</h3><p>缺页率：缺页次数/内存访问次数 或 缺页平均时间间隔的倒数</p>
<p>影响缺页率因素</p>
<ul>
<li>页面置换算法</li>
<li>分配给进程的物理页面数目</li>
<li>页面大小</li>
<li>编程内容</li>
</ul>
<p>原理：</p>
<ul>
<li><p>通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内</p>
<ul>
<li>若进程缺页率过高，则增加常驻集以分配更多</li>
<li>若缺页率过低，则减小常驻集</li>
</ul>
</li>
</ul>
<p>实现</p>
<ul>
<li>访存时，设置引用位标志</li>
<li>缺页时，计算上次缺页时间到现在缺页时间的间隔<ul>
<li>如果间隔&gt;T，则置换所有在该间隔中所有没有被引用的页</li>
<li>否则，增加缺失页到常驻集</li>
</ul>
</li>
</ul>
<h3 id="抖动和负载控制"><a href="#抖动和负载控制" class="headerlink" title="抖动和负载控制"></a>抖动和负载控制</h3><p><strong>抖动：</strong></p>
<ul>
<li>进程物理页面太少，不能包含工作集</li>
<li>造成大量缺页，频繁置换</li>
<li>进程运行速度变慢</li>
</ul>
<p>产生抖动的原因</p>
<ul>
<li>随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升</li>
</ul>
<p>操作系统需要在并发和缺页率到达一个平衡。</p>
<p><strong>负载控制</strong></p>
<ul>
<li>通过调节并发进程数来进行系统负载控制</li>
</ul>
<p><img src="assets/1551532183444.png" alt="1551532183444"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Java/base/java并发：线程安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/Java/base/java并发：线程安全/" class="post-title-link" itemprop="url">java并发：线程安全</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-03-01 15:42:55" itemprop="dateCreated datePublished" datetime="2019-03-01T15:42:55+08:00">2019-03-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-31 15:46:43" itemprop="dateModified" datetime="2019-07-31T15:46:43+08:00">2019-07-31</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/01/Java/base/java并发：线程安全/" class="post-meta-item leancloud_visitors" data-flag-title="java并发：线程安全">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/03/01/Java/base/java并发：线程安全/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/01/Java/base/java并发：线程安全/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><blockquote>
<p>线程安全：当多个线程访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用放进行任何其他的协调操作， <strong>调用这个对象的行为</strong>都可以获得正确的结果，那这个对象是线程安全的。</p>
</blockquote>
<p>即要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段(互斥同步等)，令调用者无须关系多线程的问题，更无须自己采用任何措施来保证多线程的正确调用。但这个并不容易做到</p>
<p>因此一般将定义弱化一些,即将调用这个对象的行为限定为<strong>单次调用</strong>，若其他描述成立，则称它线程安全。</p>
<p>在一项工作进行前，会被不停中断与切换，对象的属性可能会在中断期间被修改和变脏。如何保证程序在计算机中正确无误地运行</p>
<h2 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h2><p>线程安全限定于多个线程间存在共享数据访问这个前提，如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度看，程序是串行执行还是多线程执行对它没有区别</p>
<p>依照线程安全的<strong>安全程度</strong>排序来看，Java中各种操作共享的数据分为以下5类：</p>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>final对象，不可边的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要采用任何的线程安全保障措施。</p>
<p>只要一个不可变的对象被正确地构建出来(this引用没有逃逸)，那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程中处于不一致的状态。</p>
<ul>
<li>对于一个<strong>数据类型</strong>，只需要在定义时使用final即可</li>
<li>对于一个<strong>对象</strong>，则需要保证对象的行为不糊对其状态产生任何影响才行。例如String，subString会返回一个新的字符串，对其本身没有影响。</li>
</ul>
<h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>指完全满足定义。即使一个类的所有方法都时被synchronized修饰的，也不意味着调用它永远都不需要同步手段了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread removeThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)&#123;</span><br><span class="line">            vector.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread printThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)&#123;</span><br><span class="line">            System.out.println(vector.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    removeThread.start();</span><br><span class="line">    printThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例当中，依然时线程不安全的，当remove刚好删除一个元素，导致序号i已经不可用，此时去访问数组会抛出ArrayIndexOutOfBoundsException</p>
<p>而要改为绝对安全则需要将<code>synchronized(vector)</code></p>
<h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>保证单次调用下，线程是安全的，对于特定顺序的连续调用，则可能需要使用额外的同步手段。Java中的大多数线程安全类都属于该类型</p>
<h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>对象本身并不是线程安全，但可以在调用端正确使用同步手段来保证对象在并发环境可以安全使用。一般常说类不是线程安全的绝大部分是指该情况。</p>
<h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>无论调用端是否采用了同步措施，都无法在多线程环境并发使用的代码。</p>
<p>例如Thread的<code>suspend()</code>与<code>resume()</code>，如果两个线程同时持有一个线程对象，一个尝试中断线程，另一个尝试恢复线程。当并发进行时，无论调用是否同步，目标线程都存在死锁风险。</p>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><blockquote>
<p>同步指多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个(或一些)线程使用。</p>
<p>互斥是实现同步的一种手段。</p>
</blockquote>
<p>互斥同步最主要的问题是进行线程阻塞与唤醒带来的性能问题。悲观的并发策略。</p>
<ul>
<li>临界区、互斥量、信号量都是主要互斥实现方法。</li>
<li>synchronized关键字：需要系统帮助完成</li>
<li>J.U.C包下的重入锁，例如ReentrantLock</li>
</ul>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>由于硬件指令集的发展而出现。基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，则采用其他补偿措施（例如不断重试，直到成功）。</p>
<p>由于该方法大多实现不需要将线程挂起，即称为非阻塞同步。</p>
<ul>
<li>测试并设置 Test and Set</li>
<li>获取并增加 Fetch and Increment</li>
<li>交换 Swap</li>
<li>比较并交换 Compare and Swap     CAS<ul>
<li>ABA问题，如果要解决ABA问题可以使用Atomic，但是可能互斥同步更高效一些。</li>
</ul>
</li>
<li>加载链接/条件存储 Load-Linked/Store-Conditional     LL/SC</li>
</ul>
<h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>对于一些方法本身不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此由一些代码天生就是线程安全的。</p>
<h4 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h4><p>即纯代码。不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<p>如果一个方法，它的返回结果时可以预测的，即只要输入了相同的数据，就能返回相同的结果。那么就满足可重入的要求。</p>
<h4 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h4><p>如果一段代码中所需要的数据必须与其他代码共享，那就看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，就可以将共享数据的可见范围限制在同一个线程内，这样无须同步也能保证线程间不会出现数据争用的问题。</p>
<p>例如大部分消费队列的架构模式都会将产品的消费过程尽量在一个线程中消费完，例如一个请求对应一个服务器线程的处理方式。</p>
<p>通过ThreadLocal实现。</p>
<h1 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h1><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>编写线程安全的代码，本质上就是管理对<strong>状态</strong>的访问，而且通常都是<strong>共享、可变</strong>的状态。</p>
<p>一个对象的状态就是它的数据，存储在状态变量中，如静态域、实例域。共享即一个变量可以被多个线程访问。可变即变量的值在其生命周期内都可以改变。真正要做到的线程安全是在不可控制的并发访问当中保护数据。</p>
<p>无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。</p>
<p>java的同步机制：synchronized(独占锁)，volatile(显示锁和原子变量的使用)</p>
<p>修复同步隐患</p>
<ul>
<li>不跨线程的共享变量</li>
<li>使用状态变量为不可变的</li>
<li>在任何访问状态变量的时候使用同步</li>
</ul>
<h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p>当多个线程访问某个类时，不管运行时环境采用<strong>何种调度方式</strong>或者这些进程将如何交替执行，并且在主调代码中不需要<strong>任何额外的同步或协同</strong>，这个类都能表现出<strong>正确的行为</strong>。</p>
<p>无状态的对象永远是安全的。即指这个对象没有状态域，也没有引用其他对象的域，是一次特定计算的瞬时状态，会唯一存放在一个本地变量当中，即线程的栈当中。而两个线程并不共享状态。</p>
<p><strong>三个方面</strong></p>
<ul>
<li>原子性：提供了互斥访问，同一时刻只能有一个线程对它进行操作</li>
<li>可见性：一个线程对主内存的修改可以及时被其他线程观察到</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般无序</li>
</ul>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性：能作为一个单独的、不可分割的操作去执行</p>
<p>当向一个无状态的对象添加一个域，并进行long++操作（读+改+写），则不是线程安全</p>
<p>将long换作一个atomic包下的AtomicLong变量，则由于该变量是一个原子变量类，该计数器是线程安全的，该对象的状态即该计数器的对象，即该对象线程安全。（利用已有的线程安全类进行管理，如果只有一个，则线程安全，如果多个，则未必线程安全）</p>
<p>当变量之间相互关联，则在一个原子操作当中，要将几个相互关联的变量同时更新</p>
<p><strong>竞争条件</strong></p>
<p>​    想得到正确的答案，依赖时序。</p>
<h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><p>JDK的Atomic包，通过CAS完成原子性</p>
<p>int类型变为AtomicInteger，自增的方法为incrementAndGet</p>
<h4 id="CAS核心"><a href="#CAS核心" class="headerlink" title="CAS核心"></a>CAS核心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//计数方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count.incrementAndGet();<span class="comment">//先执行增加操作，再获取值</span></span><br><span class="line"><span class="comment">//        count.getAndIncrement(); //先获取当前的值，再执行增加操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>源码实现，基于一个unsafe类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以dowhile语句为核心实现,CompareAndSwap是C.A.S的核心.</p>
<p>因为使用循环，如果修改很频繁，会不断循环尝试修改，使得性能受到影响</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * var1:当前的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//通过调用底层方法,获得var1对象底层当前的值</span></span><br><span class="line">            <span class="comment">//如果没有其他线程更改,则var5就会等于var2</span></span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">            <span class="comment">//比较底层的值var5与传入的值var2</span></span><br><span class="line">            <span class="comment">//如果底层的值与传入值相同,那么更新为var5+增量var4</span></span><br><span class="line">            <span class="comment">//如果值不相同,则将var2的值更改为底层当前的值,然后重新do,获得var5的值,进行比较</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以native标识，即java底层的实现，不是java的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p><strong>AtomicLong</strong></p>
<p>对于很精确的数值需要使用</p>
<p><strong>LongAdder</strong></p>
<p>原理：JVM对于普通的long与double，允许将64位的读操作与写操作拆分为两个32位的操作。</p>
<p>核心：将热点数据分离，将一个value分割为一个数组，每个线程针对一个数值，最后的value由数组的值合成，将单点的更新压力分散为多点的更新压力。在低并行的时候，对value直接更新。</p>
<p>优点：在高并发下，效率很高</p>
<p>缺点：如果有并行更新，可能导致统计数据有一些误差</p>
<p><strong>AtomicReference</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; count = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出4</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        count.compareAndSet(<span class="number">0</span>,<span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line">        count.compareAndSet(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// no</span></span><br><span class="line">        count.compareAndSet(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// no</span></span><br><span class="line">        count.compareAndSet(<span class="number">2</span>,<span class="number">4</span>); <span class="comment">// 4</span></span><br><span class="line">        count.compareAndSet(<span class="number">3</span>,<span class="number">5</span>); <span class="comment">// no</span></span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>,count.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>AtomicReferenceFieldUpdater</strong></p>
<p>以<strong>原子性更新</strong>某个类的一个实例的一个字段，字段必须volatile，并且非static</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater = AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class,<span class="string">"count"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicExample5 atomicExample5 = <span class="keyword">new</span> AtomicExample5();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (updater.compareAndSet(atomicExample5,<span class="number">100</span>,<span class="number">120</span>))&#123;</span><br><span class="line">        log.info(<span class="string">"update success,&#123;&#125;"</span>,atomicExample5.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (updater.compareAndSet(atomicExample5,<span class="number">100</span>,<span class="number">120</span>))&#123;</span><br><span class="line">        log.info(<span class="string">"update success,&#123;&#125;"</span>,atomicExample5.getCount());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">"update error&#123;&#125;"</span>,atomicExample5.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AtomicLongArray</strong></p>
<p>更新一个long的数组</p>
<p><strong>AtomicBoolean</strong></p>
<p>实现代码只执行一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean isHappend = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (isHappend.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line"></span><br><span class="line">         log.info(<span class="string">"execute"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CAS的ABA问题"><a href="#CAS的ABA问题" class="headerlink" title="CAS的ABA问题"></a>CAS的ABA问题</h4><p>ABA问题：在CAS操作中，其他线程将数据A改为B，又改为A。</p>
<p>解决：在每次更新的时候，记录一个版本号，每次更新+1</p>
<p>通过AtomicStampReference实现，核心方法为CompareAndSet</p>
<h3 id="原子性：锁"><a href="#原子性：锁" class="headerlink" title="原子性：锁"></a>原子性：锁</h3><p>synchronized：依赖JVM，在该关键字作用对象的作用范围内，只有一个线程可以操作</p>
<p>Lock：依赖特殊的CPU指令，由代码实现。ReentrantLock</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>同步锁，修饰的对象：</p>
<ul>
<li>修饰代码块：大括号括起来的代码，作用于<strong>调用的对象</strong></li>
<li>修饰方法：整个方法，作用于<strong>调用的对象</strong></li>
<li>修饰静态方法：整个静态方法，作用于<strong>所有对象</strong></li>
<li>修饰类：括号括起来部分，作用于<strong>所有对象</strong></li>
</ul>
<p>作用于所有的对象。则如果两个对象调用一个修饰的方法，他们会并行执行。而如果调用一个静态方法，则他们无法并行执行。</p>
<p>对于修饰代码块与修饰方法，不同的调用对象互相不影响</p>
<p><strong><em>继承</em></strong></p>
<p>如果子类调用继承于父类的synchronize方法（synchronize不属于一个类），是没有synchronize效果的，必须显式声明</p>
<p><strong><em>特性</em></strong></p>
<ul>
<li><p>重进入：内部锁是重进入的，当线程试图获得它自己所占有的锁时候，请求会成功，即重进入是基于每<strong>线程</strong>的，而不是调用。</p>
<p>实现是通过为每个锁关联一个请求计数与一个占有它的线程，当同一线程访问，则计数++，线程退出该锁，则计数–，直到计数为0，释放该锁（父类与子类的使用）</p>
</li>
</ul>
<p><strong><em>用锁来保持状态</em></strong></p>
<ul>
<li>如果每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行状态当中占有同一个锁，则称该变量是由这个锁保护的</li>
<li>每个共享的可变变量都需要唯一一个确定的锁保护</li>
</ul>
<p><strong><em>设计</em></strong></p>
<ul>
<li>决定synchronize块大小需要权衡安全性（不能妥协）、简单性、性能。通常简单性与性能相互牵制，实现一个同步策略时候，不要过早地为了性能而牺牲简单性（是对安全性潜在的妥协）</li>
<li>有些耗时的计算或操作，如网络或者控制台IO，难以快速完成，执行它们的时候不要占有锁</li>
</ul>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><h3 id="原子性对比："><a href="#原子性对比：" class="headerlink" title="原子性对比："></a>原子性对比：</h3><ul>
<li>synchronize；不可中断锁，适合竞争不激烈，可读性好</li>
<li>Lock：可中断锁，多样化同步，竞争激烈能维持常态</li>
<li>Atomic：竞争激烈能维持常态，比lock性能好，但是只能同步一个值</li>
</ul>
<h3 id="活跃度与性能"><a href="#活跃度与性能" class="headerlink" title="活跃度与性能"></a>活跃度与性能</h3><p>​    不能武断地将整个方法设置为synchronize的，通过缩小synchronize的范围来提高并发性</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550563393365.png" alt="1550563393365"></p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>一个线程对主内存的修改可以及时被其他线程观察到。</p>
<p>导致共享变量在线程间不可见的原因</p>
<ul>
<li>线程交叉执行</li>
<li>重排序结合线程交叉执行</li>
<li>共享变量更新后的值没有在工作内存与主内存间及时更新</li>
</ul>
<h3 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h3><p>JVM对synchronize的规定</p>
<ul>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存</li>
<li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享内存是需要从主内存中重新读取最新的值</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>通过加入内存屏障与禁止重排序优化来实现。</p>
<ul>
<li>对volatile变量<strong>写操作</strong>时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存。（每次写之后都刷新），CPU指令级别进行操作。</li>
</ul>
<p><img src="assets/1551425245832.png" alt="1551425245832"></p>
<ul>
<li>对volatile变量<strong>读操作</strong>时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量。（每次读从主内存读）</li>
</ul>
<p><img src="assets/1551425259624.png" alt="1551425259624"></p>
<p>但是volatile<strong>无法保证</strong>线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count++;</span><br><span class="line"><span class="comment">// 1、count//获得的是最新值</span></span><br><span class="line"><span class="comment">// 2、+1   //两个进程同时++</span></span><br><span class="line"><span class="comment">// 3、count//同时写回,即丢掉了一次.</span></span><br></pre></td></tr></table></figure>

<p>volatile<strong>使用</strong></p>
<ul>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ul>
<p>可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>使用场景</p>
<ul>
<li>很适合作为状态标示量</li>
<li>检查两次</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般无序</p>
<p>方式：volatile、synchronized、lock、java内存模型的先天有序性（happens before原则）</p>
<h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens before原则"></a>happens before原则</h3><ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定操作：一个unlock操作先行发生于后面对同一个锁的lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对于这个变量的读操作</li>
<li>传递规则；如果操作A先行发生于操作B，而操作B又先行发生于操作C，则操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start（）方法先行发生于此线程的每一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测</li>
<li>对象终结规则：一个对象的初始化完成先行发生于它的finalize（）方法的开始</li>
</ul>
<p>如果两个操作的执行次序无法从happens before推导出来，则JVM可以对它进行随意的重排序。</p>
<h1 id="线程安全策略"><a href="#线程安全策略" class="headerlink" title="线程安全策略"></a>线程安全策略</h1><p>进行共享和发布对象，使得多个线程可以安全地访问他们。</p>
<ul>
<li>线程限制<ul>
<li>一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改</li>
<li>线程封闭：把对象封装到一个线程当中，只有一个线程可以看到它</li>
</ul>
</li>
<li>共享只读<ul>
<li>一个共享只读的对象，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它</li>
<li>不可变对象：一种对象只要发布了就是安全的，即不可变对象，是一种躲避并发的方法</li>
</ul>
</li>
<li>线程安全对象<ul>
<li>一个线程安全的对象或者容器，在内部通过同步机制来保证线程安全，所有其他线程无需额外同步就可以通过公共接口随意访问它</li>
</ul>
</li>
<li>被守护对象<ul>
<li>只能通过获取特定的锁来访问</li>
</ul>
</li>
</ul>
<h2 id="线程安全的困难"><a href="#线程安全的困难" class="headerlink" title="线程安全的困难"></a>线程安全的困难</h2><h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><p>​    重排序现象：在单个线程当中，只要重排序不会对结果产生影响，则不能保证操作一定按照程序写定的顺序执行（java虚拟机的高性能）</p>
<p>​    如果数据需要跨线程共享，就要进行恰当的同步。</p>
<p><strong>过期数据</strong></p>
<p>​    当读线程检查一个变量时，可能看到一个过期的数据。并且过期不会发生在全部变量上，也不会完全不出现。</p>
<p>​    对于get与set方法，同样需要同步化，进行synchronize</p>
<p><strong>锁与可见性</strong></p>
<p>​    锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能看到共享的、可变变量的最新值，读取和写入线程必须使用公共的锁进行同步</p>
<p>​    volatile：弱同步，确保对一个变量的更新以可预见的方式告知其他线程</p>
<h3 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h3><p>​    发布：发布一个对象指它能够被当前范围以外的代码所使用。发布一个对象，同时将发布该对象所有的非私有域引用的对象。</p>
<p>​    逸出：一个对象在尚未准备好的时候就发布</p>
<p>发布方式：</p>
<ul>
<li>将对象存放到公共静态域</li>
</ul>
<p>逸出：</p>
<ul>
<li><p>this引用在构造期间逸出，即对象在没有通过构造函数构造完毕（执行到了构造函数的某一句）时候逸出。</p>
<p>当对象在构造函数当中创建一个线程，this引用总是被新线程共享，</p>
</li>
</ul>
<h2 id="线程不安全类与写法"><a href="#线程不安全类与写法" class="headerlink" title="线程不安全类与写法"></a>线程不安全类与写法</h2><p>线程不安全类：</p>
<ul>
<li>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</li>
<li>如果一个类的对象可以同时被多个线程访问，如果没有做并发处理，则会出现异常</li>
</ul>
<p>StringBuilder是线程不安全的。</p>
<p>StringBuffer是线程安全的，它内部方法添加了synchronized，但也因此它的性能有损耗。</p>
<p><strong>ArrayList、hashMap、hashSet等collection</strong></p>
<p>线程不安全</p>
<p><strong><em>示例</em></strong></p>
<p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    ThreadUnsafeExample example = <span class="keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h2><p>​    如果希望跨线程共享对象，则必须安全地共享它</p>
<p>​    对象的引用对其他线程可见，但它的状态可能是过期的，即对象的状态不一定对消费线程可见。</p>
<p><strong>安全发布的模式</strong></p>
<ul>
<li>通过静态初始化器初始化对象的引用（JVM内部的同步机制）</li>
<li>将它的引用存储到volatile域或者atomicReference</li>
<li>将它的引用存储到正确创建的对象的final域</li>
<li>或者将它的引用存储到由锁正确保护的域中</li>
</ul>
<p><strong>线程安全容器</strong></p>
<p>​    线程安全容器的内部同步，即将对象置入这些容器的操作符合最后一条要求</p>
<ul>
<li>HashTable、synchronizedMap、concurrentMap</li>
<li>Vector、CopyOnWriteArrayList、synchronizedList</li>
<li>BlockingQueue、concurrentLinkedQueue</li>
</ul>
<p><strong>高效不可变对象</strong></p>
<p>​    一个对象在技术上不是不可变得，但是它的状态在发布后不会再更改，即有效不可变对象。</p>
<blockquote>
<p>任何线程都可以在没有额外同步的情况下安全使用一个<strong>安全发布</strong>的高效不可变对象</p>
</blockquote>
<p><strong>可变对象</strong></p>
<p>​    安全发布仅仅保证发布当时的可见性，对于可变性，还需要线程安全或锁</p>
<ul>
<li><p>可变对象必须要安全发布，同时必须要线程安全或者是锁保护的</p>
<blockquote>
<ul>
<li>线程限制：一个线程限制的对象，通过限制在线程中，而被线程独占，且只能被占有它的线程修改</li>
<li>共享只读：在没有额外同步的情况下可以被多个对象并发访问，但是任何线程都不可以修改它，包括可变对象和高效不可变对象</li>
<li>共享线程安全：一个线程安全的对象在内部同步，所以其他线程无须额外同步，就可以通过公共接口访问</li>
<li>被守护的：一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布对象</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="线程安全实现方式："><a href="#线程安全实现方式：" class="headerlink" title="线程安全实现方式："></a>线程安全实现方式：</h2><h3 id="不可变-1"><a href="#不可变-1" class="headerlink" title="不可变"></a>不可变</h3><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>
<p>不可变的<strong>类型</strong>：</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
<p>不可变对象需要满足的<strong>条件</strong></p>
<ul>
<li>对象创建以后状态就不能修改<ul>
<li>将类声明为final</li>
</ul>
</li>
<li>对象所有域都是final类型<ul>
<li>所有域声明为私有</li>
<li>不通过set方法</li>
<li>将所有可变数据声明为final</li>
</ul>
</li>
<li>对象是正确创建的，this引用没有逸出<ul>
<li>通过构造器初始化所有成员</li>
<li>在get方法不直接返回对象本身，而是返回一个clone</li>
</ul>
</li>
</ul>
<p><strong>final关键字</strong>：类、方法、变量</p>
<ul>
<li>修饰类：<ul>
<li>不能被继承</li>
<li>所有成员方法会隐式选择为final</li>
</ul>
</li>
<li>修饰方法<ul>
<li>锁定方法不能被继承修改</li>
</ul>
</li>
<li>修饰变量<ul>
<li>基本数据类型变量</li>
<li>引用类型变量（初始化后，不能指向另一个对象）</li>
</ul>
</li>
</ul>
<p>其他创建不可变对象方法</p>
<ul>
<li>对于集合类型，Collections.unmodifiableXXX：Collection、List、Set、Map…</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//创建final的map</span></span><br><span class="line">        map = Collections.unmodifiableMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//会抛出异常, map无法被修改</span></span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>,map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将返回一个新的map，将数据拷贝过去，然后将所有更改数据转换为了抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Guava：ImmutableXXX：Collection、List、Set、Map…</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableList&lt;Integer&gt; list = ImmutableList.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableSet set = ImmutableSet.copyOf(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer,Integer&gt; map = ImmutableMap.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer,Integer&gt; map2 = ImmutableMap.&lt;Integer,Integer&gt;builder()</span><br><span class="line">            .put(<span class="number">1</span>,<span class="number">2</span>).put(<span class="number">3</span>,<span class="number">4</span>).put(<span class="number">5</span>,<span class="number">6</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        set.add(4);</span></span><br><span class="line"><span class="comment">//        map2.put(1,4);</span></span><br><span class="line">        System.out.println(map2.get(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥同步-1"><a href="#互斥同步-1" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>synchronized 和 ReentrantLock。</p>
<h3 id="非阻塞同步-1"><a href="#非阻塞同步-1" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<h4 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h4><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<h4 id="2-AtomicInteger"><a href="#2-AtomicInteger" class="headerlink" title="2. AtomicInteger"></a>2. AtomicInteger</h4><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p>
<p>以下代码使用了 AtomicInteger 执行了自增的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private AtomicInteger cnt = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">public void add() &#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p>
<p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ABA"><a href="#3-ABA" class="headerlink" title="3. ABA"></a>3. ABA</h4><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p>
<p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h3 id="无同步方案-1"><a href="#无同步方案-1" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><p>访问共享的、可变的数据要求使用同步。一个可以避免同步的方法就是不共享数据，如果数据仅仅在单线程当中访问，则不需要任何同步。当对象封装在一个线程当中，则自动成为线程安全的。</p>
<ul>
<li>Swing将事件分发到线程当中</li>
<li>JDBC从池中分配一个对象给线程。</li>
</ul>
<p><strong>线程封闭方法：</strong></p>
<ul>
<li><p>Ad-hoc线程封闭：程序控制实现，最糟糕。</p>
<ul>
<li>指维护线程限制性的任务全部落在实现上的情况</li>
<li>确保只通过单一线程写入共享的volatile变量，则操作便是共享</li>
</ul>
</li>
<li><p>堆栈封闭：局部变量，无并发问题。</p>
<ul>
<li><p>是线程限制的特例，只能通过本地变量才可以触及对象。本地变量使得对象更容易被限制在线程本地中<strong>，本地变量本身就被限制在执行线程</strong>中，它们存在于执行线程栈。其他线程无法访问这个栈</p>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>例如方法当中的numPairs。在该方法当中，实例化的animals只有一个引用指向它，因此它保存在线程的栈当中，倘若发布了animals或其内部对象的引用，则破坏了限制，并导致了对象逸出</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550587826303.png" alt="1550587826303"></p>
</li>
</ul>
</li>
</ul>
<h4 id="线程本地存储（Thread-Local-Storage）"><a href="#线程本地存储（Thread-Local-Storage）" class="headerlink" title="线程本地存储（Thread Local Storage）"></a>线程本地存储（Thread Local Storage）</h4><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<ul>
<li>ThreadLocal线程封闭：特别好的封闭方法。<ul>
<li>内部维护了一个map，key是线程名称，值是对象</li>
<li>更规范的方式，允许将每个线程与持有数值的对象关联在一起。ThradLocal提供了get和set，为每个使用它的线程维护一份单独的拷贝，所以get总是返回当前执行线程通过set设置的最新值。</li>
</ul>
</li>
</ul>
<blockquote>
<p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被<code>private static</code>修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
</blockquote>
<p>总的来说，<strong>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</strong></p>
<p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>为了理解 ThreadLocal，先看以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal1 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h5><p>它所对应的底层结构图为：</p>
<p><img src="assets/6782674c-1bfe-4879-af39-e9d722a95d39.png" alt="img"></p>
<p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get() 方法类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<h4 id="可重入代码（Reentrant-Code）"><a href="#可重入代码（Reentrant-Code）" class="headerlink" title="可重入代码（Reentrant Code）"></a>可重入代码（Reentrant Code）</h4><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h3 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h3><p>类别</p>
<ul>
<li>ArrayList-&gt;Vector、Stack</li>
<li>HashMap-&gt;HashTable</li>
<li>Collections.synchronizedXXX(List、Set、Map)<ul>
<li>collection的静态工厂创建</li>
</ul>
</li>
</ul>
<p>同步容器也未必线程安全</p>
<p>同步容器虽然保证了同一时刻只有一个线程可以访问，但是线程交替进行访问依然会出现问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">            vector.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//在size=10,i=9时刻,上面的线程将其删除,而此时读取则会出现异常</span></span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size()</span></span>; i++) &#123;</span><br><span class="line">            vector.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>原子性：Atomic包、CAS算法、synchronized、Lock</p>
<p>可见性：synchronized、volatile</p>
<p>有序性：happens-before</p>
<h1 id="待迁移"><a href="#待迁移" class="headerlink" title="待迁移"></a>待迁移</h1><h1 id="发布对象与逸出"><a href="#发布对象与逸出" class="headerlink" title="发布对象与逸出"></a>发布对象与逸出</h1><p>发布对象：发布一个对象指它能够被当前范围以外的代码所使用。发布一个对象，同时将发布该对象所有的非私有域引用的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafePublish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] states = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接获得了私有对象states的引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String[] getStates()&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UnsafePublish unsafePublish = <span class="keyword">new</span> UnsafePublish();</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">        <span class="comment">//发布states对象,无法确定其他线程是否会修改该对象的数据</span></span><br><span class="line">        <span class="comment">//因此在使用这个对象的数据的时候,无法完全确定对象里面的数据</span></span><br><span class="line">        <span class="comment">//即线程不安全的</span></span><br><span class="line">        unsafePublish.getStates()[<span class="number">0</span>] = <span class="string">"d"</span>;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象逸出：一个对象在尚未准备好的时候就发布，使得它被其他线程可见</p>
<p>逸出：</p>
<ul>
<li>this引用在构造期间逸出，即对象在没有通过构造函数构造完毕（执行到了构造函数的某一句）时候逸出。</li>
<li>当对象在构造函数当中创建一个线程，this引用总是被新线程共享.</li>
</ul>
<p>如果要在构造函数中创建线程</p>
<ul>
<li>使用工厂方法或者私有构造函数来完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Escape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> thisCanBeEscape = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Escape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//在这里启动了一个线程,新线程已经可以看到escape类的对象</span></span><br><span class="line">        <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//包含了对封装实例隐含的引用,在对象未构造完全就被发布</span></span><br><span class="line">            </span><br><span class="line">            log.info(<span class="string">"&#123;&#125;"</span>,Escape.<span class="keyword">this</span>.thisCanBeEscape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Escape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="安全发布对象的四种方法"><a href="#安全发布对象的四种方法" class="headerlink" title="安全发布对象的四种方法"></a>安全发布对象的四种方法</h1><ul>
<li>通过静态初始化器初始化对象的引用（JVM内部的同步机制）</li>
<li>将它的引用存储到volatile域或者atomicReference对象中</li>
<li>将它的引用存储到正确创建的对象的final域</li>
<li>或者将它的引用存储到由锁正确保护的域中</li>
</ul>
<h2 id="单例发布对象"><a href="#单例发布对象" class="headerlink" title="单例发布对象"></a>单例发布对象</h2><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><h4 id="线程不安全法"><a href="#线程不安全法" class="headerlink" title="线程不安全法"></a>线程不安全法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时候进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotRecommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="comment">//即其他途径无法创建这个类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//包含对资源的处理等等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingletonExample1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//多线程环境很容易出现问题</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双重检测机制</strong>(线程不安全)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式 --&gt; 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时候进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotRecommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2.ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3. instance = memory 设置instance 指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//JVM和CPU优化，发生了指令重排</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 3. instance = memory 设置instance 指向刚分配的内存</span></span><br><span class="line">    <span class="comment">// 2.ctorInstance() 初始化对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在第三步的时候,instance!=null</span></span><br><span class="line">    <span class="comment">//而此时在指令重排下,另一个线程就会获得一个没有初始化对象的引用,并将其返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123; <span class="comment">//双重检测机制          //B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4.class)&#123; <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4(); <span class="comment">//A - 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程安全法"><a href="#线程安全法" class="headerlink" title="线程安全法"></a><strong>线程安全法</strong></h4><p>不推荐法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="comment">//synchronized限制,而存在性能开销</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonExample3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双重同步锁</strong></p>
<p>基于volatile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式 --&gt; 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时候进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample5</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2.ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3. instance = memory 设置instance 指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象 volatitle+ 双重检测机制 -&gt; 禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonExample5 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingletonExample5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123; <span class="comment">//双重检测机制          //B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample5.class)&#123; <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample5(); <span class="comment">//A - 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>通过静态域实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在装载使用时候进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果构造方法中存在过多的功能,则在加载时会过慢,存在性能问题</span></span><br><span class="line">        <span class="comment">//只进行资源加载而没有实际调用,则会导致资源浪费</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过静态块实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class SingletonExample6 &#123;</span><br><span class="line"></span><br><span class="line">    //私有的构造函数</span><br><span class="line">    private SingletonExample6()&#123;&#125;</span><br><span class="line">	//静态资源是顺序执行的</span><br><span class="line">    //单例对象</span><br><span class="line">    private static SingletonExample6 instance = null;</span><br><span class="line">	//必须写在后面,如果写在前面,则会被上一句赋值为null</span><br><span class="line">    static &#123;</span><br><span class="line">        instance = new SingletonExample6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //静态的工厂方法</span><br><span class="line">    private static SingletonExample6 getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举模式：最安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Recommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//在实际使用的时候才会初始化</span></span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JVM保证这个方法绝对只调用一次</span></span><br><span class="line">        Singleton()&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/youzhidakeai/concurrency" target="_blank" rel="noopener">慕课网《Java并发编程入门与高并发面试 》课程学习</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Java/base/JVM：程序优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/Java/base/JVM：程序优化/" class="post-title-link" itemprop="url">JVM（5）：程序优化</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-03-01 10:47:13" itemprop="dateCreated datePublished" datetime="2019-03-01T10:47:13+08:00">2019-03-01</time>
            </span>
          

          
            <span id="/2019/03/01/Java/base/JVM：程序优化/" class="post-meta-item leancloud_visitors" data-flag-title="JVM（5）：程序优化">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/03/01/Java/base/JVM：程序优化/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/01/Java/base/JVM：程序优化/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Java/base/JVM：类文件与类加载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/Java/base/JVM：类文件与类加载/" class="post-title-link" itemprop="url">JVM（4）：类文件与类加载</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-03-01 10:46:32" itemprop="dateCreated datePublished" datetime="2019-03-01T10:46:32+08:00">2019-03-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-31 10:02:10" itemprop="dateModified" datetime="2019-07-31T10:02:10+08:00">2019-07-31</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/01/Java/base/JVM：类文件与类加载/" class="post-meta-item leancloud_visitors" data-flag-title="JVM（4）：类文件与类加载">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/03/01/Java/base/JVM：类文件与类加载/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/01/Java/base/JVM：类文件与类加载/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>.class文件，类文件，字节码文件。</p>
<p>代码编译的结果从本期机器码转变为字节码，是存储格式发展的一步</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>计算机只能识别0和1，因此程序需要经编译器翻译成二进制格式。</p>
<p>而随着虚拟机的发展，越来越多程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。即将程序编译成二进制本地机器码已经不是唯一的选择</p>
<h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><ul>
<li><p>平台无关系</p>
<ul>
<li>许多虚拟机都可以载入和执行同一种平台无关的字节码，实现“一次编写，到处运行</li>
<li>各种不同平台的虚拟机与所有平台都统一使用的程序存储格式–<strong>字节码</strong>，是构成平台无关系的基石</li>
</ul>
</li>
<li><p>虚拟机的另一种中立特性，即语言无关性，</p>
<ul>
<li>其他语言也可以允许在JVM上。Java虚拟机不和任何语言绑定，只与Class文件这种特定的二进制文件格式关联</li>
<li>Class文件包含JVM指令集和符号表以及若干其他辅助信息。基于安全，要求Class文件使用许多强制性的语法和结构化约束</li>
<li>Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成。字节码所能提供的语言描述能力比Java更强大。</li>
</ul>
</li>
</ul>
<h2 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h2><p>任何一个Class文件都对应着唯一一个类或接口的定义信息，但是类或接口并不一定都得定义在文件里(譬如类或接口也可以通过类加载器直接生成)</p>
<ul>
<li>Class文件是一组以8字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，<strong>中间没有添加任何分割符</strong>，使得Class文件中存储的内容几乎全部是程序允许的必要数据，没有空隙存在</li>
<li>当遇到需要占用8字节以上空间的数据项时，则按照高位在前的方式分割成若干个8位字节进行存储<ul>
<li>高位在前：最高位字节在地址最低位，最低位字节在地址最高处</li>
</ul>
</li>
<li>Class文件格式采用类C语言结构体的伪结构存储数据<ul>
<li>两种数据类型：无符号数，表</li>
<li>无符号数：基本的数据类型，描述数字、索引引用、数量值或按UTF8编码的字符串值。u1、u2、u4、u8分别代表1、2、4、8个字节的无符号数</li>
<li>表：由多个无符号数或其他表构成的符合数据结构，习惯性以_info结尾。用于描述具有层次关系的符合结构的数据。整个Class文件本质上是一张表</li>
</ul>
</li>
</ul>
<p><img src=".%5Cassets%5C1564483003687.png" alt="1564483003687"></p>
<h3 id="魔数与Class文件版本"><a href="#魔数与Class文件版本" class="headerlink" title="魔数与Class文件版本"></a>魔数与Class文件版本</h3><ul>
<li>魔数magic：Class文件的头4个字节。用于确定文件是否为一个能够被虚拟机接受的Class文件<ul>
<li>即用于身份识别，例如jpeg等在文件头都有魔数。基于安全考虑，因为扩展名可以随意改动。</li>
</ul>
</li>
<li>5-8字节：Class文件的版本号，5-6字节：minor_version次版本号，7-8字节：major_version主版本号<ul>
<li>JDK能够向下兼容，但也必须拒绝执行超过其版本号的Class文件</li>
</ul>
</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>跟在主次版本号之后的是常量池入口。</p>
<ul>
<li>常量池可以理解为Class文件中的资源仓库，是Class文件结构中与其他项目关联最多的数据类型，也是占用空间最大的数据项目之一，同时是Class文件中第一个出现表数据项目</li>
<li>常量池中的常量的数量是不固定的，因此在入口需要放置一项u2类型的数据，代表常量池容量计数值：constant_pool_count。其计数从1开始，0表达不引用任何一个常量池项目。</li>
<li>常量池主要存放两大类常量<ul>
<li>字面量。文本字符串、声明为Final的常量值</li>
<li>符号引用。类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li>
</ul>
</li>
</ul>
<p>虚拟机加载Class文件会进行<strong>动态连接，并不会像C一样有连接步骤</strong>，即Class文件不会保存各个方法、字段的内存最终布局信息。因此需要通过运行期转换才能得到真正的内存入口地址。</p>
<p>当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析，翻译到具体的内存地址之中。</p>
<p>常量池中的每个常量都是一个表，在JDK7中具有14中，其共同特点是表开始的第一位是一个u1类型标志位，戴白哦该常量属于那种常量类型。</p>
<p><img src=".%5Cassets%5C1564484128891.png" alt="1564484128891"></p>
<p>其中<strong>CONSTANT_Class_info</strong>类型代表一个类或接口的符号引用。</p>
<ul>
<li>name_index是一个索引值，指向一个CONSTANT_Utf8_info类型常量，代表了这个类或接口的全限定名。<ul>
<li>若值为0x0002即指向常量池中的第二项常量</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>CONSTANT_Utf8_info</strong>结构如下：</p>
<ul>
<li>length说明该UTF-8编码的字符串长度</li>
<li>bytes字节的连续数据是一个UTF-8缩略编码表示的字符串。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
<td>length</td>
</tr>
</tbody></table>
<h4 id="其它常量"><a href="#其它常量" class="headerlink" title="其它常量"></a>其它常量</h4><p>当利用javap进行分析常量池时，其中会出现一些其它的常量，例如<code>I</code>、<code>V</code>、<code>&lt;init&gt;</code>、<code>LineNumberTable</code>等，它们会被字段表、方法表、属性表引用到。用于描述一些不方便用<strong>固定字节</strong>表达的内容，例如方法的返回值是说明，有几个参数，每个参数的类型是说明等。</p>
<p><strong>常量表常量项的结构总表</strong></p>
<p><img src=".%5Cassets%5C1564484562491.png" alt="1564484562491"></p>
<p><img src=".%5Cassets%5C1564484590893.png" alt="1564484590893"></p>
<h3 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h3><p>位于常量池之后，紧接的两个字节代表访问标志<code>access_flags</code>，标志用于标识一些类或者接口层次的访问信息。如该Class是类还是接口，是否为public等。如果是类，是否为final。</p>
<p><img src=".%5Cassets%5C1564484888567.png" alt="1564484888567"></p>
<h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合****"></a>类索引、父类索引与接口索引集合****</h3><p>类索引<code>this_class</code>、父类索引<code>super_class</code>：一个u2类型的数据。接口索引的集合<code>interfaces</code>：一组u2类型的数据。Class文件用于确定类的继承关系</p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p><code>field_info</code>用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>
<p><img src=".%5Cassets%5C1564485105441.png" alt="1564485105441"></p>
<ul>
<li><code>access_flags</code>描述字段的访问级别</li>
<li><code>name_index</code>是对常量池的引用，描述字段的简单名称</li>
<li><code>descriptor_index</code>描述字段和方法的描述符，描述符的作用是描述字段的数据类型、方法的参数列表(数量、类型、顺序)和返回值。</li>
</ul>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>与字段表几乎一致。在描述了方法表之后，方法内部的代码经过编译器编译成字节码指令后，存放在<strong>方法属性表集合</strong>中一个名为<code>Code</code>属性中。</p>
<h3 id="TODO属性表集合"><a href="#TODO属性表集合" class="headerlink" title="TODO属性表集合"></a>TODO属性表集合</h3><p>Class文件、字段表、方法表都可以携带自己的属性表集合，用于描述某些场景专有的信息。</p>
<p>属性表集合不再要求各个属性表具有严格的顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表写入自己定义的属性信息，JVM运行时会忽略其不认识的属性。</p>
<p><img src=".%5Cassets%5C1564485753438.png" alt="1564485753438"></p>
<p><img src="D:%5CBlog%5Csource_posts%5CJava%5Cbase%5Cassets%5C1564485766278.png" alt="1564485766278"></p>
<h1 id="公有设计与私有实现"><a href="#公有设计与私有实现" class="headerlink" title="公有设计与私有实现"></a>公有设计与私有实现</h1><h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>如何将字节码文件加载到虚拟机当中</p>
<p>java.lang.ClassNotFoundExcetpion类加载异常</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>虚拟机如何加载Class文件？Class文件中的信息进入虚拟机后会发生什么变化</p>
<p>类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p>
<p>Java里，类型的加载、连接和初始化过程都是在程序运行期间完成的，虽然使得类加载时稍增加一些性能开销，但是为应用提供高度灵活性。这实现了Java可以动态扩展的语言特性，其天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p>
<ul>
<li>编写一个面向接口的应用程序，可以等到运行时再指定实际的实现类</li>
<li>用户可以通过Java预定义的和自定义的类加载器，让一个本地应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分</li>
</ul>
<p>这里的Class文件：一串二进制字节流</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期：</p>
<p>加载、验证、准备、解析、初始化、使用、卸载</p>
<p><img src=".%5Cassets%5C1564488177169.png" alt="1564488177169"></p>
<p>加载、验证、准备、初始化、卸载的顺序是确定的，依次顺序开始（只是开始，不是进行或者完成，他们中间混合交叉进行）。而解析阶段不一定，它在某些情况下可以在初始化之后再开始，以支持动态绑定</p>
<p><strong>立即对类进行初始化的情况</strong></p>
<p>有且只有：这5种场景中的行为称为对一个类进行主动引用，除此外，所有引用类的方式都不会触发初始化，称为被动引用。</p>
<ul>
<li>遇到new、getstatic、putstatic、invokestatic的字节码指令，如果类没有初始化，则需要先触发其初始化</li>
<li>遇到java.lang.reflect包的方法对类进行反射调用时</li>
<li>当初始化一个类，如果其父类还没有进行初始化，则先父类初始化（如果是接口，则不要求父类接口全部完成初始化，只有真正使用到父类接口时才会初始化）</li>
<li>当虚拟机启动时，用户需要指定一个主类，先初始化主类</li>
<li>当使用JDK7的动态语言支持时，例如一个Java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化则要先进行初始化</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流<ul>
<li>读取途径<ul>
<li>从ZIP包读取，成为日后JAR格式的基础</li>
<li>从网络中获取，如applet</li>
<li>运行时计算生成，动态代理技术，java.lang.reflect.Proxy，为特定接口生成形式为<code>*$Proxy</code>的代理类的二进制字节流</li>
<li>由其他文件生成，如JSP，由JSP文件生成Class类</li>
<li>从数据库中读取等</li>
</ul>
</li>
<li>开发人员可控性最强（非数组类）<ul>
<li>可以使用系统提供的引导类加载器完成，也可以由用户自定义的类加载器完成，重写一个loadClass()方法</li>
</ul>
</li>
<li>数组类：由JVM直接创建，不由类加载器创建。但是内部的元素由类加载器创建。一个数组类C的创建过程：<ul>
<li>如果数组的组件（即数组去掉一个维度的类型）是引用类型，则递归加载这个组件类型，数组C将在加载该组件类型的类加载器的类名空间上被标识</li>
<li>如果不是引用类型，Java虚拟机将在数组C标记为与引导类加载器关联</li>
<li>数组类的可见性与它的组件类型可见性一致，如果组件类型不是引用类型，那么数组类的可见性默认为public</li>
</ul>
</li>
</ul>
</li>
<li>加载结束后，虚拟机外部的二进制字节流就按照虚拟机要求的格式存储在方法区中。之后将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存（堆）中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>连接阶段的第一步，为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。严重阶段的工作量在虚拟机的类加载子系统中占了相当大的一部分。</p>
<p><strong><em>文件格式验证</em></strong></p>
<p>验证字节流是否符合Class文件格式的规范，并能够被当前JVM处理</p>
<ul>
<li>是否以魔数开头</li>
<li>主次版本号是否在当前虚拟机处理范围内</li>
<li>常量池的常量是否有不被支持的常量类型</li>
<li>指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量</li>
<li>文件中各个部分已经文件本身是否有被删除或附加的其他信息。<strong>等等</strong></li>
</ul>
<p>只有该阶段直接操作字节流，并且只有通过文件格式验证后，字节流才会进入内存的方法区。其他三个验证阶段都是基于方法区的存储结构进行的。</p>
<p><strong><em>元数据验证</em></strong></p>
<p>对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范</p>
<ul>
<li>这个类是否有父类</li>
<li>这个类的父类是否继承了不允许被继承的类</li>
<li>如果这个类不是抽象类，是否实现了父类或接口中要求的所有方法</li>
<li>类中的字段、方法是否与父类矛盾</li>
</ul>
<p><strong><em>字节码验证</em></strong></p>
<p>目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。</p>
<p>对类的方法体进行校验分析，保证方法在运行时不会做出危害虚拟机安全的事件</p>
<ul>
<li>保证方法体中的类型转换时有效，不会出现对象赋值给与它无关的数据类型</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
</ul>
<p><strong><em>符号引用验证</em></strong></p>
<p>发生在虚拟机将符号引用转化为直接引用的时候，这个转化在解析阶段发生</p>
<p>对类自身以外的信息进行匹配性校验。</p>
<ul>
<li>通过字符串描述的限定名是否能找到对应的类</li>
<li>符号引用中的类、字段、方法的访问性是否可以被当前类访问</li>
</ul>
<p>确保解析动作能够正常执行</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为类变量（static的）分配内存并设置类遍历初始值（0值）的阶段，这些变量使用的内存都将在<strong>方法区</strong>中进行分配。而实例变量将在对象实例化时随着对象一起分配在Java堆中。</p>
<p>如果类变量是final的，则初始化的时候即被赋值为final的那个值，如果不是的话，则会在初始化的时候进行静态赋值，即准备阶段后值依然为0。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。以字面量形式定义在Class文件中。</li>
<li>直接引用：直接指向目标的指针、相对偏移量或一个能够间接定位到目标的句柄。是与虚拟机实现的内存布局相关的。</li>
<li>符号引用可能不存在于内存当中，但直接引用一定存在内存中</li>
</ul>
<p>对于同一个 符号引用进行多次解析是常见的，除invokedynamic指令外，虚拟机实现对第一次解析的结果进行缓存（<strong>缓存</strong>：在运行时常量池中记录直接引用，并将常量标识为已解析状态），从而避免解析重复进行。</p>
<p>虚拟机需要保证在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功。如果第一次失败了，那么其他指令对这个符号的解析请求也应该收到同样的异常</p>
<p>invokedynamic指令用于动态语言支持，只有当实际运行到该节点，才开始解析。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号</p>
<p><strong><em>类或接口解析</em></strong></p>
<p>假设当前代码所处的类为D，要将一个从未解析过的符号引用N解析为一个类或接口C的直接引用</p>
<ul>
<li>如果C不是一个数组类型， 虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C，加载过程中，会涉及验证等一系列相关类加载动作，如果加载过程中出现了任何异常则解析过程就宣告失败</li>
<li>如果C是一个数组类型， 并且数组的元素类型为对象，则会按照之前的方式夹杂数组元素类型。如果是Integer则会由虚拟机生成一个代表此数组维度和元素的数组对象</li>
<li>如果上面步骤没有任何异常，则C在虚拟机中已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。若不具备则抛出<code>Java.lang.IllegalAccessError</code></li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化真正开始执行类中定义的Java程序代码。执行类构造器&lt;client&gt;()方法的过程</li>
<li>&lt;client&gt;方法由编译器收集类中所有类变量的赋值动作与静态语句块的语句合并而成，顺序由出现顺序而定。</li>
<li>&lt;client&gt;方法与类构造函数不同，不需要显式调用父类构造器，虚拟机保证在此前，父类的&lt;client&gt;方法已经执行完毕</li>
<li>虚拟机会保证一个类的&lt;client&gt;方法会在多线程环境正确被加锁、同步。多个线程同时初始化一个类，只有一个线程去执行该方法，其他线程阻塞</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>将类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”的动作放到虚拟机外部实现，以便让程序自己决定如何获取所需要的类。实现该动作的代码模块为类加载器。</p>
<p>类加载器（class loader）用来加载Java类到Java虚拟机中。一般来说，Java虚拟机使用Java类的方式如下：Java 源程序（.java 文件）在经过Java编译器编译之后就被转换成Java字节代码（.class 文件）。类加载器负责读取Java字节代码，并转换成<code>java.lang.Class</code>类的一个实例。每个这样的实例用来表示一个Java类。通过此实例的<code>newInstance()</code>方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><ul>
<li>基本职责：根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 <code>java.lang.Class</code>类的一个实例。还负责加载 Java 应用所需的资源</li>
<li>对于任意一个类，都需要由加载它的类加载器与这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器都有一个独立的类名称空间</li>
<li>判断两个类是否相等，只有两个类是由同一个类加载器加载的前提下才有意义</li>
<li>相等：equals等方法返回的结果，如果没有考虑类加载器的影响，某些情况下可能或产生具有迷惑性的结果。<ul>
<li>对于同一个Class，我们使用系统应用程序类加载器与自定义类加载器加载，instanceof会返回false。它们是一个类文件，但是是两个独立的类。</li>
</ul>
</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从Java虚拟机角度讲，只存在两种不同的类加载器</p>
<ul>
<li>启动类加载器，使用C++实现，是虚拟机自身一部分</li>
<li>所有其他的类加载器，Java实现，独立于虚拟机外部，并全部继承自抽象类java.lang.ClassLoader</li>
</ul>
<p>从程序员角度讲</p>
<ul>
<li>启动类加载器。负责将类库(<java_home>\lib下的jar包)加载到虚拟机内存当中，该加载器无法被Java程序直接引用。用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可</java_home></li>
<li>扩展类加载器。负责加载&lt;JAVA_HOME&gt;\lib\ext目录，或者java.ext.dirs系统变量指定的路径中所有类库，开发者可以直接使用扩展类加载器</li>
<li>应用程序（系统）类加载器。负责加载用户类路径上指定的路径，可以直接使用这个类加载器，并且是程序中的默认加载器</li>
</ul>
<p><img src="assets%5C1564537447891.png" alt="1564537447891"></p>
<p>要求除了顶层的启动类加载器，其余的类加载器都应当有自己的父类加载器。父子关系一般不会以继承关系实现，而都是以组合关系来复用代码。</p>
<p><strong><em>工作过程</em></strong>：</p>
<ul>
<li>如果一个类加载器收到了类加载的请求，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此既</li>
<li>所有的加载请求都会传送到顶层的启动类加载器，只有父类无法完成这个加载请求，子加载器才会尝试自己去加载</li>
</ul>
<p><strong><em>优势</em></strong>：</p>
<ul>
<li>Java类随着它的类加载器一起具备了一种带有优先级的层次关系。如Object类，任何一个类加载器加载这个类，都委派给了启动类加载器，因此他们都是同一个类。而如果让各个类去自行加载，那么系统会出现多个不同的object类。</li>
<li>其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</li>
</ul>
<p>实现：</p>
<ul>
<li>先检查是否已经被加载过</li>
<li>如果没有，则调用父类的loadClass</li>
<li>若父加载器为空，则默认使用启动类加载器作为父加载器</li>
<li>如果父加载失败，抛出异常，则调用字节的findClass方法加载</li>
</ul>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p><strong><em>模型缺陷</em></strong></p>
<p>双亲委派模型是为了解决各个类加载器的基础类的统一问题，基础类之所以基础是因为它们总是作为被用户代码调用的API，但是如果基础类又要调回用户的代码该如何解决</p>
<p>例如JNDI服务，它的代码由启动类加载器加载，但JNDI的目的是对资源进行集中管理和查找，因此需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者(<strong>SPI</strong>)的代码，但是启动类加载器不可能认识这些。</p>
<p><strong>解决</strong>：引入了<strong>线程上下文类加载器</strong>，可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoaser()</code>方法进行设置，如果创建线程时还未设置，则会从父线程中继承一个，如果应用程序全局没有设置，则该加载器默认就是应用程序类加载器</p>
<p>JNDI使用线程上下文类加载器加载需要的SPI代码，即类加载器请求子类加载器去完成类加载行为。例如JDBC等都是这样实现的。</p>
<p><strong><em>用户对程序动态性的追求而导致</em></strong></p>
<p>例如<strong>代码热替换</strong>、<strong>模块热部署</strong>即类似计算机一样可以更新外设。</p>
<p>OSGI模块化热部署的关键是在它自定义的类加载器机制的实现，每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时就将Bundle连同类加载器一起换掉以实现代码的热替换。</p>
<p>在OSGI中类加载器不再是树状结构，而是发展为网状结构，当收到类加载请求时</p>
<ul>
<li>将以java.*开头的类委派给父类加载器加载</li>
<li>否则将委派列表名单内的类委派给父类加载器加载</li>
<li>否则将Import列表内的类委派给Export这个类的Bundle的类加载器加载</li>
<li>否则查找当前Bundle的ClassPath，使用自己的类加载器加载</li>
<li>否则查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载</li>
<li>否则查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载</li>
<li>否则类查找失败</li>
</ul>
<h2 id="网络类加载器"><a href="#网络类加载器" class="headerlink" title="网络类加载器"></a>网络类加载器</h2><p>下面将通过一个网络类加载器来说明如何通过类加载器来实现组件的动态更新。即基本的场景是：Java 字节代码（.class）文件存放在服务器上，客户端通过网络的方式获取字节代码并执行。当有版本更新的时候，只需要替换掉服务器上保存的文件即可。通过类加载器可以比较简单的实现这种需求。</p>
<p>类 <code>NetworkClassLoader</code>负责通过网络下载 Java 类字节代码并定义出 Java 类。它的实现与 <code>FileSystemClassLoader</code>类似。在通过 <code>NetworkClassLoader</code>加载了某个版本的类之后，一般有两种做法来使用它。第一种做法是使用 Java 反射 API。另外一种做法是使用接口。需要注意的是，并不能直接在客户端代码中引用从服务器上下载的类，因为客户端代码的类加载器找不到这些类。使用 Java 反射 API 可以直接调用 Java 类的方法。而使用接口的做法则是把接口的类放在客户端中，从服务器上加载实现此接口的不同版本的类。在客户端通过相同的接口来使用这些实现类。网络类加载器的具体代码见 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#artdownload" target="_blank" rel="noopener">下载</a>。</p>
<p>在介绍完如何开发自己的类加载器之后，下面说明类加载器和 Web 容器的关系。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Java/base/JVM：调优/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/Java/base/JVM：调优/" class="post-title-link" itemprop="url">JVM：调优</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-03-01 10:45:57" itemprop="dateCreated datePublished" datetime="2019-03-01T10:45:57+08:00">2019-03-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-30 18:20:34" itemprop="dateModified" datetime="2019-07-30T18:20:34+08:00">2019-07-30</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/01/Java/base/JVM：调优/" class="post-meta-item leancloud_visitors" data-flag-title="JVM：调优">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/03/01/Java/base/JVM：调优/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/01/Java/base/JVM：调优/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><p>给一个系统定位问题时，知识、经验是关键基础，数据是一句，工具是运用只是处理数据的手段。数据包括：运行日志、异常堆栈、GC日志、线程快照(threaddump、javacore文件)、堆存储快照(heapdump、hprof文件)等。</p>
<h2 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h2><p>Sun JDK监控和故障处理工具</p>
<ul>
<li>jps：JVM Proces Status Tool，显示指定系统内所有的HotSpot虚拟机进程</li>
<li>jstat：JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据</li>
<li>jinfo：Configuration Info for Java</li>
<li>jmap：Memory Map for Java，显示虚拟机配置信息</li>
<li>jhat：JVM Heap Dump Browser，生成虚拟机的内存转储快照(heapdump文件)</li>
<li>jstack：Stack Trace for Java，显示虚拟机的线程快照。</li>
</ul>
<p>JDK的很多小工具命名参考了UNIX命令的命名，例如jps，类似与ps</p>
<h3 id="jps-虚拟机进程状况工具"><a href="#jps-虚拟机进程状况工具" class="headerlink" title="jps 虚拟机进程状况工具"></a>jps 虚拟机进程状况工具</h3><p>jps可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（main函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier，LVMID）</p>
<p>LVMID与操作系统的进程ID是一致的，使用ps命令也可以查询到虚拟机进程的LVMID，但是如果同时启动了多个虚拟机进程，无法根据进程名称定位时，只能依赖jps显示主类的功能才能区分了。</p>
<p>jps通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。jps的其他常用选项如下：</p>
<ul>
<li>-q。只输出LVMID，省略主类的名称</li>
<li>-m。输出虚拟机进程启动时传递给主类main()函数的参数</li>
<li>-l。输出主类的全名，如果进程执行的时Jar包，输出Jar路径</li>
<li>-v。输出虚拟机进程启动时JVM参数</li>
</ul>
<h3 id="jstat-虚拟机统计信息监视工具"><a href="#jstat-虚拟机统计信息监视工具" class="headerlink" title="jstat 虚拟机统计信息监视工具"></a>jstat 虚拟机统计信息监视工具</h3><p>用于监视虚拟机各种运行状态信息的命令行工具，可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p>在只提供纯文本控制台环境的服务器上，是运行期定位虚拟机性能问题的首选工具</p>
<p><strong>命令格式</strong>：<code>jstat [option vmid [interval [s|ms] [count]] ]</code></p>
<ul>
<li>option。是一个选项代表用户希望查询的虚拟机信息，主要分为三类：类装载、垃圾收集、运行期编译状况。<ul>
<li>-class。监视类装载、卸载数量、总空间以及类装载所耗费的时间</li>
<li>-gc。监视Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</li>
<li>-gccapacity。监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</li>
<li>-gcutil。监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</li>
<li>-gccause。与-gcutil相同，但额外输出上一次GC产生的原因</li>
<li>-gcnew。监视新生代GC状况</li>
<li>-gcnewcapacity。监视内容与gcnew一致，输出主要关注使用到的最大、最小空间</li>
<li>-gcold。监视老年代GC状况</li>
<li>-gcoldcapacity。监视内容与gcold一致，输出主要关注使用到的最大、最小空间</li>
<li>-gcpermcapacity。输出永久代使用到的最大、最小空间</li>
<li>-compiler。输出JIT编译器编译过的方法、耗时等信息</li>
<li>-printcompilation。输出已经被JIT编译的方法</li>
<li>等等</li>
</ul>
</li>
<li>vmid：对于本地虚拟机进程，则vmid与LVMID是一致的，如果是远程虚拟机进程，则格式应为：<code>[protocol:][//]lvmid[@hostname[:port]/servername]</code></li>
<li>interval和count。代表查询间隔和次数。如果省略这两个参数，则说明只查询一次。</li>
</ul>
<p><strong>示例</strong>：每250ms查询一次进程2764垃圾收集状况，一共查询20此，则命令为：<code>jstat -gc 2764 250 20</code></p>
<h3 id="jinfo-java配置信息工具"><a href="#jinfo-java配置信息工具" class="headerlink" title="jinfo java配置信息工具"></a>jinfo java配置信息工具</h3><p>jinfo的作用是实时查看和调整虚拟机各项参数。</p>
<p><strong>命令格式</strong>：<code>jinfo [option] pid</code></p>
<p><strong><em>option选项</em></strong></p>
<ul>
<li>-sysprops。将虚拟机进程的System.getProperties内容打印出来。</li>
<li>-flag 。<ul>
<li>-flag [name]查询未被显式指定的参数的系统默认值。或使用<code>Java -XX:PrintFlagsFinal</code>。而<code>jps -v</code>只可以查看虚拟机启动时显式指定的参数列表。</li>
<li>可以在运行期修改参数，<code>-flag [+|-] name</code>或<code>-flag name = value</code>修改一部分运行期可写的虚拟机参数值</li>
</ul>
</li>
</ul>
<h3 id="jmap-Java内存映像工具"><a href="#jmap-Java内存映像工具" class="headerlink" title="jmap Java内存映像工具"></a>jmap Java内存映像工具</h3><ul>
<li>用于生成堆存储快照，一般称为heapdump或dump文件。</li>
<li>可以查询finalize执行队列、Java堆和永久代的详细信息，例如空间使用率，当前使用的收集器等。</li>
</ul>
<p>对于dump文件，也可以采用<code>-XX:+HeapDumpOnOutOfMemoryError</code>参数，让虚拟机在OOM异常出血后自动生成dump文件。<code>-XX:+HeapDumpOnCtrlBreak</code>参数则可以使用Ctrl+Break键让虚拟机生成dump文件。</p>
<p><strong>命令格式</strong>：<code>jmap [option] vmid</code></p>
<p><strong><em>option选项</em></strong></p>
<ul>
<li>-dump。格式为<code>-dump:[live,]format=b, file=&lt;filename&gt;</code>其中live子参数说明是否只dump出存活的对象</li>
<li>-finalizerinfo。显示在F-Queue中等待Finalizer线程执行finalize方法的对象</li>
<li>-heap。显示Java堆详细信息，如使用哪种回收器、参数配置、粉黛状况等</li>
<li>-histo。显示堆中对象统计信息，包括类、实例数量、合计容量</li>
<li>-permstat。以ClassLoader为统计口径显示永久代内存状态</li>
<li>-F。当虚拟机进程对-dump无响应时，强制生成dump快照</li>
</ul>
<h3 id="jhat-虚拟机堆转存储快照分析工具"><a href="#jhat-虚拟机堆转存储快照分析工具" class="headerlink" title="jhat 虚拟机堆转存储快照分析工具"></a>jhat 虚拟机堆转存储快照分析工具</h3><p>jhat与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。</p>
<ul>
<li>一般不会在部署应用程序的服务器上直接分析dump文件，即使可以也会尽量将dump文件复制到其他机器上分析，英文分析工作耗时且耗费硬件资源，而在其他机器上就不需要受到命令行限制</li>
<li>jhat的分析功能相对简陋</li>
</ul>
<h3 id="jstack-Java堆栈跟踪工具"><a href="#jstack-Java堆栈跟踪工具" class="headerlink" title="jstack Java堆栈跟踪工具"></a>jstack Java堆栈跟踪工具</h3><p>用于生成虚拟机当前时刻的线程快照，一般为threaddump或者Javacore文件。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</p>
<p>线程快照的主要目的时定位线程出现长时间停顿的原因，如线程间思索、死锁循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿时就可以通过jstack查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情或者在等待什么资源。</p>
<p>命令格式<code>jstack [option] vmid</code></p>
<ul>
<li>-F。当正常输出的请求不被响应时，强制输出线程堆栈</li>
<li>-l。除堆栈外，显示关于锁的附加信息</li>
<li>-m。如果调用到本地方法的话，可以显示C/C++的堆栈</li>
</ul>
<h3 id="hsdis-jit生成代码反汇编"><a href="#hsdis-jit生成代码反汇编" class="headerlink" title="hsdis jit生成代码反汇编"></a>hsdis jit生成代码反汇编</h3><p>在Java虚拟机规范中，详细描述了虚拟机指令集中每条指令的执行过程、执行前后对操作数栈、局部变量表的影响等细节，这些细节与早期的JVM高度吻合。</p>
<p>但是随着虚拟机的发展导致真正的细节实现方式已经渐渐与虚拟机规范描述的内容产生了越来越大的差距，其逐渐成为了概念模型，即实现只能保证规范描述等效。</p>
<p>基于以上原因，我们分析程序的执行语义问题(虚拟机做了什么)时，在字节码上分析完全可行，但分析程序的执行行为问题(虚拟机是怎样做的、性能如何)时，字节码层面分析就没有什么意义，需要通过其他方式解决。</p>
<p>HSDIS将HotSpot的-XX:+PrintAssembly指令调用它来把动态生成的本地代码还原成为汇编代码输出，并生成大量的注释。</p>
<h2 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h2><h3 id="Jconsole"><a href="#Jconsole" class="headerlink" title="Jconsole"></a>Jconsole</h3><p>Java监视与管理控制台。</p>
<h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><h1 id="JVM分析"><a href="#JVM分析" class="headerlink" title="JVM分析"></a>JVM分析</h1><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p><strong><em>定义</em></strong></p>
<p>内存泄漏就是存在一些被分配的对象，有两个特点</p>
<ul>
<li>在可达性分析时可达，即无法被GC回收</li>
<li>这些对象是无用的，即程序以后不会再使用这些对象。但占有着内存。</li>
</ul>
<p><strong><em>原因</em></strong></p>
<ul>
<li>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景</li>
</ul>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul>
<li>MemoryAnalyzer。Java堆转储文件分析工具，帮助发现内存漏洞和减少内存消耗</li>
<li>EclipseMAT。开源Java内存分析软件，查找内存泄漏，能容易找到大块内存并验证谁在一直占用它</li>
<li>JProbe。分析Java的内存泄漏</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong><em>集合类泄漏</em></strong></p>
<p>像HashMap、Vector等的使用最容易出现内存泄露，这些<strong>静态变量</strong>的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。</p>
<p>如果是非静态，那么在方法执行结束时，由于vector=null释放，因此内部的对象也释放了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="keyword">null</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</p>
<p><strong>当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	Set&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line">	Person p1 = <span class="keyword">new</span> Person(<span class="string">"唐僧"</span>,<span class="string">"pwd1"</span>,<span class="number">25</span>);</span><br><span class="line">	Person p2 = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>,<span class="string">"pwd2"</span>,<span class="number">26</span>);</span><br><span class="line">	Person p3 = <span class="keyword">new</span> Person(<span class="string">"猪八戒"</span>,<span class="string">"pwd3"</span>,<span class="number">27</span>);</span><br><span class="line">	set.add(p1);</span><br><span class="line">	set.add(p2);</span><br><span class="line">	set.add(p3);</span><br><span class="line">	System.out.println(<span class="string">"总共有:"</span>+set.size()+<span class="string">" 个元素!"</span>); <span class="comment">//结果：总共有:3 个元素!</span></span><br><span class="line">	p3.setAge(<span class="number">2</span>); <span class="comment">//修改p3的年龄,此时p3元素对应的hashcode值发生改变</span></span><br><span class="line"></span><br><span class="line">	set.remove(p3); <span class="comment">//此时remove不掉，造成内存泄漏</span></span><br><span class="line"></span><br><span class="line">	set.add(p3); <span class="comment">//重新添加，居然添加成功</span></span><br><span class="line">	System.out.println(<span class="string">"总共有:"</span>+set.size()+<span class="string">" 个元素!"</span>); <span class="comment">//结果：总共有:4 个元素!</span></span><br><span class="line">	<span class="keyword">for</span> (Person person : set)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(person);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>单例/静态变量造成的内存泄漏</em></strong></p>
<p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">		B.getInstance().setA(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B类采用单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> A a;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> B instance=<span class="keyword">new</span> B();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> B <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.a=a;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//getter...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>匿名内部类/非静态内部类</em></strong></p>
<p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：<br>public void registerMsg(Object b); </p>
<p>这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。</p>
<p><strong><em>资源未关闭造成的内存泄漏</em></strong></p>
<p>如各种连接，包括数据库连接等。</p>
<p>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的，<strong>因为这些连接是独立于JVM的</strong>。</p>
<p>对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，<strong>而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL</strong>。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接，就能避免此类泄漏。</p>
<p><strong><em>监听器</em></strong></p>
<p>在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p>
<p><strong><em>ThreadLocal内存泄漏</em></strong></p>
<p>实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p>
<p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p>
<p>ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。</p>
<h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p>如何判断JVM线程死锁。</p>
<ul>
<li>在间隔两分钟后再次收集一次thread dump，如果输出相同，仍然是大量thread都在等待给同一个地址上锁，则是死锁 </li>
</ul>
<p>如果使用VisualVM dump线程信息出来，会有哪些信息</p>
<h3 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h3><h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><h1 id="OOM分析"><a href="#OOM分析" class="headerlink" title="OOM分析"></a>OOM分析</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/2fdee831ed03" target="_blank" rel="noopener">Java内存溢出(OOM)异常完全指南</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Java/base/JVM：内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/Java/base/JVM：内存管理/" class="post-title-link" itemprop="url">JVM：内存管理</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-03-01 10:45:42" itemprop="dateCreated datePublished" datetime="2019-03-01T10:45:42+08:00">2019-03-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-30 21:18:01" itemprop="dateModified" datetime="2019-07-30T21:18:01+08:00">2019-07-30</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/01/Java/base/JVM：内存管理/" class="post-meta-item leancloud_visitors" data-flag-title="JVM：内存管理">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/03/01/Java/base/JVM：内存管理/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/01/Java/base/JVM：内存管理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="java内存区域与内存溢出异常"><a href="#java内存区域与内存溢出异常" class="headerlink" title="java内存区域与内存溢出异常"></a>java内存区域与内存溢出异常</h1><p>Java将内存扩展的权利交给了jvm，虚拟机自动内存管理机制的帮助下，不再需要为每个new操作写配对的delete/free代码，不容易出现内存泄露与内存溢出问题。如果出现问题，如果不了解JVM如何使用内存，那么排查错误将会成为一项异常艰难的工作。</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><ul>
<li>Java虚拟机在执行Java程序的过程中，会将它管理的内存划分为若干个不同的数据区域</li>
<li>区域有各自的用途、创建时间、销毁时间。</li>
<li>有的区域随着虚拟机进程的启动而存在，有的区域随着用户线程的启动和结束而建立和销毁</li>
</ul>
<p>区域包括</p>
<p><img src="assets%5C1564413541987.png" alt="1564413541987"></p>
<blockquote>
<p>对于JVM的内存区域，其实远远不止堆内存、栈内存，这种方式的流行只是说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。</p>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li>各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、class文件、即时编译器编译后的代码等数据</li>
<li>垃圾回收器也会对这部分进行回收，如常量池的清理和类型的卸载</li>
<li>Non-Heap、永久代</li>
<li>当无法满足内存分配需求时，OutOfMemoryError异常</li>
</ul>
<p><strong><em>运行时常量池</em></strong>（方法区的一部分）</p>
<ul>
<li>存放编译期生成的各种字面量和符号引用</li>
<li>相对于Class文件常量池的另一个重要特征时具备动态性，Java并不要求常量一定在编译期才能产生，即并非Class文件中常量池的内容才能进入该区域。运行期间也可以将新的常量放入池中，例如String的intern()</li>
<li>当无法满足内存分配需求时，OutOfMemoryError异常</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>虚拟机管理的内存中最大的一块，在虚拟机启动时创建，所有线程共享<ul>
<li>可以处于物理上不连续的内存空间中，只要逻辑上时连续的即可。</li>
</ul>
</li>
<li>存放对象实例，几乎所有对象实例都在这里分配内存<ul>
<li>随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术会导致一部分对象不会分配到堆上。</li>
</ul>
</li>
<li>垃圾收集器管理的主要区域，也称为GC堆<ul>
<li>从内存回收的角度，使用分代收集算法</li>
<li>堆可分为新生代和老年代</li>
<li>Eden空间、From Survivor空间、To Survivor空间</li>
<li>从内存分配的角度，划分出多个线程私有的分配缓冲区TLAB</li>
</ul>
</li>
<li>当堆无法再扩展OutOfMemoryError</li>
</ul>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ul>
<li><p>线程私有，生命周期与线程相同</p>
</li>
<li><p>描述Java方法执行的内存模型（栈内存）</p>
<ul>
<li>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法从调用至完成则对应一个栈帧在虚拟机栈入栈到出栈</li>
<li>方法体内的局部变量表（其中包括基础数据类型，例如boolean等、对象的引用）<ul>
<li>64位的long和double会占据两个局部变量空间。</li>
<li>局部变量表需要的内存空间在编译期间完成分配，当进入一个方法时这个需要分配多大的局部变量空间时完全确定的，运行期间不会改变局部变量表的大小</li>
</ul>
</li>
</ul>
</li>
<li><p>线程请求栈深度大于虚拟机允许深度，StackOverflowError异常</p>
</li>
<li><p>大部分虚拟机允许动态扩展，如果扩展无法申请到足够内存，则OutOfMemoryError</p>
</li>
</ul>
<p>  <img src="assets/ff5b89ac-798e-4fbc-b0ce-da2fc2358570.jpg" alt="img"></p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>其功能与虚拟机栈发挥作用非常类似，虚拟机使用到的Native方法服务，不一定是Java实现的。</p>
<p>本地方法栈会抛出StackOverflawError和OutOfMemoryError异常</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间（线程私有），可以看作时当前线程所执行的字节码的行号指示器。如果共享，则无法准确的执行当前线程需要执行的语句。</p>
<p>在JVM的概念模型当中（实际虚拟机可能以更高效的方式实现），字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。例如分支、循环、跳转、异常处理、线程恢复等基本功能</p>
<p>当执行Java方法时，其记录的时正在执行的虚拟机字节码指向的地址。如果执行本地方法时，值为undefined</p>
<p>CPU通过时分复用实现多线程，对确定时刻，一个CPU只会执行一条线程中的指令。每个线程都有一个独立的程序计数器。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul>
<li>不是虚拟机运行时数据区的一部分，也不是JVM定义的内存区域，但是可能导致OutOfMemoryError</li>
<li>NIO，基于通道与缓冲区的IO方式，使用Native函数库直接分配堆外内存，通过一个堆中的对象引用<ul>
<li>避免了在Java堆与native堆中来回复制</li>
</ul>
</li>
<li>不受Java堆大小限制，受本机总内存等限制</li>
</ul>
<h2 id="Hotspot虚拟机对象揭秘"><a href="#Hotspot虚拟机对象揭秘" class="headerlink" title="Hotspot虚拟机对象揭秘"></a>Hotspot虚拟机对象揭秘</h2><p>虚拟机内存中的数据如何创建、如何布局、如何访问等问题</p>
<p>揭秘Hotspot虚拟机在Java堆中对象分配、布局和访问全过程</p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>对于普通的Java对象，不包括数组和Class对象</p>
<ul>
<li>虚拟机遇到一条new指令，检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查一个符号引用代表的类是否已经被加载、解析和初始化过<ul>
<li>如果没有，则必须先执行相应的类加载过程</li>
</ul>
</li>
<li>为新生对象分配内存，所需内存在类加载完成后便可完全确定。将一块大小确定的内存从Java堆当中划分出来<ul>
<li>划分内存的方法</li>
<li>指针碰撞：Java堆中<strong>内存绝对规整</strong>（所有已用在一边，空闲在另一边），中间一个指针作为分界点的知识点，即将指针向空闲移动一段距离</li>
<li>空闲列表：<strong>内存不规整</strong>，维护一个记录可用内存的列表，分配一个足够大的空间</li>
<li>内存是否规整<strong>由垃圾收集器是否带有压缩整理的功能决定</strong>，例如Serial、ParNew等带Compact则采用指针碰撞，而CMS这种基于Mark-Sweep的通常采用空闲列表。</li>
</ul>
</li>
<li>分配内存空间可能存在线程安全问题，对象创建在虚拟机中是非常频繁的行为。<ul>
<li>对分配内存空间的动作做同步处理，虚拟机采用CAS搭配失败重试的方法</li>
<li>把内存分配的动作按线程划分在不同的空间中进行。设定-XX:+/-UseTLAB以开启<ul>
<li>每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），线程在各自的TLAB上分配内存。当TLAB用完，才需要同步锁定。</li>
</ul>
</li>
</ul>
</li>
<li>虚拟机将分配到的内存空间初始化为0（不包括对象头），此时读取实例字段值为0。如果使用TLAB，则可以提前到TLAB分配时进行。</li>
<li>对对象进行必要的设置，<strong>存放在对象头中</strong>。如对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。根据JVM当前运行状态不同，是否启用偏向锁等。</li>
<li>从虚拟机视角看，对象已经产生。从程序视角看，对象刚刚开始，即对象进行init，进行构造</li>
</ul>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象内存中存储的布局分为三部分</p>
<ul>
<li>对象头Header<ul>
<li>Mark Word存储对象自身的运行时数据。哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。在32位、64位虚拟机长度为32bit、64bit<ul>
<li>Mark Word时一个非固定的数据结构，以便在极小的空间内存储尽量多的信息。会根据对象的状态复用自己的存储空间。</li>
<li><img src="D:%5CBlog%5Csource_posts%5CJava%5Cbase%5Cassets%5C1564449805149.png" alt="1564449805149"></li>
</ul>
</li>
<li>类型指针。对象指向它类元数据的指针，JVM通过这个指针来确定这个对象是那个类的实例<ul>
<li>并不是所有JVM实现都必须在对象数据上保留类型指针，即查找对象的元数据不一定经过对象本身</li>
<li>如果是数组，则记录数组长度的数据</li>
</ul>
</li>
</ul>
</li>
<li>实例数据Instance Data<ul>
<li>对象真正存储的有效信息</li>
<li>存储顺序受虚拟机分配策略参数与字段在Java源码中定义顺序的影响<ul>
<li>longs/double、ints、shorts/chars、bytes/booleans、oops。相同宽度的字段被分配到一起</li>
<li>父类变量会出现在子类前（CompactFields为true（默认），子类中较窄的遍历也可能插入到父类变量的空隙中）</li>
</ul>
</li>
</ul>
</li>
<li>对齐填充Padding<ul>
<li>并不必然存在，起到占位符作用</li>
<li>Hotspot自动内存管理相同要求对象的其实对这必须为8字节的整数倍</li>
</ul>
</li>
</ul>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。解释引用通过何种方式去定位、访问堆中的对象的具体位置。依据JVM实现而定</p>
<ul>
<li>句柄<ul>
<li>Java堆当中划分一块内存作为句柄池，reference中存储的是对象的句柄地址</li>
<li>句柄中包含了对象实例数据域类型数据各自的地址信息</li>
<li>稳定的句柄地址，即使对象被移动（垃圾收集时，非常普遍），也不会修改reference</li>
<li><img src="assets%5C1552120017803.png" alt="1552120017803"></li>
</ul>
</li>
<li>直接指针<ul>
<li>reference存储的就是对象地址</li>
<li>Java堆对象的布局中需要考虑如何放置访问类型数据的相关信息</li>
<li>速度快，节约一次指针定位，对于非常频繁的对象访问有较好的提升。Hotspot使用的方式</li>
<li><img src="assets%5C1552120022744.png" alt="1552120022744"></li>
</ul>
</li>
</ul>
<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈是，就需要对垃圾回收技术实施必要的监控和调节。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>垃圾收集GC需要完成的三件事情：</p>
<ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ul>
<p>无需关注的内存：对于程序计数器、虚拟机栈、本地方法栈。随线程而生灭，一个栈帧内分配多少内存基本上在类结果确定下来就已知，因此内存分配与回收都具备确定性。并且方法结束或者线程线束，内存就回收了。</p>
<p><strong>GC关注的内存</strong>：对于Java堆和方法区，一个接口中的多个实现类需要的内存可能不一样，一个方法中多个分支需要的内存也可能不一样，只能在程序运行期间才能知道会创建哪些对象，分配与回收都是动态的。</p>
<h2 id="对象是否存活"><a href="#对象是否存活" class="headerlink" title="对象是否存活"></a>对象是否存活</h2><p>GC在对堆进行回收前，要确定这些对象中哪些还存活着，哪些已经死去（不可能再被任何途径使用的对象）</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>定义：为对象添加一个计数器，每当有一个地方引用它时，计数器就++，引用失效时，计数器–</p>
<p>优点：实现简单、判定效率高</p>
<p>缺陷：难以解决对象间相互循环引用的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objA.instance=objB;</span><br><span class="line">objB.instance=objA;</span><br><span class="line"><span class="comment">//相互引用，导致无法回收</span></span><br></pre></td></tr></table></figure>

<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>Java等语言的主流实现</p>
<p>基本思想：</p>
<ul>
<li><p>通过一系列称为GC Roots的对象作为起始点，从这些结点开始向下搜索，走过的路径称为引用链</p>
</li>
<li><p>一个对象到GC Roots没有任何引用链，即不可达，则对象不可用</p>
</li>
<li><p>GC Roots对象：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈当Native方法引用的对象</li>
</ul>
</li>
<li><p><img src="assets/1552121101706.png" alt="1552121101706"></p>
</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>判断对象是否存活均与引用有关。对于引用我们希望描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。很多对象的缓存功能都符合这样的场景</p>
<ul>
<li>强引用<ul>
<li>指在程序代码中还普遍存在，类似“Object o=new Object()”的引用，只要强引用还存在，则永不回收</li>
</ul>
</li>
<li>软引用<ul>
<li>描述还有用，但并非必须的对象。在系统将内存溢出异常前，会将这些对象进行第二次回收。如果还没有足够内存，才会异常。</li>
<li>以SoftReference类实现软引用</li>
</ul>
</li>
<li>弱引用<ul>
<li>描述非必须对象，强度弱于软引用只能生存到下一次垃圾回收前</li>
<li>WeafReference实现</li>
</ul>
</li>
<li>虚引用<ul>
<li>最弱的引用关系，无法通过虚引用获得一个对象的实例。唯一目的是能在这个对象被回收时收到一个系统通知</li>
<li>PhantomReference实现</li>
</ul>
</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使时不可达的对象，也并非会立即死亡，此时处于缓刑阶段。而要宣告一个对象死亡，至少要经历两次标记过程。</p>
<ul>
<li><p>如果在可达性分析中，发现无连接，则进行第一次标记以及进行一次筛选</p>
</li>
<li><p>第一次筛选，条件为此对象是否有必要执行finalize方法。</p>
<ul>
<li><p>没有必要执行的情况：</p>
<ul>
<li>对象没有覆盖finalize方法</li>
<li>finalize方法已经被虚拟机调用过</li>
</ul>
</li>
<li><p>有必要执行</p>
<ul>
<li>将对象放置在一个F-Queue队列，并在稍后由一个虚拟机自动建立，低优先级的finalizer线程去执行</li>
<li>执行：虚拟机会触发这个方法，但并不承诺会等待它运行结束。为了防止一个对象在finalize执行缓慢，或者死循环，使得其他对象等待。</li>
</ul>
</li>
</ul>
</li>
<li><p>GC对F-Queue中对象进行第二次小规模标记，</p>
<ul>
<li>finalize是对象最后一次自救机会，如果对象此时与引用链上一个对象建立关联，则此时将被移出“即将回收”集合。否则就可以确定被回收了。</li>
</ul>
</li>
</ul>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>永久代的垃圾回收效率非常低，回收内容：</p>
<ul>
<li>废弃常量<ul>
<li>常量池存在“abc”，无String引用引用，并无其他地方引用该字面量，则为废弃常量</li>
<li>常量池当中的其他类(接口)方法、字段的符号引用也与此类似</li>
</ul>
</li>
<li>无用的类，但只是可以被回收，而不是一定被回收，是否回收需要进行JVM参数控制。对于大量使用反射、动态代理等框架会频繁自定义ClassLoader需要虚拟机具备类卸载功能，保证永久代不溢出。<ul>
<li>该类所有实例都被回收</li>
<li>加载该类的ClassLoader被回收</li>
<li>该类对应的Class对象没有被引用，无法通过反射访问该类的方法</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法 Mark-Sweep"></a>标记-清除算法 Mark-Sweep</h3><p>最基础的算法，算法分为标记与清除两个阶段</p>
<ul>
<li>标记出所有需要回收的对象，在标记完成后统一回收被标记的对象</li>
</ul>
<p>不足：</p>
<ul>
<li>效率低下</li>
<li>清除后会产生大量不连续的内存碎片</li>
</ul>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>解决效率问题</p>
<p>将可用内存按容量划分为两块，每次使用一块，一块内存使用完后，将其复制到另一块，然后回收</p>
<p>用于回收新生代</p>
<ul>
<li>新生代对象98%朝生夕死，因此将内存分为一块较大的Eden空间与两块较小的Survivor空间（8：1）。</li>
<li>每次使用Eden空间与一块Survivor空间</li>
<li>当Survivor空间不够时，依赖其他内存（老年代）进行分配担保</li>
</ul>
<h3 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法 Mark-Compact"></a>标记-整理算法 Mark-Compact</h3><p>标记过后，让所有存活的对象都向一端移动，然后清理端边界外的内存</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p><strong>实际采用的算法</strong></p>
<p>根据对象存活周期的不同将内存划分为几块：新生代、老年代</p>
<p>根据各个年代的特点采用适当的收集算法，新生代：复制算法，老年代：标记-清理（整理）算法</p>
<h2 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h2><p>以上是理论实现，而虚拟机高效允许需要对算法的执行效率进行严格的考量</p>
<h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>帮助快速准确完成GC Roots枚举，其困难有</p>
<ul>
<li>GC Roots的节点非常多，逐个检查引用需要消耗非常多的时间。并且对于很多应用仅仅方法区就有数百兆</li>
<li>GC停顿问题（GC进行时必须停顿所有执行线程），必须在一个确保一致性（整个执行系统冻结在某个时间节点，不可以出现在分析过程中，引用关系还在不断变化）的快照中进行</li>
</ul>
<p>主流JVM使用准确式GC，当执行系统停顿下来，并不需要一个不漏检查完所有的引用位置，应当有办法直接得知哪些地方存放着对象引用</p>
<p>HotSpot使用OopMap达到目的，在类加载完成时，HotSpot将对象内什么偏移量是什么类型数据计算出来，在JIT编译时也会在特点位置记录栈和寄存器哪些位置是引用。</p>
<p><strong>OopMap数据解构</strong>： 保存<code>GC Roots</code> 节点，避免全局扫描去一一查找。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><ul>
<li>引用关系可能变化，OopMap内容变化指令非常多，如果为每一条指令生成对应的OopMap则需要大量空间<ul>
<li>程序执行时只有在到达<strong>安全点</strong>时才能暂停，进行GC。</li>
<li><strong>安全点的选择</strong>：以是否具有让程序长时间执行的特征为标准选定。即指令序列复用，如方法调用、循环跳转、异常跳转等。安全点的选定不能太少以致于让GC等待时间太长，也不能过于频繁过分增大运行时的负荷。</li>
</ul>
</li>
<li>如何在GC发生时，让所有线程都跑到最近的安全点再停顿<ul>
<li>抢先式中断（几乎没有JVM使用）<ul>
<li>GC发生时，首先把所有线程中断，如果线程不在安全点，就恢复线程，让它跑到安全点</li>
</ul>
</li>
<li>主动式中断<ul>
<li>当GC需要中断时，不直接对线程操作，设置一个标志（与安全点重合），各个线程执行时轮询这个标志，如果为真则自己中断挂起</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全点机制保证了程序执行时在不太长时间内就会遇到可进入GC的安全点，但是无法解决程序不执行的时候进入安全点。</p>
<ul>
<li>对于不执行的程序，如挂起或者blocked状态，无法响应中断请求，走到安全点。<ul>
<li>安全区域：在一段代码片段中，引用关系不会发生变化。则在这个区域的任意地方开始GC都是安全的</li>
<li>当线程执行到安全区域时，标识自己已经进入安全区域，当JVM发生GC时，不用管已经标识的线程。当线程离开时，需要检查系统是否完成GC，如果完成则继续执行，否则继续等待</li>
</ul>
</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>并行和并发概念补充：</strong></p>
<ul>
<li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。</li>
</ul>
<p>内存回收的具体实现</p>
<p><img src="assets%5C1552131024681.png" alt="1552131024681"></p>
<p>存在连线，则说明可以搭配使用。所处区域，说明属于新生代还是老年代收集器。为了对具体应用最合适的收集器。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial （Old）收集器是最基本最古老的收集器，是一个单线程收集器，并且在它进行垃圾回收时，必须暂停所有的用户线程。</p>
<ul>
<li>Serial是针对新生代收集器，采用copying算法</li>
<li>Serial Old针对老年代，采用Mark-Compact算法<ul>
<li>作为CMS收集器的后备预案，在并发收集出现Concurrent Mode Failture使用</li>
</ul>
</li>
<li>简单高效，但是给用户带来停顿，client模式下默认的新生代收集器。对于限定单个CPU的环境下，没有线程交互的开销，可以获得最高的单线程收集效率<ul>
<li>对于一般用户，虚拟机内存一般比较小，停顿时间可以控制在最多100ms以内。</li>
</ul>
</li>
</ul>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>是Seial收集器的多线程版本</p>
<ul>
<li>是许多运行在Server模式下的虚拟机中的首选新生代收集器。重要原因是除了serial收集器外，只有它可以与CMS收集器配合工作</li>
<li>在单CPU环境中不会比Serial更好，由于线程开销，在两个CPU环境下都未必超越Serial，默认开启的收集线程数与CPU数量相同，可以通过-XX:ParallelGCThreads限制其线程数。</li>
<li>ParNew Old是老年代版本，采用Mark-Compact<ul>
<li>搭配Parallel Scavenge</li>
</ul>
</li>
</ul>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>是新生代的多线程收集器，<strong>吞吐量优先</strong>收集器，它在回收期间不需要暂停其他用户线程，采用Copying算法，它主要是为了<strong>达到一个可控的吞吐量</strong>。吞吐量=运行用户代码时间/(用户代码+垃圾收集)而停顿时间与吞吐量是矛盾的</p>
<ul>
<li>GC时，垃圾回收的工作总量是不变的<ul>
<li>停顿时间减少，就越适合与用户交互的程序，提高用户体验，但是GC频率提高，</li>
<li>频率提高，则频繁进行GC，即吞吐量降低，性能降低，因此是以牺牲吞吐量和新生代空间换取的。</li>
<li>吞吐量提高，则高效率利用CPU时间，尽快完成程序运算，适合在后台运算而不需要太多交互的任务。</li>
</ul>
</li>
<li>对于注重吞吐量和CPU资源敏感的场合，优先考虑Parallel Scavenge与Parallel Old</li>
</ul>
<p>-XX:MaxGCPauseMillis设置最大垃圾收集停顿时间，-XX:GCTimeRatio设置吞吐量大小（垃圾收集时间占总时间的比率，值为0-100）。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>以<strong>获取最短回收停顿时间为目标</strong>的收集器，重视服务的响应速度，希望系统停顿时间最短，给用户带来体验，是一种并发收集器，采用Mark-Sweep（标记清除）算法</p>
<p>运作过程</p>
<ul>
<li>初始标记<ul>
<li>需要stop the world。仅仅只标记一下GC Roots能<strong>直接关联</strong>到的对象，速度较快</li>
</ul>
</li>
<li>并发标记<ul>
<li>进行GC Roots Tracing。耗时长，但可以与用户线程一起工作，但是会占用一定CPU资源，使得程序变慢</li>
</ul>
</li>
<li>重新标记<ul>
<li>需要stop the world。修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li>
</ul>
</li>
<li>并发清除</li>
</ul>
<p>缺点：</p>
<ul>
<li>对CPU资源非常敏感。<ul>
<li>会占用CPU资源，使得程序变慢，总吞吐量降低。默认线程数是(CPU数+3)/4，即在CPU4个以上，获得至少25%的CPU资源，当CPU不足4时，对用户程序影响较大。当CPU负载比较大，则分出一半运算能力会使得用户程序执行速度降低一半。</li>
</ul>
</li>
<li>无法处理浮动垃圾，可能出现Concurrent Mode Failure失败(预留的内存空间不足以程序运行)而导致另一次Full GC（进行全部GC，老年代临时使用Serial Old收集器）的产生<ul>
<li>由于用户线程依然运行，可能产生新的垃圾。这部分垃圾产生在标记过程后，只能在下一次GC清理，即浮动垃圾</li>
<li>由于在垃圾收集时，用户线程依然需要运行，则需要预留足够的内存给用户线程。设定合理的阈值，减少FULL GC出现的机会。设定-XX:CMSInitiatingOccupancyFraction的值来确定阈值。</li>
<li>空间碎片。-XX:UseCMSCompactAtFullCollection开关参数，默认开启，在CMS即将进行FullGC时开启内存碎片的合并整理，该过程无法并发，但是时间不会太长。-XX:CMSFullGCsBeforeCompaction设定执行多少次不压缩的FullGC后跟着来一次带压缩的。</li>
</ul>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>当前收集器最前沿的成果，面向服务端应用的收集器，能充分利用多CPU、多核环境。因此是一款并行和并发收集器，并能建立可预测的停顿时间模型。</p>
<p>G1特点：</p>
<ul>
<li>并行与并发<ul>
<li>能充分利用CPU、多核环境下的硬件优势，缩短Stop The World停顿时间，可以以并发使得Java程序继续执行</li>
</ul>
</li>
<li>分代收集</li>
<li>空间整合<ul>
<li>整体上是标记整理算法实现，局部（两个区域Region间）上是基于复制算法，不会产生内存碎片，导致提前GC</li>
</ul>
</li>
<li>可预测的停顿<ul>
<li>低停顿，并可建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒</li>
<li>实时Java的垃圾回收器特征</li>
<li>原因：<ul>
<li>可以有计划地避免在整个Java堆当中进行全区域的垃圾收集。跟踪各个Region的垃圾堆积的价值大小（回收所获得的空间大小以及需要的时间），在后台维护一个优先列表，根据允许的时间，优先回收价值最大的Region</li>
</ul>
</li>
<li>Region困难<ul>
<li>垃圾回收不能真的以Region为单位，因为一个对象存放在Region中，它可以与整个Java堆中任意对象发生引用关系。在可达性判断时，扫描困难，需要对整个堆扫描</li>
<li>使用Remembered Set避免全堆扫描，每个Region都有一个与之对应的Remembered Set，对引用类型数据进行写操作时，产生一个Write Barrier暂时中断，判断是否引用的对象处于不同的Region中，如果是，则通过CardTable把相关引用信息记录到该Region的Remembered Set中，在可达性分析中加入该Remembered Set。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>G1将Java堆的内存布局划分为多个大小相等的独立区域（Region），保留新生代、老年代概念，但是不物理隔离，都是一部分Region的集合。</p>
<p>G1的步骤（不考虑Remembered Set操作）</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记<ul>
<li>JVM将在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，记录在Remembered Set Logs中，最终标记阶段需要将Logs的数据合到Rembbered Set当中。</li>
</ul>
</li>
<li>筛选回收<ul>
<li>对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间指定回收计划。</li>
</ul>
</li>
</ul>
<h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><p>每一种收集器的日志形式都是由它们自身的实现所决定的，即每个收集器的日志格式都可以不一样。但JVM设计时将各个收集器的日志都维持一定的共性。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">33.125: [GC [DefNew: 3324K-&gt;152K(3712K), 0.0025925 secs] 3324K-&gt;152K[11904K], 0.0031680sec]</span><br><span class="line"></span><br><span class="line">100.667: [Full GC [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), [Perm : 2999K-&gt;2999K(21248K)],0.0150007 secs] [Times:user=0.01 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure>

<ul>
<li>33.125、100.667表示GC发生的时间，数字含义时从JVM启动以来经过的秒数</li>
<li>GC日志开头的GC、FullGC说明了此次垃圾收集的停顿类型。而不是新生代或老年代，即使时新生代也可能英文担保失败而导致Full GC</li>
<li>DefNew、Tenured、Perm表示GC发生的区域，与收集器密切相关</li>
<li>方括号内部的3324K-&gt;152K(3712K)，GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）</li>
<li>方括号外部的3324K-&gt;152K(11904K)表示GC前Java堆已使用容量-&gt;GC后Java堆已使用容量(Java堆总容量)</li>
<li>0.0025925 secs表示该内存区域GC所占用时间。有些收集器给出更详细时间，Times: user=0.01 sys=0.00 real=0.02即分别代表用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的<strong>墙钟时间</strong>（包括各种非运算的等待耗时，例如IO、线程阻塞等）。</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>Java的自动内存管理自动化解决了两个问题</p>
<ul>
<li>给对象分配内存。（在堆上分配，也可能经过JIT编译后被拆散为标量类型并间接地栈上分配）<ul>
<li>主要分配在新生代的Eden区。如果启动了本地线程分配缓冲，将线程优先在TLAB上分配</li>
<li>少数情况直接分配到老年代中</li>
<li>分配规则取决于当前使用哪一种垃圾回收器组合，还要虚拟机中与内存相关的参数的设置</li>
</ul>
</li>
<li>回收分配给对象的内存</li>
</ul>
<h3 id="什么时候进行GC"><a href="#什么时候进行GC" class="headerlink" title="什么时候进行GC"></a>什么时候进行GC</h3><p>Minor GC</p>
<ul>
<li>新生代当中的垃圾收集动作，采用复制算法</li>
<li>对于较大的对象，在Minor GC时候，直接进入老年代</li>
</ul>
<p>Full GC</p>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况，对象在新生代Eden区分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</p>
<ul>
<li>新生代GC（Minor GC）指发生在新生代的垃圾回收动作，因为Java对象大多具备朝生夕死的特性，所以该GC频繁，且速度快</li>
<li>老年代GC（Major GC/Full GC）指发生在老年代GC，比新生代GC慢10倍以上</li>
</ul>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象：需要大量连续内存空间的Java对象，例如很长的字符串与数组</p>
<p>经常出现大对象容易导致内存还有不少空间时就需要提前触发垃圾收集以获得连续空间</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>虚拟机为每个对象定义了一个对象年龄Age计数器，每经过一次Minor GC则age+1，当达到15（MaxTenuringThreshold设置）则升级到老年代</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>为了更好适应不同程序内存情况，并不是永远要求年龄到达阈值才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小总和大于空间的一般，年龄大于等于该年龄的对象就可以直接进入老年代</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul>
<li>在发生Minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。<ul>
<li>如果大于，则Minor GC可以确保安全</li>
<li>如果不大于，则虚拟机查看HandlePromotionFailure设置值是否允许担保失败<ul>
<li>允许，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小<ul>
<li>如果大于则尝试进行Minor GC,尽管有风险</li>
<li>如果小于，或者HandlePromotionFailure不允许冒险，则进行一次Full GC</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>失败：新生代采用复制收集算法，当出现大量对象在Minor GC后仍然存活地情况，即一个Survivor存不下，就需要老年代进行分配担保，将Survivor无法容纳地对象直接进入老年代。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Java/base/JVM：概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/Java/base/JVM：概述/" class="post-title-link" itemprop="url">JVM：概述</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-03-01 10:45:05" itemprop="dateCreated datePublished" datetime="2019-03-01T10:45:05+08:00">2019-03-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-29 23:14:26" itemprop="dateModified" datetime="2019-07-29T23:14:26+08:00">2019-07-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/03/01/Java/base/JVM：概述/" class="post-meta-item leancloud_visitors" data-flag-title="JVM：概述">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/03/01/Java/base/JVM：概述/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/01/Java/base/JVM：概述/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          JVM概述，base深入理解Java虚拟机
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/03/01/Java/base/JVM：概述/">
                Leer más &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/Java/base/java并发：线程调度-协作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/Java/base/java并发：线程调度-协作/" class="post-title-link" itemprop="url">java并发：线程调度</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-28 20:08:24" itemprop="dateCreated datePublished" datetime="2019-02-28T20:08:24+08:00">2019-02-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-31 10:41:29" itemprop="dateModified" datetime="2019-07-31T10:41:29+08:00">2019-07-31</time>
              </span>
            
          

          
            <span id="/2019/02/28/Java/base/java并发：线程调度-协作/" class="post-meta-item leancloud_visitors" data-flag-title="java并发：线程调度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/28/Java/base/java并发：线程调度-协作/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/28/Java/base/java并发：线程调度-协作/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/Java/base/java并发：JUC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/Java/base/java并发：JUC/" class="post-title-link" itemprop="url">java并发：J.U.C</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-28 20:08:11" itemprop="dateCreated datePublished" datetime="2019-02-28T20:08:11+08:00">2019-02-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-31 10:47:34" itemprop="dateModified" datetime="2019-07-31T10:47:34+08:00">2019-07-31</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/02/28/Java/base/java并发：JUC/" class="post-meta-item leancloud_visitors" data-flag-title="java并发：J.U.C">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/28/Java/base/java并发：JUC/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/28/Java/base/java并发：JUC/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JDK下面的一个并发工具包，java.util.concurrent</p>
<h3 id="locks锁框架"><a href="#locks锁框架" class="headerlink" title="locks锁框架"></a>locks锁框架</h3><ul>
<li>Lock<ul>
<li>ReentrantLock</li>
</ul>
</li>
<li>Condition</li>
<li>ReadWriteLock</li>
<li>LockSupport</li>
</ul>
<h3 id="atomic原子类框架"><a href="#atomic原子类框架" class="headerlink" title="atomic原子类框架"></a>atomic原子类框架</h3><ul>
<li>AtomicStampledReference</li>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicIntegerArray</li>
<li>AtomicInterFiledUpdater</li>
<li>AtomicLong</li>
<li>AtomicLongArray</li>
<li>AtomicLongFiledUpdater</li>
<li>AtomicReference</li>
</ul>
<h3 id="sync同步器框架"><a href="#sync同步器框架" class="headerlink" title="sync同步器框架"></a>sync同步器框架</h3><ul>
<li>CocuntDownLatch</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
<li>Executors</li>
<li>Exchanger</li>
</ul>
<h3 id="collections集合框架"><a href="#collections集合框架" class="headerlink" title="collections集合框架"></a>collections集合框架</h3><ul>
<li>Queeu</li>
<li>CopyOnWrite<ul>
<li>CopyOnWriteArrayList</li>
<li>CopyOnWriteArraySet</li>
<li>CopyOnWriteSkipListSet</li>
</ul>
</li>
<li>ConcurrentMap</li>
</ul>
<h3 id="executors执行器框架"><a href="#executors执行器框架" class="headerlink" title="executors执行器框架"></a>executors执行器框架</h3><ul>
<li>Future<ul>
<li>RunnableFuture</li>
</ul>
</li>
<li>Callable</li>
<li>Executor<ul>
<li>ThreadPoolExecutor</li>
</ul>
</li>
<li>CompletionService</li>
<li>RejectedExecutionhandler<ul>
<li>ThreadPoolExecutor.DiscardPolicy</li>
</ul>
</li>
<li>TimeUnit</li>
</ul>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1551617354545.png" alt="1551617354545"></p>
<p>AbstractQueuedSynchronizer-AQS</p>
<p>底层数据结构</p>
<ul>
<li>双向链表</li>
<li>Condition queue，单向链表<ul>
<li>当使用到condition时存在，并可能存在多个</li>
</ul>
</li>
</ul>
<p>设计</p>
<ul>
<li>使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架</li>
<li>利用一个int类型表示状态<ul>
<li>state变量，表示获取锁的线程锁，&gt;1表示重入锁的数量</li>
</ul>
</li>
<li>使用方法是继承<ul>
<li>复写其中方法</li>
</ul>
</li>
<li>子类通过继承并通过实现它的方法管理其状态（acquire和release）的方法操纵状态</li>
<li>可以同时实现排它锁和共享锁模式（独占、共享）</li>
</ul>
<p>实现思路</p>
<ul>
<li>内部维护一个队列来管理锁</li>
<li>线程尝试获取锁<ul>
<li>如果失败，将当前线程以及等待状态信息包装为一个node节点加入同步队列</li>
<li>不断尝试获取锁，只有head的直接后继才会尝试，如果失败则阻塞自己</li>
<li>当持有锁的线程释放锁的时候，唤醒head的直接后继</li>
</ul>
</li>
</ul>
<p>AQS同步组件</p>
<ul>
<li>CountDownLatch</li>
<li>Semaphore</li>
<li>CyclicBarrier</li>
<li>ReentrantLock  锁</li>
<li>Condition</li>
<li>FutureTask</li>
</ul>
<h1 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><strong>功能</strong>：用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成</p>
<ul>
<li>对象初始化时设置一个值</li>
<li>任何在这个对象上调用wait方法都将阻塞，直至计数为0</li>
<li>在对象上调用countDown来减小计数值</li>
<li>只能触发一次，计数值不能被重置</li>
<li>可重置版为CyclicBarrier</li>
<li>在对await的调用会被阻塞，直至计数值达到0</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Performs some portion of a task:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskPortion</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="comment">//这只是个引用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line">  TaskPortion(CountDownLatch latch) &#123;</span><br><span class="line">      <span class="comment">//在这里引用到真正的对象</span></span><br><span class="line">    <span class="keyword">this</span>.latch = latch;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork();</span><br><span class="line">        <span class="comment">//计数值减一</span></span><br><span class="line">      latch.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">      <span class="comment">// Acceptable way to exit</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">2000</span>));</span><br><span class="line">    print(<span class="keyword">this</span> + <span class="string">"completed"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"%1$-3d "</span>, id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Waits on the CountDownLatch:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitingTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line">    </span><br><span class="line">  WaitingTask(CountDownLatch latch) &#123;</span><br><span class="line">    <span class="keyword">this</span>.latch = latch;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//等待CountDownLatch的值到达0</span></span><br><span class="line">      latch.await();</span><br><span class="line">      print(<span class="string">"Latch barrier passed for "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">      print(<span class="keyword">this</span> + <span class="string">" interrupted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"WaitingTask %1$-3d "</span>, id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">// 初始化值为100All must share a single CountDownLatch object:</span></span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(SIZE);</span><br><span class="line">      <span class="comment">//尽管这些线程先启动，但是由于CountDownLatch的原因，他们阻塞</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="comment">//他们使用的是同一个latch</span></span><br><span class="line">      exec.execute(<span class="keyword">new</span> WaitingTask(latch));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">      exec.execute(<span class="keyword">new</span> TaskPortion(latch));</span><br><span class="line">    print(<span class="string">"Launched all tasks"</span>);</span><br><span class="line">    exec.shutdown(); <span class="comment">// Quit when all tasks complete</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><strong>功能</strong>：</p>
<ul>
<li>希望创建一组任务，它们并行地执行工作，然后再进行下个步骤前等待，直至所有任务都完成。</li>
<li>使得所有的并行任务在栅栏处列队，一致向前移动<ul>
<li>一场场连续的比赛，当所有人到达终点后，才重置，开始下一场比赛</li>
</ul>
</li>
</ul>
<p>特性：CyclicBarrier可以多次重用</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><ul>
<li>无界的BlockingQueue，用于放置实现了Delayed接口的对象</li>
<li>其中的对象只能再其到期时才能从队列中取走。</li>
<li>队列是有序的，队头对象的延迟到期时间最长</li>
<li>即优先级队列的一种变体。</li>
</ul>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><ul>
<li>基础的优先级队列，具有可阻塞的读取操作。</li>
<li>在优先级队列中的对象是按照优先级顺序从队列中出现的任务</li>
</ul>
<h2 id="ScheduledExecutor的温室控制器"><a href="#ScheduledExecutor的温室控制器" class="headerlink" title="ScheduledExecutor的温室控制器"></a>ScheduledExecutor的温室控制器</h2><ul>
<li>ScheduledThreadPoolExecutor</li>
<li>使用schedule运行一次任务</li>
<li>scheduleAtFixedRate每隔规则的时间重复执行任务</li>
<li>可以将runnable设置为在将来的某个时刻执行</li>
</ul>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，允许n个任务同时访问整个资源。</p>
<p>对象池，管理数量有限的对象，当要使用对象时可以签出他们，当用户使用完毕时，可以将他们签回。</p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><ul>
<li>Exchanger类可用于两个线程之间交换信息。</li>
<li>可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。</li>
<li>当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。</li>
</ul>
<h1 id="J-U-C-AQS"><a href="#J-U-C-AQS" class="headerlink" title="J.U.C - AQS"></a>J.U.C - AQS</h1><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p>
<h2 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用来控制一个线程等待多个线程。</p>
<p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p>
<p><img src="assets/ba078291-791e-4378-b6d1-ece76c2f0b14.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">run..run..run..run..run..run..run..run..run..run..end</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier-1"><a href="#CyclicBarrier-1" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="assets/f71af66b-0d54-4399-a44b-f47b58321984.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></figure>

<h2 id="Semaphore-1"><a href="#Semaphore-1" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">" "</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="J-U-C-其它组件"><a href="#J-U-C-其它组件" class="headerlink" title="J.U.C - 其它组件"></a>J.U.C - 其它组件</h1><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"other task is running..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">other task is running...</span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></figure>

<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p>
<ul>
<li><strong>FIFO 队列</strong> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li>
<li><strong>优先级队列</strong> ：PriorityBlockingQueue</li>
</ul>
<p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p>
<p><strong>使用 BlockingQueue 实现生产者消费者问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">"product"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"produce.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String product = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"consume.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..</span><br></pre></td></tr></table></figure>

<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinExample</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinExample leftTask = <span class="keyword">new</span> ForkJoinExample(first, middle);</span><br><span class="line">            ForkJoinExample rightTask = <span class="keyword">new</span> ForkJoinExample(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinExample example = <span class="keyword">new</span> ForkJoinExample(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    Future result = forkJoinPool.submit(example);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure>

<p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p>
<p><img src="assets/e42f188f-f4a9-4e6f-88fc-45f4682072fb.png" alt="img"></p>
<h1 id="待迁移"><a href="#待迁移" class="headerlink" title="待迁移"></a>待迁移</h1><h3 id="并发容器J-U-C"><a href="#并发容器J-U-C" class="headerlink" title="并发容器J.U.C"></a>并发容器J.U.C</h3><p>JDK下的一个包Java.util.concurrent</p>
<ul>
<li>ArrayList-&gt;CopyOnWriteArrayList<ul>
<li>写操作的时候复制，在新的数组上操作，写完后，将原有的数据指向新数组</li>
<li>拷贝数组消耗内存</li>
<li>不能用于实时读数组，可能读取到旧的，适合读多写少</li>
</ul>
</li>
<li>HashSet、TreeSet-&gt;CopyOnWriteArraySet、ConcurrentSkipListSet<ul>
<li>ConcurrentSkipListSet：支持自然排序（TreeSet），基于map。对于批量操作并不能保证原子操作，对于单个cotains操作可以</li>
</ul>
</li>
<li>HashMap、TreeMap-&gt;ConcurrentHashMap、ConcurrentSkipListMap<ul>
<li>ConcurrentHashMap:针对读操作做了大量的优化，能应付很大的并发，速度快</li>
<li>ConcurrentSkipListMap：TreeMap的安全版，基于跳表实现，支持更高的并发，线程越多越优秀</li>
</ul>
</li>
<li>Collections.synchronizedXXX(List、Set、Map)</li>
</ul>
<p><img src="D:/ABlog/source/_posts/Java/base/assets/1551612197603.png" alt="1551612197603"></p>
<h4 id="HashMap与ConcurrentHashMap"><a href="#HashMap与ConcurrentHashMap" class="headerlink" title="HashMap与ConcurrentHashMap"></a>HashMap与ConcurrentHashMap</h4><p>HashMap</p>
<p>数据结构：</p>
<ul>
<li>数组</li>
<li>引用</li>
</ul>
<p><img src="D:/ABlog/source/_posts/Java/base/assets/1551689310736.png" alt="1551689310736"></p>
<p>参数</p>
<ul>
<li>初始容量</li>
<li>加载因子</li>
</ul>
<p>寻址方式</p>
<ul>
<li>取模操作消耗操作较大，使用与操作与2^n-1进行与运算</li>
</ul>
<h4 id="同步器AQS"><a href="#同步器AQS" class="headerlink" title="同步器AQS"></a>同步器AQS</h4><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/Java/框架/SpringBoot：注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/Java/框架/SpringBoot：注解/" class="post-title-link" itemprop="url">SpringBoot（一）：注解</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-28 19:46:22 / Modificado por: 19:49:24" itemprop="dateCreated datePublished" datetime="2019-02-28T19:46:22+08:00">2019-02-28</time>
            </span>
          
            

            
          

          
            <span id="/2019/02/28/Java/框架/SpringBoot：注解/" class="post-meta-item leancloud_visitors" data-flag-title="SpringBoot（一）：注解">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/28/Java/框架/SpringBoot：注解/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/28/Java/框架/SpringBoot：注解/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>注解通过实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定注解作用的目标，该注解作用于类</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="comment">//注解存在的范围</span></span><br><span class="line"><span class="comment">//source：编译被忽略</span></span><br><span class="line"><span class="comment">//class</span></span><br><span class="line"><span class="comment">//runtime：运行时也存在</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ClassName&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="Página anterior"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="Página siguiente"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">219</span>
          <span class="site-state-item-name">entradas</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categorías</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
</div>
  <div class="powered-by">Creado mediante <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Tema – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  











  
  <script>
    function showTime(Counter) {
      var entries = [];
      var $visitors = $('.leancloud_visitors');

      $visitors.each(function() {
        entries.push( $(this).attr('id').trim() );
      });

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url: { '$in': entries } }) })
        .done(function({ results }) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if (countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function ({ responseJSON }) {
          console.log(`LeanCloud Counter Error: ${responseJSON.code} ${responseJSON.error}`);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
                'X-LC-Key': 'uTVcNIWdMCGpicrhTKygpKXi',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
            if ($('.post-title-link').length >= 1) {
              showTime(Counter);
            }
          
        });
    });
  </script>
























    
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
    appKey: 'uTVcNIWdMCGpicrhTKygpKXi',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn'
  });
</script>


</body>
</html>
