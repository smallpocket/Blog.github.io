<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: 'OZTK1BY156',
      apiKey: '',
      indexName: 'BlogIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Kopieren',
      copy_success: 'Kopiert',
      copy_failure: 'Kopieren fehlgeschlagen'
    }
  };
</script>

  <meta name="description" content="To be awesome">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/15/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="To be awesome">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="To be awesome">
  <link rel="canonical" href="http://yoursite.com/page/15/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>Über</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Schlagwörter</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Kategorien</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>Zeitplan</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Suche</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="algolia-popup popup search-popup">
  <div class="algolia-search">
    <div class="algolia-search-input-icon">
      <i class="fa fa-search"></i>
    </div>
    <div class="algolia-search-input" id="algolia-search-input"></div>
  </div>

  <div class="algolia-results">
    <div id="algolia-stats"></div>
    <div id="algolia-hits"></div>
    <div id="algolia-pagination" class="algolia-pagination"></div>
  </div>

  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>



    </div>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/OS/计算机操作系统：物理内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/OS/计算机操作系统：物理内存/" class="post-title-link" itemprop="url">计算机操作系统（二）：物理内存</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-02-28 16:37:10" itemprop="dateCreated datePublished" datetime="2019-02-28T16:37:10+08:00">2019-02-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-04-13 22:14:38" itemprop="dateModified" datetime="2019-04-13T22:14:38+08:00">2019-04-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/02/28/OS/计算机操作系统：物理内存/" class="post-meta-item leancloud_visitors" data-flag-title="计算机操作系统（二）：物理内存">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/02/28/OS/计算机操作系统：物理内存/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/28/OS/计算机操作系统：物理内存/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h1><h2 id="计算机体系结构和内存层次"><a href="#计算机体系结构和内存层次" class="headerlink" title="计算机体系结构和内存层次"></a>计算机体系结构和内存层次</h2><h3 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h3><p>计算机系统32位，即地址总线是32位的。</p>
<p>CPU寄存器（32位、64位等）、内存、外存</p>
<p>CPU：</p>
<p><img src="assets%5C1551415868764.png" alt="1551415868764"></p>
<h3 id="内存层次"><a href="#内存层次" class="headerlink" title="内存层次"></a>内存层次</h3><p>CPU：两级缓存，由硬件MMU控制，3.6GHZ(CPU的频率)</p>
<p>内存（高速缓存未命中），由OS控制，1.3GHZ</p>
<p>外存（缺页）5ms</p>
<h3 id="OS的内存管理方式"><a href="#OS的内存管理方式" class="headerlink" title="OS的内存管理方式"></a>OS的内存管理方式</h3><p>OS内存管理需要实现的目标</p>
<ul>
<li>抽象，将物料地址空间转换为逻辑地址空间</li>
<li>保护，对地址空间进行保护，独立地址空间</li>
<li>共享，访问相同内存</li>
<li>虚拟化，更大的地址空间</li>
</ul>
<p>对于内存的访问，以字节进行访问，每个字节有一个物理地址</p>
<p>对于外存的访问，</p>
<p><strong>内存管理方式</strong></p>
<ul>
<li>重定位，将每一个地址用一个段地址与一个偏移，可以使得程序可移植</li>
<li>分段，使得地址空间不必连续，但是一段必须连续</li>
<li>分页，将内存分为最基本的单位，</li>
<li>虚拟内存</li>
</ul>
<h1 id="地址空间-amp-地址生成"><a href="#地址空间-amp-地址生成" class="headerlink" title="地址空间&amp;地址生成"></a>地址空间&amp;地址生成</h1><h2 id="地址空间的定义"><a href="#地址空间的定义" class="headerlink" title="地址空间的定义"></a>地址空间的定义</h2><ul>
<li>物理地址空间，硬件支持的地址空间<ul>
<li>起始地址到MAX内存</li>
</ul>
</li>
<li>逻辑地址空间，在CPU运行的进程看到的地址<ul>
<li>起始地址0，到MAXprog</li>
</ul>
</li>
</ul>
<h2 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a><strong>地址生成</strong></h2><p>逻辑地址的生成</p>
<p><img src="assets/1551416925221.png" alt="1551416925221"></p>
<p>地址生成时机和限制</p>
<ul>
<li>编译时<ul>
<li>假设起始地址已知，如果起始地址改变，必须重新编译</li>
</ul>
</li>
<li>加载时（加载之后，地址就无法改变了）<ul>
<li>编译时起始地址未知，进行重定位生成绝对地址</li>
</ul>
</li>
<li>执行时（不要求地址空间移动）<ul>
<li>执行时代码可移动</li>
<li>需地址转换（虚拟内存）硬件支持</li>
</ul>
</li>
</ul>
<h2 id="地址生成过程"><a href="#地址生成过程" class="headerlink" title="地址生成过程"></a><strong>地址生成过程</strong></h2><p><img src="assets/1551418025948.png" alt="1551418025948"></p>
<h2 id="地址检测"><a href="#地址检测" class="headerlink" title="地址检测"></a><strong>地址检测</strong></h2><p><img src="assets/1551418392013.png" alt="1551418392013"></p>
<h1 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h1><p>在没有其他技术支持的情况下，分配的内存必须是连续的。为提高利用内存的利用效率，从如何找需要的内存分区与如何处理不能用的内存分区来考虑。</p>
<p>连续内存分配：给进程分配一块不小于指定大小的连续的物理内存区域</p>
<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p>内存碎片：空闲内存不能被利用</p>
<ul>
<li>外部碎片：分配单元之间未被使用内存</li>
<li>内部碎片：分配单元内部的未被使用内存（需要511字节，但是只能以512字节分配），取决于分配单元大小是否取整</li>
</ul>
<h2 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h2><p>当程序被加载进行时，分配一个进程指定大小可变的分区</p>
<p>分区的地址是连续的</p>
<p><strong>操作系统需要维护的数据结构</strong></p>
<ul>
<li>所有进程的已分配分区</li>
<li>空闲分区</li>
</ul>
<p><strong>分配策略</strong></p>
<ul>
<li>最先匹配</li>
<li>最佳匹配，将所有的空闲分区查找一遍</li>
<li>最差匹配，使用最大的</li>
</ul>
<h2 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h2><p>通过碎片整理获得更大的内存空间。通过调整进程占用的分区位置来减少或避免分区碎片</p>
<ul>
<li><p>紧凑</p>
<ul>
<li>通过移动分配给进程的内存分区，以合并外部碎片</li>
<li>条件：所有应用程序可动态重定位</li>
<li>通常在进程等待时刻进行紧凑</li>
<li>存在开销</li>
</ul>
</li>
<li><p>分区对换</p>
<ul>
<li>通过抢占并回收处于等待状态进程的分区，以增大可用内存空间。</li>
<li>开销相对较大，因为在外存的读取较慢</li>
</ul>
</li>
</ul>
<h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><p>连续内存分配的实例</p>
<ul>
<li>整个可分配分区大小为2^n</li>
<li>将分区切半直到大于所需的内存空间</li>
</ul>
<h1 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h1><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>如果用户不存在需要的连续的内存空间，分配就会失败</p>
<p>段式分配较大，</p>
<p>页式分配较小，分的太小，则逻辑地址到物理地址的对应关系就会有些复杂（处理方式：页表）</p>
<p><strong>连续分配</strong>的缺点：</p>
<ul>
<li>分配给程序的物理内存必须连续</li>
<li>存在外碎片与内碎片</li>
<li>内存分配的动态修改困难</li>
<li>内存利用率较低</li>
</ul>
<p><strong>非连续分配</strong></p>
<p>设计目标：提高内存利用效率与管理灵活性</p>
<ul>
<li>允许一个程序的使用非连续的物理地址空间</li>
<li>允许共享代码和数据</li>
<li>支持动态加载与动态链接</li>
</ul>
<p>需解决的问题</p>
<ul>
<li>如何实现虚拟地址和物理地址的转换<ul>
<li>硬件实现（<strong>够用</strong>，开销小）</li>
<li>软件实现（灵活，开销大，类似于外排序）</li>
</ul>
</li>
<li>非连续分配的硬件辅助机制，如何选择非连续分配中的内存分块大小<ul>
<li>段式</li>
<li>页式</li>
</ul>
</li>
</ul>
<h2 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h2><p><strong>段地址空间</strong></p>
<p>目的：更精细力度和灵活的分离与共享</p>
<p>进程的段地址空间由多个段组成</p>
<p><img src="assets/1551443700539.png" alt="1551443700539"></p>
<p><strong>段的概念</strong></p>
<ul>
<li>段表示访问方式和存储数据等属性相同的一段地址空间</li>
<li>对应一个连续的内存块</li>
<li>若干个段组成进程逻辑地址空间</li>
</ul>
<p><strong>段访问机制</strong></p>
<p>逻辑地址由二元组（s,addr）标识</p>
<ul>
<li>s:段号（查询段表，由OS控制），addr:段内偏移</li>
</ul>
<h2 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h2><p><strong>概念</strong></p>
<ul>
<li>页帧（帧，描述物理页面）<ul>
<li>把物理地址空间划分为大小相同的基本分配单位</li>
<li>2^N</li>
<li>内存物理地址表示：二元组（f,o）帧号，帧内偏移（值为s，表示每帧的字节为2^s）</li>
</ul>
</li>
<li>页面（页，逻辑页面）<ul>
<li>把逻辑地址空间划分为大小相同的基本分配单位</li>
<li>帧与页的大小相同</li>
</ul>
</li>
</ul>
<p><strong>地址转换</strong></p>
<p>页面到页帧</p>
<ul>
<li>页表<ul>
<li>保存了逻辑地址-物理地址间的映射关系</li>
</ul>
</li>
<li>MMU/TLB（存储管理单元/快表，保证转换的高速进行）</li>
</ul>
<p>逻辑地址的页号是连续的，但是物理地址中的帧号是不连续的</p>
<p>不是所有的页都有对应的帧</p>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p><strong>概述</strong></p>
<p>页表结构：</p>
<ul>
<li>每个进程都有一个页表</li>
<li>每个页面对应一个页表项<ul>
<li>页表项组成：</li>
<li>帧号</li>
<li>页表项标志：存在位（如果逻辑页号有一个物理帧对应，则值为1）、修改位（内容是否修改）、引用位（是否在过去一段时间访问过）</li>
</ul>
</li>
<li>页表内容会随着进程运行状态而动态变化</li>
<li>存放在页表基址寄存器PTBR</li>
</ul>
<p>性能问题</p>
<ul>
<li>访问一个内存单元需要两次内存访问<ul>
<li>第一次：读页表项</li>
<li>第二次：访问数据</li>
</ul>
</li>
<li>页表大小问题<ul>
<li>页表可能非常大<ul>
<li>在32K的物理内存中，1K占一个页表项，则一共32项，一个页表项4字节，则128字节</li>
<li>64位机器，1K占一个页表项，64位地址可以表现的地址范围为2^64，页的大小是2^10（1024），即2^54个页面，一个页表项占64位，即8个字节</li>
</ul>
</li>
<li>64位机器里，页表大小非常大。<strong>因为地址总线一共有64位，即想获得一个地址需要64位，地址总线当中，前a位为页表项，后面的64-a位为偏移量</strong></li>
</ul>
</li>
</ul>
<p>解决办法</p>
<ul>
<li>缓存（快表，时间与空间的相邻性）</li>
<li>间接访问（即多级页表）</li>
</ul>
<p><strong>快表</strong></p>
<p>概念</p>
<ul>
<li>缓存近期访问的页表项<ul>
<li>在CPU里面，TLB使用关联存储实现，具备快速访问性能（但是CPU里面区域较小）</li>
<li>如果TLB命中，则物理页号可以很快被获取</li>
<li>未命中，对应表项更新到TLB当中</li>
</ul>
</li>
</ul>
<p><strong>多级页表</strong></p>
<p>概念</p>
<ul>
<li>通过间接引用将页号分为k级<ul>
<li>建立页表树，整个访问次数为k+1</li>
<li>减少每级页表长度</li>
</ul>
</li>
<li>在大地址空间中很繁琐，逻辑地址空间（随着进程增多而增多）增长速度很快</li>
</ul>
<p><strong>反置页表</strong></p>
<p>反置页表与页寄存器的解决办法</p>
<ul>
<li>不让页表与逻辑地址空间的大小相对应（因此随着进程增多而不会增大）</li>
<li>让页表与物理地址空间的大小相对应</li>
</ul>
<p><strong>页寄存器</strong></p>
<ul>
<li>每个帧与一个页寄存器关联，寄存器内容<ul>
<li>使用位：是否被进程占用</li>
<li>占用页号：对应页号p</li>
<li>保护位</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>页表大小相对于物理内存很小</li>
<li>页表大小与逻辑地址空间大小无关</li>
</ul>
<p>缺点</p>
<ul>
<li>页表信息对调后，需要依靠帧号可找页号</li>
<li>在页寄存器中搜索逻辑地址中的页号（较困难）</li>
</ul>
<p>地址转换</p>
<ul>
<li>CPU生产的逻辑地址如何找到对应物理地址<ul>
<li>对逻辑地址进行hash，减少搜索</li>
</ul>
</li>
<li>用快表缓存页表项后的页寄存器搜索步骤<ul>
<li>对逻辑地址进行hash查找</li>
<li>在块表中查找对应页表项</li>
<li>查找失败时，产生异常</li>
</ul>
</li>
<li>快表功耗等</li>
</ul>
<p><strong>反置页表</strong></p>
<ul>
<li>基于hash映射值查找对应页表项中的帧号（将进程标识加入一起进行hash，因为逻辑地址是与进程有关的，所以效率会高一点）<ul>
<li>hash结束的结果以页帧号进行排序</li>
</ul>
</li>
</ul>
<h1 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h1><p>段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势</p>
<p><strong>实现</strong></p>
<ul>
<li>在段式存储管理基础上，给每个段加一个一级页表</li>
</ul>
<p><img src="assets/1551448914482.png" alt="1551448914482"></p>
<p><strong>内存共享</strong></p>
<ul>
<li>通过指向相同的页表基址，实现进程间的段共享</li>
</ul>
<p><img src="assets/1551448957878.png" alt="1551448957878"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/OS/计算机操作系统（1）：基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/OS/计算机操作系统（1）：基本概念/" class="post-title-link" itemprop="url">计算机操作系统（1）：基本概念</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-02-28 14:48:18" itemprop="dateCreated datePublished" datetime="2019-02-28T14:48:18+08:00">2019-02-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-05-14 15:12:41" itemprop="dateModified" datetime="2019-05-14T15:12:41+08:00">2019-05-14</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/02/28/OS/计算机操作系统（1）：基本概念/" class="post-meta-item leancloud_visitors" data-flag-title="计算机操作系统（1）：基本概念">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/02/28/OS/计算机操作系统（1）：基本概念/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/28/OS/计算机操作系统（1）：基本概念/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a><strong><em>操作系统定义</em></strong></h3><ul>
<li>没有公认的精确定义</li>
<li>是一个控制程序<ul>
<li>一个系统软件</li>
<li>控制程序执行结果、防止错误和计算机的不当使用</li>
<li>执行用户程序，给用户程序提供各种服务</li>
<li>方便使用</li>
</ul>
</li>
<li>是一个资源管理器<ul>
<li>应用程序与硬件间的中间层</li>
<li>管理各种软硬件资源，提供访问资源的高效手段</li>
<li>解决资源的访问冲突，确保资源公平使用</li>
</ul>
</li>
</ul>
<p>操作系统下接CPU、磁盘、内存；上接进程、文件、地址空间。</p>
<h3 id="操作系统内核特征"><a href="#操作系统内核特征" class="headerlink" title="操作系统内核特征"></a><strong><em>操作系统内核特征</em></strong></h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行。</li>
</ul>
<h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><ul>
<li>共享是指系统中的资源可以被多个并发进程共同使用。</li>
<li>同时访问（宏观）</li>
<li>互斥共享（微观），互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。</li>
</ul>
<h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><ul>
<li>虚拟技术把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时分复用技术和空分复用技术。</li>
<li>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。</li>
<li>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li>
</ul>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul>
<li>程序的执行不是一贯到底，而是走走停停，以不可预知的速度推进</li>
<li>只要运行环境相同，OS要保证程序运行的结果也相同</li>
</ul>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a><strong><em>基本功能</em></strong></h3><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
<h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p>
<h4 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h4><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p>
<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>
<h2 id="为什么学习操作系统"><a href="#为什么学习操作系统" class="headerlink" title="为什么学习操作系统"></a>为什么学习操作系统</h2><p>学习操作系统的设计与实现</p>
<p>windows：封闭式系统</p>
<p>linux：开放式系统</p>
<h2 id="操作系统演变"><a href="#操作系统演变" class="headerlink" title="操作系统演变"></a>操作系统演变</h2><p><strong>单用户系统</strong></p>
<p>问题：昂贵组件的低利用率</p>
<p><strong>批处理系统</strong></p>
<p><strong>多程序系统</strong></p>
<p>保持多个工作在内存中，并且在各工作间复用CPU</p>
<p><strong>分时</strong></p>
<p>定时中断用于工作时对CPU的复用</p>
<p><strong>个人计算机</strong>：</p>
<p>效率已不是关注点，易用性为重点</p>
<p><strong>分布式计算</strong>：</p>
<p>高可用性与可靠性</p>
<h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><h3 id="大内核结构"><a href="#大内核结构" class="headerlink" title="大内核结构"></a>大内核结构</h3><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>
<p>由于各模块共享信息，因此有很高的性能。</p>
<h3 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h3><p>因为分层结构里面层次过多，效率低下。</p>
<p>尽可能将内核功能迁移到用户空间</p>
<p>用户模块间通信使用消息传递</p>
<p>好处：灵活、安全</p>
<p>缺点：性能。需要频繁在用户态与核心态之间切换</p>
<p><strong>外核结构</strong></p>
<p>让内核分配机器的物理资源给多个应用程序，并让每个程序控制如何使用资源。类似于虚拟机的结构</p>
<h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><ol>
<li>操作系统概念（第7版 Abraham Silberschatz）</li>
<li>操作系统精髓与设计原理（第7版 William Stallings）</li>
</ol>
<h1 id="启动、中断、异常、系统调用"><a href="#启动、中断、异常、系统调用" class="headerlink" title="启动、中断、异常、系统调用"></a>启动、中断、异常、系统调用</h1><h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><p>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。</p>
<p>此外还有时钟中断、控制台中断等。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>
<h3 id="陷入"><a href="#陷入" class="headerlink" title="陷入"></a>陷入</h3><p>在用户程序中使用系统调用。</p>
<h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>计算机系统的启动过程：</p>
<p>CPU加电之后如何启动，在内存当中有一段ROM，有一些数据。</p>
<p><img src="assets%5C1551342146180.png" alt="1551342146180"></p>
<p><strong>BIOS功能</strong>：</p>
<p>为系统启动提供服务</p>
<ul>
<li>基本输入输出程序：以中断调用的方式提供基本的IO功能</li>
<li>系统设置信息（硬盘启动、光盘启动等）</li>
<li>开机自检</li>
<li>系统自启动程序</li>
</ul>
<p>BIOS将加载程序加载进来，将操作系统的代码和数据加载到内存。</p>
<h2 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h2><p>BIOS：固化在主板上的程序，包括系统设置、自检、系统自启动程序</p>
<p><img src="assets/1551342567879.png" alt="1551342567879"></p>
<ul>
<li>CPU加电稳定后，在ROM中读第一条指令<ul>
<li>CPU初始状态为16位实模式</li>
</ul>
</li>
<li>BIOS初始化<ul>
<li>硬件自检POST，检测内存、显卡等工作状态，进行设备初始化</li>
<li>执行系统BIOS，进行系统自检，检测即插即用设备</li>
<li>更新CMOS中的扩展系统配置数据ESCD</li>
</ul>
</li>
<li>主引导记录记录MBR格式<ul>
<li>启动代码</li>
<li>硬盘分区表</li>
<li>结束标志</li>
</ul>
</li>
<li>分区引导扇区<ul>
<li>跳转指令，跳转到启动代码，与平台相关</li>
<li>文件卷头</li>
<li>启动代码，跳转到加载程序</li>
<li>结束代码</li>
</ul>
</li>
<li>加载程序</li>
</ul>
<p><img src="assets%5C1551342910109.png" alt="1551342910109"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/26/Java/base/Java并发：并发基础概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/26/Java/base/Java并发：并发基础概述/" class="post-title-link" itemprop="url">java并发：并发基础概述</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-02-26 19:59:31" itemprop="dateCreated datePublished" datetime="2019-02-26T19:59:31+08:00">2019-02-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-07-31 11:11:20" itemprop="dateModified" datetime="2019-07-31T11:11:20+08:00">2019-07-31</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/02/26/Java/base/Java并发：并发基础概述/" class="post-meta-item leancloud_visitors" data-flag-title="java并发：并发基础概述">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/02/26/Java/base/Java并发：并发基础概述/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/26/Java/base/Java并发：并发基础概述/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          并发基础
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/02/26/Java/base/Java并发：并发基础概述/">
                Weiterlesen &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/26/计算机网络/计算机网络：HTTP协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/26/计算机网络/计算机网络：HTTP协议/" class="post-title-link" itemprop="url">计算机网络：HTTP协议</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-02-26 16:31:34" itemprop="dateCreated datePublished" datetime="2019-02-26T16:31:34+08:00">2019-02-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-04-21 20:08:15" itemprop="dateModified" datetime="2019-04-21T20:08:15+08:00">2019-04-21</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/02/26/计算机网络/计算机网络：HTTP协议/" class="post-meta-item leancloud_visitors" data-flag-title="计算机网络：HTTP协议">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/02/26/计算机网络/计算机网络：HTTP协议/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/26/计算机网络/计算机网络：HTTP协议/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="了解Web及网络基础"><a href="#了解Web及网络基础" class="headerlink" title="了解Web及网络基础"></a>了解Web及网络基础</h1><p>web是建立在何种技术上，HTTP协议是如何诞生并发展的</p>
<p>使用HTTP协议访问web</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>超文本传输协议（HYperText Transfer Protocol）</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>由两个程序实现：一个客户程序和一个服务器程序。运行在不同的端系统当中，通过交换HTTP报文进行会话。</li>
<li>HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式</li>
<li>HTTP定义了web客户向web服务器请求web页面的方式，以及服务器向客户传送web页面的方式</li>
<li>HTTP使用TCP作为支撑运输协议。一旦连接建立，即可以通过套接字接口访问TCP</li>
<li>HTTP是无状态协议。不会存储任何关于客户的状态信息<ul>
<li>即使一个客户在短时间内两次请求同一个对象，服务器不会因为刚为该客户提供了对象而不再做出反应，而是重新发送该对象</li>
<li>简化了服务器设计，允许工程师开发可以同时处理数千TCP连接的高性能web服务器</li>
</ul>
</li>
</ul>
<p><strong>web术语</strong></p>
<p>web页面是由对象组成的。</p>
<ul>
<li>一个对象只是一个文件。如HTML文件、JPEG图形、Java小程序、一个视频片段这样的文件。且它们可通过一个URL地址寻址。<ul>
<li>多数web页面含有一个<strong>HTML基本文件</strong>，以及几个引用对象</li>
<li>如一个Web页面包含HTML文本和5个JPEG图形，则拥有6个对象。HTML基本文件通过对象的URL地址引用页面的其他对象<ul>
<li>URL组成：存放对象的服务器主机名和对象的路径名。<a href="http://www.someSchool.edu(主机名)/someDepartment/picture.gif（路径名）" target="_blank" rel="noopener">http://www.someSchool.edu(主机名)/someDepartment/picture.gif（路径名）</a></li>
</ul>
</li>
</ul>
</li>
<li>web浏览器实现了HTTP的客户端</li>
<li>web服务器实现了HTTP的服务器端，用于存储web对象，每个对象由URL寻址。流行的服务器由Apache和IIS</li>
</ul>
<h2 id="非持续连接与持续连接"><a href="#非持续连接与持续连接" class="headerlink" title="非持续连接与持续连接"></a>非持续连接与持续连接</h2><p>非持续连接：每个<strong>请求\响应对</strong>是经一个单独的TCP连接发送，即传输一个请求报文和一个响应报文</p>
<p>持续连接：所有的请求及响应经相同的TCP连接发送</p>
<p><strong>采用非持续连接的HTTP</strong></p>
<p>当服务器向客户传送一个web页面（包含1个HTML与10个JPEG，并存储在一台服务器上）</p>
<ul>
<li>HTTP客户进程在端口80（HTTP的默认端口，在客户和服务器上分别有一个套接字与该连接相关联）发起一个到服务器www,someSchool.edu的TCP连接。</li>
<li>HTTP客户经它的套接字向该服务器发送一个HTTP请求报文。报文包含路径名/someDepartment/home.index</li>
<li>HTTP服务器进程经套接字接受该请求报文，从存储器中检索出该对象home.index，在一个HTTP相应报文中封装对象，并通过其套接字发送响应报文</li>
<li>HTTP服务器进程通知TCP断开该TCP连接。</li>
<li>HTTP客户接受响应报文，TCP连接关闭。报文指出封装的是一个HTML文件，客户从响应报文中提取出文件，检查文件，得到10个JPEG的图形引用</li>
<li>对每个引用的JPEG重复前步骤（可能串行，可能并行）</li>
</ul>
<p>缺陷：</p>
<ul>
<li>每一个新的请求都要建立和维护一个全新的连接，针对每个链接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量。</li>
<li>每一个对象经受2倍的RTT交付时延</li>
</ul>
<p><strong>持续连接的HTTP</strong></p>
<p>服务器在发送响应后，保持该TCP连接打开，在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。</p>
<ul>
<li>带流水线的持续连接：一个接一个地发出对对象的请求，而不必等待对未决请求的回答</li>
<li>不带流水线的</li>
</ul>
<h2 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h2><p><strong>请求报文</strong></p>
<p><strong>响应报文</strong></p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>用户与服务器的交互：cookie</p>
<p><strong>作用</strong></p>
<ul>
<li>允许站点对用户进行跟踪，将内容与用户身份联系起来，标识一个用户。</li>
<li>在无状态的HTTP上建立了一个用户会话层。但是对用户隐私的一种侵害</li>
</ul>
<p><strong>概述</strong></p>
<p>cookie技术的4个组件：</p>
<ul>
<li>在HTTP响应报文中的一个cookie首部行</li>
<li>在HTTP请求报文中的一个cookie首部行</li>
<li>在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理</li>
<li>位于web站点的一个后端数据库</li>
</ul>
<p>cookie实现了站点对用户的跟踪。它可以确切的知道，cookie值为x的用户，按什么顺序、在什么时间访问了哪些页面。因此可以在之后向其推荐相关内容。</p>
<h2 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h2><p>web缓存器也叫代理服务器</p>
<p><strong>作用</strong></p>
<ul>
<li>web缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与web缓存器间的瓶颈带宽</li>
<li>web缓存器可以大大减少一个机构的接入链路到因特网的通信量。因此，该机构不必急于增加带宽，因此降低了费用</li>
<li>整体上大大降低了因特网上的Web流量，改善所有应用性能</li>
</ul>
<p><strong>概述</strong></p>
<ul>
<li>能够代表初始web服务器来满足HTTP请求的网络实体。有自己的磁盘存储，在存储空间保存最近请求过的对象的副本。</li>
<li>可以配置用户的浏览器，使得用户的所有HTTP请求首先指向web缓存器</li>
</ul>
<p>web缓存器通常由ISP购买并安装</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>内容分发网络（Content Distribution Network）,Web缓存器正在因特网中发挥着越来越重要的作用。</p>
<h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><p>如何创建报文、如何理解报文。</p>
<ul>
<li>报文是如何流动的</li>
<li>HTTP报文的三个组成部分（起始行、首部和实体的主体部分）</li>
<li>请求和响应报文间的区别</li>
<li>请求报文支持的各种功能（方法）</li>
<li>和响应报文一起返回的各种状态码</li>
<li>各种各样的HTTP首部都是用来干什么的</li>
</ul>
<h2 id="报文流"><a href="#报文流" class="headerlink" title="报文流"></a>报文流</h2><p>HTTP报文是在HTTP应用程序间发送的数据块。报文在客户端、服务器和代理间流动。“流出”、“流入”、“上游”、“下游”都是描述报文方向的</p>
<ul>
<li>数据块以一些文本形式的<strong>元信息</strong>开头，描述了报文的内容和含义</li>
<li>后面跟着可选的数据部分</li>
</ul>
<h3 id="报文流入源端服务器"><a href="#报文流入源端服务器" class="headerlink" title="报文流入源端服务器"></a>报文流入源端服务器</h3><p>HTTP使用术语流入、流出描述事务处理的方向。</p>
<p>报文流入源端服务器，工作完成后，会流回用户的Agent代理中。</p>
<p><img src="assets/1555161443581.png" alt="1555161443581"></p>
<h3 id="报文向下游流动"><a href="#报文向下游流动" class="headerlink" title="报文向下游流动"></a>报文向下游流动</h3><p>无论是请求报文还是响应报文，所有报文都会向下游流动。</p>
<p>所有报文的发送者都在接收者的上游。</p>
<p><img src="assets/1555161432557.png" alt="1555161432557"></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>服务器并不需要实现所有的方法，如果兼容HTTP1.1，只要为资源实现GET方法和HEAD方法。</p>
<p>即使服务器实现了所有的方法，方法的使用可能也是受限的。如DELETE方法或PUT方法的服务器，可能并不希望任何人都能够删除或存储资源。这些限制通常在服务器的配置当中进行设置的，因此会随着站点和服务器的不同而不同</p>
<h3 id="安全方法"><a href="#安全方法" class="headerlink" title="安全方法"></a>安全方法</h3><p>HTTP定义了安全方法包括GET、HEAD方法。</p>
<p><strong>目的</strong>是允许HTTP应用程序开发者通知用户，什么时候会使用某个可能引发动作的不安全方法。</p>
<ul>
<li>安全方法意味着使用GET或HEAD方法的HTTP请求都不会产生什么动作。<ul>
<li>不产生动作：HTTP请求不会再服务器上产生什么结果。</li>
</ul>
</li>
<li>并不一定什么动作都不执行，实际上是由WEB开发者决定的。</li>
</ul>
<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>通常用于请求服务器发送某个资源。HTTP1.1要求服务器实现该方法。</p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>与GET类似，服务器在响应中只返回首部，不会反悔实体的主体部分。HTTP1.1要求实现该方法</p>
<ul>
<li>允许客户端在未获取实际资源的情况下，对资源的首部进行检查。判断其类型</li>
<li>通过查看响应中的状态码，查看某个对象是否存在</li>
<li>通过查看首部，测试资源是否被修改了。</li>
</ul>
<p>服务器开发者必须确保HEAD方法返回的首部与GET请求返回的首部完全相同。</p>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>向服务器写入文档。</p>
<p>PUT：让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档。如果该URL已经存在，则用这个主体替代它。</p>
<p>由于PUT允许用户对内容进行修改，因此很多web服务器要求在执行PUT前用密码登录</p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>起初是用来向服务器输入数据的。</p>
<p>通常用于支持表单。</p>
<p><strong><em>使用post请求的情况</em></strong></p>
<ul>
<li><p>无法使用缓存文件（更新服务器上的文件或数据库）</p>
</li>
<li><p>向服务器发送大量数据</p>
</li>
<li><p>发送包含未知字符的用户输入时，post比Get更稳定可靠</p>
</li>
<li><p>Post比Get安全性更高</p>
</li>
</ul>
<h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子</p>
<ul>
<li>客户端发起一个请求，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求</li>
</ul>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>请求WEB服务器告知其支持的各种功能。</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>请服务器删除请求URL所指定的资源。</p>
<p>但是客户端应用程序无法保证删除操作一定会执行，HTTP规范允许服务在不通知客户端的情况下撤销请求。</p>
<h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p><strong><em>Get和Post的区别</em></strong></p>
<ul>
<li>get被服务器强制支持</li>
<li>浏览器对URL长度有限制，因此get请求不能代替post发送大量数据</li>
<li>get请求发送数据量更小</li>
<li>get请求是幂等的</li>
<li>Post请求不能被缓存</li>
<li>post请求相对于Get是安全的</li>
</ul>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><h2 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a><a href="http://zhangchangle.com/#/notes/HTTP?id=_1xx-%e4%bf%a1%e6%81%af" target="_blank" rel="noopener">1XX 信息</a></h2><ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a><a href="http://zhangchangle.com/#/notes/HTTP?id=_2xx-%e6%88%90%e5%8a%9f" target="_blank" rel="noopener">2XX 成功</a></h2><ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a><a href="http://zhangchangle.com/#/notes/HTTP?id=_3xx-%e9%87%8d%e5%ae%9a%e5%90%91" target="_blank" rel="noopener">3XX 重定向</a></h2><ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a><a href="http://zhangchangle.com/#/notes/HTTP?id=_4xx-%e5%ae%a2%e6%88%b7%e7%ab%af%e9%94%99%e8%af%af" target="_blank" rel="noopener">4XX 客户端错误</a></h2><ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong></li>
</ul>
<h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a><a href="http://zhangchangle.com/#/notes/HTTP?id=_5xx-%e6%9c%8d%e5%8a%a1%e5%99%a8%e9%94%99%e8%af%af" target="_blank" rel="noopener">5XX 服务器错误</a></h2><ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTP协议中有可能存在信息窃听或身份伪装等安全问题。</p>
<p>HTTPS通信机制可以有效地防止这些问题。</p>
<h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><ul>
<li>通信使用明文（不加密），内容可能被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能已遭篡改</li>
<li>等</li>
</ul>
<p><strong>通信使用明文可能被窃听</strong></p>
<p>HTTP本身不具备加密的功能，因此也无法做到对通信整体进行加密。</p>
<ul>
<li>TCP/IP是可能被窃听的网络<ul>
<li>以TCP/IP的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。</li>
<li>即使已经过加密处理的通信，也会被窥视到通信内容，只是可能让人无法破译密文的含义</li>
<li>窃听方式：收集在互联网上流动的数据包（帧）<ul>
<li>对于收集来的数据包的解析工作，可通过抓包或者嗅探工具</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><em>加密处理可防止被窃听</em></strong></p>
<p>加密对象：</p>
<ul>
<li>通信的加密。<ul>
<li>通过和SSL或TLS组合使用，加密HTTP的通信内容。</li>
</ul>
</li>
<li>内容的加密<ul>
<li>将报文中包含的内容进行加密处理，客户端需要对HTTP报文进行加密处理后再发送请求</li>
<li>要求客户端和服务端具备加密和解密机制。</li>
<li>内容具有被篡改的风险</li>
</ul>
</li>
</ul>
<p><strong>不验证通信方的身份，因此有可能遭遇伪装</strong></p>
<p>即存在服务器是否就是发送请求中URI真正指定的主机？</p>
<p>返回的响应是否真的返回实际提出请求的客户端等问题。</p>
<ul>
<li>任何人都可发起请求。不存在确认通信方的处理步骤，服务器只要接受到请求，就会返回一个响应<ul>
<li>无法确认请求发送至目标的web服务器是否按真实意图返回响应的那台服务器，可能是已伪装的web服务器</li>
<li>无法确认响应返回到的客户端是否按真实意图接受响应的那个客户端，可能是已伪装的客户端</li>
<li>无法确定正在通信的双方是否具备访问权限。因为某些web服务器上保存着重要信息，只想发送给特定用户通信的权限</li>
<li>无法判定请求是来自何方、出自谁手</li>
<li>即使是无意义的请求也会照单全收。无法阻止海量请求下的DOS攻击</li>
</ul>
</li>
</ul>
<p><strong><em>查明对手的证书</em></strong></p>
<p>SSL使用了证书的手段，用于确认方</p>
<p>伪造证书从技术角度讲异常困难。通过确认通信方持有的证书，即可判断通信方的真实意图</p>
<ul>
<li>服务器持有证书，即意料中的服务器</li>
<li>客户端持有证书，即完成个人信息的确认，页可以用于对web网站的认证环节</li>
</ul>
<p><strong>无法证明报文完整性、可能已经被篡改</strong></p>
<p>没有办法确认，发出的请求/响应和接受到的请求/响应是前后相同的。</p>
<ul>
<li>文件可能在传输途中被更改（中间人攻击MITM）</li>
</ul>
<p><strong><em>防止篡改</em></strong>：</p>
<ul>
<li>MD5与SHA-1等散列值校验的方法</li>
<li>用来确认<strong>文件</strong>的数字签名方法</li>
<li>都需要客户端的用户本人亲自检查验证是否是原来服务器上的文件，浏览器无法自动帮助用户检查</li>
</ul>
<p>如果数字前面与MD5本身被改写，用户是没有办法意识到的。</p>
<h2 id="HTTPS定义"><a href="#HTTPS定义" class="headerlink" title="HTTPS定义"></a>HTTPS定义</h2><p>HTTP+加密+认证+完整性保护=HTTPS</p>
<ul>
<li>HTTPS是身披SSL外壳的HTTP。</li>
<li>当使用SSL，HTTP先和SSL通信，SSL再和TCP通信。</li>
</ul>
<h1 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h1><h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><p>混合加密机制</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/18/Java/base/java并发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/18/Java/base/java并发/" class="post-title-link" itemprop="url">java并发</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-02-18 23:05:11" itemprop="dateCreated datePublished" datetime="2019-02-18T23:05:11+08:00">2019-02-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-05-06 12:47:23" itemprop="dateModified" datetime="2019-05-06T12:47:23+08:00">2019-05-06</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/02/18/Java/base/java并发/" class="post-meta-item leancloud_visitors" data-flag-title="java并发">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/02/18/Java/base/java并发/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/18/Java/base/java并发/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="十一、线程安全"><a href="#十一、线程安全" class="headerlink" title="十一、线程安全"></a>十一、线程安全</h1><p>​    多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​    编写线程安全的代码，本质上就是管理对<strong>状态</strong>的访问，而且通常都是<strong>共享、可变</strong>的状态。</p>
<p>​    一个对象的状态就是它的数据，存储在状态变量中，如静态域、实例域。共享即一个变量可以被多个线程访问。可变即变量的值在其生命周期内都可以改变。真正要做到的线程安全是在不可控制的并发访问当中保护数据。</p>
<p>​    无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。</p>
<p>​    java的同步机制：synchronized(独占锁)，volatile(显示锁和原子变量的使用)</p>
<p>​    修复同步隐患</p>
<ul>
<li>不跨线程的共享变量</li>
<li>使用状态变量为不可变的</li>
<li>在任何访问状态变量的时候使用同步</li>
</ul>
<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><ul>
<li>无状态的对象永远是安全的。即指这个对象没有状态域，也没有引用其他对象的域，是一次特定计算的瞬时状态，会唯一存放在一个本地变量当中，即线程的栈当中。而两个线程并不共享状态。</li>
</ul>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>​    原子性：能作为一个单独的、不可分割的操作去执行</p>
<p>​    当向一个无状态的对象添加一个域，并进行long++操作（读+改+写），则不是线程安全</p>
<p>​    将long换作一个atomic包下的AtomicLong变量，则由于该变量是一个原子变量类，该计数器是线程安全的，该对象的状态即该计数器的对象，即该对象线程安全。（利用已有的线程安全类进行管理，如果只有一个，则线程安全，如果多个，则未必线程安全）</p>
<p>​    当变量之间相互关联，则在一个原子操作当中，要将几个相互关联的变量同时更新</p>
<p><strong>竞争条件</strong></p>
<p>​    想得到正确的答案，依赖时序。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="内部锁（互斥锁）"><a href="#内部锁（互斥锁）" class="headerlink" title="内部锁（互斥锁）"></a>内部锁（互斥锁）</h4><p>​    synchronized块，声明方法</p>
<p><strong>特性</strong></p>
<ul>
<li><p>重进入：内部锁是重进入的，当线程试图获得它自己所占有的锁时候，请求会成功，即重进入是基于每<strong>线程</strong>的，而不是调用。</p>
<p>实现是通过为每个锁关联一个请求计数与一个占有它的线程，当同一线程访问，则计数++，线程退出该锁，则计数–，直到计数为0，释放该锁（父类与子类的使用）</p>
</li>
</ul>
<p><strong>用锁来保持状态</strong></p>
<ul>
<li>如果每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行状态当中占有同一个锁，则称该变量是由这个锁保护的</li>
<li>每个共享的可变变量都需要唯一一个确定的锁保护</li>
</ul>
<p><strong>设计</strong></p>
<ul>
<li>决定synchronize块大小需要权衡安全性（不能妥协）、简单性、性能。通常简单性与性能相互牵制，实现一个同步策略时候，不要过早地为了性能而牺牲简单性（是对安全性潜在的妥协）</li>
<li>有些耗时的计算或操作，如网络或者控制台IO，难以快速完成，执行它们的时候不要占有锁</li>
</ul>
<h3 id="活跃度与性能"><a href="#活跃度与性能" class="headerlink" title="活跃度与性能"></a>活跃度与性能</h3><p>​    不能武断地将整个方法设置为synchronize的，通过缩小synchronize的范围来提高并发性</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550563393365.png" alt="1550563393365"></p>
<h2 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h2><p>​    在前面，使用同步来避免多个线程在同一时间访问同一数据，在该部分，进行共享和发布对象，使得多个线程可以安全地访问他们。</p>
<p>​    同步的两个方面：</p>
<ul>
<li>原子操作</li>
<li>内存可见性，即一个线程修改了对象的状态后，其他线程能够真正地看到改变</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>​    重排序现象：在单个线程当中，只要重排序不会对结果产生影响，则不能保证操作一定按照程序写定的顺序执行（java虚拟机的高性能）</p>
<p>​    如果数据需要跨线程共享，就要进行恰当的同步。</p>
<p><strong>过期数据</strong></p>
<p>​    当读线程检查一个变量时，可能看到一个过期的数据。并且过期不会发生在全部变量上，也不会完全不出现。</p>
<p>​    对于get与set方法，同样需要同步化，进行synchronize</p>
<p><strong>锁与可见性</strong></p>
<p>​    锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能看到共享的、可变变量的最新值，读取和写入线程必须使用公共的锁进行同步</p>
<p>​    volatile：弱同步，确保对一个变量的更新以可预见的方式告知其他线程</p>
<h3 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h3><p>​    发布：发布一个对象指它能够被当前范围以外的代码所使用。发布一个对象，同时将发布该对象所有的非私有域引用的对象。</p>
<p>​    逸出：一个对象在尚未准备好的时候就发布</p>
<p>发布方式：</p>
<ul>
<li>将对象存放到公共静态域</li>
</ul>
<p>逸出：</p>
<ul>
<li><p>this引用在构造期间逸出，即对象在没有通过构造函数构造完毕（执行到了构造函数的某一句）时候逸出。</p>
<p>当对象在构造函数当中创建一个线程，this引用总是被新线程共享，</p>
</li>
</ul>
<h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><p>​    访问共享的、可变的数据要求使用同步。一个可以避免同步的方法就是不共享数据，如果数据仅仅在单线程当中访问，则不需要任何同步。当对象封装在一个线程当中，则自动成为线程安全的。</p>
<ul>
<li>Swing将事件分发到线程当中</li>
<li>JDBC从池中分配一个对象给线程。</li>
</ul>
<p><strong>Ad-hoc线程限制</strong></p>
<p>​    指维护线程限制性的任务全部落在实现上的情况</p>
<ul>
<li>确保只通过单一线程写入共享的volatile变量，则操作便是共享</li>
</ul>
<p><strong>栈限制</strong></p>
<p>​    是线程限制的特例，只能通过本地变量才可以触及对象。本地变量使得对象更容易被限制在线程本地中<strong>，本地变量本身就被限制在执行线程</strong>中，它们存在于执行线程栈。其他线程无法访问这个栈</p>
<p>​    例如方法当中的numPairs</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550587826303.png" alt="1550587826303"></p>
<p>​    在该方法当中，实例化的animals只有一个引用指向它，因此它保存在线程的栈当中，倘若发布了animals或其内部对象的引用，则破坏了限制，并导致了对象逸出</p>
<p><strong>ThreadLocal</strong></p>
<p>​    更规范的方式，允许将每个线程与持有数值的对象关联在一起。ThradLocal提供了get和set，为每个使用它的线程维护一份单独的拷贝，所以get总是返回当前执行线程通过set设置的最新值。</p>
<blockquote>
<p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被<code>private static</code>修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
</blockquote>
<p>​    总的来说，<strong>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</strong></p>
<h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>​    创建后不能被修改的对象称为不可变对象，不可变对象永远是线程安全的。</p>
<p>不可变对象特征：</p>
<ul>
<li>状态创建后不能再修改</li>
<li>所有域都是final类型（不获得可变对象的引用）</li>
<li>对象被正确创建，不逸出this</li>
</ul>
<h3 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h3><p>​    如果希望跨线程共享对象，则必须安全地共享它</p>
<p>​    对象的引用对其他线程可见，但它的状态可能是过期的，即对象的状态不一定对消费线程可见。</p>
<p><strong>安全发布的模式</strong></p>
<ul>
<li>通过静态初始化器初始化对象的引用（JVM内部的同步机制）</li>
<li>将它的引用存储到volatile域或者atomicReference</li>
<li>将它的引用存储到正确创建的对象的final域</li>
<li>或者将它的引用存储到由锁正确保护的域中</li>
</ul>
<p><strong>线程安全容器</strong></p>
<p>​    线程安全容器的内部同步，即将对象置入这些容器的操作符合最后一条要求</p>
<ul>
<li>HashTable、synchronizedMap、concurrentMap</li>
<li>Vector、CopyOnWriteArrayList、synchronizedList</li>
<li>BlockingQueue、concurrentLinkedQueue</li>
</ul>
<p><strong>高效不可变对象</strong></p>
<p>​    一个对象在技术上不是不可变得，但是它的状态在发布后不会再更改，即有效不可变对象。</p>
<blockquote>
<p>任何线程都可以在没有额外同步的情况下安全使用一个<strong>安全发布</strong>的高效不可变对象</p>
</blockquote>
<p><strong>可变对象</strong></p>
<p>​    安全发布仅仅保证发布当时的可见性，对于可变性，还需要线程安全或锁</p>
<ul>
<li><p>可变对象必须要安全发布，同时必须要线程安全或者是锁保护的</p>
<blockquote>
<ul>
<li>线程限制：一个线程限制的对象，通过限制在线程中，而被线程独占，且只能被占有它的线程修改</li>
<li>共享只读：在没有额外同步的情况下可以被多个对象并发访问，但是任何线程都不可以修改它，包括可变对象和高效不可变对象</li>
<li>共享线程安全：一个线程安全的对象在内部同步，所以其他线程无须额外同步，就可以通过公共接口访问</li>
<li>被守护的：一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布对象</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="组合对象"><a href="#组合对象" class="headerlink" title="组合对象"></a>组合对象</h1><p>​    构造类的模式，使得类更容易成为线程安全的，并且不会使程序意外破坏类的线程安全性</p>
<h2 id="设计线程安全的类"><a href="#设计线程安全的类" class="headerlink" title="设计线程安全的类"></a>设计线程安全的类</h2><blockquote>
<p>设计线程安全类的过程的基本要素</p>
<ul>
<li>确定对象状态是由哪些变量构成的（linkedList状态包含了所有存储在链表中节点对象的状态）</li>
<li>确定限制状态变量的不变约束</li>
<li>制定一个管理并发访问对象状态的策略</li>
</ul>
</blockquote>
<h3 id="同步策略"><a href="#同步策略" class="headerlink" title="同步策略"></a>同步策略</h3><blockquote>
<p>同步策略定义了对象如何协调对其状态的访问，并且不会违反它的不变约束或后验条件。规定了如何把不可变性、线程限制、锁结合起来，从而维护线程的安全性，还指明了哪些锁维护哪些变量</p>
</blockquote>
<p>​    状态空间：对象与变量可能处于状态的范围</p>
<p>​    <strong>操作的后验条件</strong>：对状态的值进行检验，如果不符合，则异常</p>
<p>​    状态转换：一个对象的下一个状态源于当前状态。如果某些状态是非法的，则必须封装该状态下的状态变量，否则客户代码会将对象置于非法状态。如果一个操作的过程当中出现非法状态，则该操作必须是原子的</p>
<p><strong>状态依赖的操作</strong></p>
<p>​    某些对象的方法基于对象的先验条件，例如无法从空队列移除一个对象。在多线程当中，原本为假地先验条件可能在后续为真</p>
<p><strong>状态所有权</strong></p>
<h2 id="实例限制"><a href="#实例限制" class="headerlink" title="实例限制"></a>实例限制</h2><p>​    即使对象不是线程安全的，依然可以使得它安全用于多线程，比如确保其只在单一线程被访问（线程限制）、类实例（private的类成员）、语汇范围（本地变量），要确保不逸出</p>
<blockquote>
<p>​    将数据封装在对象内部，把对数据的访问限制在对象的方法（线程安全的锁或。。。）上，更容易确保线程在访问数据时总能获得正确的锁。</p>
<p>​    限制性使得构造线程安全的类变得容易，因为类的状态被限制后，分析它的线程安全性便不需要检查完整的程序。</p>
</blockquote>
<p><strong>java监视器模式</strong></p>
<p>​    遵循java监视器模式的对象封装了所有的可变状态，并且由对象自己的内部锁保护</p>
<p>​    对于凭空创建一个类，或者使用非线程安全的对象组装一个类时，非常有效</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550634538699.png" alt="1550634538699"></p>
<p>​    内部锁：将synchronize添加到方法上</p>
<h2 id="委托线程安全"><a href="#委托线程安全" class="headerlink" title="委托线程安全"></a>委托线程安全</h2><p>​    如果类的状态组件都是线程安全的，则监视器模式的使用需要视情况而定，它是一个额外的线程安全层。如果类组件都是线程安全的，那么可以说类将它的线程安全委托给了它的组件，因为组件安全，所以它也是安全的。</p>
<p>​    如果将线程安全委托到多个隐含的状态变量上，只要这些变量相互独立，组合对象未增加任何涉及多个状态变量的<strong>不变约束</strong></p>
<blockquote>
<p>​    如果一个类由多个彼此相互独立的线程安全的状态变量组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态变量</p>
</blockquote>
<p><strong>发布底层的状态变量</strong>（类组件）</p>
<blockquote>
<p>​    如果一个状态变量是线程安全的，没有任何的不变约束限制它的值，并且没有任何状态转换限制它的操作，那么它可以被安全发布</p>
</blockquote>
<h2 id="向已有的线程安全类添加功能"><a href="#向已有的线程安全类添加功能" class="headerlink" title="向已有的线程安全类添加功能"></a>向已有的线程安全类添加功能</h2><ul>
<li>修改原始的类。但通常不可能，首先需要理解原始类的同步策略，其次要有修改源码的权限</li>
<li>继承扩展，但并非所有类给子类暴露了足够多的状态，并且子类可能被底层类不知不觉破坏</li>
<li>扩展功能。</li>
</ul>
<p><strong>客户端加锁</strong></p>
<p>​    将扩展代码与类置于一个新类当中</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550636338076.png" alt="1550636338076"></p>
<p>​    但是这样并不正确，因为给方法加锁，但是这个锁与list的锁并不一致，方法所用的锁与list用于客户端加锁与外部加锁时用的锁并不一致。</p>
<p>​    正确写法：</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550641893865.png" alt="1550641893865"></p>
<p>​    相比于扩展类，在客户端加锁更加脆弱，会破坏同步策略的封装性</p>
<p><strong>组合</strong></p>
<p>​    使用内部锁，基于java监视器实现了新的一层锁，只要持有list的唯一引用，则是线程安全的</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550642087788.png" alt="1550642087788"></p>
<h1 id="构建块"><a href="#构建块" class="headerlink" title="构建块"></a>构建块</h1><p>​    线程安全容器以及多种同步工具（synchronizer），synchronizer可以调节相互协作的线程间的控制流。</p>
<h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><p>​    包括Vector和HashTable，这些类通过封装它们的状态，并对每一个公共方法进行同步实现了线程安全，这样一次只能有一个线程访问容器。通过对容器的所有状态串行访问实现的线程安全，削弱了并发性。</p>
<p>​    容器本身是线程安全的，无论有多少线程同时调用容器，也不会破坏容器。但是对于方法的调用者来说，当线程在并发地修改容器，最后得到的结果并不是所预期的结果。面对这种情况，需要对容器类自身进行加锁，synchronized(list)。保证复合操作的原子性</p>
<p><strong>迭代</strong></p>
<p>​    对容器进行迭代的时候，需要对容器进行加锁，防止容器数据更改，但是这么一来对并发的性能就大大下降，会在相当长时间加锁，甚至产生死锁。一个解决办法是复制容器，因为是存在线程当中，但是在复制过程中依然需要加锁，而且占用空间。</p>
<blockquote>
<p>​    正如封装一个对象的状态，能够使它更容易地保持不变约束一样，封装它的同步则可以迫使它符合同步策略</p>
</blockquote>
<p>​    隐藏迭代器：有些迭代器是隐藏的，比如toString方法，hashCode方法，equals方法都会对容器进行迭代</p>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>​    为多线程的并发访问而设计。concurrentHashMap代替同步的HashMap，当多数操作为读取，CoayOnWriteArrayList是List的同步，concurrentMap接口增加了常见复合操作的支持</p>
<blockquote>
<p>​    用并发容器替换同步容器，这种做法以有很小的风险带来了可扩展性显著提高</p>
</blockquote>
<p><strong>ConcurrentHashMap</strong></p>
<p>​    在该容器前，程序使用一个公共锁同步每一个方法，明确只有一个线程可以访问容器</p>
<p>​    ConcurrentHashMap使用更细化的锁机制，即<strong>分离锁</strong>，任意数量的读线程可以并发访问，读者与写者可以并发访问，有限数量的写进程可以并发修改。该容器的迭代器具有<strong>弱一致性</strong>，即该迭代器容许并发修改，它会感应到迭代器被创建后对容器的修改。</p>
<p>​    在独占的访问加锁中，该容器无法胜任</p>
<h2 id="阻塞和可中断方法"><a href="#阻塞和可中断方法" class="headerlink" title="阻塞和可中断方法"></a>阻塞和可中断方法</h2><p>​    阻塞状态：blocked，waiting，Timed_waiting</p>
<p>​    中断：thread.interrupt()，中断是一种协作机制，</p>
<h2 id="synchronizer"><a href="#synchronizer" class="headerlink" title="synchronizer"></a>synchronizer</h2><h1 id="构建并发应用程序"><a href="#构建并发应用程序" class="headerlink" title="构建并发应用程序"></a>构建并发应用程序</h1><p>​    大多数的并发程序是围绕<strong>任务</strong>进行管理，任务即抽象、离散的工作单元</p>
<h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p><strong>在线程中执行任务</strong></p>
<p>指明任务的边界，使得任务为一个独立的活动，不依赖其他任务的状态、结果、边界效应。</p>
<p>任务边界：</p>
<ul>
<li>单独的客户请求</li>
</ul>
<p>任务执行策略：</p>
<ul>
<li><p>顺序执行</p>
<p>即收到一个请求，服务器要处理完该请求才能继续accept下一个请求</p>
</li>
</ul>
<p><img src="assets%5C1550825942991.png" alt="1550825942991"></p>
<ul>
<li>显式地为任务创建线程，为每一个服务请求创建一个线程<ul>
<li>并行处理，并且能同时接受多个请求</li>
<li>任务处理代码必须线程安全</li>
<li>线程生命周期的开销、资源消耗、无限制线程的稳定性拖垮系统</li>
</ul>
</li>
</ul>
<p><img src="assets%5C1550825994345.png" alt="1550825994345"></p>
<p><strong>Exeutor框架</strong></p>
<p>​    基于生产者-消费者模式，提交任务的执行者是生产者，执行任务的线程是消费者。</p>
<p>​    该框架可以用于异步任务执行，并且支持多种类型的任务执行策略，为任务提交与任务执行做了解耦。</p>
<p><img src="assets%5C1550988548365.png" alt="1550988548365"></p>
<p><strong>执行策略</strong></p>
<p>​    任务的提交与任务的执行解耦，可以更简单地为一个类给定的任务制定执行策略，一个执行策略包含“what where when how”的因素</p>
<ul>
<li>任务在什么线程执行 what</li>
<li>任务以什么顺序执行 what (FIFO,LIFO,优先级)</li>
<li>可以由多少个任务并发执行 how many</li>
<li>可以有多少个任务进入等待执行队列 how many</li>
<li>如果系统过载，需要放弃一个任务，选择哪一个任务？如何通知应用程序 which</li>
<li>在一个任务执行前与后，应该做什么处理 what</li>
</ul>
<p><strong>生命周期</strong></p>
<p>​    由于exectuor异步执行任务，所以之前提交的任务状态不能立即可见（有些已经完成，有些正在运行，有些在队列当中），如果将其关闭，可能出现各种问题</p>
<h2 id="取消和关闭"><a href="#取消和关闭" class="headerlink" title="取消和关闭"></a>取消和关闭</h2><p>​    中断，一种协作机制，使得一个线程能够要求另一个线程停止当前工作</p>
<p><strong>任务取消</strong></p>
<p>​    原因</p>
<ul>
<li>用户请求的取消，cancel</li>
<li>限时活动，超时取消</li>
<li>应用程序事件，当程序的不同任务在搜索，一个任务找到了解决方案，其他任务就取消</li>
<li>错误，IO等错误</li>
<li>关闭，</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>​    线程池与工作队列（持有所有等待执行的任务）绑定，线程从工作队列获取下一个任务，执行。</p>
<p>优势</p>
<ul>
<li>重用存在的线程，抵消线程创建、消亡的开销</li>
<li>在请求到达时，线程已存在，创建线程的等待时间不会延误任务的执行</li>
<li>可以防止创建过多的线程，争夺资源</li>
</ul>
<p>死锁</p>
<p>性能与可伸缩性</p>
<p>显式锁</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>Java并发编程实战</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/17/计算机网络/计算机网络：面试准备/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/17/计算机网络/计算机网络：面试准备/" class="post-title-link" itemprop="url">计算机网络：面试准备</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-02-17 22:53:49" itemprop="dateCreated datePublished" datetime="2019-02-17T22:53:49+08:00">2019-02-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-04-21 15:36:19" itemprop="dateModified" datetime="2019-04-21T15:36:19+08:00">2019-04-21</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/02/17/计算机网络/计算机网络：面试准备/" class="post-meta-item leancloud_visitors" data-flag-title="计算机网络：面试准备">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/02/17/计算机网络/计算机网络：面试准备/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/17/计算机网络/计算机网络：面试准备/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="计算机网络与因特网"><a href="#计算机网络与因特网" class="headerlink" title="计算机网络与因特网"></a>计算机网络与因特网</h1><p><strong>因特网</strong>具体构成描述：</p>
<p><strong>端系统（或称主机）</strong>通过通信链路和分组交换机连接到一起。<strong>链路</strong>的传输速率为bit/s，当主机间发送数据，发送端将数据分段，并为每段数据加上首部字节，形成的信息包为<strong>分组</strong>。<strong>分组交换机</strong>（包含路由器与链路层交换机）从它的一条入通信链路接受到达的分组，从它的一条出通信链路转发分组。一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径。</p>
<p>端系统通过<strong>因特网服务提供商（ISP）</strong>接入网络，每个ISP是一个由多个分组交换机和多段通信链路组成的网络。</p>
<p><strong>协议</strong></p>
<blockquote>
<p>一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和/或接受一条报文或其他事件所采取的行动</p>
</blockquote>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p><strong>分组交换</strong></p>
<p>存储转发交换：多数的分组交换机在链路的输入端使用存储转发交换机制。即在交换机能够开始向输出链路传输该分组的第一个比特前，必须接受到整个分组。</p>
<p>排队时延和分组丢失：对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>，用于存储路由器准备发往那条链路的分组。当缓存已满，则到达的分组或者排队之一的分组将被丢弃。</p>
<p>转发表和路由选择协议：</p>
<p><strong>电路交换</strong></p>
<p>电路交换、分组交换：通过网络链路和交换机移动数据的两种基本方法。</p>
<p>电路交换中，在会话期间预留了端系统间通信沿路径所需要的资源。（电话）</p>
<p><strong>频分复用</strong></p>
<p>要传送的<a href="https://baike.baidu.com/item/%E4%BF%A1%E5%8F%B7%E5%B8%A6%E5%AE%BD" target="_blank" rel="noopener">信号带宽</a>是有限的，而线路可使用的<a href="https://baike.baidu.com/item/%E5%B8%A6%E5%AE%BD" target="_blank" rel="noopener">带宽</a>则远远大于要传送的信号带宽，通过对多路信号采用不同频率进行调制的方法，使调制后的各路信号在频率位置上错开，以达到多路信号同时在一个<a href="https://baike.baidu.com/item/%E4%BF%A1%E9%81%93" target="_blank" rel="noopener">信道</a>内传输的目的。因此，频分复用的各路信号是在时间上重叠而在<a href="https://baike.baidu.com/item/%E9%A2%91%E8%B0%B1" target="_blank" rel="noopener">频谱</a>上不重叠的信号</p>
<p><strong>时分复用</strong></p>
<p><strong><em>时延、丢包、吞吐量</em></strong></p>
<p><strong>时延</strong>：</p>
<ul>
<li>结点处理时延（检验分组首部和决定将该分组导向何处）</li>
<li>排队时延（在输出队列中的等待时间）</li>
<li>传输时延（将分组推向链路）</li>
<li>传播时延（在链路向路由器传播）</li>
</ul>
<p><strong>吞吐量</strong>：服务器到客户端的传输速率是min{链宽}</p>
<h2 id="面对攻击的网络"><a href="#面对攻击的网络" class="headerlink" title="面对攻击的网络"></a>面对攻击的网络</h2><ul>
<li>自我复制：感染一台主机后，从该主机寻求进入其他主机的方式</li>
<li>病毒：需要某种形式的用户交互来感染设备</li>
<li>蠕虫：无需明显交互的</li>
</ul>
<p>DOS攻击：</p>
<ul>
<li>弱点攻击：向容易受到攻击的程序制作精细的报文</li>
<li>带宽泛洪：向主机发送大量分组，使得接入链路拥堵</li>
<li>连路洪泛：创建大量TCP连接，停止接受合法TCP连接</li>
</ul>
<p>嗅探分组：</p>
<p>检测网络上的分组，并保存副本</p>
<p>冒充：</p>
<p>生成精细的分组，发送的网络中，进行IP哄骗。</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h1 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a><a href="http://zhangchangle.com/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82?id=%e5%9f%9f%e5%90%8d%e7%b3%bb%e7%bb%9f" target="_blank" rel="noopener">域名系统</a></h1><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>
<p><img src="assets/b54eeb16-0b0e-484c-be62-306f57c40d77.jpg" alt="img"></p>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ul>
<h1 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a><a href="http://zhangchangle.com/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82?id=%e6%96%87%e4%bb%b6%e4%bc%a0%e9%80%81%e5%8d%8f%e8%ae%ae" target="_blank" rel="noopener">文件传送协议</a></h1><p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p>
<ul>
<li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>
<li>数据连接：用来传送一个文件数据。</li>
</ul>
<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p>
<ul>
<li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li>
</ul>
<p><img src="assets/03f47940-3843-4b51-9e42-5dcaff44858b.jpg" alt="img"></p>
<ul>
<li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li>
</ul>
<p><img src="assets/be5c2c61-86d2-4dba-a289-b48ea23219de.jpg" alt="img"></p>
<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>
<h1 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a><a href="http://zhangchangle.com/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82?id=%e5%8a%a8%e6%80%81%e4%b8%bb%e6%9c%ba%e9%85%8d%e7%bd%ae%e5%8d%8f%e8%ae%ae" target="_blank" rel="noopener">动态主机配置协议</a></h1><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>DHCP 工作过程如下：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<p><img src="assets/bf16c541-0717-473b-b75d-4115864f4fbf.jpg" alt="img"></p>
<h1 id="远程登录协议"><a href="#远程登录协议" class="headerlink" title="远程登录协议"></a><a href="http://zhangchangle.com/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82?id=%e8%bf%9c%e7%a8%8b%e7%99%bb%e5%bd%95%e5%8d%8f%e8%ae%ae" target="_blank" rel="noopener">远程登录协议</a></h1><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p>
<p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>
<h1 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a><a href="http://zhangchangle.com/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82?id=%e7%94%b5%e5%ad%90%e9%82%ae%e4%bb%b6%e5%8d%8f%e8%ae%ae" target="_blank" rel="noopener">电子邮件协议</a></h1><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>
<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
<p><img src="assets/7b3efa99-d306-4982-8cfb-e7153c33aab4.png" alt="img"></p>
<h2 id="1-SMTP"><a href="#1-SMTP" class="headerlink" title="1. SMTP"></a><a href="http://zhangchangle.com/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82?id=_1-smtp" target="_blank" rel="noopener">1. SMTP</a></h2><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>
<p><img src="assets/ed5522bb-3a60-481c-8654-43e7195a48fe.png" alt="img"></p>
<h2 id="2-POP3"><a href="#2-POP3" class="headerlink" title="2. POP3"></a><a href="http://zhangchangle.com/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82?id=_2-pop3" target="_blank" rel="noopener">2. POP3</a></h2><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。</p>
<h2 id="3-IMAP"><a href="#3-IMAP" class="headerlink" title="3. IMAP"></a><a href="http://zhangchangle.com/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82?id=_3-imap" target="_blank" rel="noopener">3. IMAP</a></h2><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>
<h1 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a><a href="http://zhangchangle.com/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82?id=%e5%b8%b8%e7%94%a8%e7%ab%af%e5%8f%a3" target="_blank" rel="noopener">常用端口</a></h1><table>
<thead>
<tr>
<th>应用</th>
<th>应用层协议</th>
<th>端口号</th>
<th>传输层协议</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>域名解析</td>
<td>DNS</td>
<td>53</td>
<td>UDP/TCP</td>
<td>长度超过 512 字节时使用 TCP</td>
</tr>
<tr>
<td>动态主机配置协议</td>
<td>DHCP</td>
<td>67/68</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>简单网络管理协议</td>
<td>SNMP</td>
<td>161/162</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>文件传送协议</td>
<td>FTP</td>
<td>20/21</td>
<td>TCP</td>
<td>控制连接 21，数据连接 20</td>
</tr>
<tr>
<td>远程终端协议</td>
<td>TELNET</td>
<td>23</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>超文本传送协议</td>
<td>HTTP</td>
<td>80</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>简单邮件传送协议</td>
<td>SMTP</td>
<td>25</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>邮件读取协议</td>
<td>POP3</td>
<td>110</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>网际报文存取协议</td>
<td>IMAP</td>
<td>143</td>
<td>TCP</td>
<td></td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/17/算法/刷题小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/17/算法/刷题小结/" class="post-title-link" itemprop="url">刷题小结</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-02-17 14:48:05" itemprop="dateCreated datePublished" datetime="2019-02-17T14:48:05+08:00">2019-02-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-03-15 20:01:38" itemprop="dateModified" datetime="2019-03-15T20:01:38+08:00">2019-03-15</time>
              </span>
            
          

          
            <span id="/2019/02/17/算法/刷题小结/" class="post-meta-item leancloud_visitors" data-flag-title="刷题小结">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/02/17/算法/刷题小结/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/17/算法/刷题小结/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><ul>
<li>遍历数组</li>
<li>寻找链表的环</li>
<li>节约遍历时间</li>
<li>反转，回文</li>
</ul>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p><strong>异或运算</strong></p>
<ul>
<li>利用 x ^ 1s = ~x 的特点，可以将位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</li>
<li>利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。</li>
<li>利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。</li>
</ul>
<p><strong>位与运算</strong></p>
<ul>
<li>n&amp;(n-1) 去除 n 的位级表示中最低的那一位。例如对于二进制表示 10110100，减去 1 得到 10110011，这两个数相与得到 10110000。</li>
<li>n&amp;(-n) 得到 n 的位级表示中最低的那一位。-n 得到 n 的反码加 1，对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。</li>
<li>n-n&amp;(~n+1) 去除 n 的位级表示中最高的那一位。</li>
</ul>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ul>
<li>快速排序<ul>
<li><strong>Kth Element</strong> 问题，使用快速排序的 partition() 进行实现。</li>
</ul>
</li>
<li>堆排序<ul>
<li>求解 <strong>TopK Elements</strong> 问题，通过维护一个大小为 K 的堆，堆中的元素就是 TopK Elements。</li>
<li>Kth Element 问题，堆顶元素就是 Kth Element。</li>
</ul>
</li>
<li>桶排序<ul>
<li>出现频率最多的 k 个数</li>
</ul>
</li>
</ul>
<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><ul>
<li>从问题的最小解开始，左右问题相互独立</li>
<li>利用递归（树是一种经典问题）</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li>使用长度为 256 的整型数组来统计每个字符出现的个数，每个字符有偶数个可以用来构成回文字符串。</li>
</ul>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h3 id="广度优先BFS"><a href="#广度优先BFS" class="headerlink" title="广度优先BFS"></a>广度优先BFS</h3><ul>
<li>可以<strong>求解最短路径等 最优解</strong> 问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径。</li>
<li>队列：用来存储每一轮遍历得到的节点；</li>
<li>标记：对于遍历过的节点，应该将它标记，防止重复遍历。</li>
<li>java pair,配对，用于返回两个值</li>
</ul>
<h3 id="深度优先DFS"><a href="#深度优先DFS" class="headerlink" title="深度优先DFS"></a>深度优先DFS</h3><ul>
<li>用来<strong>求解 可达性</strong> 问题。</li>
<li>栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。</li>
<li>标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。</li>
</ul>
<h3 id="回溯法Backtracking"><a href="#回溯法Backtracking" class="headerlink" title="回溯法Backtracking"></a>回溯法Backtracking</h3><ul>
<li>Backtracking 主要用于<strong>求解 排列组合</strong> 问题</li>
<li>例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li>
<li>因为 Backtracking 不是立即就返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：<ul>
<li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</li>
<li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</li>
</ul>
</li>
</ul>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>​    后面的状态依赖于前面已知的状态，根据前面已知，以及最新的数字，可以对后面状态进行推导</p>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>​    题目描述：有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p>
<ul>
<li><p>将容量N，价值MaxV的问题，分解到了求在容量1-N下，价值MaxV的问题</p>
</li>
<li><p>dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p>
<ul>
<li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dpij = dp(i-1)j。</li>
<li>第 i 件物品添加到背包中，dpij= dp(i-1)(j-w) + v。</li>
</ul>
<p><a href="https://camo.githubusercontent.com/00df29727a33906f588337c972831c35988a152b/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d5b6a5d3d6d61782864705b692d315d5b6a5d2c64705b692d315d5b6a2d775d2b7629" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/00df29727a33906f588337c972831c35988a152b/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b695d5b6a5d3d6d61782864705b692d315d5b6a5d2c64705b692d315d5b6a2d775d2b7629" alt="img"></a>    </p>
<p>​    在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp(i-1)j 也可以表示 dpij。此时，</p>
<p><a href="https://camo.githubusercontent.com/854f645dd2443eeaabf715e590cdebc928944626/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b6a5d3d6d61782864705b6a5d2c64705b6a2d775d2b7629" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/854f645dd2443eeaabf715e590cdebc928944626/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f64705b6a5d3d6d61782864705b6a5d2c64705b6a2d775d2b7629" alt="img"></a></p>
<p>​    因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，以防将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按<strong>倒序</strong>来循环求解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>​    0-1 背包和完全背包在实现上的不同之处是，0-1 背包对物品的迭代是在最外层，而完全背包对物品的迭代是在最里层。</p>
<h1 id="数据结构相关"><a href="#数据结构相关" class="headerlink" title="数据结构相关"></a>数据结构相关</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>如果是两个链表找交点，找环，一般都是走两个指针</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/CyC2018" target="_blank" rel="noopener">CyC2018</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/OS/操作系统概念总览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/14/OS/操作系统概念总览/" class="post-title-link" itemprop="url">操作系统概念总览</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-02-14 15:47:14" itemprop="dateCreated datePublished" datetime="2019-02-14T15:47:14+08:00">2019-02-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-03-19 20:43:35" itemprop="dateModified" datetime="2019-03-19T20:43:35+08:00">2019-03-19</time>
              </span>
            
          

          
            <span id="/2019/02/14/OS/操作系统概念总览/" class="post-meta-item leancloud_visitors" data-flag-title="操作系统概念总览">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/02/14/OS/操作系统概念总览/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/14/OS/操作系统概念总览/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>​    进程之间的资源不共享，是系统分配资源的基本单位，因此不能够创建多个进程去进行并行处理一个文件。共享内存是另一种</p>
<p>线程无法利用时钟强制中断线程让出cpu，需要使用线程调用therd_yield，通过编程解决</p>
<h1 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h3><p>进程是资源分配的基本单位。</p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/a6ac2b08-3861-4e85-baa8-382287bfee9f.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/a6ac2b08-3861-4e85-baa8-382287bfee9f.png" alt="img"></a></p>
<h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>线程是独立调度的基本单位。</p>
<p>一个进程中可以有多个线程，它们共享进程资源。</p>
<p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/3cd630ea-017c-488d-ad1d-732b4efeddf5.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/3cd630ea-017c-488d-ad1d-732b4efeddf5.png" alt="img"></a></p>
<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h3><p>Ⅰ 拥有资源</p>
<p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p>
<p>Ⅱ 调度</p>
<p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p>
<p>Ⅲ 系统开销</p>
<p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p>
<p>Ⅳ 通信方面</p>
<p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p>
<h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/ProcessState.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/ProcessState.png" alt="img"></a></p>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>​    当多个进程或线程处于就绪状态，对CPU的资源进行竞争，选择下一个要运行的进程，即调度</p>
<p><strong>进程切换代价</strong></p>
<ul>
<li>用户态必须切换到内核态，保存当前进程的状态，内存映像也需要保存</li>
<li>将新进程的内存映像装入MMU，新进程开始运行</li>
<li>整个内存的高速缓存失效，强迫缓存从内存中动态重新装入两次（进入内核、离开内核）</li>
</ul>
<p><strong>进程行为</strong></p>
<p>​    计算密集型进程：具有较长时间的CPU集中使用与较短的IO等待</p>
<p>​    IO密集型进程：具有较短时间的CPU集中使用与频繁的IO等待，（IO调度更为重要）</p>
<p>​    在IO开始后无论处理数据是多还是少，必须花费同样的时间提出硬件请求读取磁盘块。更多的进程开始倾向为IO密集型，因为CPU的改进比磁盘更快。如果需要运行IO密集型进程，就应该让它尽早得到机会，以便使得磁盘始终忙碌。</p>
<p><strong>调度算法</strong></p>
<p>​    不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h3 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<p>按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>按估计剩余时间最短的顺序进行调度。</p>
<h3 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>2.1 时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/8c662999-c16c-481c-9f40-1fdba5bc9167.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/8c662999-c16c-481c-9f40-1fdba5bc9167.png" alt="img"></a></p>
<p><strong>2.2 优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>2.3 多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/042cf928-3c8e-4815-ae9c-f2780202c68f.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/042cf928-3c8e-4815-ae9c-f2780202c68f.png" alt="img"></a></p>
<h3 id="3-实时系统"><a href="#3-实时系统" class="headerlink" title="3. 实时系统"></a>3. 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure>

<h3 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h3><ul>
<li>同步：多个进程按一定顺序执行；</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">void P1() &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    // 临界区</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void P2() &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    // 临界区</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用信号量实现生产者-消费者问题</strong> </p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define N 100</span><br><span class="line">typedef int semaphore;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = 0;</span><br><span class="line"></span><br><span class="line">void producer() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        int item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        int item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    procedure insert();</span><br><span class="line">    begin</span><br><span class="line">        // ...</span><br><span class="line">    end;</span><br><span class="line"></span><br><span class="line">    procedure remove();</span><br><span class="line">    begin</span><br><span class="line">        // ...</span><br><span class="line">    end;</span><br><span class="line">end monitor;</span><br></pre></td></tr></table></figure>

<p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。</p>
<p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<p><strong>使用管程实现生产者-消费者问题</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 管程</span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := 0;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    procedure insert(item: integer);</span><br><span class="line">    begin</span><br><span class="line">        if count = N then wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + 1;</span><br><span class="line">        if count = 1 then signal(empty);</span><br><span class="line">    end;</span><br><span class="line"></span><br><span class="line">    function remove: integer;</span><br><span class="line">    begin</span><br><span class="line">        if count = 0 then wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - 1;</span><br><span class="line">        if count = N -1 then signal(full);</span><br><span class="line">    end;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line">// 生产者客户端</span><br><span class="line">procedure producer</span><br><span class="line">begin</span><br><span class="line">    while true do</span><br><span class="line">    begin</span><br><span class="line">        item = produce_item;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">// 消费者客户端</span><br><span class="line">procedure consumer</span><br><span class="line">begin</span><br><span class="line">    while true do</span><br><span class="line">    begin</span><br><span class="line">        item = ProducerConsumer.remove;</span><br><span class="line">        consume_item(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><p>生产者和消费者问题前面已经讨论过了。</p>
<h3 id="1-读者-写者问题"><a href="#1-读者-写者问题" class="headerlink" title="1. 读者-写者问题"></a>1. 读者-写者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore;</span><br><span class="line">semaphore count_mutex = 1;</span><br><span class="line">semaphore data_mutex = 1;</span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line">void reader() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        if(count == 0) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writer() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下内容由 <a href="https://github.com/yugandharbandi" target="_blank" rel="noopener">@Bandi Yugandhar</a> 提供。</p>
<p>The first case may result Writer to starve. This case favous Writers i.e no writer, once added to the queue, shall be kept waiting longer than absolutely necessary(only when there are readers that entered the queue before the writer).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">int readcount, writecount;                   //(initial value = 0)</span><br><span class="line">semaphore rmutex, wmutex, readLock, resource; //(initial value = 1)</span><br><span class="line"></span><br><span class="line">//READER</span><br><span class="line">void reader() &#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line"> down(&amp;readLock);                 //  reader is trying to enter</span><br><span class="line"> down(&amp;rmutex);                  //   lock to increase readcount</span><br><span class="line">  readcount++;                 </span><br><span class="line">  if (readcount == 1)          </span><br><span class="line">   down(&amp;resource);              //if you are the first reader then lock  the resource</span><br><span class="line"> up(&amp;rmutex);                  //release  for other readers</span><br><span class="line"> up(&amp;readLock);                 //Done with trying to access the resource</span><br><span class="line"></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line">//reading is performed</span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line"> down(&amp;rmutex);                  //reserve exit section - avoids race condition with readers</span><br><span class="line"> readcount--;                       //indicate you&apos;re leaving</span><br><span class="line">  if (readcount == 0)          //checks if you are last reader leaving</span><br><span class="line">   up(&amp;resource);              //if last, you must release the locked resource</span><br><span class="line"> up(&amp;rmutex);                  //release exit section for other readers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//WRITER</span><br><span class="line">void writer() &#123;</span><br><span class="line">  &lt;ENTRY Section&gt;</span><br><span class="line">  down(&amp;wmutex);                  //reserve entry section for writers - avoids race conditions</span><br><span class="line">  writecount++;                //report yourself as a writer entering</span><br><span class="line">  if (writecount == 1)         //checks if you&apos;re first writer</span><br><span class="line">   down(&amp;readLock);               //if you&apos;re first, then you must lock the readers out. Prevent them from trying to enter CS</span><br><span class="line">  up(&amp;wmutex);                  //release entry section</span><br><span class="line"></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"> down(&amp;resource);                //reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource</span><br><span class="line">  //writing is performed</span><br><span class="line"> up(&amp;resource);                //release file</span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  down(&amp;wmutex);                  //reserve exit section</span><br><span class="line">  writecount--;                //indicate you&apos;re leaving</span><br><span class="line">  if (writecount == 0)         //checks if you&apos;re the last writer</span><br><span class="line">   up(&amp;readLock);               //if you&apos;re last writer, you must unlock the readers. Allows them to try enter CS for reading</span><br><span class="line">  up(&amp;wmutex);                  //release exit section</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can observe that every reader is forced to acquire ReadLock. On the otherhand, writers doesn’t need to lock individually. Once the first writer locks the ReadLock, it will be released only when there is no writer left in the queue.</p>
<p>From the both cases we observed that either reader or writer has to starve. Below solutionadds the constraint that no thread shall be allowed to starve; that is, the operation of obtaining a lock on the shared data will always terminate in a bounded amount of time.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">int readCount;                  // init to 0; number of readers currently accessing resource</span><br><span class="line"></span><br><span class="line">// all semaphores initialised to 1</span><br><span class="line">Semaphore resourceAccess;       // controls access (read/write) to the resource</span><br><span class="line">Semaphore readCountAccess;      // for syncing changes to shared variable readCount</span><br><span class="line">Semaphore serviceQueue;         // FAIRNESS: preserves ordering of requests (signaling must be FIFO)</span><br><span class="line"></span><br><span class="line">void writer()</span><br><span class="line">&#123; </span><br><span class="line">    down(&amp;serviceQueue);           // wait in line to be servicexs</span><br><span class="line">    // &lt;ENTER&gt;</span><br><span class="line">    down(&amp;resourceAccess);         // request exclusive access to resource</span><br><span class="line">    // &lt;/ENTER&gt;</span><br><span class="line">    up(&amp;serviceQueue);           // let next in line be serviced</span><br><span class="line"></span><br><span class="line">    // &lt;WRITE&gt;</span><br><span class="line">    writeResource();            // writing is performed</span><br><span class="line">    // &lt;/WRITE&gt;</span><br><span class="line"></span><br><span class="line">    // &lt;EXIT&gt;</span><br><span class="line">    up(&amp;resourceAccess);         // release resource access for next reader/writer</span><br><span class="line">    // &lt;/EXIT&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reader()</span><br><span class="line">&#123; </span><br><span class="line">    down(&amp;serviceQueue);           // wait in line to be serviced</span><br><span class="line">    down(&amp;readCountAccess);        // request exclusive access to readCount</span><br><span class="line">    // &lt;ENTER&gt;</span><br><span class="line">    if (readCount == 0)         // if there are no readers already reading:</span><br><span class="line">        down(&amp;resourceAccess);     // request resource access for readers (writers blocked)</span><br><span class="line">    readCount++;                // update count of active readers</span><br><span class="line">    // &lt;/ENTER&gt;</span><br><span class="line">    up(&amp;serviceQueue);           // let next in line be serviced</span><br><span class="line">    up(&amp;readCountAccess);        // release access to readCount</span><br><span class="line"></span><br><span class="line">    // &lt;READ&gt;</span><br><span class="line">    readResource();             // reading is performed</span><br><span class="line">    // &lt;/READ&gt;</span><br><span class="line"></span><br><span class="line">    down(&amp;readCountAccess);        // request exclusive access to readCount</span><br><span class="line">    // &lt;EXIT&gt;</span><br><span class="line">    readCount--;                // update count of active readers</span><br><span class="line">    if (readCount == 0)         // if there are no readers left:</span><br><span class="line">        up(&amp;resourceAccess);     // release resource access for all</span><br><span class="line">    // &lt;/EXIT&gt;</span><br><span class="line">    up(&amp;readCountAccess);        // release access to readCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-哲学家进餐问题"><a href="#2-哲学家进餐问题" class="headerlink" title="2. 哲学家进餐问题"></a>2. 哲学家进餐问题</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg" alt="img"></a></p>
<p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p>下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define N 5</span><br><span class="line"></span><br><span class="line">void philosopher(int i) &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       // 拿起左边的筷子</span><br><span class="line">        take((i+1)%N); // 拿起右边的筷子</span><br><span class="line">        eat();</span><br><span class="line">        put(i);</span><br><span class="line">        put((i+1)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#define N 5</span><br><span class="line">#define LEFT (i + N - 1) % N // 左邻居</span><br><span class="line">#define RIGHT (i + 1) % N    // 右邻居</span><br><span class="line">#define THINKING 0</span><br><span class="line">#define HUNGRY   1</span><br><span class="line">#define EATING   2</span><br><span class="line">typedef int semaphore;</span><br><span class="line">int state[N];                // 跟踪每个哲学家的状态</span><br><span class="line">semaphore mutex = 1;         // 临界区的互斥</span><br><span class="line">semaphore s[N];              // 每个哲学家一个信号量</span><br><span class="line"></span><br><span class="line">void philosopher(int i) &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat();</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void take_two(int i) &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    test(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void put_two(i) &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    test(LEFT);</span><br><span class="line">    test(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test(i) &#123;         // 尝试拿起两把筷子</span><br><span class="line">    if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<h4 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h4><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pipe(int fd[2]);</span><br></pre></td></tr></table></figure>

<p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）；</li>
<li>只能在父子进程中使用。</li>
</ul>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png" alt="img"></a></p>
<h4 id="2-FIFO"><a href="#2-FIFO" class="headerlink" title="2. FIFO"></a>2. FIFO</h4><p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int mkfifo(const char *path, mode_t mode);</span><br><span class="line">int mkfifoat(int fd, const char *path, mode_t mode);</span><br></pre></td></tr></table></figure>

<p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png" alt="img"></a></p>
<h4 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h4><p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<h4 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h4><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。down与up操作</p>
<h4 id="5-共享存储"><a href="#5-共享存储" class="headerlink" title="5.共享存储"></a>5.共享存储</h4><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p>
<p>需要使用信号量用来同步对共享存储的访问。</p>
<p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段。</p>
<h4 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6. 套接字"></a>6. 套接字</h4><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>​    协作的进程可能共享一些彼此公用的存储区，最后的结果取决于进程运行的精确时序（涉及到时钟中断等原因）</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>​    用于阻止多个进程同时读写共享数据，方法便是实现互斥访问</p>
<ul>
<li>屏蔽中断，当访问临界区，则屏蔽对进程的中断，该方案对于OS并不明智</li>
<li>锁变量，但是依然存在竞争条件的问题</li>
<li>严格轮换，设置值去记录轮转到可以进入临界区的进程。</li>
<li>等等</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>分层存储器体系：</p>
<p>​    若干M快速、昂贵、易失的高速缓存cache,数G的速度与价格适中，易失的内存，数TB的低俗、廉价、非易失的磁盘+USB等</p>
<p>​    任务：有效管理内存、记录哪些内存正在使用、哪些空闲、在进程需要时分配内存，使用完释放内存。</p>
<p><strong>存储器抽象</strong></p>
<p>​    如果将物理地址暴露给进程会带来危险</p>
<ul>
<li><p>如果用户进程可以寻址内存的每个字节，就可以很容易破坏OS</p>
</li>
<li><p>运行多个程序将十分困难</p>
</li>
</ul>
<p>要保证多个程序同时处于内存并不相互影响，则需要解决两个问题：保护、重定位</p>
<p>​    创造一个新的内存抽象：地址空间，地址空间是一个进程可用于寻址内存的一套地址集合。每个进程有其独立的一个地址空间。</p>
<p><strong>交换技术</strong></p>
<p>​    由于内存无法保存所有的进程，因此需要对进程进行处理。有两种处理内存超载的通用方法：交换与虚拟内存。</p>
<p>​    交换：将一个进程完整地调入内存，使该进程运行一段时间，然后存入磁盘。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>需要运行的程序往往大到内存无法容纳，且系统必须同时支持多个程序同时运行</p>
<p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/7b281b1e-0595-402b-ae35-8c91084c33c1.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/7b281b1e-0595-402b-ae35-8c91084c33c1.png" alt="img"></a></p>
<p><strong>分页</strong></p>
<p>虚拟地址空间按照固定大小划分成称为页面的若干单元，在物理内存中对应的单元称为页框（一般与页面大小一致）。RAM与磁盘间的交换通常以整个页面为单元进行。</p>
<p>缺页中断：由于虚拟内存大于物理内存，因此如果访问到了没有映射的页面，则发生缺页中断，OS找到一个很少使用的页框将其写入磁盘，随后将缺失的页面写入内存，重新执行上次的指令。</p>
<p><strong>页表</strong></p>
<p>虚拟内存到物理地址的映射：虚拟地址被分成虚拟页号（页表索引，由页表找到页框号）与偏移量（地址字节偏量,与页框号组合形成物理地址）</p>
<p><strong>加速分页过程</strong></p>
<p>两个主要问题</p>
<ul>
<li>虚拟内存到物理地址的映射必须非常快</li>
<li>如果虚拟地址空间很大，页表也会很大</li>
</ul>
<p>每个进程都有自己的页表，因为它有自己的虚拟地址空间</p>
<p>​    <strong>转换检测缓冲区TLB</strong></p>
<p>基于：大多数程序总是对少量的页面进行多次访问</p>
<p>加快虚拟地址到物理地址的转换</p>
<p><strong>针对大内存的页表</strong></p>
<ul>
<li>多级页表，针对32位系统，在64位系统当中，页表过于庞大</li>
<li>倒排页表，在实际内存中，每一个页框有一个表项，而不是每一个虚拟内存有一个表项。<ul>
<li>虚拟地址到物理地址的转换较困难，无法通过索引，而必须对整个页表进行查找才能找到对应的页</li>
<li>使用TLB解决，全局搜索使用散列表</li>
</ul>
</li>
</ul>
<h2 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h2><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" alt="img"></a></p>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<h3 id="1-最佳"><a href="#1-最佳" class="headerlink" title="1. 最佳"></a>1. 最佳</h3><blockquote>
<p>OPT, Optimal replacement algorithm</p>
</blockquote>
<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>
<p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<p><a href="https://camo.githubusercontent.com/7be506554fa5a86670d2bd1f22c786ae88e0bd31/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f37efbc8c30efbc8c31efbc8c32efbc8c30efbc8c33efbc8c30efbc8c34efbc8c32efbc8c33efbc8c30efbc8c33efbc8c32efbc8c31efbc8c32efbc8c30efbc8c31efbc8c37efbc8c30efbc8c31" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/7be506554fa5a86670d2bd1f22c786ae88e0bd31/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f37efbc8c30efbc8c31efbc8c32efbc8c30efbc8c33efbc8c30efbc8c34efbc8c32efbc8c33efbc8c30efbc8c33efbc8c32efbc8c31efbc8c32efbc8c30efbc8c31efbc8c37efbc8c30efbc8c31" alt="img"></a></p>
<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p>
<h3 id="2-最近最久未使用"><a href="#2-最近最久未使用" class="headerlink" title="2. 最近最久未使用"></a>2. 最近最久未使用</h3><blockquote>
<p>LRU, Least Recently Used</p>
</blockquote>
<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>
<p><a href="https://camo.githubusercontent.com/bb6f10172ad16d1094a12ee638783cbf3a15370a/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f34efbc8c37efbc8c30efbc8c37efbc8c31efbc8c30efbc8c31efbc8c32efbc8c31efbc8c32efbc8c36" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/bb6f10172ad16d1094a12ee638783cbf3a15370a/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f34efbc8c37efbc8c30efbc8c37efbc8c31efbc8c30efbc8c31efbc8c32efbc8c31efbc8c32efbc8c36" alt="img"></a></p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/eb859228-c0f2-4bce-910d-d9f76929352b.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/eb859228-c0f2-4bce-910d-d9f76929352b.png" alt="img"></a></p>
<h3 id="3-最近未使用"><a href="#3-最近未使用" class="headerlink" title="3. 最近未使用"></a>3. 最近未使用</h3><blockquote>
<p>NRU, Not Recently Used</p>
</blockquote>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<h3 id="4-先进先出"><a href="#4-先进先出" class="headerlink" title="4. 先进先出"></a>4. 先进先出</h3><blockquote>
<p>FIFO, First In First Out</p>
</blockquote>
<p>选择换出的页面是最先进入的页面。</p>
<p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p>
<h3 id="5-第二次机会算法"><a href="#5-第二次机会算法" class="headerlink" title="5. 第二次机会算法"></a>5. 第二次机会算法</h3><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p>
<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png" alt="img"></a></p>
<h3 id="6-时钟"><a href="#6-时钟" class="headerlink" title="6. 时钟"></a>6. 时钟</h3><blockquote>
<p>Clock</p>
</blockquote>
<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png" alt="img"></a></p>
<h2 id="分页系统的设计"><a href="#分页系统的设计" class="headerlink" title="分页系统的设计"></a>分页系统的设计</h2><p><strong>局部分配策略与全局分配策略</strong></p>
<p>怎么样在相互竞争的可运行进程间分配内存</p>
<p>局部：淘汰进程中最差的页面</p>
<p>全局：淘汰整个内存当中最差的页面</p>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p>
<p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/22de0538-7c6e-4365-bd3b-8ce3c5900216.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/22de0538-7c6e-4365-bd3b-8ce3c5900216.png" alt="img"></a></p>
<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png" alt="img"></a></p>
<h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<h2 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h2><ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的。</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li>
<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/算法/算法：查找算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/12/算法/算法：查找算法/" class="post-title-link" itemprop="url">算法：查找算法</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-02-12 22:13:04" itemprop="dateCreated datePublished" datetime="2019-02-12T22:13:04+08:00">2019-02-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-03-21 20:11:54" itemprop="dateModified" datetime="2019-03-21T20:11:54+08:00">2019-03-21</time>
              </span>
            
          

          
            <span id="/2019/02/12/算法/算法：查找算法/" class="post-meta-item leancloud_visitors" data-flag-title="算法：查找算法">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/02/12/算法/算法：查找算法/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/12/算法/算法：查找算法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><p>顺序查找</p>
</li>
<li><p>二分查找</p>
<ul>
<li><p>基于二分的优化：</p>
</li>
<li><p>斐波那契查找</p>
</li>
<li><p>插值查找</p>
</li>
</ul>
</li>
<li><p>树表查找</p>
<ul>
<li>二叉树查找</li>
<li>平衡查找树之2-3查找树</li>
<li>平衡查找树之2-3红黑树</li>
<li>B树</li>
<li>B+树</li>
</ul>
</li>
<li><p>分块查找</p>
</li>
<li><p>哈希查找</p>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="​静态查找与动态查找"><a href="#​静态查找与动态查找" class="headerlink" title="​静态查找与动态查找"></a>​静态查找与动态查找</h4><ul>
<li>静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。</li>
</ul>
<h4 id="无序查找与有序查找"><a href="#无序查找与有序查找" class="headerlink" title="无序查找与有序查找"></a>无序查找与有序查找</h4><ul>
<li>无序查找：被查找数列有序无序均可；</li>
<li>有序查找：被查找数列必须为有序数列。</li>
</ul>
<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>​    二分查找对于middle的划分属于傻瓜式。打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。</p>
<p>​    改进法：mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，即将1/2改为自适应的参数</p>
<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>​    基于黄金分割比例，斐波那契数列中，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618</p>
<p>​    他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549981578676.png" alt="1549981578676"></p>
<h2 id="树查找"><a href="#树查找" class="headerlink" title="树查找"></a>树查找</h2><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>​    基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 </p>
<p>　　<strong>二叉查找树</strong>（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：</p>
<p>  　　1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>        　　2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>            　　3. 任意节点的左、右子树也分别为二叉查找树。</p>
<p>　　<strong>二叉查找树性质</strong>：<strong>对二叉查找树进行中序遍历，即可得到有序的数列。</strong></p>
<h3 id="平衡查找树之2-3查找树"><a href="#平衡查找树之2-3查找树" class="headerlink" title="平衡查找树之2-3查找树"></a>平衡查找树之2-3查找树</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>​    <strong>2-3查找树定义</strong>：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：</p>
<ol>
<li>要么为空，要么：</li>
<li>对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。</li>
<li>对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。</li>
</ol>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>如果中序遍历2-3查找树，就可以得到排好序的序列；</li>
<li>在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）</li>
</ol>
<h3 id="平衡查找树之红黑树"><a href="#平衡查找树之红黑树" class="headerlink" title="平衡查找树之红黑树"></a>平衡查找树之红黑树</h3><p>​    2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。</p>
<h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>　　<strong>基本思想：</strong>红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。</p>
<p>​    <strong>定义</strong>:红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：</p>
<ul>
<li>红色节点向左倾斜</li>
<li>一个节点不可能有两个红色链接</li>
<li>整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。</li>
<li>如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。</li>
</ul>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549984639227.png" alt="1549984639227"></p>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><p>​    整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。</p>
<p>​    红黑树的平均高度大约为logn。</p>
<ol>
<li>每个结点要么是红的要么是黑的。  </li>
<li>根结点是黑的。  </li>
<li>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  </li>
<li>如果一个结点是红的，那么它的两个儿子都是黑的。  </li>
<li>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。 </li>
</ol>
<p>​    <strong>复杂度分析</strong>：最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。</p>
<h4 id="平衡性的修正"><a href="#平衡性的修正" class="headerlink" title="平衡性的修正"></a>平衡性的修正</h4><p>​    在红-黑树中插入的节点都是红色的，这不是偶然的，因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小。原因是：插入黑色节点总会改变黑色高度（违背规则4），但是插入红色节点只有一半的机会会违背规则3。另外违背规则3比违背规则4要更容易修正。</p>
<p>​    红-黑树主要通过三种方式对平衡进行修正：</p>
<h5 id="改变节点颜色"><a href="#改变节点颜色" class="headerlink" title="改变节点颜色"></a>改变节点颜色</h5><p>​    改变节点颜色比较容易理解，因为它违背了规则3。假设现在有个节点E，然后插入节点A和节点S，节点A在左子节点，S在右子节点，目前是平衡的。如果此时再插一个节点，那么就出现了不平衡了，因为红色节点的子节点必须为黑色，但是新插的节点是红色的。所以这时候就必须改变节点颜色了。所以我们将根的两个子节点从红色变为黑色（至于为什么都要变，下面插入的时候会详细介绍），将父节点会从黑色变成红色。可以用如下示意图表示一下：</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549985388359.png" alt="1549985388359"></p>
<h5 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h5><p>​    通常左旋操作用于将一个向右倾斜的红色链接旋转为向左链接</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549985353690.png" alt="1549985353690"></p>
<h5 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h5><p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549985363590.png" alt="1549985363590"></p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>​    在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化<strong>大块数据的读和写操作</strong>。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在<strong>数据库</strong>和<strong>文件系统</strong></p>
<h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p><strong>定义：</strong> <strong>B树</strong>可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p>
<ul>
<li>根节点至少有两个子节点</li>
<li>每个节点有M-1个key，并且以升序排列</li>
<li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li>
<li>其它节点至少有M/2个子节点</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>[[Data Structure &amp; Algorithm] 七大查找算法</li>
<li><a href="https://www.cnblogs.com/maybe2030/p/4715035.html" target="_blank" rel="noopener">数据结构和算法05 红-黑树（看完包懂~</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/面试/面试问题：Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/12/面试/面试问题：Redis/" class="post-title-link" itemprop="url">面试问题-Redis</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-02-12 16:10:58" itemprop="dateCreated datePublished" datetime="2019-02-12T16:10:58+08:00">2019-02-12</time>
            </span>
          

          
            <span id="/2019/02/12/面试/面试问题：Redis/" class="post-meta-item leancloud_visitors" data-flag-title="面试问题-Redis">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Aufrufe: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Kommentare: </span>
    
  
    <a href="/2019/02/12/面试/面试问题：Redis/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/12/面试/面试问题：Redis/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="Vorherige Seite"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">219</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">Kategorien</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">schlagwörter</span>
        
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  











  
  <script>
    function showTime(Counter) {
      var entries = [];
      var $visitors = $('.leancloud_visitors');

      $visitors.each(function() {
        entries.push( $(this).attr('id').trim() );
      });

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url: { '$in': entries } }) })
        .done(function({ results }) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if (countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function ({ responseJSON }) {
          console.log(`LeanCloud Counter Error: ${responseJSON.code} ${responseJSON.error}`);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
                'X-LC-Key': 'uTVcNIWdMCGpicrhTKygpKXi',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
            if ($('.post-title-link').length >= 1) {
              showTime(Counter);
            }
          
        });
    });
  </script>












  
<link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">
<script src="/lib/algolia-instant-search/instantsearch.min.js"></script>


<script src="/js/algolia-search.js?v=7.2.0"></script>














    
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
    appKey: 'uTVcNIWdMCGpicrhTKygpKXi',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn'
  });
</script>


</body>
</html>
