<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: 'OZTK1BY156',
      apiKey: '',
      indexName: 'BlogIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copiar',
      copy_success: 'Copiado',
      copy_failure: 'Copiar falló'
    }
  };
</script>

  <meta name="description" content="To be awesome">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/16/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="To be awesome">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="To be awesome">
  <link rel="canonical" href="http://yoursite.com/page/16/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Cambiar a barra de navegación">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Inicio</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>Sobre mi</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Etiquetas</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categorías</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archivo</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>Calendario</a>

  </li>
    </ul>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/面试/面经：字节跳动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/12/面试/面经：字节跳动/" class="post-title-link" itemprop="url">字节跳动面经</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-12 16:03:26" itemprop="dateCreated datePublished" datetime="2019-02-12T16:03:26+08:00">2019-02-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-03-17 16:39:05" itemprop="dateModified" datetime="2019-03-17T16:39:05+08:00">2019-03-17</time>
              </span>
            
          

          
            <span id="/2019/02/12/面试/面经：字节跳动/" class="post-meta-item leancloud_visitors" data-flag-title="字节跳动面经">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/12/面试/面经：字节跳动/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/12/面试/面经：字节跳动/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          字节跳动面经问题整理
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/02/12/面试/面经：字节跳动/">
                Leer más &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/面试/面试问题：多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/12/面试/面试问题：多线程/" class="post-title-link" itemprop="url">多线程</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-12 16:03:14" itemprop="dateCreated datePublished" datetime="2019-02-12T16:03:14+08:00">2019-02-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-02-14 20:56:28" itemprop="dateModified" datetime="2019-02-14T20:56:28+08:00">2019-02-14</time>
              </span>
            
          

          
            <span id="/2019/02/12/面试/面试问题：多线程/" class="post-meta-item leancloud_visitors" data-flag-title="多线程">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/12/面试/面试问题：多线程/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/12/面试/面试问题：多线程/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/78313167" target="_blank" rel="noopener">面试/笔试第四弹 —— 多线程面试问题集锦</a></li>
<li><a href="https://juejin.im/post/5ba133126fb9a05ce02a6f12" target="_blank" rel="noopener">互联网校招面试必备——Java多线程 | 掘金技术征文</a></li>
<li><a href="http://blog.51cto.com/13676067/2105547" target="_blank" rel="noopener">天下无难试之多线程面试刁难大全</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/面试/面试准备：数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/12/面试/面试准备：数据库/" class="post-title-link" itemprop="url">数据库</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-12 16:03:09" itemprop="dateCreated datePublished" datetime="2019-02-12T16:03:09+08:00">2019-02-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-02-14 22:53:40" itemprop="dateModified" datetime="2019-02-14T22:53:40+08:00">2019-02-14</time>
              </span>
            
          

          
            <span id="/2019/02/12/面试/面试准备：数据库/" class="post-meta-item leancloud_visitors" data-flag-title="数据库">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/12/面试/面试准备：数据库/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/12/面试/面试准备：数据库/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h1 id="什么是-内连接、外连接、交叉连接、笛卡尔积等？"><a href="#什么是-内连接、外连接、交叉连接、笛卡尔积等？" class="headerlink" title="什么是 内连接、外连接、交叉连接、笛卡尔积等？"></a>什么是 内连接、外连接、交叉连接、笛卡尔积等？</h1><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的 列值。</p>
<p><strong>内连接分三种</strong>：</p>
<ol>
<li><strong>等值连接</strong>：在连接条件中使用等于号<code>(=)</code>运算符比较被连接列的列值，其查询结 果中列出被连接表中的所有列，包括其中的重复列。</li>
</ol>
<p>例，下面使用等值连接列出authors和publishers表中位于同一城市的作者和出版社：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM authors AS a INNER JOIN publishers AS p ON a.city=p.city </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>不等连接</strong>： 在连接条件使用除等于运算符以外的其它比较运算符比较被连接的 列的列值。这些运算符包括<code>&gt;、&gt;=、&lt;=、&lt;、!&gt;、!&lt;</code>和<code>&lt;&gt;</code>。</li>
<li><strong>自然连接</strong>：在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选 择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。</li>
</ol>
<p>例，在选择列表中删除authors 和publishers 表中重复列(city和state)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.*,p.pub_id,p.pub_name,p.country FROM authors AS a INNER JOIN publishers AS p ON a.city=p.city</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>​    外连接，返回到查询结果集合中的不仅包含符合连接条件的行，<strong>而且还包括左表</strong>(<strong>左外连接或左连接</strong>)、右表(<strong>右外连接或右连接</strong>)或两个边接表(全外连接)中的所有数据行。   </p>
<ul>
<li><strong>left join</strong>(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录。</li>
<li><strong>right join</strong>(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录。</li>
</ul>
<p><strong>例如1</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.*,b.* FROM luntan LEFT JOIN usertable as b ON a.username=b.username</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>例如2</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.*,b.* FROM city as a FULL OUTER JOIN user as b ON a.username=b.username</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><p>​    <strong>交叉连接不带 WHERE 子句</strong>，<strong>它返回被连接的两个表所有数据行的“笛卡尔积”</strong>，返回到结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。</p>
<p>例，titles表中有6类图书，而publishers表中有8家出版社，则下 列交叉连接检索到的记录数将等于6*8=48行。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT type,pub_name FROM titles CROSS JOIN publishers  ORDER BY type</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><p>​    笛卡尔积是两个表每一个字段相互匹配，去掉<code>where</code> 或者<code>inner join</code>的等值 得出的结果就是笛卡尔积。<strong>笛卡尔积也等同于交叉连接</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>内连接: 只连接匹配的行。</li>
<li>左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行。</li>
<li>右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行。</li>
<li>全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</li>
<li>交叉连接  生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配。</li>
</ul>
<h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><ul>
<li><p>第一范式（1NF）：符合1NF的关系中的每个属性都不可再分。是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。</p>
</li>
<li><p>第二范式（2NF）：2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖，应当是完全依赖。</p>
</li>
<li><p>第三范式（3NF）：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。</p>
</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>​    索引是一种数据结构 。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>
<h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h3><ul>
<li>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</li>
<li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</li>
</ul>
<h3 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h3><p>​    B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>
<h3 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h3><p>​    由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p>
<h3 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h3><ul>
<li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li>
<li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li>
<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li>
<li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li>
<li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li>
</ul>
<h3 id="数据库索引为什么要用-B-树而不用红黑树呢？"><a href="#数据库索引为什么要用-B-树而不用红黑树呢？" class="headerlink" title="数据库索引为什么要用 B+ 树而不用红黑树呢？"></a>数据库索引为什么要用 B+ 树而不用红黑树呢？</h3><p>​    AVL 数和红黑树基本都是存储在内存中才会使用的数据结构，那磁盘中会有什么不同呢？</p>
<p>​    这就要牵扯到磁盘的存储原理了,操作系统读写磁盘的基本单位是扇区，而文件系统的基本单位是簇(Cluster)。,也就是说，磁盘读写有一个最少内容的限制，即使我们只需要这个簇上的一个字节的内容，我们也要含着泪把一整个簇上的内容读完。</p>
<p>​    那么，现在问题就来了,一个父节点只有 2 个子节点，并不能填满一个簇上的所有内容啊？那多余的内容岂不是要浪费了？我们怎么才能把浪费的这部分内容利用起来呢？哈哈，答案就是 B+ 树。由于 B+ 树分支比二叉树更多，所以相同数量的内容，B+ 树的深度更浅，深度代表什么？代表磁盘 io 次数啊！数据库设计的时候 B+ 树有多少个分支都是按照磁盘一个簇上最多能放多少节点设计的啊！</p>
<h3 id="MySQL-B-Tree索引和Hash索引的区别？"><a href="#MySQL-B-Tree索引和Hash索引的区别？" class="headerlink" title="MySQL B+Tree索引和Hash索引的区别？"></a>MySQL B+Tree索引和Hash索引的区别？</h3><ul>
<li><p>Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;</p>
</li>
<li><p>B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;</p>
<p>那为什么大家不都用Hash索引而还要使用B+树索引呢？</p>
</li>
</ul>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ol>
<li>Hash索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；</li>
<li>Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；</li>
<li>Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；</li>
<li>Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；</li>
<li>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。</li>
</ol>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>​    <strong>MySQL中，只有HEAP/MEMORY引擎才显示支持Hash索引</strong>。</p>
<p>​    <strong>常用的InnoDB引擎中默认使用的是B+树索引</strong>，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（<strong>在InnoDB中默认开启自适应哈希索引</strong>），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</p>
<h4 id="B-树索引和哈希索引的明显区别是："><a href="#B-树索引和哈希索引的明显区别是：" class="headerlink" title="B+树索引和哈希索引的明显区别是："></a>B+树索引和哈希索引的明显区别是：</h4><ul>
<li><strong>如果是等值查询，那么哈希索引明显有绝对优势</strong>，<strong>因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据</strong>；</li>
<li><strong>如果是范围查询检索，这时候哈希索引就毫无用武之地了</strong>，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</li>
<li>同理，<strong>哈希索引没办法利用索引完成排序</strong>，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</li>
<li><strong>哈希索引也不支持多列联合索引的最左匹配规则</strong>；</li>
<li>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，<strong>在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题</strong>。</li>
<li><strong>在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了</strong>。</li>
</ul>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul>
<li><p>主键索引: 数据列不允许重复，不允许为NULL.一个表只能有一个主键。</p>
</li>
<li><p>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p>
</li>
<li><p>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>
</li>
<li><p>聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</p>
<ul>
<li>含有大量非重复值的列。</li>
<li>使用BETWEEN,&gt;,&gt;=,&lt;或&lt;=返回一个范围值的列</li>
<li>被连续访问的列</li>
<li>返回大型<a href="https://baike.baidu.com/item/%E7%BB%93%E6%9E%9C%E9%9B%86" target="_blank" rel="noopener">结果集</a>的查询</li>
<li>经常被使用连接或GROUP BY子句的查询访问的列</li>
</ul>
</li>
<li><p>非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个</p>
</li>
</ul>
<h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>索引加快数据库的检索速度</li>
<li>索引降低了插入、删除、修改等维护任务的速度</li>
<li>唯一索引可以确保每一行数据的唯一性</li>
<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li>
<li>索引需要占物理和数据空间 </li>
</ul>
<h3 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h3><p>​    通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</p>
<p>​    索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p>
<ul>
<li>基于一个范围的检索,一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ul>
<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><ul>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>​    事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p>
<h3 id="四大特性-简称ACID"><a href="#四大特性-简称ACID" class="headerlink" title="四大特性(简称ACID)"></a>四大特性(简称ACID)</h3><p>数据库如果支持事务的操作，那么就具备以下四个特性：</p>
<ol>
<li>原子性(Atomicity) 事务是数据库的逻辑工作单位，事务中包括的诸操作要么全做，要么全不做。</li>
<li>一致性(Consistency) 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li>
<li>隔离性(Isolation) 一个事务的执行不能被其他事务干扰。</li>
<li>持续性/永久性(Durability) 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</li>
</ol>
<h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p>​    数据库事务的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550147793989.png" alt="1550147793989"></p>
<ul>
<li><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
</li>
<li><p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>
</li>
<li><p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h4 id="Read-Uncommitted（读取未提交内容）"><a href="#Read-Uncommitted（读取未提交内容）" class="headerlink" title="Read Uncommitted（读取未提交内容）"></a>Read Uncommitted（读取未提交内容）</h4><p>​    在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p>
<h4 id="Read-Committed（读取提交内容）"><a href="#Read-Committed（读取提交内容）" class="headerlink" title="Read Committed（读取提交内容）"></a>Read Committed（读取提交内容）</h4><p>​    这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p>
<h4 id="Repeatable-Read（可重读）"><a href="#Repeatable-Read（可重读）" class="headerlink" title="Repeatable Read（可重读）"></a>Repeatable Read（可重读）</h4><p>​    这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>
<h4 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h4><p>​    这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>
<h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><p>​    在Read Uncommitted级别下，读操作不加S锁； 在Read Committed级别下，读操作需要加S锁，但是在语句执行完以后释放S锁； 在Repeatable Read级别下，读操作需要加S锁，但是在事务提交之前并不释放S锁，也就是必须等待事务执行完毕以后才释放S锁。 在Serialize级别下，会在Repeatable Read级别的基础上，添加一个范围锁。保证一个事务内的两次查询结果完全一样，而不会出现第一次查询结果是第二次查询结果的子集。</p>
<h3 id="事物隔离是怎么实现的？"><a href="#事物隔离是怎么实现的？" class="headerlink" title="事物隔离是怎么实现的？"></a>事物隔离是怎么实现的？</h3><p>​    是基于锁实现的.</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>​    数据库的乐观锁和悲观锁是什么？</p>
<p>​    数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p>
<p>​    乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<ul>
<li><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p>
</li>
<li><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<p><strong>悲观锁：</strong> 悲观锁指对数据被意外修改持保守态度，依赖数据库原生支持的锁机制来保证当前事务处理的安全性，防止其他并发事务对目标数据的破坏或破坏其他并发事务数据，将在事务开始执行前或执行中申请锁定，执行完后再释放锁定。这对于长事务来讲，可能会严重影响系统的并发处理能力。 自带的数据库事务就是典型的悲观锁。<br> <strong>乐观锁：</strong> 乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。<br> 一般是加一个版本号字段 每次更新时候比较版本号。</p>
<p><strong>响应速度</strong>：如果需要非常高的响应速度，<strong>建议采用乐观锁方案</strong>，成功就执行，不成功就失败，不需要等待其他并发去释放锁。</p>
<p><strong>冲突频率</strong>：如果冲突频率非常高，<strong>建议采用悲观锁</strong>，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</p>
<p><strong>重试代价</strong>：如果重试代价大，建议采用悲观锁。</p>
</li>
</ul>
<h2 id="有哪些锁？分别介绍下"><a href="#有哪些锁？分别介绍下" class="headerlink" title="有哪些锁？分别介绍下"></a>有哪些锁？分别介绍下</h2><p>​    在DBMS中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>
<p>​    <strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。<br>​     特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p>​    <strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。<br>​     特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<p>​    <strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。<br>     特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>​    存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>存储过程是预编译过的，执行效率高。 </li>
<li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li>
<li>安全性搞，执行存储过程需要有一定权限的用户。</li>
<li>存储过程可以重复使用，减少数据库开发人员的工作量。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。 </li>
<li>移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。 </li>
<li>重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。 </li>
<li>如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</li>
</ol>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>​    视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以一旦基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。 视图一经定义，就可以和基本表一样被查询、被删除。也可以在一个视图上再定义新的视图，但对视图的更新（增、删、改）操作则有一定的限制。</p>
<h3 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h3><ol>
<li>查询简单化。视图能简化用户的操作</li>
<li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>
<li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li>
</ol>
<h3 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a>视图的缺点</h3><ol>
<li>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</li>
<li>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的，这些视图有如下特征：   a.有UNIQUE等集合操作符的视图。   b.有GROUP BY子句的视图。   c.有诸如AVG\SUM\MAX等聚合函数的视图。   d.使用DISTINCT关键字的视图。   e.连接表的视图（其中有些例外）</li>
</ol>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>​    将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ol>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ol>
<h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550147891959.png" alt="1550147891959"></p>
<p>​    Binary log：主数据库的二进制日志 Relay log：从服务器的中继日志 第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。 第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。 第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p>
<h1 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h1><ol>
<li>优化shema、sql语句+索引；</li>
<li>第二加缓存，memcached, redis；</li>
<li>主从复制，读写分离；</li>
<li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li>
<li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/78308460#comments" target="_blank" rel="noopener">面试/笔试第三弹 —— 数据库面试问题集锦</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23713529" target="_blank" rel="noopener">常见面试题整理–数据库篇（每位开发者必备）</a></li>
<li><a href="https://juejin.im/post/5ba4b65be51d450e51627f33" target="_blank" rel="noopener">互联网校招面试必备——数据库 | 掘金技术征文</a></li>
<li><a href="https://juejin.im/post/5baafdccf265da0af93b05e4" target="_blank" rel="noopener">互联网公司面试必问的mysql题目(上)</a></li>
<li><a href="https://juejin.im/post/5ba1f32ee51d450e805b43f2" target="_blank" rel="noopener">互联网公司面试必问的mysql题目(下）</a></li>
<li><a href="https://juejin.im/post/5ab50d9b6fb9a028c812cc78" target="_blank" rel="noopener">20个数据库常见面试题讲解</a></li>
<li><a href="https://juejin.im/post/5a9ca0d6518825555c1d1acd" target="_blank" rel="noopener">数据库面试题(开发者必看)</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/面试/面试准备：操作系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/12/面试/面试准备：操作系统/" class="post-title-link" itemprop="url">操作系统</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-12 16:03:04" itemprop="dateCreated datePublished" datetime="2019-02-12T16:03:04+08:00">2019-02-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-02-13 23:02:02" itemprop="dateModified" datetime="2019-02-13T23:02:02+08:00">2019-02-13</time>
              </span>
            
          

          
            <span id="/2019/02/12/面试/面试准备：操作系统/" class="post-meta-item leancloud_visitors" data-flag-title="操作系统">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/12/面试/面试准备：操作系统/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/12/面试/面试准备：操作系统/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550036581992.png" alt="1550036581992"></p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h3 id="进程有哪几种状态，状态转换圈，导致转换的事件"><a href="#进程有哪几种状态，状态转换圈，导致转换的事件" class="headerlink" title="进程有哪几种状态，状态转换圈，导致转换的事件"></a>进程有哪几种状态，状态转换圈，导致转换的事件</h3><p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550036626213.png" alt="1550036626213"></p>
<p>​    包含三种状态：就绪状态，运行状态和阻塞状态。阻塞和就绪区别：阻塞是等待CPU以外的资源，就绪等待的是CPU资源。</p>
<ul>
<li><p>执行状态：进程正在处理器上运行。</p>
</li>
<li><p>就绪状态：进程已经处于准备运行的状态，即进程已经获得了除了处理器以外的所有资源，一旦的到处理器即可运行。</p>
</li>
<li><p>阻塞状态：进程正在等待某一事件的发生，如果等待某一资源为可用或等待输入输出完成。即使处理器空闲当前进程也不能执行。</p>
<p>转换事件：</p>
</li>
<li><p>就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；</p>
</li>
<li><p>执行——阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等； </p>
</li>
<li><p>阻塞——就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；</p>
</li>
<li><p>执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。</p>
</li>
</ul>
<h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><ol>
<li>管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</li>
<li>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li>消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</li>
<li>共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；</li>
<li>信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</li>
<li>套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</li>
</ol>
<p>​    进程通信是指进程之间的信息交换。PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。</p>
<p><strong>共享存储</strong></p>
<p>​    在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。</p>
<p>​    需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。</p>
<p><strong>消息传递</strong></p>
<p>​    在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。</p>
<ol>
<li>直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</li>
<li>间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。</li>
</ol>
<p><strong>管道通信</strong></p>
<p>​    管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。</p>
<h3 id="进程同步方式"><a href="#进程同步方式" class="headerlink" title="进程同步方式"></a>进程同步方式</h3><p>​    多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性</p>
<p>原则：</p>
<ol>
<li>空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请</li>
<li>忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问</li>
<li>有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等</li>
<li>让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等</li>
</ol>
<p>​    原子操作、信号量机制、自旋锁管程、会合、分布式系统</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550070112546.png" alt="1550070112546"></p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>​    <strong>先来先服务调度算法FCFS：</strong>既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；</p>
<p>​    <strong>短作业优先调度算法SJF：</strong>作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；</p>
<p>​    <strong>高相应比算法HRN：</strong>响应比=(等待时间+要求服务时间)/要求服务时间；</p>
<p>​    <strong>时间片轮转调度RR：</strong>按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;</p>
<p>​    <strong>多级反馈队列调度算法：</strong>目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>​    在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态，</p>
<h3 id="线程同步方式"><a href="#线程同步方式" class="headerlink" title="线程同步方式"></a>线程同步方式</h3><ol>
<li>互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li>
<li>信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li>
<li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li>
</ol>
<h1 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​    进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</p>
<p>​    线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>​    进程和线程的主要差别在于它们是不同的操作系统资源管理方式。</p>
<p>​    进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<ol>
<li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li>
</ol>
<ul>
<li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</li>
<li>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。 </li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>​    线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP（双CPU机器）机器上运行，而进程则可以跨机器迁移。</p>
<h1 id="什么是缓冲区溢出？有什么危害？其原因是什么？"><a href="#什么是缓冲区溢出？有什么危害？其原因是什么？" class="headerlink" title="什么是缓冲区溢出？有什么危害？其原因是什么？"></a>什么是缓冲区溢出？有什么危害？其原因是什么？</h1><p>​    缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>
<p>危害有以下两点：</p>
<ul>
<li><p>程序崩溃，导致拒绝额服务</p>
</li>
<li><p>跳转并且执行一段恶意代码</p>
<p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。 </p>
</li>
</ul>
<h1 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h1><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​    多个进程因竞争资源而造成的一种僵局（互相等待），若无外力则这些进程都将无法向前推进。实例：线程1持有资源a，线程2持有资源b，但是线程1必须也同时持有资源b才能进行下去，所以线程1等待线程2释放资源b，而线程2也必须持有资源a才能进行下去，所以线程2等待线程1释放资源a，这样就形成了循环等待的条件，都无法进行下去，这就是死锁现象。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol>
<li>系统资源不足；</li>
<li>进程推进顺序非法。</li>
</ol>
<h2 id="导致死锁的四个必要条件"><a href="#导致死锁的四个必要条件" class="headerlink" title="导致死锁的四个必要条件"></a>导致死锁的四个必要条件</h2><ol>
<li>互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；</li>
<li>占有并等待：一个 进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；</li>
<li>非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放</li>
<li>循环等待：若干进程之间形成一种头尾相接的环形等待资源关系</li>
</ol>
<h2 id="死锁的处理基本策略和常用方法"><a href="#死锁的处理基本策略和常用方法" class="headerlink" title="死锁的处理基本策略和常用方法"></a>死锁的处理基本策略和常用方法</h2><p>基本方法主要有 预防死锁、避免死锁、检测死锁、解除死锁 </p>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>死锁预防的基本思想是 只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生，具体方法包括：</p>
<ol>
<li>打破互斥条件：允许进程同时访问某些资源。但是，有些资源是不能被多个进程所共享的，这是由资源本身属性所决定的，因此，这种办法通常并无实用价值。</li>
<li>打破占有并等待条件：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。</li>
<li>打破非抢占条件：允许进程强行从占有者哪里夺取某些资源。也就是说，但一个进程占有了一部分资源，在其申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。这种预防死锁的方式实现起来困难，会降低系统性能。</li>
<li>打破循环等待条件：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。</li>
</ol>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>​    死锁避免的基本思想是动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的，换句话说就是，如果存在一个安全序列，那么系统处于安全状态。资源分配图算法和银行家算法是两种经典的死锁避免的算法，其可以确保系统始终处于安全状态。其中，资源分配图算法应用场景为每种资源类型只有一个实例(申请边，分配边，需求边，不形成环才允许分配)，而银行家算法应用于每种资源类型可以有多个实例的场景。</p>
<h3 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h3><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>策略:鸵鸟策略（发生死锁的情况很少，不设计解除策略以提高整体性能）、预防策略、避免策略、检测与解除死锁 </p>
<p>​    死锁解除的常用两种方法为进程终止和资源抢占。所谓进程终止是指简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源，此时必须考虑三个问题：</p>
<p>   　1. 选择一个牺牲品<br>   　2. 回滚：回滚到安全状态<br>   　3. 饥饿（在代价因素中加上回滚次数，回滚的越多则越不可能继续被作为牺牲品，避免一个进程总是被回滚）<br>   　4. 剥夺资源<br> 　5. 撤销进程</p>
<h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><h1 id="缓存算法（页面置换算法）"><a href="#缓存算法（页面置换算法）" class="headerlink" title="缓存算法（页面置换算法）"></a>缓存算法（页面置换算法）</h1><p>​    <strong>最佳置换算法：</strong>只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。</p>
<p>​    <strong>先进先出置换算法：</strong>简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。</p>
<p>​    <strong>最近最久未使用算法LRU：</strong>算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。</p>
<p>​    <strong>时钟算法clock(也被称为是最近未使用算法NRU)：</strong>页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。</p>
<p>​    <strong>改进型Clock算法：</strong>在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。</p>
<p>​    <strong>最少使用算法LFU：</strong>设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。</p>
<h1 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h1><p>​    程序中<strong>创建一个线程</strong>或者在堆上<strong>申请一块内存时</strong>，都涉及到很多<strong>系统调用</strong>，也<strong>非常耗CPU</strong>，如果程序中有很多类似的工作线程或者需要<strong>频繁的申请释放小的内存</strong>，如果没有进行优化，那么此处代码可能成为程序的<strong>瓶颈</strong>。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>​    线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>线程池管理器：用于创建并管理线程池，包括创建线程、销毁线程池、添加新任务。</p>
<p>工作线程：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务。</p>
<p>任务接口：每个任务必须实现的接口，以供工作线程调度任务的执行。主要规定了任务的入口任务完成后的收尾工作，任务执行状态等。</p>
<p>任务队列（请求）：用于存放没有处理的任务，提供一种缓冲机制。</p>
<p>结果队列：用于存储请求执行后返回的结果</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol>
<li><p>需要大量的线程来完成任务，且完成任务的时间比较短。 WEB服务器完成网页请求这样的任务，使用线程池技术是非常合适的。因为单个任务小，而任务数量巨大，你可以想象一个热门网站的点击次数。但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Telnet会话时间比线程的创建时间大多了。</p>
</li>
<li><p>对性能要求苛刻的应用，比如要求服务器迅速响应客户请求。</p>
</li>
<li><p>接受突发性的大量请求，但不至于使服务器因此产生大量线程的应用。突发性大量客户请求，在没有线程池情况下，将产生大量线程，虽然理论上大部分操作系统线程数目最大值不是问题，短时间内产生大量线程可能使内存到达极限，并出现”OutOfMemory”的错误。</p>
</li>
</ol>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>​    目的:提出解决方案管理程序中内存的使用，提高内存的使用效率。</p>
<p>​    原理:预先分配足够大的内存，形成一个初步的“内存池”。分配内存，就是用户请求内存时，会返回内存池中一块空闲的内存，并将其标识为已经使用。释放内存时，不是真正的delete或者free而是把内存放回内存池的过程，同时把标志位设置空闲。最后应用程序结束时，把内存池销毁。</p>
<p>​    优缺点:</p>
<ol>
<li>减少了内存碎片的产生，因为创建内存池时，分配的都是一块一块比较完整的内存块。</li>
<li>提高了内存的使用效率。这个可以从分配和释放内存看出，因为每次释放没有调用系统函数，而是复用内存池中的内存。</li>
</ol>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>​    数据库连接池的解决方案是在应用程序启动时<strong>建立足够的数据库连接</strong>，由<strong>应用程序</strong>动态地对池中的连接进行<strong>申请、使用和释放</strong>。对于多于连接池中连接数的并发请求，应该在请求<strong>队列中排队等待</strong>。并且<strong>应用程序</strong>可以根据池中连接的<strong>使用率，动态增加或减少池中的连接</strong>数。</p>
<p>​    <strong>最小连接数</strong>是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费；</p>
<p>​    <strong>最大连接数</strong>是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。</p>
<h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><p>​    避免在程序的生命周期中创建和删除大量的对象。如果知道程序需要同一类型的对象，而且对象的生命周期都很短，就可以为这些对象创建一个池进行缓存。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>​    Windows提供了3种方法来进行内存管理：虚拟内存，最适合用来管理大型对象或者结构数组；内存映射文件，最适合用来管理大型数据流（通常来自文件）以及在单个计算机上运行多个进程之间共享数据；内存堆栈，最适合用来管理大量的小对象。</p>
<p>　　Windows操纵内存可以分两个层面：物理内存和虚拟内存。</p>
<h2 id="分页和分段有什么区别"><a href="#分页和分段有什么区别" class="headerlink" title="分页和分段有什么区别"></a>分页和分段有什么区别</h2><p>​    段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p>
<p>　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。</p>
<h3 id="两者的不同点："><a href="#两者的不同点：" class="headerlink" title="两者的不同点："></a>两者的不同点：</h3><ol>
<li>目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</li>
<li>大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；</li>
<li>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li>
<li>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</li>
<li>内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</li>
</ol>
<ul>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</li>
<li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定</li>
<li>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li>
<li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li>
</ul>
<h2 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h2><p>​    <strong>首次适应(First  Fit)算法：</strong>空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。</p>
<p>​    <strong>最佳适应(Best  Fit)算法：</strong>空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。</p>
<p>​    <strong>最坏适应(Worst  Fit)算法：</strong>又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="内存发展历史"><a href="#内存发展历史" class="headerlink" title="内存发展历史"></a>内存发展历史</h3><p>​    没有内存抽象(单进程，除去操作系统所用的内存之外，全部给用户程序使用) —&gt; 有内存抽象（多进程，进程独立的地址空间，交换技术(内存大小不可能容纳下所有并发执行的进程)<br>）—&gt; 连续内存分配(固定大小分区(多道程序的程度受限)，可变分区(首次适应，最佳适应，最差适应)，碎片) —&gt; 不连续内存分配（分段，分页，段页式，虚拟内存）</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>　　虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图5所示。 </p>
<p>​    注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1550041033975.png" alt="1550041033975"></p>
<p>　　由图5可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。</p>
<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>​    虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：</p>
<ul>
<li>在内存中可以保留多个进程，系统并发度提高</li>
<li>解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/sdausxc/article/details/52856592" target="_blank" rel="noopener">互联网操作系统面试===常考点</a></li>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/78304294" target="_blank" rel="noopener">面试/笔试第二弹 —— 操作系统面试问题集锦</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23755202" target="_blank" rel="noopener">常见面试题整理–操作系统篇（每位开发者必备）</a></li>
<li><a href="https://yq.aliyun.com/articles/133729" target="_blank" rel="noopener">操作系统常见面试题总结</a></li>
<li><a href="https://www.jianshu.com/p/d254b138de03" target="_blank" rel="noopener">操作系统面试重难点总结</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/面试/面试准备：计算机网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/12/面试/面试准备：计算机网络/" class="post-title-link" itemprop="url">面试准备：计算机网络</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-12 16:03:01" itemprop="dateCreated datePublished" datetime="2019-02-12T16:03:01+08:00">2019-02-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-04-17 12:14:24" itemprop="dateModified" datetime="2019-04-17T12:14:24+08:00">2019-04-17</time>
              </span>
            
          

          
            <span id="/2019/02/12/面试/面试准备：计算机网络/" class="post-meta-item leancloud_visitors" data-flag-title="面试准备：计算机网络">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/12/面试/面试准备：计算机网络/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/12/面试/面试准备：计算机网络/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549959881399.png" alt="1549959881399"></p>
<h3 id="TCP-IP体系"><a href="#TCP-IP体系" class="headerlink" title="TCP/IP体系"></a>TCP/IP体系</h3><p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549959915072.png" alt="1549959915072"></p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>即 传输控制协议</p>
<blockquote>
<ol>
<li>属于 传输层通信协议</li>
<li>基于<code>TCP</code>的应用层协议有<code>HTTP</code>、<code>SMTP</code>、<code>FTP</code>、<code>Telnet</code> 和 <code>POP3</code></li>
</ol>
</blockquote>
<p>特点</p>
<blockquote>
<ol>
<li>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li>
<li>每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li>
<li>TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li>
<li>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li>
<li>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li>
</ol>
</blockquote>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>即 用户数据报协议</p>
<blockquote>
<ol>
<li>属于 传输层通信协议</li>
<li>基于<code>UDP</code>的应用层协议有 <code>TFTP</code>、<code>SNMP</code> 与 <code>DNS</code></li>
</ol>
</blockquote>
<p>特点</p>
<blockquote>
<p>UDP 是无连接的；</p>
<p>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</p>
<p>UDP 是面向报文的；</p>
<p>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</p>
<p>UDP 支持一对一、一对多、多对一和多对多的交互通信；</p>
<p>UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</p>
</blockquote>
<h1 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP\UDP"></a>TCP\UDP</h1><h2 id="请简述TCP-UDP的区别"><a href="#请简述TCP-UDP的区别" class="headerlink" title="请简述TCP\UDP的区别"></a>请简述TCP\UDP的区别</h2><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>两者的区别大致如下：</p>
<ul>
<li><p>TCP是面向连接的，UDP是无连接的</p>
</li>
<li><p>TCP是可靠的，UDP是不可靠的；</p>
</li>
<li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</p>
</li>
<li><p>TCP是面向字节流的，UDP是面向报文的；</p>
</li>
<li><p>TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；</p>
</li>
<li><p>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</p>
</li>
</ul>
<h2 id="TCP三次-二次握手、四次挥手"><a href="#TCP三次-二次握手、四次挥手" class="headerlink" title="TCP三次\二次握手、四次挥手"></a>TCP三次\二次握手、四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)：</p>
<ul>
<li><p>第一次握手：Client客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server服务端，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549959595174.png" alt="1549959595174"></p>
</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>四次挥手(我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧)：</p>
<ul>
<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li>
<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</li>
<li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li>
<li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li>
</ul>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549959631400.png" alt="1549959631400"></p>
<h4 id="为什么TCP链接需要三次握手？"><a href="#为什么TCP链接需要三次握手？" class="headerlink" title="为什么TCP链接需要三次握手？"></a>为什么TCP链接需要三次握手？</h4><p>​    为了防止 已失效的链接请求报文突然又传送到了服务端，因而产生错误。</p>
<p>　　客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。</p>
<h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>​    任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><p>​    接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><p>​    双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<h2 id="TCP的拥塞处理"><a href="#TCP的拥塞处理" class="headerlink" title="TCP的拥塞处理"></a>TCP的拥塞处理</h2><p>​    计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种：</p>
<h4 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h4><blockquote>
<p>​    拥塞窗口:TCP包首部有一个字段是16位的窗口大小,窗口分为滑动窗口和拥塞窗口。滑动窗口是接受数据端使用的窗口大小，用来告知发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。那么对于数据的发送端就是拥塞窗口了，拥塞窗口不代表缓存，拥塞窗口指某一源端数据流在一个RTT（RTT=传播时延（往返哒）+排队时延（路由器和交换机的）+数据处理时延（应用程序的）。）内可以最多发送的数据包数.</p>
<p>​    迄今为止，在本章所有的例子中，发送方一开始便向网络发送多个报文段，直至达到接收方通告的窗口大小为止。当发送方和接收方处 于同一个局域网时，这种方式是可以的。但是如果在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。一些中间路由器必须缓存分 组，并有可能耗尽缓存，[Jacobson 1988]证明了这种连接方式是如何严重降低了TCP连接的吞吐量的。现在，TCP需要支持一种被称为“慢启动(slow start)”的算法。该算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。</p>
<p>​    慢启动为发送方的TCP增加了另一个窗口：拥塞窗口(congestion window)，记为cwnd。当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ACK， 拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗 口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。</p>
<p>​    发送方开始时发送一个报文段，然后等待ACK。当收到该ACK时，拥塞窗口从1增加为2，即可以发送两个报文段。当收到这两个报文段的ACK时，拥塞窗口就增加为4。这是一种指数增加的关系。</p>
<p>​    拥塞避免是发送方使用 的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估 计，而后者则与接收方在该连接上的可用缓存大小有关。</p>
<p>​    拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</p>
<p>​    拥塞发生有超时和收到重复确认两种情况，</p>
</blockquote>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><blockquote>
<p>​    滑动窗口：滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。ACK包含两个非常重要的信息：</p>
<p>​    一是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据，此时如果接收方收到第n+1字节数据而不是第n字节数据，接 收方是不会发送序号为n+2的ACK的。举个例子，假如接收端收到1-1024字节，它会发送一个确认号为1025的ACK,但是接下来收到的是 2049-3072，它是不会发送确认号为3072的ACK,而依旧发送1025的ACK。</p>
<p>​    二是当前的窗口大小m，如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，假定当前发送方已发送到第x字节，则可以发送的字节数就是y=m-(x-n).这就是滑动窗口控制流量的基本原理.</p>
</blockquote>
<ol>
<li><p>慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</p>
</li>
<li><p>拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</p>
</li>
</ol>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549968393816.png" alt="1549968393816"></p>
<ol start="3">
<li>快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>
</ol>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549968412533.png" alt="1549968412533"></p>
<ol start="4">
<li>快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</li>
</ol>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549968445968.png" alt="1549968445968"></p>
<h2 id="TCP协议如何来保证传输的可靠性"><a href="#TCP协议如何来保证传输的可靠性" class="headerlink" title="TCP协议如何来保证传输的可靠性"></a>TCP协议如何来保证传输的可靠性</h2><p>​    TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。</p>
<p>　　对于可靠性，TCP通过以下方式进行保证：</p>
<ul>
<li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</li>
<li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li>
<li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li>
<li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li>
<li>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li>
<li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li>
</ul>
<h2 id="客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？"><a href="#客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？" class="headerlink" title="客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？"></a>客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？</h2><p>　　服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认</p>
<ol>
<li>DDos 攻击</li>
</ol>
<ul>
<li>客户端向服务端发送请求链接数据包</li>
<li>服务端向客户端发送确认数据包</li>
<li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认</li>
</ul>
<ol start="2">
<li>DDos 预防 ( 没有彻底根治的办法，除非不使用TCP )</li>
</ol>
<ul>
<li>限制同时打开SYN半链接的数目</li>
<li>缩短SYN半链接的Time out 时间</li>
<li>关闭不必要的服务</li>
</ul>
<h1 id="HTTP！！！！！！"><a href="#HTTP！！！！！！" class="headerlink" title="HTTP！！！！！！"></a>HTTP！！！！！！</h1><p>HTTP简介，设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549967838050.png" alt="1549967838050"></p>
<p><strong>HTTP是不保存状态的协议：</strong></p>
<p>​    HTTP是一种不保存状态的协议，即无状态的协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。每当有新的请求，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应信息，所以在购物网站中一般使用Cookie技术。</p>
<h2 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h2><ul>
<li><strong>通用首部字段（请求报文与响应报文都会使用的首部字段）</strong><ul>
<li>Date：创建报文时间</li>
<li>Connection：连接的管理</li>
<li>Cache-Control：缓存的控制</li>
<li>Transfer-Encoding：报文主体的传输编码方式</li>
</ul>
</li>
<li><strong>请求首部字段（请求报文会使用的首部字段）</strong><ul>
<li>Host：请求资源所在服务器</li>
<li>Accept：可处理的媒体类型</li>
<li>Accept-Charset：可接收的字符集</li>
<li>Accept-Encoding：可接受的内容编码</li>
<li>Accept-Language：可接受的自然语言</li>
</ul>
</li>
<li><strong>响应首部字段（响应报文会使用的首部字段）</strong><ul>
<li>Accept-Ranges：可接受的字节范围</li>
<li>Location：令客户端重新定向到的URI</li>
<li>Server：HTTP服务器的安装信息</li>
</ul>
</li>
<li><strong>实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</strong><ul>
<li>Allow：资源可支持的HTTP方法</li>
<li>Content-Type：实体主类的类型</li>
<li>Content-Encoding：实体主体适用的编码方式</li>
<li>Content-Language：实体主体的自然语言</li>
<li>Content-Length：实体主体的的字节数</li>
<li>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</li>
</ul>
</li>
</ul>
<h2 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h2><p>​    Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；</p>
<p>​    Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p>
<p>​    端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</p>
<p>​    资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</p>
<p>​    开销：Https通信需要证书，而证书一般需要向认证机构购买；<br>　     Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>
<h3 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h3><p>​    SSL协议，这个协议提供网络连接的加密，如果我们访问一个https的网站，我们的电脑会先和服务器建立一个安全的连接通道，然后服务器会先发送一份网址的安全信息证书到我们的电脑，告诉我们的电脑，访问的服务器没有问题，确认了信息后，服务器就会生成一个加锁的箱子，但是这把锁有两把不一样的钥匙，一把时给我们的电脑的，一把是给服务器自己，然后服务器会把没有上锁的箱子和钥匙发给我们的电脑，我们把信息放在箱子里面然后用钥匙锁上，然后发给服务器，服务器用自己的钥匙打开箱子来保证信息的安全。</p>
<h3 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h3><p>　　对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</p>
<p>​    而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
<h2 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h2><p>​    在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>​    而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>​    在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p>​    <strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p>
<h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><ol>
<li>相对于使用 TCP 的HTTP1.1,用户在大多数情况下的感知延迟要有实质上、可度量的改进；</li>
<li>解决 HTTP 中的“队首阻塞”问题；<ul>
<li>队首阻塞会在下面的HTTP Pipelining解释</li>
</ul>
</li>
<li>并行操作无需与服务器建立多个连接，从而改进TCP的利用率，特别是拥塞控制方面；</li>
<li>保持 HTTP 1.1 的语义，利用现有文档，包括（但不限于）HTTP 方法、状态码、URI，以及首部字段(既向下兼容)</li>
<li>解决突破HTTP1.0 &amp; HTTP1.1 的性能限制,改进传输性能，实现低延迟和高吞吐量</li>
</ol>
<h4 id="主要改变"><a href="#主要改变" class="headerlink" title="主要改变"></a>主要改变</h4><ul>
<li>通过支持首部字段压缩和在同一连接上发送多个并发消息，让应用更有效地利用网络资源，减少感知的延迟时间。而且，它还支持服务器到客户端的主动推送机制</li>
</ul>
<h4 id="二进制分帧数据层"><a href="#二进制分帧数据层" class="headerlink" title="二进制分帧数据层"></a>二进制分帧数据层</h4><ul>
<li><p>作用:封装HTTP消息,并在客户端与服务器之间传输,将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码</p>
</li>
<li><p><strong>组成:帧 &amp; 消息 &amp; 流</strong></p>
<ul>
<li><p>组成:流既通道,通道内双向传输消息,消息由帧组成</p>
</li>
<li><p>流:连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…n)</p>
</li>
<li><p>消息：是指逻辑上的HTTP消息，比如请求、响应等，由一或多个帧组成</p>
</li>
<li><p>帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据,如HTTP的header 负荷等等,<strong>所有首部数据都会被压缩</strong></p>
</li>
</ul>
</li>
<li><p>二进制分帧层实现了多项请求和响应,可以把消息分级为互不依赖的帧,乱序发送</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 可以并行交错地发送请求，请求之间互不影响；</span><br><span class="line">2. 可以并行交错地发送响应，响应之间互不干扰；</span><br><span class="line">3. 只使用一个连接即可并行发送多个请求和响应；</span><br><span class="line">4. 消除不必要的延迟，从而减少页面加载的时间；</span><br><span class="line">5. 不必再为绕过 HTTP 1.x 限制而多做很多工作</span><br></pre></td></tr></table></figure>

<ul>
<li>作用 <ol>
<li>HTTP 2.0 的二进制分帧机制解决了HTTP1.x中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。</li>
<li>有了新的分帧机制后，HTTP 2.0不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多帧,而这些帧可以交错，还可以分别优先级。HTTP2.0连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可。</li>
<li>大多数HTTP 连接的时间都很短，而且是突发性的，但TCP 只在长时间连接传输大块数据时效率才最高。HTTP 2.0 通过让所有数据流共用同一个连接，可以更有效地使用TCP 连接。</li>
</ol>
</li>
</ul>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><ul>
<li>HTTP 2.0 新增的一个强大的新功能，就是服务器可以对一个客户端<strong>请求</strong>发送多个响应。服务器向客户端推送资源无需客户端明确地请求</li>
</ul>
<h4 id="HTTP-Pipelining"><a href="#HTTP-Pipelining" class="headerlink" title="HTTP Pipelining"></a>HTTP Pipelining</h4><ul>
<li>HTTP Pipelining:其实是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应。</li>
</ul>
<h2 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h2><ul>
<li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li>
<li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li>
<li>OPTIONS：查询相应URI支持的HTTP方法。</li>
</ul>
<p>GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：</p>
<ol>
<li><p>从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；</p>
</li>
<li><p>从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；</p>
</li>
<li><p>从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&amp;相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。</p>
</li>
<li><p>就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。</p>
</li>
<li><p>从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</p>
</li>
</ol>
<h3 id="GET请求中URL编码的意义"><a href="#GET请求中URL编码的意义" class="headerlink" title="GET请求中URL编码的意义"></a>GET请求中URL编码的意义</h3><p>　　我们知道，在GET请求中会对URL中非西文字符进行编码，这样做的目的就是为了 避免歧义。看下面的例子，</p>
<p>　　针对“name1=value1&amp;name2=value2”的例子，我们来谈一下数据从客户端到服务端的解析过程。首先，上述字符串在计算机中用ASCII吗表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6E616D6531 3D 76616C756531 26 6E616D6532 3D 76616C756532</span><br><span class="line">6E616D6531：name1 </span><br><span class="line">3D：= </span><br><span class="line">76616C756531：value1 </span><br><span class="line">26：&amp;</span><br><span class="line">6E616D6532：name2 </span><br><span class="line">3D：= </span><br><span class="line">76616C756532：value2</span><br></pre></td></tr></table></figure>

<p>​    服务端在接收到该数据后就可以遍历该字节流，一个字节一个字节的吃，当吃到3D这字节后，服务端就知道前面吃得字节表示一个key，再往后吃，如果遇到26，说明从刚才吃的3D到26子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。</p>
<p>　　现在考虑这样一个问题，如果我们的参数值中就包含=或&amp;这种特殊字符的时候该怎么办？比如，“name1=value1”，其中value1的值是“va&amp;lu=e1”字符串，那么实际在传输过程中就会变成这样“name1=va&amp;lu=e1”。这样，我们的本意是只有一个键值对，但是服务端却会解析成两个键值对，这样就产生了歧义。</p>
<p>　　那么，如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码：例如，我们对上述会产生歧义的字符进行URL编码后结果：“name1=va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。</p>
<h2 id="Session、Cookie-与-Application"><a href="#Session、Cookie-与-Application" class="headerlink" title="Session、Cookie 与 Application"></a>Session、Cookie 与 Application</h2><p>​    Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>​    Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>​    同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用 cookie机制 ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过 URL重写机制 将sessionid传回服务器。</p>
<h3 id="Session-与-Cookie-的对比"><a href="#Session-与-Cookie-的对比" class="headerlink" title="Session 与 Cookie 的对比"></a>Session 与 Cookie 的对比</h3><ul>
<li><p>实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</p>
</li>
<li><p>大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p>
</li>
<li><p>安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p>
</li>
<li><p>服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>
<p>Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。</p>
</li>
</ul>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>​    Application（Java Web中的ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。</p>
<h2 id="从输入网址到获得页面的过程"><a href="#从输入网址到获得页面的过程" class="headerlink" title="从输入网址到获得页面的过程"></a>从输入网址到获得页面的过程</h2><ol>
<li>浏览器分析链接指向页面的URL</li>
<li>浏览器向DNS请求解析百度服务器的IP地址</li>
<li>域名系统DNS解析出百度服务器的IP地址 </li>
<li>浏览器与服务器建立TCP连接</li>
<li>浏览器发出取文件命令（一般是发送HTTP请求）</li>
<li>服务器给出响应，把文件发送给浏览器（服务器通过HTTP响应把页面发送给浏览器）</li>
<li>释放TCP连接</li>
<li>浏览器显示</li>
</ol>
<ol>
<li><p>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</p>
</li>
<li><p>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</p>
</li>
<li><p>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</p>
</li>
<li><p>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</p>
</li>
<li><p>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</p>
</li>
<li><p>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</p>
</li>
</ol>
<h2 id="一次完整的HTTP请求所经历的7个步骤"><a href="#一次完整的HTTP请求所经历的7个步骤" class="headerlink" title="一次完整的HTTP请求所经历的7个步骤"></a>一次完整的HTTP请求所经历的7个步骤</h2><p>​    建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</p>
<ul>
<li><p>建立TCP连接</p>
<p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。<strong>HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</strong></p>
</li>
<li><p>Web浏览器向Web服务器发送请求行</p>
<p>一旦建立了TCP连接，<strong>Web浏览器就会向Web服务器发送请求命令</strong>。例如：GET /sample/hello.jsp HTTP/1.1。</p>
</li>
<li><p>Web浏览器发送请求头</p>
<ul>
<li>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，<strong>之后浏览器发送了一空白行来通知服务器</strong>，它已经结束了该头信息的发送。</li>
</ul>
</li>
<li><p>Web服务器应答</p>
<ul>
<li>客户机向服务器发出请求后，服务器会客户机回送应答， <strong>HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</strong></li>
</ul>
</li>
<li><p>Web服务器发送应答头</p>
<ul>
<li>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</li>
</ul>
</li>
<li><p>Web服务器向浏览器发送数据</p>
<ul>
<li>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，<strong>它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</strong>。</li>
</ul>
</li>
<li><p>Web服务器关闭TCP连接</p>
<ul>
<li>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码keep-alive：</li>
</ul>
</li>
</ul>
<h2 id="常见状态码及原因短语"><a href="#常见状态码及原因短语" class="headerlink" title="常见状态码及原因短语"></a>常见状态码及原因短语</h2><p>​    HTTP请求结构： 请求方式 + 请求URI + 协议及其版本<br>　　HTTP响应结构： 状态码 + 原因短语 + 协议及其版本</p>
<ul>
<li><p>1×× : 请求处理中，请求已被接受，正在处理</p>
</li>
<li><p>2×× : 请求成功，请求被成功处理 </p>
<ul>
<li>200 OK</li>
</ul>
</li>
<li><p>3×× : 重定向，要完成请求必须进行进一步处理 </p>
<ul>
<li>301 : 永久性转移 </li>
<li>302 ：暂时性转移 </li>
<li>304 ： 已缓存</li>
</ul>
</li>
<li><p>4×× : 客户端错误，请求不合法 </p>
<ul>
<li>400：Bad Request,请求有语法问题<br>403：拒绝请求<br>404：客户端所访问的页面不存在</li>
</ul>
</li>
<li><p>5×× : 服务器端错误，服务器不能处理合法请求 </p>
<ul>
<li><p>500 ：服务器内部错误 </p>
</li>
<li><p>503 ： 服务不可用，稍等 </p>
</li>
</ul>
</li>
</ul>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><p>​    IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。</p>
<p>　　每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：</p>
<ul>
<li><p>A类地址：以0开头，第一个字节范围：0~127；</p>
</li>
<li><p>B类地址：以10开头，第一个字节范围：128~191；</p>
</li>
<li><p>C类地址：以110开头，第一个字节范围：192~223；</p>
</li>
<li><p>D类地址：以1110开头，第一个字节范围为224~239；</p>
</li>
<li><p>E类地址：以1111开头，保留地址</p>
</li>
</ul>
<h2 id="网络层的ARP协议工作原理"><a href="#网络层的ARP协议工作原理" class="headerlink" title="网络层的ARP协议工作原理"></a>网络层的ARP协议工作原理</h2><p>​    网络层的ARP协议完成了IP地址与物理地址的映射。</p>
<ul>
<li>首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。</li>
<li>此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖</li>
<li>然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；</li>
<li>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。</li>
<li>如果源主机一直没有收到ARP响应数据包，表示ARP查询失败.</li>
</ul>
<h2 id="IP地址与物理地址"><a href="#IP地址与物理地址" class="headerlink" title="IP地址与物理地址"></a>IP地址与物理地址</h2><p>　　物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，其中ARP协议用于IP地址与物理地址的对应。</p>
<h1 id="路由器与交换机"><a href="#路由器与交换机" class="headerlink" title="路由器与交换机"></a>路由器与交换机</h1><p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549969125224.png" alt="1549969125224"></p>
<h1 id="TOKEN"><a href="#TOKEN" class="headerlink" title="TOKEN"></a>TOKEN</h1><p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549969159203.png" alt="1549969159203"></p>
<h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><ul>
<li>即套接字，<strong>是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）</strong></li>
</ul>
<p><img src="C:%5CUsers%5CHeper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549976861895.png" alt="1549976861895"></p>
<blockquote>
<ol>
<li><code>Socket</code>不是一种协议，而是一个编程调用接口（<code>API</code>），属于传输层（主要解决数据如何在网络中传输）</li>
<li>即：通过<code>Socket</code>，我们才能在Andorid平台上通过 <code>TCP/IP</code>协议进行开发</li>
<li>对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信</li>
</ol>
</blockquote>
<ul>
<li>成对出现，一对套接字：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket =&#123;(IP地址1:PORT端口号)，(IP地址2:PORT端口号)&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个 <code>Socket</code> 实例 唯一代表一个主机上的一个应用程序的通信链路</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/24001696" target="_blank" rel="noopener">常见面试题整理–计算机网络篇(每位开发者必备)</a></li>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/78303617" target="_blank" rel="noopener">面试/笔试第一弹 —— 计算机网络面试问题集锦</a></li>
<li><a href="https://blog.csdn.net/chenkaibsw/article/details/79772021" target="_blank" rel="noopener">互联网公司计算机网络热门面试题整理</a></li>
<li><a href="https://juejin.im/post/5b7be0b2e51d4538db34a51e" target="_blank" rel="noopener">搞定计算机网络面试，看这篇就够了（补充版）</a></li>
<li><a href="https://juejin.im/post/5ad7e6c35188252ebd06acfa" target="_blank" rel="noopener">面试带你飞：这是一份全面的 计算机网络基础 总结攻略</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F089fb79e308b" target="_blank" rel="noopener">Android：这是一份很详细的Socket使用攻略</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/11/算法/算法：面试准备/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/11/算法/算法：面试准备/" class="post-title-link" itemprop="url">面试算法准备</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-11 19:14:52" itemprop="dateCreated datePublished" datetime="2019-02-11T19:14:52+08:00">2019-02-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-03-22 20:47:48" itemprop="dateModified" datetime="2019-03-22T20:47:48+08:00">2019-03-22</time>
              </span>
            
          

          
            <span id="/2019/02/11/算法/算法：面试准备/" class="post-meta-item leancloud_visitors" data-flag-title="面试算法准备">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/11/算法/算法：面试准备/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/11/算法/算法：面试准备/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="海量数据排序"><a href="#海量数据排序" class="headerlink" title="海量数据排序"></a>海量数据排序</h1><p><strong>外部排序</strong></p>
<p>传统的排序算法一般指内排序算法，针对的是数据可以一次全部载入内存中的情况。但是面对海量数据，即数据不可能一次全部载入内存，需要用到外排序的方法。外排序采用分块的方法（分而治之），首先将数据分块，对块内数据按选择一种高效的内排序策略进行排序。然后采用归并排序的思想对于所有的块进行排序，得到所有数据的一个有序序列。</p>
<p>例如，考虑一个1G文件，可用内存100M的排序方法。</p>
<ol>
<li>首先将文件分成10个100M，并依次载入内存中进行排序，最后结果存入硬盘。得到的是10个分别排序的文件。</li>
<li>接着从每个文件载入9M的数据到输入缓存区，输出缓存区大小为10M。对输入缓存区的数据进行归并排序，输出缓存区写满之后写在硬盘上，缓存区清空继续写接下来的数据。</li>
<li>对于输入缓存区，当一个块的9M数据全部使用完，载入该块接下来的9M数据，一直到所有的9个块的所有数据都已经被载入到内存中被处理过。最后我们得到的是一个1G的排序好的存在硬盘上的文件。</li>
</ol>
<p><strong>继续优化</strong> </p>
<ul>
<li>磁盘I/O通常是越少越好（最好完全没有），那么如何降低磁盘I/O操作呢？关键就在第5和第6步中的40路输入缓冲区，我们可以先做8路merge sort，把每8个块合并为1路，然后再做5-to-1的合并操作。 </li>
<li>再深入思考一下，如果有多余的硬件，如何继续优化呢？有三个方向可以考虑： <ul>
<li>使用并发：如多磁盘（并发I/O提高）、多线程、使用异步I/O、使用多台主机集群计算。 </li>
<li>提升硬件性能：如更大内存、更高RPM的磁盘、升级为SSD、Flash、使用更多核的CPU。 </li>
<li>提高软件性能：比如采用radix sort、压缩文件（提高I/O效率）等。</li>
</ul>
</li>
</ul>
<h1 id="TOP-K"><a href="#TOP-K" class="headerlink" title="TOP K"></a>TOP K</h1><p><strong>问题描述：</strong></p>
<p>TopK Elements 问题用于找出一组数中最大的 K 个的数。</p>
<p><img src="assets/e96d0bc52e3a0b38fc5f3976ca78e6b3.png" alt="img"></p>
<p>此外还有一种叫 Kth Element 问题，用于找出一组数中第 K 大的数。</p>
<p><img src="assets/54a40d9e1d1d4e058d2e633de10523eb.png" alt="img"></p>
<p>如果要找的 TopK Elements 是最小的 K 个数，那么可以将问题转换成求解 TopK Elements，因为找到 Kth Element 之后，再遍历一遍，小于等于 Kth Element 的数都是 TopK Elements。</p>
<p><strong>堆排序</strong></p>
<p>可针对海量数据</p>
<p>为了查找Top k大的数，我们可以使用大根堆来存储最大的K个元素。大根堆的堆顶元素就是最大K个数中最小的一个。每次考虑下一个数x时，如果x比堆顶元素小，则不需要改变原来的堆。如果想x比堆顶元素大，那么用x替换堆顶元素， 同时，在替换之后，x可能破坏最小堆的结构，需要调整堆来维持堆的性质。算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findTopK(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> heapArray[] = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        heapArray[i] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    buildMaxHeap(heapArray);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; heapArray[<span class="number">0</span>]) &#123;</span><br><span class="line">            heapArray[<span class="number">0</span>] = array[i];<span class="comment">//更新堆顶</span></span><br><span class="line">            adjustMaxHeap(heapArray, <span class="number">0</span>, heapArray.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heapArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建大根堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        adjustMaxHeap(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整堆结构</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root   根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> root, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = root * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">//左节点下标，数组下标从0开始，所以加1</span></span><br><span class="line">    <span class="keyword">int</span> right = left + <span class="number">1</span>; <span class="comment">//右节点下标</span></span><br><span class="line">    <span class="keyword">int</span> largest = root;<span class="comment">// 存放三个节点中最大节点的下标</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; length &amp;&amp; array[left] &gt; array[root]) &#123; <span class="comment">//左节点大于根节点，更新最大节点的下标</span></span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; length &amp;&amp; array[right] &gt; array[largest]) &#123;<span class="comment">//右节点大于根节点，最大节点的下标</span></span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root != largest) &#123;</span><br><span class="line">        swap(array, largest, root);</span><br><span class="line">        adjustMaxHeap(array, largest, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快排</strong></p>
<p>虽然我们不会采用快速排序的算法来实现TOP-K问题，但我们可以利用快速排序的思想，在数组中随机找一个元素key，将数组分成两部分Sa和Sb，其中Sa的元素&gt;=key，Sb的元素&lt;key，然后分析两种情况：</p>
<ul>
<li>若Sa中元素的个数大于或等于k，则在Sa中查找最大的k个数</li>
<li>若Sa中元素的个数小于k，其个数为len，则在Sb中查找k-len个数字</li>
</ul>
<p>如此递归下去，不断把问题分解为更小的问题，直到求出结果。</p>
<p>该算法的平均时间复杂度为O(N * logk)。以求K大的数为例，算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findTopK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(array, left, right);</span><br><span class="line">        <span class="keyword">int</span> len = pos - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len == k) &#123;</span><br><span class="line">            index = pos;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; k) &#123;<span class="comment">//Sa中元素个数小于K，到Sb中查找k-len个数字</span></span><br><span class="line">            index = findTopK(array, pos + <span class="number">1</span>, right, k - len);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//Sa中元素的个数大于或等于k</span></span><br><span class="line">            index = findTopK(array, left, pos - <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按基准点划分数组，左边的元素大于基准点，右边的元素小于基准点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = array[left];<span class="comment">//基准点，随机选择</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (array[right] &lt; x &amp;&amp; left &lt; right)<span class="comment">//从后向前扫描，找到第一个比基准点大的元素</span></span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            array[left] = array[right];<span class="comment">//大元素前移</span></span><br><span class="line">            left++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (array[left] &gt;= x &amp;&amp; left &lt; right) <span class="comment">//从前向后扫描，找到第一个比基准点小的元素</span></span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            array[right] = array[left];<span class="comment">//小元素后移</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (left &lt; right);</span><br><span class="line">    array[left] = x;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间换时间</strong></p>
<p>如果所有N个数都是正整数，且他们的取值范围并不大，可以考虑申请空间，记录每个整数出现的次数，然后再从大到小取最大的K个。实际就是利用计数排序的思想。 假设所有整数都在（0，maxN）区间，利用一个数组count[maxN]来记录每个整数出现的次数。count[i]表示整数i在N个数中出现的次数。只需要扫描一遍就可以得到count数组，然后寻找第K大的元素。算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findTopK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; array[i]) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count[] = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        count[array[i]] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; topKList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sumCount = <span class="number">0</span>, j = count.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = count[j];</span><br><span class="line">        sumCount += c;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">                topKList.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sumCount &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> topKList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个典型的以空间换取时间的做法。当数组中取值范围比较大时，是及其浪费空间的。如[3,1…9999]，为了求出最大的K个元素，需要额外申请一个长度为10000的数组。</p>
<h1 id="Rand7"><a href="#Rand7" class="headerlink" title="Rand7"></a>Rand7</h1><p>问题描述： 已知rand5能等概率产生1, 2, 3, 4, 5， 现要用rand5来实现rand7（rand7的意思是要等概率产生1, 2, 3, 4, 5, 6, 7）</p>
<ul>
<li>用rand5产生等概率的0, 1, 2, 3, 4，准备插入到下一步的等间距数组中, 使得插入后， 刚好合适。</li>
<li>用rand5产生等概率的0, 1, 2, 3, 4,  然后为了被插入， 将其散开成0, 5, 10, 15, 20.</li>
<li>将第一步插入 到第二步中， 于是， 就形成了0， 1， 2， 3， 4， 5， 6， 7， 8， …， 20， 21， 22， 23， 24.  然后就很容易等概率地生成1, 2, 3, 4, 5, 6, 7了。</li>
</ul>
<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            result ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            result ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到result的不为0的第一个字节</span></span><br><span class="line">        <span class="comment">//如何找呢</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((result &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            result = result &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            pos = pos &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; pos) == <span class="number">0</span>) &#123;</span><br><span class="line">                res[<span class="number">0</span>] ^= i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[<span class="number">1</span>] ^= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="求众数"><a href="#求众数" class="headerlink" title="求众数"></a>求众数</h1><p>给定一个大小为 <em>n</em> 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> maj = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (maj == nums[i])</span><br><span class="line">				count++;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				count--;</span><br><span class="line">				<span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">					maj = nums[i + <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maj;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="鸡蛋掉落"><a href="#鸡蛋掉落" class="headerlink" title="鸡蛋掉落"></a>鸡蛋掉落</h1><h2 id="标准版"><a href="#标准版" class="headerlink" title="标准版"></a>标准版</h2><p>有2个鸡蛋，从100层楼上往下扔，以此来测试鸡蛋的硬度。比如鸡蛋在第9层没有摔碎，在第10层摔碎了，那么鸡蛋不会摔碎的临界点就是9层。<br>问：如何用最少的尝试次数，测试出鸡蛋不会摔碎的临界点？</p>
<p><strong>二分法</strong></p>
<p><strong>平方根法</strong></p>
<h2 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h2><p>你知道存在楼层 <code>F</code> ，满足 <code>0 &lt;= F &lt;= N</code> 任何从高于 <code>F</code> 的楼层落下的鸡蛋都会碎，从 <code>F</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次<em>移动</em>，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 <code>X</code> 扔下（满足 <code>1 &lt;= X &lt;= N</code>）。</p>
<p>你的目标是<strong>确切地</strong>知道 <code>F</code> 的值是多少。</p>
<p>无论 <code>F</code> 的初始值如何，你确定 <code>F</code> 的值的最小移动次数是多少？</p>
<p><strong>动态规划</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.zhihu.com/question/24964987" target="_blank" rel="noopener">互联网公司最常见的面试算法题有哪些？</a></li>
<li><a href="https://blog.csdn.net/fx677588/article/details/72471357" target="_blank" rel="noopener">海量数据排序——如果有1TB的数据需要排序，但只有32GB的内存如何排序处理？</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/11/算法/五大常用算法之五：分支限界法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/11/算法/五大常用算法之五：分支限界法/" class="post-title-link" itemprop="url">五大常用算法之五：分支限界法</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-11 19:14:40 / Modificado por: 21:42:18" itemprop="dateCreated datePublished" datetime="2019-02-11T19:14:40+08:00">2019-02-11</time>
            </span>
          
            

            
          

          
            <span id="/2019/02/11/算法/五大常用算法之五：分支限界法/" class="post-meta-item leancloud_visitors" data-flag-title="五大常用算法之五：分支限界法">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/11/算法/五大常用算法之五：分支限界法/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/11/算法/五大常用算法之五：分支限界法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="基本描述"><a href="#基本描述" class="headerlink" title="基本描述"></a>基本描述</h1><p>​    类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。<strong>回溯法的求解目标是找出T中满足约束条件的所有解</strong>，而<strong>分支限界法</strong>的求解目标则是找出<strong>满足约束条件的一个解</strong>，或是在满足约束条件的解中找出使某一目标函数值达到<strong>极大或极小的解</strong>，即在某种意义下的<strong>最优解</strong>。</p>
<h2 id="分支搜索算法"><a href="#分支搜索算法" class="headerlink" title="分支搜索算法"></a>分支搜索算法</h2><p>​    所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。</p>
<p>​    选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。</p>
<ol>
<li>FIFO搜索</li>
<li>LIFO搜索</li>
<li>优先队列式搜索</li>
</ol>
<h2 id="分支限界搜索算法"><a href="#分支限界搜索算法" class="headerlink" title="分支限界搜索算法"></a>分支限界搜索算法</h2><h1 id="分支限界法的一般过程"><a href="#分支限界法的一般过程" class="headerlink" title="分支限界法的一般过程"></a>分支限界法的一般过程</h1><p>​    由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。<strong>回溯法以深度优先的方式搜索解空间树T</strong>，而<strong>分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T</strong>。</p>
<p>​    分支限界法的<strong>搜索策略是</strong>：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p>
<p>​    分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的<strong>解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树</strong>。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。</p>
<h1 id="回溯法和分支限界法的一些区别"><a href="#回溯法和分支限界法的一些区别" class="headerlink" title="回溯法和分支限界法的一些区别"></a>回溯法和分支限界法的一些区别</h1><p>​    有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？</p>
<p>​    回溯法和分支限界法的一些区别：</p>
<p>​    方法对解空间树的搜索方式       <a href="http://www.storworld.com/" target="_blank" rel="noopener">存储</a>结点的常用数据结构      结点<a href="http://www.storworld.com/" target="_blank" rel="noopener">存储</a>特性常用应用</p>
<p>​    回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</p>
<p>​    分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741378.html" target="_blank" rel="noopener">五大常用算法之五：分支限界法</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/11/算法/五大常用算法之四：回溯法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/11/算法/五大常用算法之四：回溯法/" class="post-title-link" itemprop="url">五大常用算法之四：回溯法</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-11 19:14:34 / Modificado por: 21:43:42" itemprop="dateCreated datePublished" datetime="2019-02-11T19:14:34+08:00">2019-02-11</time>
            </span>
          
            

            
          

          
            <span id="/2019/02/11/算法/五大常用算法之四：回溯法/" class="post-meta-item leancloud_visitors" data-flag-title="五大常用算法之四：回溯法">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/11/算法/五大常用算法之四：回溯法/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/11/算法/五大常用算法之四：回溯法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>​    回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>​    回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>​    许多<strong><em>复杂的，规模较大</em></strong>的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>​    在包含问题的所有解的解空间树中，按照<strong>深度优先搜索的策略</strong>，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>
<p>​    若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>
<p>​       而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
<h1 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h1><ol>
<li>针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</li>
<li>确定结点的扩展搜索规则</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用<strong><em>剪枝函数</em></strong>避免无效搜索。</li>
</ol>
<h1 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h1><ol>
<li><p>问题框架</p>
<p>设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。</p>
</li>
<li><p>非递归回溯框架</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> int a[n],i;</span><br><span class="line"> 初始化数组a[];</span><br><span class="line"> i = 1;</span><br><span class="line"> while (i&gt;0(有路可走)   and  (未达到目标))  // 还未回溯到头</span><br><span class="line">     if(i &gt; n)                                              // 搜索到叶结点</span><br><span class="line">     &#123;   </span><br><span class="line">           搜索到一个解，输出；</span><br><span class="line">     &#125;</span><br><span class="line">     else                                                   // 处理第i个元素</span><br><span class="line">     &#123; </span><br><span class="line">         a[i]第一个可能的值；</span><br><span class="line">         while(a[i]在不满足约束条件且在搜索空间内)</span><br><span class="line">         &#123;</span><br><span class="line">            a[i]下一个可能的值；</span><br><span class="line">         &#125;</span><br><span class="line">         if(a[i]在搜索空间内)</span><br><span class="line">         &#123;</span><br><span class="line">              标识占用的资源；</span><br><span class="line">               i = i+1;                              // 扩展下一个结点</span><br><span class="line">         &#125;</span><br><span class="line">         else </span><br><span class="line">         &#123;</span><br><span class="line">              清理所占的状态空间；            // 回溯</span><br><span class="line">              i = i –1; </span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>递归的算法框架</p>
<p>回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> int a[n];</span><br><span class="line"> try(int i)</span><br><span class="line"> &#123;</span><br><span class="line">       if(i&gt;n)</span><br><span class="line">           输出结果;</span><br><span class="line">       else</span><br><span class="line">       &#123;</span><br><span class="line">       for(j = 下界; j &lt;= 上界; j=j+1)  // 枚举i所有可能的路径</span><br><span class="line">       &#123;</span><br><span class="line">              if(fun(j))                 // 满足限界函数和约束条件</span><br><span class="line">              &#123;</span><br><span class="line">                a[i] = j;</span><br><span class="line">                ...                         // 其他操作</span><br><span class="line">                try(i+1);</span><br><span class="line">              回溯前的清理工作（如a[i]置空值等）;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html" target="_blank" rel="noopener">五大常用算法之四：回溯法</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/11/算法/五大常用算法之三：贪心算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/11/算法/五大常用算法之三：贪心算法/" class="post-title-link" itemprop="url">五大常用算法之三：贪心算法</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-11 19:14:20 / Modificado por: 19:32:59" itemprop="dateCreated datePublished" datetime="2019-02-11T19:14:20+08:00">2019-02-11</time>
            </span>
          
            

            
          

          
            <span id="/2019/02/11/算法/五大常用算法之三：贪心算法/" class="post-meta-item leancloud_visitors" data-flag-title="五大常用算法之三：贪心算法">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/11/算法/五大常用算法之三：贪心算法/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/11/算法/五大常用算法之三：贪心算法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>​    所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p>
<p>​    贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>​    所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p>
<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><pre><code>1. 建立数学模型来描述问题。
2. 把求解的问题分成若干个子问题。
3. 对每一子问题求解，得到子问题的局部最优解。
4. 把子问题的解局部最优解合成原来解问题的一个解。</code></pre><h1 id="适用问题"><a href="#适用问题" class="headerlink" title="适用问题"></a>适用问题</h1><p>​    贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</p>
<p>​    实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p>
<h1 id="实现框架"><a href="#实现框架" class="headerlink" title="实现框架"></a>实现框架</h1><p>​    从问题的某一初始解出发；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while （能朝给定总目标前进一步）</span><br><span class="line">&#123; </span><br><span class="line">      利用可行的决策，求出可行解的一个解元素；</span><br><span class="line">&#125;</span><br><span class="line">由所有解元素组合成问题的一个可行解；</span><br></pre></td></tr></table></figure>

<h1 id="贪心策略的选择"><a href="#贪心策略的选择" class="headerlink" title="贪心策略的选择"></a>贪心策略的选择</h1><p>​    因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p>
<p>​    贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html" target="_blank" rel="noopener">五大常用算法之三：贪心算法</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/11/算法/五大常用算法之二：动态规划算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/11/算法/五大常用算法之二：动态规划算法/" class="post-title-link" itemprop="url">五大常用算法之二：动态规划算法</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-02-11 19:13:57 / Modificado por: 19:36:59" itemprop="dateCreated datePublished" datetime="2019-02-11T19:13:57+08:00">2019-02-11</time>
            </span>
          
            

            
          

          
            <span id="/2019/02/11/算法/五大常用算法之二：动态规划算法/" class="post-meta-item leancloud_visitors" data-flag-title="五大常用算法之二：动态规划算法">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/02/11/算法/五大常用算法之二：动态规划算法/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/11/算法/五大常用算法之二：动态规划算法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>​    动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p>
<h1 id="基本思想与策略"><a href="#基本思想与策略" class="headerlink" title="基本思想与策略"></a>基本思想与策略</h1><p>​    基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<p>​    由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
<p>​    与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<h1 id="适用的情况"><a href="#适用的情况" class="headerlink" title="适用的情况"></a>适用的情况</h1><p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<pre><code>1. 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
2. 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
3. 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</code></pre><h1 id="求解的基本步骤"><a href="#求解的基本步骤" class="headerlink" title="求解的基本步骤"></a>求解的基本步骤</h1><p>​    动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p>
<p>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p>
<ol>
<li><p><strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p>
</li>
<li><p><strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p>
</li>
<li><p><strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p>
</li>
<li><p><strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p>
</li>
</ol>
<p>​    一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。实际应用中可以按以下几个简化的步骤进行设计：</p>
<ol>
<li>分析最优解的性质，并刻画其结构特征。</li>
<li>递归的定义最优解。</li>
<li>以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</li>
<li>根据计算最优值时得到的信息，构造问题的最优解</li>
</ol>
<h1 id="算法实现的说明"><a href="#算法实现的说明" class="headerlink" title="算法实现的说明"></a>算法实现的说明</h1><p>​    动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p>
<p>​    使用动态规划求解问题，最重要的就是确定动态规划三要素：</p>
<ol>
<li>问题的阶段 </li>
<li>每个阶段的状态</li>
<li>从前一个阶段转化到后一个阶段之间的递推关系。</li>
</ol>
<p>​    递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p>
<p>​    确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p>
<p>​          <strong>f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</strong></p>
<h1 id="经典问题举例"><a href="#经典问题举例" class="headerlink" title="经典问题举例"></a>经典问题举例</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html" target="_blank" rel="noopener">五大常用算法之二：动态规划算法</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="Página anterior"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="Página siguiente"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">219</span>
          <span class="site-state-item-name">entradas</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categorías</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
</div>
  <div class="powered-by">Creado mediante <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Tema – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  











  
  <script>
    function showTime(Counter) {
      var entries = [];
      var $visitors = $('.leancloud_visitors');

      $visitors.each(function() {
        entries.push( $(this).attr('id').trim() );
      });

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url: { '$in': entries } }) })
        .done(function({ results }) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if (countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function ({ responseJSON }) {
          console.log(`LeanCloud Counter Error: ${responseJSON.code} ${responseJSON.error}`);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
                'X-LC-Key': 'uTVcNIWdMCGpicrhTKygpKXi',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
            if ($('.post-title-link').length >= 1) {
              showTime(Counter);
            }
          
        });
    });
  </script>
























    
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
    appKey: 'uTVcNIWdMCGpicrhTKygpKXi',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn'
  });
</script>


</body>
</html>
