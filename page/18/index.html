<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: 'OZTK1BY156',
      apiKey: '',
      indexName: 'BlogIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copiar',
      copy_success: 'Copiado',
      copy_failure: 'Copiar falló'
    }
  };
</script>

  <meta name="description" content="To be awesome">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/18/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="To be awesome">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="To be awesome">
  <link rel="canonical" href="http://yoursite.com/page/18/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Cambiar a barra de navegación">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Inicio</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>Sobre mi</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Etiquetas</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categorías</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archivo</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>Calendario</a>

  </li>
    </ul>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/09/Java/设计模式/设计模式：策略模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/09/Java/设计模式/设计模式：策略模式/" class="post-title-link" itemprop="url">策略模式</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2018-10-09 09:04:04" itemprop="dateCreated datePublished" datetime="2018-10-09T09:04:04+08:00">2018-10-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-29 08:54:55" itemprop="dateModified" datetime="2019-07-29T08:54:55+08:00">2019-07-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2018/10/09/Java/设计模式/设计模式：策略模式/" class="post-meta-item leancloud_visitors" data-flag-title="策略模式">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2018/10/09/Java/设计模式/设计模式：策略模式/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/10/09/Java/设计模式/设计模式：策略模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          设计模式入门学习，涉及到：策略模式
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/10/09/Java/设计模式/设计模式：策略模式/">
                Leer más &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/08/Java/设计模式/设计模式：观察者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/08/Java/设计模式/设计模式：观察者模式/" class="post-title-link" itemprop="url">观察者模式</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2018-10-08 17:19:18" itemprop="dateCreated datePublished" datetime="2018-10-08T17:19:18+08:00">2018-10-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-29 08:57:41" itemprop="dateModified" datetime="2019-07-29T08:57:41+08:00">2019-07-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2018/10/08/Java/设计模式/设计模式：观察者模式/" class="post-meta-item leancloud_visitors" data-flag-title="观察者模式">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2018/10/08/Java/设计模式/设计模式：观察者模式/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/10/08/Java/设计模式/设计模式：观察者模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>将一个系统分割成一系列相互协作的类有一个常见的副作用，需要维护相关对象间的一致性。不希望为了维持一致性而使各个类紧密耦合，这样降低了它们的可重用性</p>
<h3 id="问题案例"><a href="#问题案例" class="headerlink" title="问题案例"></a>问题案例</h3><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将二者封装在独立的对象中以使它们可以格子独立地改变和复用</li>
<li>当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变</li>
<li>当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望对象是紧耦合的。</li>
</ul>
<h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>考虑报纸和杂志的订阅</p>
<ul>
<li>报社的业务就是出版报纸</li>
<li>向某家报社订阅报纸，只要他们有新的报纸出版，就会给你送来，只要你是他们的订户，你就会一直收到报纸</li>
<li>当你不想再看报纸时，取消订阅，他们就不会再送新报纸过来</li>
<li>只要报社还在运营，就会一直有人向他们订阅报纸或取消订阅报纸</li>
</ul>
<p>在观察者模式当中：出版社为“主题”，订阅者为“观察者”</p>
<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>考虑Excel里面的图表与数据</p>
<ul>
<li>定义数据的类和负责界面表示的类可以各自独立地复用，也可以一起工作</li>
<li>当数据改变时，柱状图、表格等会立即改变。但是表格对象和柱状图似乎不知道对方的存在，可以根据需要单独复用表格和柱状图</li>
<li>即意味着表格对象和柱状图都依赖于数据对象，因此数据对象的任何状态改变都应立即通知它们。而且对于数据可以有任意数目的不同的用户界面</li>
</ul>
<h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>观察者模式:定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新</p>
</blockquote>
<ul>
<li>可观察者（主题）与观察者，一旦主题的状态发生改变，所有的观察者状态都会得到通知，作为对通知的响应，观察者都会将查询目标的状态与自己的状态同步。</li>
<li>帮助对象知晓现状，不会错过该对象感兴趣的事情，对象甚至可以在运行时可决定是否要继续被通知</li>
<li>定义了一种对象之间的一对多依赖，这样一来，当一个对象改变时，它的所有依赖者都会收到通知并自动更新</li>
</ul>
<p><strong><em>一对多的依赖关系</em></strong></p>
<ul>
<li>主题是真正拥有数据的人 ，观察者是依赖者，只是更新数据，但并不控制数据</li>
<li>主题是具有状态的对象，并可以控制状态，观察者使用状态，依赖主题告诉他们状态何时改变</li>
</ul>
<p><strong><em>松耦合</em></strong></p>
<ul>
<li>对于观察者的一切，主题只知道观察者实现了某个接口，主题并不需要知道观察者具体是谁。</li>
<li>当出现新的观察者或新的具体类，只需要实现观察者接口，并将其注册到主题上即可</li>
<li>改变主题与观察者，并不会影响另一方，只要还遵循接口，便可以自由地改变</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="assets/1559290104936.png" alt="1559290104936"></p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li>Subject：主题对象<ul>
<li>主题知道它的观察者，可以有任意多个观察者观察同一个目标</li>
<li>提供注册和删除观察者对象的接口</li>
</ul>
</li>
<li>Observer：观察者对象，订阅（注册）主题，以便在主题数据改变时能受到更新</li>
<li>ConcreteSubject：具体目标<ul>
<li>将有关的状态存入各个ConcreteObserver中，当状态改变时通知观察者</li>
</ul>
</li>
<li>ConcreteObserver：具体观察者<ul>
<li>维护一个指向ConcreteSubject的引用</li>
<li>存储有关状态，这些状态与Subject的状态一直，并实现Observer的更新接口，以使得一旦数据改变，新的数据便会以某种形式送到观察者手中</li>
</ul>
</li>
</ul>
<h3 id="协作-1"><a href="#协作-1" class="headerlink" title="协作"></a>协作</h3><ul>
<li>类关系</li>
<li>逻辑关系<ul>
<li>当ConcreteSubject发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者</li>
<li>当得到一个具体Subject的改变通知后，ConcreteObserver可以向Subject查询信息，并使用这些信息以使得它的状态与Subject的状态一致</li>
</ul>
</li>
</ul>
<h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><h1 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h1><h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><h2 id="效果（优缺）"><a href="#效果（优缺）" class="headerlink" title="效果（优缺）"></a>效果（优缺）</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现有两种情景</p>
<ul>
<li>主题进行推送通知</li>
<li>观察者拉取通知  </li>
</ul>
<p>在之后的手动实现中，只考虑推送通知，而拉取通知有Java的内置实现</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p><strong><em>IDE支持</em></strong></p>
<p>java.util包中包含有最基本的Observer（观察者）接口和Observvable（主题）类，并且可以进行拉取操作</p>
<p><strong>如何获得观察者</strong></p>
<p>实现Observer接口，然后使用主题类进行addObserver（）,删除则remove</p>
<p><strong>主题如何推送通知</strong></p>
<h3 id="案例1-1"><a href="#案例1-1" class="headerlink" title="案例1"></a>案例1</h3><h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="使用Lambda"><a href="#使用Lambda" class="headerlink" title="使用Lambda"></a>使用Lambda</h3><h2 id="反省总结"><a href="#反省总结" class="headerlink" title="反省总结"></a>反省总结</h2><ul>
<li>观察者模式定义了对象间一对多的关系</li>
<li>主题（可观察者）用一个共同的接口更新观察者</li>
<li>观察者与可观察者之间松耦合，二者并不清楚内部的细节</li>
<li>使用此模式，可以从观察者处推或拉数据</li>
<li>有多个观察者时，不可以依赖特定的观察次序</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/08/Java/设计模式/设计模式：目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/08/Java/设计模式/设计模式：目录/" class="post-title-link" itemprop="url">设计模式：目录</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2018-10-08 17:03:13" itemprop="dateCreated datePublished" datetime="2018-10-08T17:03:13+08:00">2018-10-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-17 10:48:30" itemprop="dateModified" datetime="2019-07-17T10:48:30+08:00">2019-07-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2018/10/08/Java/设计模式/设计模式：目录/" class="post-meta-item leancloud_visitors" data-flag-title="设计模式：目录">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2018/10/08/Java/设计模式/设计模式：目录/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/10/08/Java/设计模式/设计模式：目录/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          Java设计模式的学习
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/10/08/Java/设计模式/设计模式：目录/">
                Leer más &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/08/Java/base/JavaBase：枚举类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/08/Java/base/JavaBase：枚举类/" class="post-title-link" itemprop="url">java枚举类</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2018-10-08 14:35:04" itemprop="dateCreated datePublished" datetime="2018-10-08T14:35:04+08:00">2018-10-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-25 17:44:34" itemprop="dateModified" datetime="2019-07-25T17:44:34+08:00">2019-07-25</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2018/10/08/Java/base/JavaBase：枚举类/" class="post-meta-item leancloud_visitors" data-flag-title="java枚举类">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2018/10/08/Java/base/JavaBase：枚举类/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/10/08/Java/base/JavaBase：枚举类/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          枚举的创建于作用，使用枚举管理状态码
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/10/08/Java/base/JavaBase：枚举类/">
                Leer más &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/Java/框架/安全框架：shiro集成无状态JWT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/03/Java/框架/安全框架：shiro集成无状态JWT/" class="post-title-link" itemprop="url">shiro集成无状态JWT</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2018-10-03 15:52:53" itemprop="dateCreated datePublished" datetime="2018-10-03T15:52:53+08:00">2018-10-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2018-10-17 12:09:06" itemprop="dateModified" datetime="2018-10-17T12:09:06+08:00">2018-10-17</time>
              </span>
            
          

          
            <span id="/2018/10/03/Java/框架/安全框架：shiro集成无状态JWT/" class="post-meta-item leancloud_visitors" data-flag-title="shiro集成无状态JWT">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2018/10/03/Java/框架/安全框架：shiro集成无状态JWT/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/10/03/Java/框架/安全框架：shiro集成无状态JWT/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <blockquote>
<p>转</p>
</blockquote>
<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="为什么要使用JWT"><a href="#为什么要使用JWT" class="headerlink" title="为什么要使用JWT"></a>为什么要使用JWT</h2><ul>
<li>在前后端分离的项目当中,服务器端无法存储会话(session),而是每次请求带上相应的用户名</li>
<li>因此我们要实现完全的前后端分离，所以不可能使用session，cookie的方式进行鉴权</li>
<li>JWT的鉴权,通过一个加密的秘钥来实现鉴权</li>
</ul>
<h2 id="JWT的介绍"><a href="#JWT的介绍" class="headerlink" title="JWT的介绍"></a>JWT的介绍</h2><p>放弃Cookie,Session,使用JWT进行鉴权，完全实现无状态鉴权。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>访问一个URL:<br><a href="http://127.0.0.1:8080/hello?username=admin&amp;params1=love&amp;params2=girl&amp;digest=df7f1595bd5682638556072c8ccde5edadcd807a829373d21af38fb1bc707da7" target="_blank" rel="noopener">http://127.0.0.1:8080/hello?username=admin&amp;params1=love&amp;params2=girl&amp;digest=df7f1595bd5682638556072c8ccde5edadcd807a829373d21af38fb1bc707da7</a></p>
<p>如果digest是正确的话，那么就会返回Hello,Andy,否则会login,error。</p>
<h2 id="后台过程"><a href="#后台过程" class="headerlink" title="后台过程"></a>后台过程</h2><ol>
<li>访问该URL</li>
<li>首先进入AccessControlFilter，进行访问控制过滤拦截，如果不满足条件的话，那么直接就返回了，否则接着往下处理。</li>
<li>在AccessControlFilter中我们为委托AuthorizingRealm进行身份的认证。在AuthorizingRealm中的身份验证访问进行客户端消息摘要和服务器端消息摘要的匹配。</li>
<li>如果成功的话，那么就会到Shiro进行进一步的处理，最后到我们的Controller，然后进行返回。</li>
</ol>
<h3 id="对象的需求"><a href="#对象的需求" class="headerlink" title="对象的需求"></a>对象的需求</h3><ol>
<li>ShiroConfiguration：在这个类中主要是注入shiro的filterFactoryBean和securityManager等对象。</li>
<li>StatelessAccessControlFilter：这个类中实现访问控制过滤，当我们访问url的时候，这个类中的两个方法会进行拦截处理。</li>
<li>StatelessAuthorizingRealm：这个类中主要是身份认证，验证信息是否合理，是否有角色和权限信息。</li>
<li>StatelessAuthenticationToken：在shiro中有一个我们常用的UsernamePasswordToken，因为我们需要这里需要自定义一些属性值，比如：消息摘要，参数Map。</li>
<li>StatelessDefaultSubjectFactory：由于我们编写的是无状态的，每人情况是会创建session对象的，那么我们需要修改createSubject关闭session的创建。</li>
<li>HmacSHA256Utils：Java 加密解密之消息摘要算法，对我们的参数信息进行处理。</li>
</ol>
<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><h2 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h2><pre><code> &lt;!-- spring boot web支持：mvc,aop... --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- shiro spring. --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
   &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
   &lt;version&gt;1.2.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
        &lt;groupId&gt;commons-codec&lt;/groupId&gt;
        &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
  &lt;/dependency&gt;</code></pre><h2 id="contrller"><a href="#contrller" class="headerlink" title="contrller"></a>contrller</h2><p>Rest测试</p>
<pre><code>import javax.servlet.http.HttpSession;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authz.annotation.RequiresRoles;
import org.apache.shiro.session.Session;
import org.apache.shiro.subject.Subject;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

  @RequestMapping(&quot;/hello&quot;)
  public String hello(String params1,String params2){
    return &quot;hello,Andy,params1=&quot;+params1+&quot;,params1=&quot;+params2;
  }
}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>访问<a href="http://127.0.0.1:8080/hello" target="_blank" rel="noopener">http://127.0.0.1:8080/hello</a></p>
<p>浏览器返回:<br>hello,Andy,params1=null,params1=null</p>
<p>至此,基础配置已经完成</p>
<h1 id="集成shiro的基本配置"><a href="#集成shiro的基本配置" class="headerlink" title="集成shiro的基本配置"></a>集成shiro的基本配置</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="添加shiro"><a href="#添加shiro" class="headerlink" title="添加shiro"></a>添加shiro</h3><p>spring配置shiro最基本的操作就是注入ShiroFilterFactoryBean和DefaultWebSecurityManager.</p>
<p>因此,新建ShiroConfiguration类</p>
<pre><code>import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
* shiro配置类
* @author Angel --守护天使
* @version v.0.1
* @date 2017年2月25日
*/

@Configuration
public class ShiroConfiguration {

    @Bean
    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager){
      ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();
      factoryBean.setSecurityManager(securityManager);
      return factoryBean;
    }

    /**
    * shiro安全管理器:
    * 主要是身份认证的管理，缓存管理，cookie管理，
    * 所以在实际开发中我们主要是和SecurityManager进行打交道的
    * @return
    */

    @Bean
    public DefaultWebSecurityManager securityManager() {
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        return securityManager;
    }

}</code></pre><h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>首先,restful风格里面,是没有session和cookie等相关东西的,所以在配置当中要关闭这些东西</p>
<p>需要配置以下的几个地方</p>
<ol>
<li>SubjectContext在创建的时候，需要关闭session的创建，这个主要是由DefaultWebSubjectFactory的createSubject进行管理。</li>
<li>需要禁用使用Sessions 作为存储策略的实现，这个主要由securityManager的subjectDao的sessionStorageEvaluator进行管理的。</li>
<li>需要禁用掉会话调度器，这个主要由sessionManager进行管理。</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>我们需要先定义一个StatelessDefaultSubjectFactory类，此类继承于DefaultWebSubjectFactory，我们重写createSubject的方法，通过SubjectContext关闭session的创建</p>
<pre><code>import org.apache.shiro.subject.Subject;
import org.apache.shiro.subject.SubjectContext;
import org.apache.shiro.web.mgt.DefaultWebSubjectFactory;
/**
*
通过调用context.setSessionCreationEnabled(false)表示不创建会话；如果之后调用
Subject.getSession()将抛出DisabledSessionException异常。
* @author Angel --守护天使
* @version v.0.1
* @date 2017年2月25日
*/

public class StatelessDefaultSubjectFactory extends DefaultWebSubjectFactory{

    @Override
    public Subject createSubject(SubjectContext context) {
      //不创建session.
      context.setSessionCreationEnabled(false);
    System.out.println(&quot;shiro.config.subjectFactory.createSubject.SessionCreationEnabled.false&quot;);
      return super.createSubject(context);
    }

}</code></pre><ul>
<li><p>调整下ShiroConfiguration，首先我们要注入StatelessDefaultSubjectFactory；其次就是将StatelessDefaultSubjectFactory交给DefaultWebSecurityManager进行管理；最后使用securityManager获取到subjectDao禁用session的存储策略</p>
</li>
<li><p>（注意新加的代码为：Add.2.x）</p>
<p>  import org.apache.shiro.mgt.DefaultSessionStorageEvaluator;<br>  import org.apache.shiro.mgt.DefaultSubjectDAO;<br>  import org.apache.shiro.mgt.SecurityManager;<br>  import org.apache.shiro.session.mgt.DefaultSessionManager;<br>  import org.apache.shiro.spring.web.ShiroFilterFactoryBean;<br>  import org.apache.shiro.web.mgt.DefaultWebSecurityManager;<br>  import org.apache.shiro.web.mgt.DefaultWebSubjectFactory;<br>  import org.springframework.context.annotation.Bean;<br>  import org.springframework.context.annotation.Configuration;</p>
<p>  /**</p>
<ul>
<li><p>shiro配置类.</p>
</li>
<li><p>@author Angel –守护天使</p>
</li>
<li><p>@version v.0.1</p>
</li>
<li><p>@date 2017年2月25日</p>
</li>
<li><p>/</p>
<p>@Configuration<br>public class ShiroConfiguration {</p>
<p>   @Bean<br>   public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager){</p>
<pre><code>ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();
factoryBean.setSecurityManager(securityManager);
return factoryBean;</code></pre><p>   }</p>
<p>   /**</p>
<ul>
<li><p>shiro安全管理器:</p>
</li>
<li><p>主要是身份认证的管理，缓存管理，cookie管理，</p>
</li>
<li><p>所以在实际开发中我们主要是和SecurityManager进行打交道的</p>
</li>
<li><p>@return</p>
</li>
<li><p>/<br>@Bean<br>public DefaultWebSecurityManager securityManager() {<br>   DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();<br>   //Add.2.2<br>   securityManager.setSubjectFactory(subjectFactory());<br>   //Add.2.5<br>   securityManager.setSessionManager(sessionManager());</p>
<p>   /*</p>
<ul>
<li>禁用使用Sessions 作为存储策略的实现，但它没有完全地禁用Sessions</li>
<li>所以需要配合context.setSessionCreationEnabled(false);</li>
<li>/<br>//Add.2.3<br>((DefaultSessionStorageEvaluator)((DefaultSubjectDAO)securityManager.getSubjectDAO()).getSessionStorageEvaluator()).setSessionStorageEnabled(false);<br>return securityManager;<br>}</li>
</ul>
<p>/**</p>
</li>
<li><p>Add.2.1</p>
</li>
<li><p>subject工厂管理器.</p>
</li>
<li><p>@return</p>
</li>
<li><p>/<br>@Bean<br>public DefaultWebSubjectFactory subjectFactory(){<br> StatelessDefaultSubjectFactory subjectFactory = new StatelessDefaultSubjectFactory();<br> return subjectFactory;<br>}<br>/**</p>
</li>
<li><p>Add.2.4</p>
</li>
<li><p>session管理器：</p>
</li>
<li><p>sessionManager通过sessionValidationSchedulerEnabled禁用掉会话调度器，</p>
</li>
<li><p>因为我们禁用掉了会话，所以没必要再定期过期会话了。</p>
</li>
<li><p>@return</p>
</li>
<li><p>/<br>@Bean<br>public DefaultSessionManager sessionManager(){<br> DefaultSessionManager sessionManager = new DefaultSessionManager();<br> sessionManager.setSessionValidationSchedulerEnabled(false);<br> return sessionManager;<br>}</p>
</li>
</ul>
<p>}</p>
</li>
</ul>
</li>
</ul>
<p>成功关闭session等</p>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>测试原理：如果是无状态的话，那么在调用代码：currentUser.getSession()是会抛出异常的。所以很好测试，直接在HellController中加入如下方法即可测试</p>
<pre><code>/**
* 此方法执行的时候，会抛出异常：
* Session creation has been disabled for the current subject.
* @param session
* @return
*/
@RequestMapping(&quot;/hello3&quot;)
public String hello3(){
  Subject currentUser = SecurityUtils.getSubject(); 
  Session session = currentUser.getSession();
  System.out.println(session);
  return&quot;hello3,Andy&quot;;
}</code></pre><p>访问:<a href="http://127.0.0.1:8080/hello3" target="_blank" rel="noopener">http://127.0.0.1:8080/hello3</a></p>
<p>报错:</p>
<p>Session creation has been disabled for the current subject.</p>
<p>恭喜成功,达成目标,无状态的shiro</p>
<h1 id="请求控制拦截。"><a href="#请求控制拦截。" class="headerlink" title="请求控制拦截。"></a>请求控制拦截。</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="工具类-对参数信息处理——加密解密之消息摘要算法"><a href="#工具类-对参数信息处理——加密解密之消息摘要算法" class="headerlink" title="工具类:对参数信息处理——加密解密之消息摘要算法"></a>工具类:对参数信息处理——加密解密之消息摘要算法</h3><pre><code>package example.shiro.config;

import java.util.List;
import java.util.Map;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Hex;

/**
* @Title : 
* Created by Hyper on 2018/10/3 16:54
*/
public class HmacSHA256Utils {

  public static String digest(String key, String content) {
    try {
      Mac mac = Mac.getInstance(&quot;HmacSHA256&quot;);
      byte[] secretByte = key.getBytes(&quot;utf-8&quot;);
      byte[] dataBytes = content.getBytes(&quot;utf-8&quot;);
      SecretKey secret = new SecretKeySpec(secretByte, &quot;HMACSHA256&quot;);
      mac.init(secret);
      byte[] doFinal = mac.doFinal(dataBytes);
      byte[] hexB = new Hex().encode(doFinal);
      return new String(hexB, &quot;utf-8&quot;);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public static String digest(String key, Map&lt;String, ?&gt; map) {
    StringBuilder s = new StringBuilder();
    for (Object values : map.values()) {
      if (values instanceof String[]) {
        for (String value : (String[]) values) {
          s.append(value);
        }
      } else if (values instanceof List) {
        for (String value : (List&lt;String&gt;) values) {
          s.append(value);
        }
      } else {
        s.append(values);
      }
    }
    return digest(key, s.toString());
  }
}</code></pre><h3 id="保存我们的身份信息-用户名，客户端传入的消息摘要，还有客户端传入的参数map等"><a href="#保存我们的身份信息-用户名，客户端传入的消息摘要，还有客户端传入的参数map等" class="headerlink" title="保存我们的身份信息,用户名，客户端传入的消息摘要，还有客户端传入的参数map等"></a>保存我们的身份信息,用户名，客户端传入的消息摘要，还有客户端传入的参数map等</h3><pre><code>import org.apache.shiro.authc.AuthenticationToken;

import java.util.Map;

/**
* 用于授权的Token对象
* 用户身份即用户名；
* 凭证即客户端传入的消息摘要。
*
* @Time :Created by Hyper on 2018/10/3 16:55
*/

public class StatelessAuthenticationToken implements AuthenticationToken {

    private static final long serialVersionUID = 1L;

    //用户身份即用户名；
    private String username;

    //参数.
    private Map&lt;String, ?&gt; params;

    //凭证即客户端传入的消息摘要。
    private String clientDigest;

    public StatelessAuthenticationToken() {
    }

    public StatelessAuthenticationToken(String username, Map&lt;String, ?&gt; params, String clientDigest) {
        super();
        this.username = username;
        this.params = params;
        this.clientDigest = clientDigest;
    }

    public StatelessAuthenticationToken(String username, String clientDigest) {
        super();
        this.username = username;
        this.clientDigest = clientDigest;
    }

    @Override
    public Object getPrincipal() {
        return username;
    }

    @Override
    public Object getCredentials() {
        return clientDigest;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public Map&lt;String, ?&gt; getParams() {
        return params;
    }

    public void setParams(Map&lt;String, ?&gt; params) {
        this.params = params;
    }

    public String getClientDigest() {
        return clientDigest;
    }

    public void setClientDigest(String clientDigest) {
        this.clientDigest = clientDigest;
    }

}</code></pre><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>实现访问控制过滤器，拦截我们的请求，我们主要是处理onAccessDenied（）方法，接收到请求的参数，组装成StatelessAuthenticationToken，然后委托为Realm进行处理</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>客户端生成的消息摘要；</li>
<li>客户端传入的用户身份；</li>
<li>客户端请求的参数列表；</li>
<li>生成无状态Token</li>
<li>委托给Realm进行登录</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="访问控制过滤器"><a href="#访问控制过滤器" class="headerlink" title="访问控制过滤器"></a>访问控制过滤器</h4><pre><code>import org.apache.shiro.web.filter.AccessControlFilter;

import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
* @Time : Created by Hyper on 2018/10/3 16:55
*/
public class StatelessAccessControlFilter extends AccessControlFilter {

    /**
    * 先执行：isAccessAllowed 再执行onAccessDenied
    * &lt;p&gt;
    * isAccessAllowed：表示是否允许访问；mappedValue就是[urls]配置中拦截器参数部分，
    * 如果允许访问返回true，否则false；
    * &lt;p&gt;
    * 如果返回true的话，就直接返回交给下一个filter进行处理。
    * 如果返回false的话，回往下执行onAccessDenied
    */
    @Override
    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response,
                                      Object mappedValue)
            throws Exception {
        System.out.println(&quot;StatelessAuthcFilter.isAccessAllowed()&quot;);
        return false;
    }

    /**
    * onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回true表示需要继续处理；
    * 如果返回false表示该拦截器实例已经处理了，将直接返回即可。
    */
    @Override
    protected boolean onAccessDenied(ServletRequest request, ServletResponse response)
            throws Exception {
        System.out.println(&quot;StatelessAuthcFilter.onAccessDenied()&quot;);
        //1、客户端生成的消息摘要
        String clientDigest = request.getParameter(&quot;digest&quot;);
        //2、客户端传入的用户身份
        String username = request.getParameter(&quot;username&quot;);
        //3、客户端请求的参数列表
        Map&lt;String, String[]&gt; params = new HashMap&lt;String, String[]&gt;(request.getParameterMap());
        //为什么要移除呢？签名或者消息摘要算法的时候不能包含digest.
        params.remove(&quot;digest&quot;);
        //4、生成无状态Token
        StatelessAuthenticationToken token = new StatelessAuthenticationToken(username, params,
                clientDigest);
//     UsernamePasswordToken token = new UsernamePasswordToken(username,clientDigest);
        try {
            //5、委托给Realm进行登录
            getSubject(request, response).login(token);
        } catch (Exception e) {
            e.printStackTrace();
            //6、登录失败
            onLoginFail(response);
            //就直接返回给请求者.
            return false;
        }
        return true;
    }

    /**
    * 登录失败时默认返回401 状态码
    */
    private void onLoginFail(ServletResponse response) throws IOException {
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        httpResponse.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        httpResponse.getWriter().write(&quot;login error&quot;);
    }
}</code></pre><h4 id="Realm进行登录"><a href="#Realm进行登录" class="headerlink" title="Realm进行登录"></a>Realm进行登录</h4><p>请求就到了我们的Realm代码，所以我们需要编写一个Realm来进行身份验证下，这里的核心就是获取到AccessControlFilter传递过来的StatelessAuthenticationToken中的参数进行消息摘要，然后生成对象SimpleAuthenticationInfo交给Shiro进行比对</p>
<pre><code>import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;


/**
* @Time :Created by Hyper on 2018/10/3 16:56
*/
public class StatelessAuthorizingRealm extends AuthorizingRealm {

    /**
    * 仅支持StatelessToken 类型的Token，
    * 那么如果在StatelessAuthcFilter类中返回的是UsernamePasswordToken，那么将会报如下错误信息：
    * Please ensure that the appropriate Realm implementation is configured correctly or
    * that the realm accepts AuthenticationTokens of this type.StatelessAuthcFilter.isAccessAllowed()
    */
    @Override
    public boolean supports(AuthenticationToken token) {
        return token instanceof StatelessAuthenticationToken;
    }

    /**
    * 身份验证
    */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)
            throws AuthenticationException {
        System.out.println(&quot;StatelessRealm.doGetAuthenticationInfo()&quot;);
        StatelessAuthenticationToken statelessToken = (StatelessAuthenticationToken) token;
        //不能为null,否则会报错的.
        String username = (String) statelessToken.getPrincipal();
        //根据用户名获取密钥（和客户端的一样）
        String key = getKey(username);
        //在服务器端生成客户端参数消息摘要
        String serverDigest = HmacSHA256Utils.digest(key, statelessToken.getParams());
        System.out.println(serverDigest + &quot;,&quot; + statelessToken.getCredentials());
        //然后进行客户端消息摘要和服务器端消息摘要的匹配
        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(
                username,
                serverDigest,
                getName());
        return authenticationInfo;
    }


    /**
    * 授权
    */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        System.out.println(&quot;StatelessRealm.doGetAuthorizationInfo()&quot;);
        //根据用户名查找角色，请根据需求实现
        String username = (String) principals.getPrimaryPrincipal();
        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();
        //这里模拟admin账号才有role的权限.
        if (&quot;admin&quot;.equals(username)) {
            authorizationInfo.addRole(&quot;admin&quot;);
        }
        return authorizationInfo;
    }

    /**
    * 得到密钥，此处硬编码一个.
    *
    * @param username
    * @return
    */
    private String getKey(String username) {
        return &quot;andy123456&quot;;
    }

}</code></pre><h4 id="配置到ShiroConfiguration-Add-4-x"><a href="#配置到ShiroConfiguration-Add-4-x" class="headerlink" title="配置到ShiroConfiguration(Add.4.x)"></a>配置到ShiroConfiguration(Add.4.x)</h4><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p><a href="http://127.0.0.1:8080/hello?username=admin&amp;params1=love&amp;params2=girl&amp;digest=df7f1595bd5682638556072c8ccde5edadcd807a829373d21af38fb1bc707da7" target="_blank" rel="noopener">http://127.0.0.1:8080/hello?username=admin&amp;params1=love&amp;params2=girl&amp;digest=df7f1595bd5682638556072c8ccde5edadcd807a829373d21af38fb1bc707da7</a></p>
<p>digest是根据参数生成的,更换值则会login error</p>
<h2 id="权限控制篇"><a href="#权限控制篇" class="headerlink" title="权限控制篇"></a>权限控制篇</h2><h3 id="配置ShiroConfiguration"><a href="#配置ShiroConfiguration" class="headerlink" title="配置ShiroConfiguration"></a>配置ShiroConfiguration</h3><p>在shiroConfiguration中加入【开启shiro aop注解支持】和【自动代理所有的advisor】</p>
<p>具体代码为:Add.5.x</p>
<h3 id="在方法-controller-中加入注解-RequiresRoles-“admin”"><a href="#在方法-controller-中加入注解-RequiresRoles-“admin”" class="headerlink" title="在方法(controller)中加入注解@RequiresRoles(“admin”)"></a>在方法(controller)中加入注解@RequiresRoles(“admin”)</h3><pre><code>  @RequestMapping(&quot;/hello4&quot;)
  @RequiresRoles(&quot;admin&quot;)
// @RequiresPermissions(&quot;userInfo:add&quot;)//权限管理;要求拥有userInfo:add权限才可以执行
  public String hello4() {
    return &quot;hello4,Andy&quot;;
  }</code></pre><h2 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h2><h3 id="正确的地址"><a href="#正确的地址" class="headerlink" title="正确的地址"></a>正确的地址</h3><p><a href="http://127.0.0.1:8080/hello4?username=admin&amp;params1=love&amp;params2=girl&amp;digest=df7f1595bd5682638556072c8ccde5edadcd807a829373d21af38fb1bc707da7" target="_blank" rel="noopener">http://127.0.0.1:8080/hello4?username=admin&amp;params1=love&amp;params2=girl&amp;digest=df7f1595bd5682638556072c8ccde5edadcd807a829373d21af38fb1bc707da7</a></p>
<h3 id="错误的"><a href="#错误的" class="headerlink" title="错误的"></a>错误的</h3><p><a href="http://127.0.0.1:8080/hello4?username=zs&amp;params1=love&amp;params2=girl&amp;digest=df7f1595bd5682638556072c8ccde5edadcd807a829373d21af38fb1bc707da7" target="_blank" rel="noopener">http://127.0.0.1:8080/hello4?username=zs&amp;params1=love&amp;params2=girl&amp;digest=df7f1595bd5682638556072c8ccde5edadcd807a829373d21af38fb1bc707da7</a></p>
<p>报错.UnauthorizedException: Subject does not have role [admin]</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p> <a href="https://github.com/smallpocket/spring-boot-demo/spring-boot-shiro" target="_blank" rel="noopener">个人源码实战练习</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://412887952-qq-com.iteye.com/blog/2359084" target="_blank" rel="noopener">Spring Boot之Shiro无状态（1）【从零开始学Spring Boot】</a></li>
<li><a href="http://412887952-qq-com.iteye.com/blog/2359097" target="_blank" rel="noopener">Spring Boot之Shiro无状态（2）【从零开始学Spring Boot】</a></li>
<li><a href="http://412887952-qq-com.iteye.com/blog/2359098" target="_blank" rel="noopener">Spring Boot之Shiro无状态（3）【从零开始学Spring Boot】</a></li>
<li><a href="http://412887952-qq-com.iteye.com/blog/2359099" target="_blank" rel="noopener">Spring Boot之Shiro无状态（4）【从零开始学Spring Boot】</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/02/Java/框架/上传文件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/02/Java/框架/上传文件/" class="post-title-link" itemprop="url">上传文件</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2018-10-02 23:21:48" itemprop="dateCreated datePublished" datetime="2018-10-02T23:21:48+08:00">2018-10-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2018-10-17 12:09:14" itemprop="dateModified" datetime="2018-10-17T12:09:14+08:00">2018-10-17</time>
              </span>
            
          

          
            <span id="/2018/10/02/Java/框架/上传文件/" class="post-meta-item leancloud_visitors" data-flag-title="上传文件">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2018/10/02/Java/框架/上传文件/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/10/02/Java/框架/上传文件/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/02/Java/框架/邮件服务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/02/Java/框架/邮件服务/" class="post-title-link" itemprop="url">邮件服务</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2018-10-02 23:19:25" itemprop="dateCreated datePublished" datetime="2018-10-02T23:19:25+08:00">2018-10-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2018-10-17 12:09:19" itemprop="dateModified" datetime="2018-10-17T12:09:19+08:00">2018-10-17</time>
              </span>
            
          

          
            <span id="/2018/10/02/Java/框架/邮件服务/" class="post-meta-item leancloud_visitors" data-flag-title="邮件服务">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2018/10/02/Java/框架/邮件服务/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/10/02/Java/框架/邮件服务/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.ityouknow.com/springboot/2017/05/06/springboot-mail.html" target="_blank" rel="noopener">springboot(十)：邮件服务</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/02/Java/框架/定时任务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/02/Java/框架/定时任务/" class="post-title-link" itemprop="url">定时任务</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2018-10-02 23:19:14" itemprop="dateCreated datePublished" datetime="2018-10-02T23:19:14+08:00">2018-10-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2018-10-17 12:09:15" itemprop="dateModified" datetime="2018-10-17T12:09:15+08:00">2018-10-17</time>
              </span>
            
          

          
            <span id="/2018/10/02/Java/框架/定时任务/" class="post-meta-item leancloud_visitors" data-flag-title="定时任务">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2018/10/02/Java/框架/定时任务/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/10/02/Java/框架/定时任务/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.ityouknow.com/springboot/2016/12/02/spring-boot-scheduler.html" target="_blank" rel="noopener">springboot(九)：定时任务</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/02/Java/框架/消息队列：RabbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/02/Java/框架/消息队列：RabbitMQ/" class="post-title-link" itemprop="url">消息队列：RabbitMQ</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2018-10-02 23:19:03" itemprop="dateCreated datePublished" datetime="2018-10-02T23:19:03+08:00">2018-10-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-04-17 16:42:24" itemprop="dateModified" datetime="2019-04-17T16:42:24+08:00">2019-04-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/框架/" itemprop="url" rel="index"><span itemprop="name">框架</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2018/10/02/Java/框架/消息队列：RabbitMQ/" class="post-meta-item leancloud_visitors" data-flag-title="消息队列：RabbitMQ">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2018/10/02/Java/框架/消息队列：RabbitMQ/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/10/02/Java/框架/消息队列：RabbitMQ/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="常用消息队列"><a href="#常用消息队列" class="headerlink" title="常用消息队列"></a>常用消息队列</h1><p>一般商用的容器，比如WebLogic，JBoss，都支持JMS标准，开发上很方便。但免费的比如Tomcat，Jetty等则需要使用第三方的消息中间件。本部分内容介绍常用的消息中间件（Active MQ，Rabbit MQ，Zero MQ，Kafka）以及他们的特点。</p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>RabbitMQ是一个消息代理。它的核心思想非常简单：接收并转发消息。你可以把它想象成一个邮局：当你把邮件丢进邮箱时，你非常确定邮递员先生会把它送到收件人手中。在这个比喻中，RabbitMQ就是邮箱、邮局和邮递员。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>
<p><img src="../%E6%A1%86%E6%9E%B6/assets/bd2e7e5edbadb274871b5891ee5a786d" alt="img"></p>
<p>​                                    RabbitMQ结构图</p>
<p>通常我们谈到队列服务, 会有三个概念： 发消息者、队列、收消息者，RabbitMQ 在这个基本概念之上, 多做了一层抽象, 在发消息者和 队列之间, 加入了交换器 (Exchange). 这样发消息者和队列就没有直接联系, 转而变成发消息者把消息给交换器, 交换器根据调度策略再把消息再给队列。</p>
<p>上图中有几个重要概念：</p>
<ul>
<li>Broker：简单来说就是消息队列服务器实体。</li>
<li><strong>Producer</strong>：消息生产者，就是投递消息的程序。</li>
<li><strong>Consumer</strong>：消息消费者，就是接受消息的程序。</li>
<li><strong>Exchange</strong>：消息交换机，它指定消息按什么规则，路由到哪个队列。<ul>
<li><em>Exchange 用于转发消息，但是它不会做存储</em> ，如果没有 Queue bind 到 Exchange 的话，它会直接丢弃掉 Producer 发送过来的消息。 </li>
</ul>
</li>
<li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li>
<li>Binding：绑定，它的作用就是把Exchange和Queue按照路由规则绑定起来。<ul>
<li>也就是交换机需要和队列相绑定，这其中如上图所示，是多对多的关系。</li>
</ul>
</li>
<li>Routing Key：路由关键字，Exchange根据这个关键字进行消息投递。<ul>
<li>消息到交换机的时候，交互机会转发到对应的队列中，那么究竟转发到哪个队列，就要根据该路由键。</li>
</ul>
</li>
<li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。<ul>
<li>一个虚拟主机持有一组交换机、队列和绑定。为什么需要多个虚拟主机呢？很简单， RabbitMQ 当中，<em>用户只能在虚拟主机的粒度进行权限控制。</em> 因此，如果需要禁止A组访问B组的交换机/队列/绑定，必须为A和B分别创建一个虚拟主机。每一个 RabbitMQ 服务器都有一个默认的虚拟主机“/”。</li>
</ul>
</li>
<li>channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</li>
</ul>
<p>消息队列的使用过程，如下：</p>
<ol>
<li>客户端连接到消息队列服务器，打开一个channel。</li>
<li>客户端声明一个exchange，并设置相关属性。</li>
<li>客户端声明一个queue，并设置相关属性。</li>
<li>客户端使用routing key，在exchange和queue之间建立好绑定关系。</li>
<li>客户端投递消息到exchange。</li>
</ol>
<p>exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，在启用ack模式后，交换机找不到队列会返回错误。交换机有四种类型：Direct, Topic, Headers and Fanout</p>
<ul>
<li>Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 <strong>routing_key</strong>, 消息的<strong>routing_key</strong> 匹配时, 才会被交换器投送到绑定的队列中去.</li>
<li>Topic：按规则转发消息（最灵活）</li>
<li>Headers：设置 header attribute 参数类型的交换机</li>
<li>Fanout：转发消息到所有绑定队列</li>
</ul>
<p><strong>Direct Exchange</strong></p>
<p>Direct Exchange 是 RabbitMQ 默认的交换机模式，也是最简单的模式，根据key全文匹配去寻找队列。</p>
<p><img src="assets/rabbitMq_direct.png" alt="img"></p>
<p>第一个 X - Q1 就有一个 binding key，名字为 orange； X - Q2 就有 2 个 binding key，名字为 black 和 green。<em>当消息中的 路由键 和 这个 binding key 对应上的时候，那么就知道了该消息去到哪一个队列中。</em></p>
<p>Ps：为什么 X 到 Q2 要有 black，green，2个 binding key呢，一个不就行了吗？ - 这个主要是因为可能又有 Q3，而Q3只接受 black 的信息，而Q2不仅接受black 的信息，还接受 green 的信息。</p>
<p><strong>Topic Exchange</strong></p>
<p><em>Topic Exchange 转发消息主要是根据通配符。</em> 在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。</p>
<p>在这种交换机模式下：</p>
<ul>
<li>路由键必须是一串字符，用句号（<code>.</code>） 隔开，比如说 agreements.us，或者 agreements.eu.stockholm 等。</li>
<li>路由模式必须包含一个 星号（<code>*</code>），主要用于匹配路由键指定位置的一个单词，比如说，一个路由模式是这样子：agreements..b.*，那么就只能匹配路由键是这样子的：第一个单词是 agreements，第四个单词是 b。 井号（#）就表示相当于一个或者多个单词，例如一个匹配模式是 agreements.eu.berlin.#，那么，以agreements.eu.berlin 开头的路由键都是可以的。</li>
</ul>
<p>具体代码发送的时候还是一样，第一个参数表示交换机，第二个参数表示 routing key，第三个参数即消息。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(<span class="string">"testTopicExchange"</span>,<span class="string">"key1.a.c.key2"</span>, <span class="string">" this is  RabbitMQ!"</span>);</span><br></pre></td></tr></table></figure>

<p>topic 和 direct 类似, 只是匹配上支持了”模式”, 在”点分”的 routing_key 形式中, 可以使用两个通配符:</p>
<ul>
<li><code>*</code>表示一个词.</li>
<li><code>#</code>表示零个或多个词.</li>
</ul>
<p><strong>Headers Exchange</strong></p>
<p>headers 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型， 在队列与交换器绑定时, 会设定一组键值对规则， 消息中也包括一组键值对( headers 属性),，当这些键值对有一对,，或全部匹配时, 消息被投送到对应队列。</p>
<p><strong>Fanout Exchange</strong></p>
<p>Fanout Exchange 消息广播的模式，不管路由键或者是路由模式，<em>会把消息发给绑定给它的全部队列</em>，如果配置了 routing_key 会被忽略。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>使用Java进行实现。</p>
<p>会写两个Java程序。一个发送一条消息的producer和一个接收消息并打印出来的consumer。因为只是刚刚起步，我们会忽略一些Java API的细节，只把精力集中在简单的事情上。消息的内容是“Hello World”。</p>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>假定RabbitMQ 已在标准端口（5672）上的localhost上安装并运行。如果您使用不同的主机，端口或凭据，则需要调整连接设置。</p>
<blockquote>
<p>下载客户端压缩包，按照描述检查它的signature。解压到你的工作目录下，并从中取出所有JAR文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ unzip rabbitmq-java-client-bin-*.zip</span><br><span class="line">&gt; $ cp rabbitmq-java-client-bin-*/*.jar ./</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>RabbitMQ的java客户端可以通过maven下载，它的groupId是com.rabbitmq，artifactId是amqp-client。</p>
</blockquote>
<h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p><img src="assets/v2-2187dc2912ce5aa0f6e0c22bbd9eea1b_hd.png" alt="img"></p>
<p>我们把发消息的类叫做Send，收消息的类叫做Recv。Send类将会连接（connect）RabbitMQ，发送一条消息然后退出。</p>
<p>在Send.java中，我们需要import一些类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br></pre></td></tr></table></figure>

<p>创建类并且为queue起个名字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们创建一个到server的connection：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">Connection connection = factory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br></pre></td></tr></table></figure>

<p>connection是socket连接的抽象，并且为我们管理协议版本协商（protocol version negotiation），认证（authentication ）等等事情。这里我们要连接的消息代理在本地，因此我们将host设为“localhost”。如果我们想连接其他机器上的代理，只需要将这里改为特定的主机名或IP地址。</p>
<p>接下来，我们创建一个channel，绝大部分API方法需要通过调用它来完成。</p>
<p>发送之前，我们必须声明消息要发往哪个队列，然后我们可以向队列发一条消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br></pre></td></tr></table></figure>

<p>队列的声明是幂等的，也就是说只有当队列不存在时才会创建它。消息内容是byte数组，因此你可以使用各种编码方式。</p>
<p>最后，我们把channel和connection关掉：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="消息没发出去！"><a href="#消息没发出去！" class="headerlink" title="消息没发出去！"></a>消息没发出去！</h2><p>如果这是你第一次使用RabbitMQ，并且你没有看到“Sent”信息被打印出来，那你可能会在抓耳挠腮，搞不清哪里出了错。也许消息代理启动时没有足够的磁盘空间（默认需要1Gb）所以它拒绝了消息。检查一下代理的logfile，假如有必要的话也可以减少磁盘空间的限制。</p>
<p>配置文件文档</p>
<p>将会告诉你如何设置disk_free_limit。</p>
</blockquote>
<p>Send.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="keyword">try</span> (Connection connection = factory.newConnection();</span><br><span class="line">             Channel channel = connection.createChannel()) &#123;</span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><p><img src="assets/v2-4009f53c71c8ac8258f65352ed07005c_hd.png" alt="img"></p>
<p>以上就是我们的发送者。RabbitMQ会把消息推送给接收者，所以不同于只发了一条信息的发送者，我们会让接收者一直监听消息并打印出来。</p>
<p>Recv.java的import部分和Send类差不多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br></pre></td></tr></table></figure>

<p>新增的DefaultConsumer类是Consumer接口的实现,我们使用它来接收server推送来的消息。<br>起始的代码和sender差不多（译注：都是样板代码）：我们创建连接，打开channel，并且声明我们要监听的队列。注意这个队列要与Send类要发送的队列一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> java.io.IOException,</span></span><br><span class="line"><span class="function">             java.lang.InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到，我们在这里也声明了队列。因为我们可能在启动发送者之前启动接收者，因此需要保证在接收消息之前，队列已经存在。</p>
<p>接下来我们要告诉server把队列中的消息发送给我们。因为推送消息是异步的，我们需要以对象的形式提供一个回调，它会缓存消息，直到我们准备好使用它。我们通过一个DefaultConsumer的子类来完成这件事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, </span></span></span><br><span class="line"><span class="function"><span class="params">AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br></pre></td></tr></table></figure>

<p>Recv.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">            System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><ul>
<li>生产者消费者模式，在工人间分配任务</li>
</ul>
<p><img src="assets/python-two.png" alt="img"></p>
<p>在这个中，我们将创建一个<em>工作队列</em>，用于在多个工作人员之间分配耗时的任务。</p>
<p>工作队列（又称：<strong>任务队列</strong>）背后的主要思想是避免立即执行资源密集型任务，并且必须等待它完成。相反，我们安排任务稍后完成。我们将<em>任务</em>封装 为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当您运行许多工作程序时，它们之间将共享任务。</p>
<p>这个概念在Web应用程序中特别有用，在这些应用程序中，在短HTTP请求窗口期间无法处理复杂任务。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在本教程的前一部分中，我们发送了一条包含“Hello World！”的消息。现在我们将发送代表复杂任务的字符串。我们没有真实世界的任务，比如要调整大小的图像或要渲染的pdf文件，所以让我们通过<strong>假装我们很忙</strong>来伪造它 - 使用<code>Thread.sleep（）</code>函数。我们将字符串中的点数作为其复杂性; 每个点都会占据“工作”的一秒钟。例如，<code>Hello ...</code>描述的假任务 将花费三秒钟。</p>
<p>我们将稍微修改前一个示例中的<em>Send.java</em>代码，以允许从命令行发送任意消息。该程序将任务安排到我们的工作队列，所以我们将其命名为 <code>NewTask.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String message = String.join（“”，argv）;</span><br><span class="line"></span><br><span class="line">channel.basicPublish（“”，“hello”，<span class="keyword">null</span>，message.getBytes（））;</span><br><span class="line">System.out.println（“[x] Sent<span class="string">'” + message + “'</span>”）;</span><br></pre></td></tr></table></figure>

<p>我们的旧<em>Recv.java</em>程序还需要进行一些更改：它需要伪造消息体中每个点的第二个工作。它将处理传递的消息并执行任务，所以我们称之为<code>Worker.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DeliverCallback deliverCallback =（consumerTag，delivery） - &gt; &#123;</span><br><span class="line">  String message = <span class="keyword">new</span> String（delivery.getBody（），“UTF-<span class="number">8</span>”）;</span><br><span class="line"></span><br><span class="line">  System.out.println（“[x] Received<span class="string">'” + message + “'</span>”）;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    doWork(message);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println（“[x] Done”）;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">true</span> ; <span class="comment">//确认如下</span></span><br><span class="line">channel.basicConsume（TASK_QUEUE_NAME，autoAck，deliverCallback，consumerTag  - &gt; &#123;&#125;）;</span><br></pre></td></tr></table></figure>

<p>我们的假任务是模拟执行时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  doWork （String task） <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     <span class="keyword">for</span>（ <span class="keyword">char</span> ch：task.toCharArray（））&#123;</span><br><span class="line">         <span class="keyword">if</span>（ch == <span class="string">'。'</span>）Thread.sleep（ <span class="number">1000</span>）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp $ CP NewTask.java Worker.java</span><br></pre></td></tr></table></figure>

<h3 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h3><p>使用任务队列的一个优点是能够轻松地并行工作。如果我们正在积压工作积压，我们可以添加更多工人，这样就可以轻松扩展。</p>
<p>首先，让我们尝试同时运行两个worker实例。他们都会从队列中获取消息，但究竟如何呢？让我们来看看。</p>
<p>你需要打开三个控制台。两个将运行工作程序。这些游戏机将成为我们的两个消费者 - C1和C2。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#shell 1 java -cp $ CP Worker</span></span><br><span class="line"> ＃=&gt; [*]正在等待消息。要退出按CTRL + C.</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#shell 2 java -cp $ CP Worker</span></span><br><span class="line"> ＃=&gt; [*]等待消息。要退出按CTRL + C.</span><br></pre></td></tr></table></figure>

<p>在第三个中，我们将发布新任务。启动消费者后，您可以发布一些消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#shell 3 </span></span><br><span class="line">java -cp $ CP NewTask First message。</span><br><span class="line">＃=&gt; [x]发送“第一条消息”。</span><br><span class="line">java -cp $ CP NewTask第二条消息..</span><br><span class="line"> ＃=&gt; [x]发送<span class="string">'第二条消息..'</span> </span><br><span class="line">java -cp $ CP NewTask第三条消息...</span><br><span class="line"> ＃=&gt; [x]发送<span class="string">'第三条消息......'</span> </span><br><span class="line">java  - cp $ CP NewTask第四条消息....</span><br><span class="line"> ＃=&gt; [x]发送<span class="string">'第四条消息....'</span> </span><br><span class="line">java -cp $ CP NewTask第五条消息.....</span><br><span class="line"> ＃=&gt; [x]发送<span class="string">'第五条消息.. ......”</span></span><br></pre></td></tr></table></figure>

<p>让我们看看交给我们工人的是什么：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -cp $ CP Worker</span><br><span class="line"> ＃=&gt; [*]正在等待消息。要退出，请按CTRL + C </span><br><span class="line">＃=&gt; [x]收到“第一条消息”。</span><br><span class="line">＃=&gt; [x]收到<span class="string">'第三条消息......'</span> </span><br><span class="line">＃=&gt; [x]收到<span class="string">'第五条消息.....'</span></span><br><span class="line">java -cp $ CP Worker</span><br><span class="line"> ＃=&gt; [*]正在等待消息。要退出按CTRL + C </span><br><span class="line">＃=&gt; [x]收到<span class="string">'第二条消息..'</span> </span><br><span class="line">＃=&gt; [x]收到<span class="string">'第四条消息....'</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，RabbitMQ将按顺序将每条消息发送给下一个消费者。平均而言，每个消费者将获得相同数量的消息。这种分发消息的方式称为循环法。与三个或更多工人一起尝试。</p>
<h3 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h3><p>执行任务可能需要几秒钟。你可能想知道如果其中一个消费者开始一项长期任务并且只是部分完成而死亡会发生什么。使用我们当前的代码，一旦RabbitMQ向消费者发送消息，它立即将其标记为删除。在这种情况下，如果你杀死一个工人，我们将丢失它刚刚处理的消息。我们还将丢失分发给这个特定工作者但尚未处理的所有消息。</p>
<p>但我们不想失去任何任务。如果工人死亡，我们希望将任务交付给另一名工人。</p>
<p>为了确保消息永不丢失，RabbitMQ支持<strong>消息确认</strong>。消费者发回ack（nowledgement）告诉RabbitMQ已收到，处理了特定消息，RabbitMQ可以自由删除它。</p>
<p>如果消费者死亡（其通道关闭，连接关闭或TCP连接丢失）而不发送确认，RabbitMQ将理解消息未完全处理并将重新排队。如果同时有其他在线消费者，则会迅速将其重新发送给其他消费者。这样你就可以确保没有消息丢失，即使工人偶尔会死亡。</p>
<p>没有任何消息超时; 当消费者死亡时，RabbitMQ将重新发送消息。即使处理消息需要非常长的时间，也没关系。</p>
<p>默认情况下，<strong>手动消息确认</strong>已打开。在前面的示例中，我们通过<code>autoAck = true</code> 标志明确地将它们关闭。一旦我们完成任务，就应该将此标志设置为<code>false</code>并从工作人员发送适当的确认。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>); <span class="comment">// accept only one unack-ed message at a time (see below)</span></span><br><span class="line"></span><br><span class="line">DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">  String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    doWork(message);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">" [x] Done"</span>);</span><br><span class="line">    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<p>使用此代码，我们可以确定即使您在处理消息时使用CTRL + C杀死一名工作人员，也不会丢失任何内容。工人死后不久，所有未经确认的消息将被重新传递。</p>
<p>确认必须在收到交付的同一频道上发送。尝试使用不同的通道进行确认将导致通道级协议异常。</p>
<blockquote>
<h4 id="被遗忘的确认"><a href="#被遗忘的确认" class="headerlink" title="被遗忘的确认"></a>被遗忘的确认</h4><p>错过basicAck是一个常见的错误。这是一个简单的错误，但后果是严重的。当您的客户端退出时，消息将被重新传递（这可能看起来像随机重新传递），但RabbitMQ会占用越来越多的内存，因为它无法释放任何未经消息的消息。</p>
<p>为了调试这种错误，您可以使用rabbitmqctl 来打印messages_unacknowledged字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>在Windows上，删除sudo：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rabbitmqctl.bat list_queues name messages_ready messages_unacknowledged</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="消息持久性"><a href="#消息持久性" class="headerlink" title="消息持久性"></a>消息持久性</h3><p>我们已经学会了如何确保即使消费者死亡，任务也不会丢失。但是如果RabbitMQ服务器停止，我们的任务仍然会丢失。</p>
<p>当RabbitMQ退出或崩溃时，它将忘记队列和消息，除非你告诉它不要。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久。</p>
<p>首先，我们需要确保RabbitMQ永远不会丢失我们的队列。为此，我们需要声明它是<em>持久的</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span> ;</span><br><span class="line">channel.queueDeclare（“hello”，durable，<span class="keyword">false</span>，<span class="keyword">false</span>，<span class="keyword">null</span>）;</span><br></pre></td></tr></table></figure>

<p>虽然此命令本身是正确的，但它在我们当前的设置中不起作用。那是因为我们已经定义了一个名为hello的队列 ，这个队列不耐用。RabbitMQ不允许您使用不同的参数重新定义现有队列，并且会向尝试执行此操作的任何程序返回错误。但是有一个快速的解决方法 - 让我们声明一个具有不同名称的队列，例如task_queue：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span> ;</span><br><span class="line">channel.queueDeclare（“task_queue”，durable，<span class="keyword">false</span>，<span class="keyword">false</span>，<span class="keyword">null</span>）;</span><br></pre></td></tr></table></figure>

<p>此queueDeclare更改需要应用于生产者和消费者代码。</p>
<p>此时我们确信即使RabbitMQ重新启动，task_queue队列也不会丢失。现在我们需要将消息标记为持久性 - 通过将MessageProperties（实现BasicProperties）设置为值PERSISTENT_TEXT_PLAIN。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.MessageProperties;</span><br><span class="line"></span><br><span class="line">channel.basicPublish（“”，“task_queue”，</span><br><span class="line">            MessageProperties.PERSISTENT_TEXT_PLAIN，</span><br><span class="line">            message.getBytes（））;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="有关消息持久性的注释"><a href="#有关消息持久性的注释" class="headerlink" title="有关消息持久性的注释"></a>有关消息持久性的注释</h4><p>将消息标记为持久性并不能完全保证消息不会丢失。虽然它告诉RabbitMQ将消息保存到磁盘，但是当RabbitMQ接受消息并且尚未保存消息时，仍然有一个短时间窗口。此外，RabbitMQ不会为每条消息执行fsync（2） - 它可能只是保存到缓存而不是真正写入磁盘。持久性保证不强，但对于我们简单的任务队列来说已经足够了。如果您需要更强的保证，那么您可以使用 <strong>生产者确认</strong>。</p>
</blockquote>
<h3 id="公平派遣"><a href="#公平派遣" class="headerlink" title="公平派遣"></a>公平派遣</h3><p>您可能已经注意到调度仍然无法完全按照我们的意愿运行。例如，在有两个工人的情况下，当所有奇怪的消息都很重，甚至消息很轻时，一个工人将经常忙，而另一个工作人员几乎不会做任何工作。那么，RabbitMQ对此一无所知，仍然会均匀地发送消息。</p>
<p>发生这种情况是因为RabbitMQ只是在消息进入队列时调度消息。它不会查看消费者未确认消息的数量。它只是盲目地向第n个消费者发送每个第n个消息。</p>
<p><img src="assets/prefetch-count.png" alt="img"></p>
<p>为了打败我们可以使用basicQos方法和 prefetchCount = 1设置。这告诉RabbitMQ一次不向一个worker发送一条消息。或者，换句话说，在处理并确认前一个消息之前，不要向工作人员发送新消息。相反，它会将它发送给下一个仍然很忙的工人。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">1</span> ;</span><br><span class="line">channel.basicQos（prefetchCount）;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="关于队列大小的说明"><a href="#关于队列大小的说明" class="headerlink" title="关于队列大小的说明"></a>关于队列大小的说明</h4><p>如果所有工作人员都很忙，您的队列就会填满。您将需要关注这一点，并可能添加更多工作人员，或者采取其他策略。</p>
</blockquote>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>Final code of our NewTask.java class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.MessageProperties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"task_queue"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    <span class="keyword">try</span> (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        String message = String.join(<span class="string">" "</span>, argv);</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, TASK_QUEUE_NAME,</span><br><span class="line">                MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And our Worker.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"task_queue"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    <span class="keyword">final</span> Connection connection = factory.newConnection();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">    channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doWork(message);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">" [x] Done"</span>);</span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(TASK_QUEUE_NAME, <span class="keyword">false</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(String task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : task.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException _ignored) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h2><p>我们将向多个消费者传递信息。此模式称为“发布/订阅”。</p>
<p>为了说明这种模式，我们将构建一个简单的日志记录系统。它将包含两个程序 - 第一个将发出日志消息，第二个将接收和打印它们。</p>
<p>在我们的日志记录系统中，接收程序的每个运行副本都将获取消息。这样我们就可以运行一个接收器并将日志指向磁盘; 同时我们将能够运行另一个接收器并在屏幕上看到日志。</p>
<p>基本上，发布的日志消息将被广播给所有接收者。</p>
<h3 id="Exchanges"><a href="#Exchanges" class="headerlink" title="Exchanges"></a>Exchanges</h3><p>让我们快速浏览前面教程中介绍的内容：</p>
<ul>
<li>甲<em>生产者</em>是发送消息的用户的应用程序。</li>
<li>甲<em>队列</em>是存储消息的缓冲器。</li>
<li>甲<em>消费者</em>是接收消息的用户的应用程序。</li>
</ul>
<p>RabbitMQ中消息传递模型的核心思想是生产者永远不会将任何消息直接发送到队列。实际上，生产者通常甚至不知道消息是否会被传递到任何队列。</p>
<p>相反，生产者只能向<em>Exchanges</em>发送消息。交换是一件非常简单的事情。一方面，它接收来自生产者的消息，另一方面将它们推送到队列。交易所必须确切知道如何处理它收到的消息。它应该附加到特定队列吗？它应该附加到许多队列吗？或者它应该被丢弃。其规则由<em>Exchange类型</em>定义 。</p>
<p><img src="assets/exchanges.png" alt="img"></p>
<p>有几种交换类型可供选择：<code>direct, topic, headers和 fanout</code>.。我们将专注于最后一个 <code>fanout</code>。让我们创建一个这种类型的交换，并将其称为日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare（“logs”，“fanout”）;</span><br></pre></td></tr></table></figure>

<p>fanout交换非常简单。正如您可能从名称中猜到的那样，它只是将收到的所有消息广播到它知道的所有队列中。而这正是我们记录器所需要的。</p>
<blockquote>
<h4 id="无名交流"><a href="#无名交流" class="headerlink" title="无名交流"></a>无名交流</h4><p>在本教程的前几部分中，我们对交换一无所知，但仍然可以向队列发送消息。这是可能的，因为我们使用默认交换，我们通过空字符串（“”）来识别。</p>
<p>回想一下我们之前如何发布消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; channel.basicPublish（“”，“hello”，<span class="keyword">null</span>，message.getBytes（））;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>第一个参数是交换的名称。空字符串表示默认或<em>无名</em>交换：消息通过routingKey指定的名称路由到队列（如果存在）。</p>
</blockquote>
<p>现在，我们可以发布到我们的命名交换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish（“logs”，“”，<span class="keyword">null</span>，message.getBytes（））;</span><br></pre></td></tr></table></figure>

<h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><p>您可能还记得以前我们使用过具有特定名称的队列（还记得<code>hello</code>和<code>task_queue</code>吗？）。能够命名队列对我们来说至关重要 - 我们需要将工作人员指向同一个队列。当您想要在生产者和消费者之间共享队列时，为队列命名非常重要。</p>
<p>但我们的记录器并非如此。我们希望了解所有日志消息，而不仅仅是它们的一部分。我们也只对目前流动的消息感兴趣，而不是旧消息。要解决这个问题，我们需要两件事。</p>
<p>首先，每当我们连接到Rabbit时，我们都需要一个新的空队列。为此，我们可以使用随机名称创建队列，或者更好 - 让服务器为我们选择随机队列名称。</p>
<p>其次，一旦我们断开消费者，就应该自动删除队列。</p>
<p>在Java客户端中，当我们没有向queueDeclare（）提供参数时，我们 使用生成的名称创建一个非持久的，独占的自动删除队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String queueName = channel.queueDeclare（）。getQueue（）;</span><br></pre></td></tr></table></figure>

<p>您可以在队列指南中了解有关独占标志和其他队列属性的更多信息。</p>
<p>此时，queueName包含随机队列名称。例如，它可能看起来像amq.gen-JzTY20BRgKO-HjmUJj0wLg。</p>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p><img src="assets/bindings.png" alt="img"></p>
<p>我们已经创建了一个<code>fanout</code>交换和一个队列。现在我们需要告诉交换机将消息发送到我们的队列。交换和队列之间的关系称为<em>绑定</em>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind（queueName，“logs”，“”）;</span><br></pre></td></tr></table></figure>

<p>从现在开始，日志交换会将消息附加到我们的队列中。</p>
<blockquote>
<h4 id="列出绑定"><a href="#列出绑定" class="headerlink" title="列出绑定"></a>列出绑定</h4><p>你猜对了，你可以列出现有的绑定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rabbitmqctl list_bindings</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="把它们放在一起"><a href="#把它们放在一起" class="headerlink" title="把它们放在一起"></a>把它们放在一起</h3><p><img src="assets/python-three-overall.png" alt="img"></p>
<p>生成日志消息的生产者程序与前一个教程没有太大的不同。最重要的变化是我们现在想要将消息发布到我们的日志交换而不是无名交换。我们需要在发送时提供routingKey，但是对于<code>fanout</code>交换，它的值会被忽略。这里是</p>
<p><code>EmitLog.java</code>程序的代码 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    <span class="keyword">try</span> (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        String message = argv.length &lt; <span class="number">1</span> ? <span class="string">"info: Hello World!"</span> :</span><br><span class="line">                            String.join(<span class="string">" "</span>, argv);</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如您所见，在建立连接后，我们宣布了交换。此步骤是必要的，因为禁止发布到不存在的交换。</p>
<p>如果没有队列绑定到交换机，消息将会丢失，但这对我们没有问题; 如果没有消费者在听，我们可以安全地丢弃该消息。</p>
<p><code>ReceiveLogs.java</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line">    String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">    channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">    DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul>
<li>有选择地接收消息</li>
</ul>
<p>上一个教程中，我们构建了一个简单的日志系统 我们能够向许多接收者广播日志消息。</p>
<p>在本教程中，我们将为其添加一个功能 - 我们将只能订阅一部分消息。例如，我们只能将关键错误消息定向到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。</p>
<h3 id="绑定-1"><a href="#绑定-1" class="headerlink" title="绑定"></a>绑定</h3><p>在前面的例子中，我们已经创建了绑定。您可能会记得以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind（queueName，EXCHANGE_NAME，“”）;</span><br></pre></td></tr></table></figure>

<p>绑定是交换和队列之间的关系。这可以简单地理解为：队列对来自此交换的消息感兴趣。</p>
<p>绑定可以采用额外的routingKey参数。为了避免与basic_publish参数混淆，我们将其称为 绑定密钥。这就是我们如何使用键创建绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind（queueName，EXCHANGE_NAME，“black”）;</span><br></pre></td></tr></table></figure>

<p>绑定密钥的含义取决于交换类型。我们之前使用的<code>fanout</code>交换只是忽略了它的价值。</p>
<h3 id="直接交换"><a href="#直接交换" class="headerlink" title="直接交换"></a>直接交换</h3><p>我们上一个教程中的日志记录系统向所有消费者广播所有消息。我们希望扩展它以允许根据消息的严重性过滤消息。例如，我们可能需要一个程序将日志消息写入磁盘以仅接收严重错误，而不是在警告或信息日志消息上浪费磁盘空间。</p>
<p>我们使用的是<code>fanout</code>交换，它没有给我们太大的灵活性 - 它只能进行无意识的广播。</p>
<p>我们将使用<code>direct</code>交换。<code>direct</code>交换背后的路由算法很简单 </p>
<ul>
<li>消息进入队列，其 绑定密钥与消息的路由密钥完全匹配。</li>
</ul>
<p>为了说明这一点，请考虑以下设置：</p>
<p><img src="assets/direct-exchange.png" alt="img"></p>
<p>在此设置中，我们可以看到<code>direct</code>交换X与两个绑定到它的队列。第一个队列绑定橙色绑定，第二个绑定有两个绑定，一个绑定密钥为黑色，另一个绑定为绿色。</p>
<p>在这样的设置中，使用路由密钥orange发布到交换机的消息 将被路由到队列Q1。路由键为黑色 或绿色的消息将转到Q2。所有其他消息将被丢弃。</p>
<h3 id="多个绑定"><a href="#多个绑定" class="headerlink" title="多个绑定"></a>多个绑定</h3><p><img src="assets/direct-exchange-multiple.png" alt="img"></p>
<p>使用相同的绑定密钥绑定多个队列是完全合法的。在我们的示例中，我们可以在X和Q1之间添加绑定键黑色的绑定。在这种情况下，<code>direct</code>交换将表现得像<code>fanout</code>一样，并将消息广播到所有匹配的队列。路由键为黑色的消息将传送到 Q1和Q2。</p>
<h3 id="发送日志"><a href="#发送日志" class="headerlink" title="发送日志"></a>发送日志</h3><p>我们将此模型用于我们的日志系统。我们会将消息发送给<code>direct</code>交换，而不是<code>fanout</code>。我们将提供日志严重性作为路由密钥。这样接收程序将能够选择它想要接收的严重性。让我们首先关注发送日志。</p>
<p>一如既往，我们需要先创建一个交换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare（EXCHANGE_NAME，“direct”）;</span><br></pre></td></tr></table></figure>

<p>我们已准备好发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish（EXCHANGE_NAME，severity，<span class="keyword">null</span>，message.getBytes（））;</span><br></pre></td></tr></table></figure>

<p>为简化起见，我们假设“严重性”可以是“信息”，“警告”，“错误”之一。</p>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>接收消息将像上一个教程一样工作，但有一个例外 - 我们将为我们感兴趣的每个严重性创建一个新的绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String severity : argv)&#123;</span><br><span class="line">  channel.queueBind(queueName, EXCHANGE_NAME, severity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="把它们放在一起-1"><a href="#把它们放在一起-1" class="headerlink" title="把它们放在一起"></a>把它们放在一起</h3><p><img src="assets/python-four.png" alt="img"></p>
<p>EmitLogDirect.java类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogDirect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    <span class="keyword">try</span> (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</span><br><span class="line"></span><br><span class="line">        String severity = getSeverity(argv);</span><br><span class="line">        String message = getMessage(argv);</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, severity, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + severity + <span class="string">"':'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReceiveLogsDirect.java的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</span><br><span class="line">    String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.err.println(<span class="string">"Usage: ReceiveLogsDirect [info] [warning] [error]"</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String severity : argv) &#123;</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, severity);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">    DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">" [x] Received '"</span> +</span><br><span class="line">            delivery.getEnvelope().getRoutingKey() + <span class="string">"':'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ul>
<li>根据模式（主题）接收消息</li>
</ul>
<p>在上一个教程中，我们改进了日志系统。我们使用的是<code>direct</code>的，而不是使用只能进行虚拟广播的<code>fanout</code>交换，并且有可能选择性地接收日志。</p>
<p>虽然使用<code>direct</code>交换改进了我们的系统，但它仍然有局限性 - 它不能基于多个标准进行路由。</p>
<p>在我们的日志记录系统中，我们可能不仅要根据严重性订阅日志，还要根据发出日志的源来订阅日志。您可能从syslog unix工具中了解这个概念，该 工具根据严重性（info / warn / crit …）和facility（auth / cron / kern …）来路由日志。</p>
<p>这会给我们带来很大的灵活性 - 我们可能想要听取来自’cron’的关键错误以及来自’kern’的所有日志。</p>
<p>要在我们的日志记录系统中实现这一点，我们需要了解更复杂的<code>topic</code>交换。</p>
<h3 id="Topic-exchange"><a href="#Topic-exchange" class="headerlink" title="Topic exchange"></a>Topic exchange</h3><p>发送到主题交换的消息不能具有任意的 routing_key - 它必须是由点分隔的单词列表。单词可以是任何内容，但通常它们指定与消息相关的一些功能。一些有效的路由键示例：“ stock.usd.nyse ”，“ nyse.vmw”，“ quick.orange.rabbit ”。路由密钥中可以包含任意数量的单词，最多可达255个字节。</p>
<p>绑定密钥也必须采用相同的形式。主题交换背后的逻辑 类似于直接交换- 使用特定路由密钥发送的消息将被传递到与匹配绑定密钥绑定的所有队列。但是绑定键有两个重要的特殊情况：</p>
<ul>
<li>*（星号）可以替代一个单词。</li>
<li>＃（hash）可以替换零个或多个单词。</li>
</ul>
<p>在一个例子中解释这个是最容易的：</p>
<p><img src="assets/python-five.png" alt="img"></p>
<p>在这个例子中，我们将发送所有描述动物的消息。消息将与包含三个单词（两个点）的路由键一起发送。路由键中的第一个单词将描述速度，第二个是颜色，第三个是物种：“ &lt;speed&gt;。&lt;color&gt;。&lt;species&gt;”。</p>
<p>我们创建了三个绑定：Q1绑定了绑定<strong>键“ * .orange.* ”</strong>，Q2 绑定了<strong>“ ..rabbit ”和“ lazy.＃ ”</strong>。</p>
<p>这些绑定可以概括为：</p>
<ul>
<li>Q1对所有橙色动物感兴趣。</li>
<li>Q2希望听到关于兔子的一切，以及关于懒惰动物的一切。</li>
</ul>
<p>路由密钥设置为“ quick.orange.rabbit ”的消息将传递到两个队列。消息“ lazy.orange.elephant ”也将同时发送给他们。另一方面，“ quick.orange.fox ”只会转到第一个队列，而“ lazy.brown.fox ”只会转到第二个队列。“ lazy.pink.rabbit ”将仅传递到第二个队列一次，即使它匹配两个绑定。“ quick.brown.fox ”与任何绑定都不匹配，因此它将被丢弃。</p>
<p>如果我们违反合同并发送带有一个或四个单词的消息，例如“ orange ”或“ quick.orange.male.rabbit ”，会发生什么？好吧，这些消息将不匹配任何绑定，并将丢失。</p>
<p>另一方面，“ lazy.orange.male.rabbit ”，即使它有四个单词，也会匹配最后一个绑定，并将被传递到第二个队列。</p>
<blockquote>
<h4 id="Topic-交流"><a href="#Topic-交流" class="headerlink" title="Topic 交流"></a>Topic 交流</h4><p>Topic 交换功能强大，可以像其他交易所一样运行。</p>
<p>当队列绑定“ ＃ ”（哈希）绑定密钥时 - 它将接收所有消息，而不管路由密钥 - 如fanout交换。</p>
<p>当特殊字符“ * ”（星号）和“ ＃ ”（哈希）未在绑定中使用时，topic交换的行为就像dirct交换一样。</p>
</blockquote>
<h3 id="把它们放在一起-2"><a href="#把它们放在一起-2" class="headerlink" title="把它们放在一起"></a>把它们放在一起</h3><p>我们将在我们的日志记录系统中使用主题交换。我们将首先假设日志的路由键有两个词：“ &lt;facility&gt;。&lt;severity&gt; ”。</p>
<p>代码与上一个教程中的代码几乎相同 。</p>
<p>EmitLogTopic.java的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogTopic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    <span class="keyword">try</span> (Connection connection = factory.newConnection();</span><br><span class="line">         Channel channel = connection.createChannel()) &#123;</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line"></span><br><span class="line">        String routingKey = getRouting(argv);</span><br><span class="line">        String message = getMessage(argv);</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + routingKey + <span class="string">"':'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReceiveLogsTopic.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsTopic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line">    String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.err.println(<span class="string">"Usage: ReceiveLogsTopic [binding_key]..."</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String bindingKey : argv) &#123;</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">    DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">" [x] Received '"</span> +</span><br><span class="line">            delivery.getEnvelope().getRoutingKey() + <span class="string">"':'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><ul>
<li>如何将往返消息作为远程过程调用</li>
</ul>
<h3 id="请求回复模式"><a href="#请求回复模式" class="headerlink" title="请求回复模式"></a>请求回复模式</h3><p>当两个应用程序通过<em>Messaging</em>进行通信时，通信是单向的。应用程序可能需要双向对话。</p>
<p><strong>当应用程序发送消息时，它如何从接收方获得响应？</strong></p>
<p><img src="assets/RequestReply.gif" alt="img"></p>
<p><strong>发送一对请求 - 回复消息，每个消息都在自己的频道上。</strong></p>
<p><em>Request-Reply</em>有两个参与者：</p>
<h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><p>在第二篇教程中，我们学习了如何使用<em>工作队列</em>在多个工作人员之间分配耗时的任务。</p>
<p>但是如果我们需要在远程计算机上运行一个函数并等待结果呢？嗯，这是一个不同的故事。此模式通常称为<em>远程过程调用</em>或<em>RPC</em>。</p>
<p>在本教程中，我们将使用RabbitMQ构建RPC系统：客户端和可伸缩的RPC服务器。由于我们没有任何值得分发的耗时任务，我们将创建一个返回<code>Fibonacci</code>数字的虚拟RPC服务。</p>
<h3 id="客户端界面"><a href="#客户端界面" class="headerlink" title="客户端界面"></a>客户端界面</h3><p>为了说明如何使用RPC服务，我们将创建一个简单的客户端类。它将公开一个名为<code>call</code>的方法，该方法发送一个RPC请求并阻塞，直到收到答案为止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FibonacciRpcClient fibonacciRpc = <span class="keyword">new</span> FibonacciRpcClient();</span><br><span class="line">String result = fibonacciRpc.call(<span class="string">"4"</span>);</span><br><span class="line">System.out.println( <span class="string">"fib(4) is "</span> + result);</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="有关RPC的说明"><a href="#有关RPC的说明" class="headerlink" title="有关RPC的说明"></a>有关RPC的说明</h4><p>尽管RPC在计算中是一种非常常见的模式，但它经常受到批评。当程序员不知道函数调用是本地的还是慢的RPC时，会出现问题。这样的混淆导致系统不可预测，并增加了调试的不必要的复杂性。错误使用RPC可以导致不可维护的意大利面条代码，而不是简化软件。</p>
<p>考虑到这一点，请考虑以下建议：</p>
<ul>
<li>确保明显哪个函数调用是本地的，哪个是远程的。</li>
<li>记录您的系统。使组件之间的依赖关系变得清晰。</li>
<li>处理错误案例。当RPC服务器长时间停机时，客户端应该如何反应？</li>
</ul>
<p>如有疑问，请避免使用RPC。如果可以，您应该使用异步管道 - 而不是类似RPC的阻塞，将结果异步推送到下一个计算阶段。</p>
</blockquote>
<h3 id="回调队列"><a href="#回调队列" class="headerlink" title="回调队列"></a>回调队列</h3><p>一般来说，通过RabbitMQ进行RPC很容易。客户端发送请求消息，服务器回复响应消息。为了接收响应，我们需要发送带有请求的“回调”队列地址。我们可以使用默认队列（在Java客户端中是独占的）。我们来试试吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">callbackQueueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">BasicProperties props = <span class="keyword">new</span> BasicProperties</span><br><span class="line">                            .Builder()</span><br><span class="line">                            .replyTo(callbackQueueName)</span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line">channel.basicPublish(<span class="string">""</span>, <span class="string">"rpc_queue"</span>, props, message.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... then code to read a response message from the callback_queue ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h4><p>AMQP 0-9-1协议预定义了一组带有消息的14个属性。大多数属性很少使用，但以下情况除外：</p>
<ul>
<li>deliveryMode：将消息标记为持久性（值为2）或瞬态（任何其他值）。你可能还记得第二篇教程中的这个属性。</li>
<li>contentType：用于描述编码的mime类型。例如，对于经常使用的JSON编码，将此属性设置为：application / json是一种很好的做法。</li>
<li>replyTo：通常用于命名回调队列。</li>
<li>correlationId：用于将RPC响应与请求相关联。</li>
</ul>
</blockquote>
<p>我们需要这个新的导入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP.BasicProperties;</span><br></pre></td></tr></table></figure>

<h3 id="相关ID"><a href="#相关ID" class="headerlink" title="相关ID"></a>相关ID</h3><p>在上面介绍的方法中，我们建议为每个RPC请求创建一个回调队列。这是非常低效的，但幸运的是有更好的方法 - 让我们为每个客户端创建一个回调队列。</p>
<p>这引发了一个新问题，在该队列中收到响应后，不清楚响应属于哪个请求。那是在使用correlationId属性的时候 。我们将为每个请求将其设置为唯一值。稍后，当我们在回调队列中收到消息时，我们将查看此属性，并根据该属性，我们将能够将响应与请求进行匹配。如果我们看到未知的 correlationId值，我们可以安全地丢弃该消息 - 它不属于我们的请求。</p>
<p>您可能会问，为什么我们应该忽略回调队列中的未知消息，而不是因为错误而失败？这是由于服务器端存在竞争条件的可能性。尽管不太可能，但是在向我们发送答案之后，但在发送请求的确认消息之前，<strong>RPC服务器可能会死亡</strong>。如果发生这种情况，重新启动的RPC服务器将再次处理请求。这就是为什么在客户端上我们必须优雅地处理重复的响应，理想情况下RPC应该是幂等的。</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p><img src="assets/python-six.png" alt="img"></p>
<p>我们的RPC将这样工作：</p>
<ul>
<li>对于RPC请求，客户端发送带有两个属性的消息： replyTo（设置为仅为请求创建的匿名独占队列）和correlationId（设置为每个请求的唯一值）。</li>
<li>请求被发送到rpc_queue队列。</li>
<li>RPC worker（aka：server）正在等待该队列上的请求。当出现请求时，它会执行该作业，并使用来自replyTo字段的队列将带有结果的消息发送回客户端。</li>
<li>客户端等待回复队列上的数据。出现消息时，它会检查correlationId属性。如果它与请求中的值匹配，则将响应返回给应用程序。</li>
</ul>
<h3 id="把它们放在一起-3"><a href="#把它们放在一起-3" class="headerlink" title="把它们放在一起"></a>把它们放在一起</h3><p>The Fibonacci task:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们宣布我们的斐波那契函数。它假定只有有效的正整数输入。（不要指望这个适用于大数字，并且它可能是最慢的递归实现）。</p>
<p>我们的RPC服务器的代码可以在这里找到：<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/RPCServer.java" target="_blank" rel="noopener">RPCServer.java</a>。</p>
<p>服务器代码非常简单：</p>
<ul>
<li>像往常一样，我们首先建立连接，通道和声明队列。</li>
<li>我们可能希望运行多个服务器进程。为了在多个服务器上平均分配负载，我们需要在channel.basicQos中设置 prefetchCount设置。</li>
<li>我们使用basicConsume来访问队列，我们以对象（DeliverCallback）的形式提供回调，它将完成工作并发回响应。</li>
</ul>
<p>我们的RPC客户端的代码可以在这里找到：<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/RPCClient.java" target="_blank" rel="noopener">RPCClient.java</a>。</p>
<p>客户端代码稍微复杂一些：</p>
<ul>
<li>我们建立了一个连接和渠道。</li>
<li>我们的调用方法生成实际的RPC请求。</li>
<li>在这里，我们首先生成一个唯一的correlationId 数并保存它 - 我们的消费者回调将使用此值来匹配相应的响应。</li>
<li>然后，我们为回复创建一个专用的独占队列并订阅它。</li>
<li>接下来，我们发布请求消息，其中包含两个属性： replyTo和correlationId。</li>
<li>在这一点上，我们可以坐下来等待正确的响应到来。</li>
<li>由于我们的消费者交付处理是在一个单独的线程中进行的，因此我们需要在响应到达之前暂停主线程。使用BlockingQueue是一种可能的解决方案。这里我们创建了ArrayBlockingQueue ，容量设置为1，因为我们只需要等待一个响应。</li>
<li>消费者正在做一个非常简单的工作，对于每个消费的响应消息，它检查correlationId 是否是我们正在寻找的那个。如果是这样，它会将响应置于BlockingQueue。</li>
<li>同时主线程正在等待响应从BlockingQueue获取它。</li>
<li>最后，我们将响应返回给用户。</li>
</ul>
<p>发出客户请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RPCClient fibonacciRpc = <span class="keyword">new</span> RPCClient();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">" [x] Requesting fib(30)"</span>);</span><br><span class="line">String response = fibonacciRpc.call(<span class="string">"30"</span>);</span><br><span class="line">System.out.println(<span class="string">" [.] Got '"</span> + response + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">fibonacciRpc.close();</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/RPCClient.java" target="_blank" rel="noopener">RPCClient.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClient</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> String requestQueueName = <span class="string">"rpc_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RPCClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line"></span><br><span class="line">        connection = factory.newConnection();</span><br><span class="line">        channel = connection.createChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (RPCClient fibonacciRpc = <span class="keyword">new</span> RPCClient()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                String i_str = Integer.toString(i);</span><br><span class="line">                System.out.println(<span class="string">" [x] Requesting fib("</span> + i_str + <span class="string">")"</span>);</span><br><span class="line">                String response = fibonacciRpc.call(i_str);</span><br><span class="line">                System.out.println(<span class="string">" [.] Got '"</span> + response + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String corrId = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        String replyQueueName = channel.queueDeclare().getQueue();</span><br><span class="line">        AMQP.BasicProperties props = <span class="keyword">new</span> AMQP.BasicProperties</span><br><span class="line">                .Builder()</span><br><span class="line">                .correlationId(corrId)</span><br><span class="line">                .replyTo(replyQueueName)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, requestQueueName, props, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BlockingQueue&lt;String&gt; response = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String ctag = channel.basicConsume(replyQueueName, <span class="keyword">true</span>, (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (delivery.getProperties().getCorrelationId().equals(corrId)) &#123;</span><br><span class="line">                response.offer(<span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        String result = response.take();</span><br><span class="line">        channel.basicCancel(ctag);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/RPCServer.java" target="_blank" rel="noopener">RPCServer.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RPC_QUEUE_NAME = <span class="string">"rpc_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (Connection connection = factory.newConnection();</span><br><span class="line">             Channel channel = connection.createChannel()) &#123;</span><br><span class="line">            channel.queueDeclare(RPC_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            channel.queuePurge(RPC_QUEUE_NAME);</span><br><span class="line"></span><br><span class="line">            channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">" [x] Awaiting RPC requests"</span>);</span><br><span class="line"></span><br><span class="line">            Object monitor = <span class="keyword">new</span> Object();</span><br><span class="line">            DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                AMQP.BasicProperties replyProps = <span class="keyword">new</span> AMQP.BasicProperties</span><br><span class="line">                        .Builder()</span><br><span class="line">                        .correlationId(delivery.getProperties().getCorrelationId())</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                String response = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">                    <span class="keyword">int</span> n = Integer.parseInt(message);</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">" [.] fib("</span> + message + <span class="string">")"</span>);</span><br><span class="line">                    response += fib(n);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">" [.] "</span> + e.toString());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">""</span>, delivery.getProperties().getReplyTo(), replyProps, response.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// RabbitMq consumer worker thread notifies the RPC server owner thread</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                        monitor.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(RPC_QUEUE_NAME, <span class="keyword">false</span>, deliverCallback, (consumerTag -&gt; &#123; &#125;));</span><br><span class="line">            <span class="comment">// Wait and be prepared to consume the message from RPC client.</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        monitor.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处介绍的设计并不是RPC服务的唯一可能实现，但它具有一些重要优势：</p>
<ul>
<li>如果RPC服务器太慢，您可以通过运行另一个服务器来扩展。尝试在新控制台中运行第二个RPCServer。</li>
<li>在客户端，RPC只需要发送和接收一条消息。不需要像queueDeclare这样的同步调用 。因此，对于单个RPC请求，RPC客户端只需要一次网络往返。</li>
</ul>
<p>我们的代码仍然相当简单，并不试图解决更复杂（但重要）的问题，例如：</p>
<ul>
<li>如果没有运行服务器，客户应该如何反应？</li>
<li>客户端是否应该为RPC设置某种超时？</li>
<li>如果服务器出现故障并引发异常，是否应将其转发给客户端？</li>
<li>在处理之前防止无效的传入消息（例如检查边界，类型）。</li>
</ul>
<h1 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h1><p>AMQP解决了什么问题，或者说它的应用场景是什么？</p>
<p>对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如：</p>
<ol>
<li>信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何方式丢失？</li>
<li>如何降低发送者和接收者的耦合度？</li>
<li>如何让Priority高的接收者先接到数据？</li>
<li>如何做到load balance？有效均衡接收者的负载？</li>
<li>如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。</li>
<li>如何做到可扩展，甚至将这个通信模块发到cluster上？</li>
<li>如何保证接收者接收到了完整，正确的数据？</li>
</ol>
<p>AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。</p>
<h1 id="消费者致谢和生产者确认"><a href="#消费者致谢和生产者确认" class="headerlink" title="消费者致谢和生产者确认"></a>消费者致谢和生产者确认</h1><p>根据定义，使用诸如RabbitMQ之类的消息传递代理的系统是分布式的。由于发送的协议方法（消息）无法保证到达对等方或被其成功处理，因此生产者和消费者都需要一种交付和处理确认的机制。RabbitMQ支持的几种消息传递协议提供了这些功能。本指南涵盖了AMQP 0-9-1中的功能，但其他协议（STOMP，MQTT等）的想法基本相同。</p>
<p>消费者对RabbitMQ的交付处理确认称为AMQP 0-9-1用语中的确认; 经纪人对生产者的确认是一种称为生产者确认的协议扩展。</p>
<p>这两个功能都基于相同的想法，并受到TCP的启发。它们对于从生产者到RabbitMQ节点以及从RabbitMQ节点到消费者的可靠传递至关重要。</p>
<h2 id="消费者交货致谢"><a href="#消费者交货致谢" class="headerlink" title="消费者交货致谢"></a>消费者交货致谢</h2><p>当RabbitMQ向消费者传递消息时，它需要知道何时考虑成功发送消息。什么样的逻辑是最佳的取决于系统。因此，它主要是一个应用决策。在AMQP 0-9-1当消费者使用注册它是由basic.consume方法或消息是与所述需求取出basic.get方法。</p>
<p>如果您更喜欢更面向示例和逐步的材料，<a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">RabbitMQ教程＃2</a>中也涵盖了消费者的认可。</p>
<h3 id="交货标识符：交货标签"><a href="#交货标识符：交货标签" class="headerlink" title="交货标识符：交货标签"></a>交货标识符：交货标签</h3><p>在我们继续讨论其他主题之前，重要的是解释如何识别交付（并且确认表明它们各自的交付）。</p>
<p>注册使用者（订阅）时，RabbitMQ将使用<code>basic.deliver</code> 方法传递（推送）消息。该方法携带<em>传递标签</em>，其唯一地标识信道上的传递。因此，每个渠道确定交付标签的范围。</p>
<p>传递标签是单调增长的正整数，并由客户端库提供。确认交付的客户端库方法将交付标记作为参数。</p>
<p>由于交付标签的范围是每个渠道，因此必须在收到的相同渠道上确认交货。确认不同的通道将导致“未知的传递标签”协议异常并关闭通道。</p>
<h3 id="消费者确认模式和数据安全注意事项"><a href="#消费者确认模式和数据安全注意事项" class="headerlink" title="消费者确认模式和数据安全注意事项"></a>消费者确认模式和数据安全注意事项</h3><p>当节点向消费者传递消息时，它必须决定消费者是否应该考虑消息处理（或至少接收）消息。由于多个事物（客户端连接，消费者应用程序等）可能会失败，因此该决定是数据安全问题。消息传递协议通常提供一种确认机制，允许消费者确认交付给他们所连接的节点。是否使用该机制是在消费者订阅时决定的。</p>
<p>根据所使用的确认模式，RabbitMQ可以在发送消息（写入TCP套接字）后立即成功传递消息，或者在收到明确（“手动”）客户端确认时。手动发送的确认可以是正面的也可以是否定的，并使用以下协议方法之一：</p>
<ul>
<li><code>basic.ack</code>用于肯定确认</li>
<li><code>basic.nack</code>用于否定确认（注意：这是<a href="https://www.rabbitmq.com/nack.html" target="_blank" rel="noopener">AMQP 0-9-1</a>的<a href="https://www.rabbitmq.com/nack.html" target="_blank" rel="noopener">RabbitMQ扩展</a>）</li>
<li><code>basic.reject</code>用于否定确认，但与<code>basic.nack</code>相比有一个限制</li>
</ul>
<p>下面将讨论如何在客户端库API中公开这些方法。</p>
<p>肯定的确认只是指示RabbitMQ记录一条消息，并且可以丢弃。<code>basic.reject</code>的否定确认具有相同的效果。差异主要在于语义：正面确认假设消息已成功处理，而负面消息表明交付未处理但仍应删除。</p>
<p>在自动确认模式中，消息被认为在发送后立即成功传送。这种模式可以降低吞吐量（只要消费者可以跟上），以降低交付和消费者处理的安全性。这种模式通常被称为“即发即忘”。与手动确认模型不同，如果消费者的TCP连接或通道在成功交付之前关闭，则服务器发送的消息将丢失。因此，自动消息确认<strong>应被视为不安全</strong> ，并不适用于所有工作负载。</p>
<p>使用自动确认模式时需要考虑的另一件事是消费者过载。手动确认模式通常与有界信道预取一起使用，该预取限制了信道上未完成（“进行中”）交付的数量。但是，通过自动确认，根据定义没有这种限制。因此，消费者可能会被交付速度所淹没，可能会累积内存积压并耗尽堆或使操作系统终止其进程。某些客户端库将应用TCP反压（停止从套接字读取，直到未处理的交付积压超过某个限制）。因此，仅建议能够以稳定的速度有效处理交付的消费者使用自动交钥匙模式。</p>
<h3 id="积极承认交付"><a href="#积极承认交付" class="headerlink" title="积极承认交付"></a>积极承认交付</h3><p>用于传递确认的API方法通常作为客户端库中的通道上的操作公开。Java客户端用户将分别使用<code>Channel.basicAck</code>和<code>Channel.basicNack</code> 来执行<code>basic.ack</code>和<code>basic.nack</code>。这是一个Java客户端示例，它表明了一个积极的认可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this example assumes an existing channel instance</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(queueName, autoAck, <span class="string">"a-consumer-tag"</span>,</span><br><span class="line">     <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">             <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">             <span class="comment">// positively acknowledge a single delivery, the message will</span></span><br><span class="line">             <span class="comment">// be discarded</span></span><br><span class="line">             channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="一次确认多次交付"><a href="#一次确认多次交付" class="headerlink" title="一次确认多次交付"></a>一次确认多次交付</h3><p>可以对手动确认进行批处理以减少网络流量。这是通过将确认方法的多个字段（见上文）设置为true来完成的。请注意，basic.reject历史上没有该字段，这就是为什么basic.nack被RabbitMQ引入为协议扩展。</p>
<p>当multiple字段设置为true时，RabbitMQ将确认所有未完成的传递标记，包括确认中指定的标记。与确认相关的所有其他内容一样，这是每个频道的范围。例如，假设在信道Ch上未确认传送标签5,6,7和8 ，当确认帧到达该信道时，delivery_tag设置为8 并且multiple设置为true，则将确认从5到8的所有标签。 。如果multiple设置为false，则交付5,6和7仍然是未确认的。</p>
<p>为了确认与RabbitMQ的Java客户端多次交货，通过真正的 多参数通道＃basicAck：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this example assumes an existing channel instance</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(queueName, autoAck, <span class="string">"a-consumer-tag"</span>,</span><br><span class="line">     <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">             <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">             <span class="comment">// positively acknowledge all deliveries up to</span></span><br><span class="line">             <span class="comment">// this delivery tag</span></span><br><span class="line">             channel.basicAck(deliveryTag, <span class="keyword">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="交货的否定确认和重新排列"><a href="#交货的否定确认和重新排列" class="headerlink" title="交货的否定确认和重新排列"></a>交货的否定确认和重新排列</h3><p>有时，消费者无法立即处理交付，但其他实例可能会。在这种情况下，可能希望将其重新排队并让另一个消费者接收并处理它。basic.reject和basic.nack是用于此的两种协议方法。</p>
<p>这些方法通常用于否定确认交付。经纪人可以丢弃此类提供或重新排队。此行为由重新排队字段控制。当该字段设置为true时，代理将使用指定的传递标记重新排列交付（或多次交付，如下所述）。</p>
<p>这两种方法通常作为客户端库中通道的操作公开。Java客户端用户将使用Channel＃basicReject和Channel＃basicNack 分别执行basic.reject和basic.nack：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this example assumes an existing channel instance</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(queueName, autoAck, <span class="string">"a-consumer-tag"</span>,</span><br><span class="line">     <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">             <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">             <span class="comment">// negatively acknowledge, the message will</span></span><br><span class="line">             <span class="comment">// be discarded</span></span><br><span class="line">             channel.basicReject(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"><span class="comment">// this example assumes an existing channel instance</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(queueName, autoAck, <span class="string">"a-consumer-tag"</span>,</span><br><span class="line">     <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">             <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">             <span class="comment">// requeue the delivery</span></span><br><span class="line">             channel.basicReject(deliveryTag, <span class="keyword">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>

<p>当消息被重新排队时，如果可能的话，它将被放置在其队列中的原始位置。如果不是（由于当多个消费者共享队列时同时传递和来自其他消费者的确认），该消息将被重新排队到更靠近队列头的位置。</p>
<p>重新排队的消息可以立即准备好重新发送，具体取决于它们在队列中的位置，即具有活动消费者的频道使用的预取值。这意味着如果所有消费者因为由于瞬态条件而无法处理交付而重新排队，则他们将创建重新排队/重新发送循环。就网络带宽和CPU资源而言，这种环路可能是昂贵的。消费者实施可以跟踪重新发送的数量并拒绝好消息（丢弃它们）或在延迟后安排重新排队。</p>
<p>可以使用basic.nack 方法一次拒绝或重新排队多条消息。这就是它与basic.reject的区别。它接受一个额外的参数，倍数。这是一个Java客户端示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this example assumes an existing channel instance</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(queueName, autoAck, <span class="string">"a-consumer-tag"</span>,</span><br><span class="line">     <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">             <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">             <span class="comment">// requeue all unacknowledged deliveries up to</span></span><br><span class="line">             <span class="comment">// this delivery tag</span></span><br><span class="line">             channel.basicNack(deliveryTag, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="信道预取设置（QoS）"><a href="#信道预取设置（QoS）" class="headerlink" title="信道预取设置（QoS）"></a>信道预取设置（QoS）</h3><p>因为消息是异步发送（推送）到客户端的，所以在任何给定时刻通常在通道上“飞行”中有多条消息。此外，客户的手动确认本质上也是异步的。因此，有一个未确认的交付标签的滑动窗口。开发人员通常更愿意限制此窗口的大小以避免消费者端的无限制缓冲区问题。这是通过使用basic.qos方法设置“预取计数”值来完成的 。该值定义通道上允许的最大未确认交货数。一旦数量达到配置的计数，RabbitMQ将停止在通道上传递更多消息，除非至少有一个未完成的消息被确认。</p>
<p>例如，假设在信道Ch上有未确认的传送标签5,6,7和8，并且信道 Ch的预取计数设置为4，则除非至少有一个未完成的传送，否则RabbitMQ将不再推送Ch的传送。得到承认。当确认帧到达该通道且delivery_tag设置为8时，RabbitMQ将注意到并再发送一条消息。</p>
<p>值得重申的是，交付流程和手动客户端确认完全是异步的。因此，如果在飞行中已经有交付的情况下改变了预取值，则会出现自然竞争条件，并且暂时可以在通道上预取未计数的未确认消息。</p>
<p>即使在手动确认模式下， QoS预取设置也不会影响使用basic.get（“pull API”）获取的消息。</p>
<p>可以为频道或消费者配置QoS设置。有关详细信息，请参阅<a href="https://www.rabbitmq.com/consumer-prefetch.html" target="_blank" rel="noopener">Consumer Prefetch</a>。</p>
<h3 id="消费者确认模式，预取和吞吐量"><a href="#消费者确认模式，预取和吞吐量" class="headerlink" title="消费者确认模式，预取和吞吐量"></a>消费者确认模式，预取和吞吐量</h3><p>确认模式和QoS预取值对消费者吞吐量具有显着影响。通常，增加预取将提高向消费者传递消息的速率。自动确认模式可以产生最佳的交付率。但是，在这两种情况下，已传送但尚未处理的消息的数量也将增加，从而增加了消费者的RAM消耗。</p>
<p>应谨慎使用具有无限预取功能的自动确认模式或手动确认模式。在没有确认的情况下消耗大量消息的消费者将导致他们所连接的节点上的内存消耗增长。找到合适的预取值是一个试验和错误的问题，并且会因工作负载而异。100到300范围内的值通常可提供最佳吞吐量，并且不会面临压倒性消费者的重大风险。较高的价值往往<a href="https://www.rabbitmq.com/blog/2014/04/14/finding-bottlenecks-with-rabbitmq-3-3/" target="_blank" rel="noopener">会影响收益递减规律</a>。</p>
<p>预取值1是最保守的。它将显着降低吞吐量，特别是在消费者连接延迟较高的环境中。对于许多应用来说，更高的值是合适的和最佳的。</p>
<h3 id="当消费者失败或失去连接时：自动重新排队"><a href="#当消费者失败或失去连接时：自动重新排队" class="headerlink" title="当消费者失败或失去连接时：自动重新排队"></a>当消费者失败或失去连接时：自动重新排队</h3><p>使用手动确认时，任何未执行的传递（消息）将在关闭发生传递的通道（或连接）时自动重新排队。这包括客户端的TCP连接丢失，消费者应用程序（进程）故障和通道级协议异常（如下所述）。</p>
<p>请注意，检测不可用的客户端需要一段时间。</p>
<p>由于这种行为，消费者必须准备好处理重新发送，否则就要考虑到幂等性。Redeliveries将有一个特殊的布尔属性，即redeliver， 由RabbitMQ 设置为true。对于第一次交付，它将被设置为false。请注意，消费者可以接收先前传递给其他消费者的消息。</p>
<h3 id="客户端错误：双重标记和未知标记"><a href="#客户端错误：双重标记和未知标记" class="headerlink" title="客户端错误：双重标记和未知标记"></a>客户端错误：双重标记和未知标记</h3><p>如果客户多次确认相同的交付标签，RabbitMQ将导致通道错误，例如PRECONDITION_FAILED  - 未知交货标签100。如果使用未知的传递标记，则将抛出相同的通道异常。</p>
<p>经纪人将抱怨“未知交付标签”的另一种情况是，在与接收交付的渠道不同的渠道上尝试确认（无论是正面还是负面）。交货必须在同一渠道上确认。</p>
<h2 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h2><p>网络可能以不太明显的方式失败，并且检测到某些故障需要时间。因此，将协议帧或一组帧（例如，已发布的消息）写入其套接字的客户端不能假定该消息已到达服务器并且已成功处理。它可能在途中丢失或其交付可能会显着延迟。</p>
<p>使用标准AMQP 0-9-1，保证消息不丢失的唯一方法是使用事务 - 使事务事务处理然后为每个消息或消息集发布，提交。在这种情况下，交易不必要地重量级并且将吞吐量减少250倍。为了解决这个问题，引入了确认机制。它模仿协议中已存在的消费者认可机制。</p>
<p>要启用确认，客户端将发送 confirm.select方法。根据是否 设置了无等待，代理可以使用confirm.select-ok进行响应。一旦在 频道上使用confirm.select方法，就会说它处于确认模式。交易渠道不能进入确认模式，一旦渠道处于确认模式，就不能进行交易。</p>
<p>一旦通道处于确认模式，代理和客户端都会计数消息（计数在第一个confirm.select上从1 开始）。然后，代理通过在同一通道上发送basic.ack来确认消息 。所述输送标签字段包含确认消息的序列号。代理还可以在basic.ack中设置多个字段，以指示已经处理了包括具有序列号的消息的所有消息。</p>
<h3 id="发布的否定致谢"><a href="#发布的否定致谢" class="headerlink" title="发布的否定致谢"></a>发布的否定致谢</h3><p>在特殊情况下，当代理无法成功处理消息而不是basic.ack时，代理将发送basic.nack。在此背景下，该领域basic.nack的含义在对应部分相同basic.ack 和重新排队字段应该被忽略。通过nack一个或多个消息，经纪人表示它无法处理消息并拒绝对它们负责; 此时，客户端可以选择重新发布消息。</p>
<p>将频道置于确认模式后，将确认所有后续发布的消息或仅确认一次。不保证消息的确定时间。没有消息将被确认和nack’d。</p>
<p>只有在负责队列的Erlang进程中发生内部错误时，才会传递basic.nack。</p>
<h3 id="什么时候发布的消息会被经纪人确认？"><a href="#什么时候发布的消息会被经纪人确认？" class="headerlink" title="什么时候发布的消息会被经纪人确认？"></a>什么时候发布的消息会被经纪人确认？</h3><p>对于不可路由的消息，代理将在交换验证消息不会路由到任何队列（发回一个空的队列列表）后发出确认。如果消息也作为必需消息发布，则basic.return将在basic.ack之前发送给客户端。负面确认（basic.nack）也是如此。</p>
<p>对于可路由消息，当所有队列都接受消息时，将发送basic.ack。对于路由到持久队列的持久性消息，这<strong>意味着持久化到磁盘</strong>。对于镜像队列，这意味着所有镜像都已接受该消息。</p>
<h3 id="永久消息的Ack延迟"><a href="#永久消息的Ack延迟" class="headerlink" title="永久消息的Ack延迟"></a>永久消息的Ack延迟</h3><p>在将消息持久保存到磁盘后，将发送路由到持久队列的持久消息的basic.ack。RabbitMQ消息存储在一段时间（几百毫秒）之后批量传递消息到磁盘，以最小化fsync（2）调用的数量，或者当队列空闲时。这意味着在恒定负载下，basic.ack的延迟 可以达到几百毫秒。为了提高吞吐量，强烈建议应用程序异步处理确认（作为流）或发布批量消息并等待未完成的确认。确切的API因客户端库而异。</p>
<h3 id="订购Publisher确认的注意事项"><a href="#订购Publisher确认的注意事项" class="headerlink" title="订购Publisher确认的注意事项"></a>订购Publisher确认的注意事项</h3><p>在大多数情况下，RabbitMQ将以与发布时相同的顺序向生产者确认消息（这适用于在单个频道上发布的消息）。但是，生产者确认是异步发出的，可以确认单个消息或一组消息。发出确认的确切时刻取决于消息的传递模式（持久性与瞬态）以及消息路由到的队列的属性（参见上文）。也就是说，可以认为不同的消息可以在不同时间进行确认。这意味着与其各自的消息相比，确认可以以不同的顺序到达。应用程序不应该尽可能依赖于确认的顺序。</p>
<h3 id="生产者确认并保证交付"><a href="#生产者确认并保证交付" class="headerlink" title="生产者确认并保证交付"></a>生产者确认并保证交付</h3><p>如果代理在将所述消息写入磁盘之前崩溃，则代理会丢失持久消息。在某些情况下，这会导致经纪人以令人惊讶的方式行事。</p>
<p>例如，考虑这种情况：</p>
<ol>
<li>客户端将持久性消息发布到持久队列</li>
<li>客户端使用队列中的消息（注意消息是持久的并且队列持久），但确认不活动，</li>
<li>经纪人去世并重新启动，并且</li>
<li>客户端重新连接并开始使用消息。</li>
</ol>
<p>此时，客户端可以合理地假设该消息将再次传递。情况并非如此：重启导致代理丢失消息。为了保证持久性，客户应该使用确认。如果生产者的频道处于确认模式，则生产者将不会收到丢失消息的确认（因为该消息尚未写入磁盘）。</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><h3 id="最大交货标签"><a href="#最大交货标签" class="headerlink" title="最大交货标签"></a>最大交货标签</h3><p>传递标记是64位长的值，因此其最大值是9223372036854775807.由于传递标记是按通道确定范围的，因此生产者或消费者在实践中不太可能运行此值。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">RabbitMQ教程</a></li>
<li><a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">消费者致谢和生产者确认</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/02/Java/框架/消息队列：概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/02/Java/框架/消息队列：概述/" class="post-title-link" itemprop="url">消息队列：概述</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2018-10-02 23:19:03" itemprop="dateCreated datePublished" datetime="2018-10-02T23:19:03+08:00">2018-10-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-04-15 16:15:43" itemprop="dateModified" datetime="2019-04-15T16:15:43+08:00">2019-04-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/框架/" itemprop="url" rel="index"><span itemprop="name">框架</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2018/10/02/Java/框架/消息队列：概述/" class="post-meta-item leancloud_visitors" data-flag-title="消息队列：概述">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2018/10/02/Java/框架/消息队列：概述/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/10/02/Java/框架/消息队列：概述/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="消息队列介绍"><a href="#消息队列介绍" class="headerlink" title="消息队列介绍"></a>消息队列介绍</h1><p>异步解耦</p>
<p>场景</p>
<ul>
<li>下单</li>
</ul>
<p>消息队列特性</p>
<ul>
<li>业务无关，只做消息分发</li>
<li>FIFO先投递先到达</li>
<li>容灾：节点的动态增删和消息的持久化</li>
<li>性能：吞吐量提升，系统内部通信效率会提高</li>
</ul>
<p>为什么需要消息队列</p>
<ul>
<li>生产和消费的速度或稳定性等因素不一致</li>
</ul>
<p>消息队列好处</p>
<ul>
<li>业务解耦<ul>
<li>只关注自己系统的核心流程</li>
</ul>
</li>
<li>最终一致性<ul>
<li>两个系统的状态保持一致</li>
<li>利用记录和补偿实现</li>
</ul>
</li>
<li>错峰与流控</li>
</ul>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><blockquote>
<p>场景说明：用户注册后，需要发送注册邮件和发送注册信息，传统的做法有两种：串行方式、并行方式</p>
</blockquote>
<h3 id="串行方式"><a href="#串行方式" class="headerlink" title="串行方式"></a>串行方式</h3><p>将注册信息写入数据库成功后，发送注册邮件，然后发送注册短信，而所有任务执行完成后，返回信息给客户端</p>
<p><img src="assets/d5bc9f19340dea143353a54959c0574d" alt="img"></p>
<p>​                                        串行方式</p>
<h3 id="并行方式"><a href="#并行方式" class="headerlink" title="并行方式"></a>并行方式</h3><p>将注册信息写入数据库成功后，同时进行发送注册邮件和发送注册短信的操作。而所有任务执行完成后，返回信息给客户端。同串行方式相比，并行方式可以提高执行效率，减少执行时间。</p>
<p><img src="assets/fce97a21d8bcb040cf7702760ab889dc" alt="img"></p>
<p>​                                        并行方式</p>
<p>上面的比较可以发现，假设三个操作均需要50ms的执行时间，排除网络因素，则最终执行完成，串行方式需要150ms，而并行方式需要100ms。</p>
<p>因为cpu在单位时间内处理的请求数量是一致的，假设：CPU每1秒吞吐量是100此，则串行方式1秒内可执行的请求量为1000/150，不到7次；并行方式1秒内可执行的请求量为1000/100，为10次。</p>
<p>由上可以看出，传统串行和并行的方式会受到系统性能的局限，那么如何解决这个问题？</p>
<p>我们需要引入消息队列，将不是必须的业务逻辑，异步进行处理，由此改造出来的流程为</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/5/5/bdb0a238908810a23a1ff2d6d3a417ce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>​                                    引入消息队列，异步处理消息</p>
<p>根据上述的流程，用户的响应时间基本相当于将用户数据写入数据库的时间，发送注册邮件、发送注册短信的消息在写入消息队列后，即可返回执行结果，写入消息队列的时间很快，几乎可以忽略，也有此可以将系统吞吐量提升至20QPS，比串行方式提升近3倍，比并行方式提升2倍。</p>
<h2 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h2><blockquote>
<p>场景说明：用户下单后，订单系统需要通知库存系统。</p>
</blockquote>
<p>传统的做法为：订单系统调用库存系统的接口。如下图所示：</p>
<p><img src="assets/a4b6208ecae07df4a29631dbb5d6fec1" alt="img"></p>
<p>​                                    传统方式：调用库存接口</p>
<p>传统方式具有如下缺点：</p>
<ol>
<li>假设库存系统访问失败，则订单减少库存失败，导致订单创建失败</li>
<li>订单系统同库存系统过度耦合</li>
</ol>
<p>如何解决上述的缺点呢？需要引入消息队列，引入消息队列后的架构如下图所示：</p>
<p><img src="assets/0a6ad0091ed17b4d92c1a708c164d714" alt="img"></p>
<p>​                                    引入消息队列，实现应用解耦</p>
<ul>
<li>订单系统：用户下单后，订单系统进行数据持久化处理，然后将消息写入消息队列，返回订单创建成功</li>
<li>库存系统：使用拉/推的方式，获取下单信息，库存系统根据订单信息，进行库存操作。</li>
</ul>
<p>假如在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其后续操作了。由此实现了订单系统与库存系统的应用解耦。</p>
<h2 id="流量削锋"><a href="#流量削锋" class="headerlink" title="流量削锋"></a>流量削锋</h2><p>流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。</p>
<blockquote>
<p>应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。</p>
</blockquote>
<ol>
<li>可以控制参与活动的人数；</li>
<li>可以缓解短时间内高流量对应用的巨大压力；</li>
</ol>
<p>流量削锋处理方式系统图如下：</p>
<p><img src="assets/50e0da28e1acd322c7e1af940428438a" alt="img"></p>
<p>​                                    流量削锋方式系统图</p>
<ol>
<li>服务器在接收到用户请求后，首先写入消息队列。这时如果消息队列中消息数量超过最大数量，则直接拒绝用户请求或返回跳转到错误页面；</li>
<li>秒杀业务根据秒杀规则读取消息队列中的请求信息，进行后续处理。</li>
</ol>
<h2 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h2><p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下：</p>
<p><img src="assets/0b1f417be6abd40f59df58e611aff047" alt="img"></p>
<p>​                                消息队列应用于日志处理的架构</p>
<ul>
<li>日志采集客户端：负责日志数据采集，定时写受写入Kafka队列；</li>
<li>Kafka消息队列：负责日志数据的接收，存储和转发；</li>
<li>日志处理应用：订阅并消费kafka队列中的日志数据；</li>
</ul>
<p>这种架构在实际开发中的应用，可以参照案例：<a href="https://link.juejin.im/?target=http%3A%2F%2Fcloud.51cto.com%2Fart%2F201507%2F484338.htm" target="_blank" rel="noopener">新浪技术分享：我们如何扛下32亿条实时日志的分析处理</a></p>
<p><img src="assets/f650fdb3cca9d9efb58c68bbebe7b91f-1553696634213" alt="img"></p>
<p>服务的技术架构设计</p>
<ol>
<li>Kafka：接收用户日志的消息队列。</li>
<li>Logstash：做日志解析，统一成JSON输出给Elasticsearch。</li>
<li>Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。</li>
<li>Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。</li>
</ol>
<h2 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h2><p>消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列、聊天室等。</p>
<h3 id="点对点通讯"><a href="#点对点通讯" class="headerlink" title="点对点通讯"></a>点对点通讯</h3><p><img src="assets/b39446ab1d44573b22b79b5257985a29" alt="img"></p>
<p>​                                点对点通讯架构设计<br>在点对点通讯架构设计中，客户端A和客户端B共用一个消息队列，即可实现消息通讯功能。</p>
<h3 id="聊天室通讯"><a href="#聊天室通讯" class="headerlink" title="聊天室通讯"></a>聊天室通讯</h3><p><img src="assets/aea9046be1a79db82eb3af17fac07cdb" alt="img"></p>
<p>​                                    聊天室通讯架构设计</p>
<p>客户端A、客户端B、直至客户端N订阅同一消息队列，进行消息的发布与接收，即可实现聊天通讯方案架构设计。</p>
<h1 id="消息中间件示例"><a href="#消息中间件示例" class="headerlink" title="消息中间件示例"></a>消息中间件示例</h1><h2 id="电商系统"><a href="#电商系统" class="headerlink" title="电商系统"></a>电商系统</h2><p><img src="assets/d2b24a914471b30be56f5629d0b88953" alt="img"></p>
<p>​                                        电商系统架构示意图</p>
<p>消息队列采用高可用、可持久化的消息中间件。比如Active MQ，Rabbit MQ，Rocket MQ。</p>
<ul>
<li>应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性）</li>
<li>扩展流程（发短信、配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。</li>
<li>消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。</li>
</ul>
<h2 id="日志收集系统"><a href="#日志收集系统" class="headerlink" title="日志收集系统"></a>日志收集系统</h2><p><img src="assets/e8e57f4f01f464878f1ea8392cda37f0" alt="img"></p>
<p>​                                    日志收集系统架构示意图<br>分为Zookeeper注册中心，日志收集客户端，Kafka集群和Storm集群（OtherApp）四部分组成。</p>
<ul>
<li>Zookeeper注册中心，提出负载均衡和地址查找服务；</li>
<li>日志收集客户端，用于采集应用系统的日志，并将数据推送到kafka队列；</li>
<li>Kafka集群：接收，路由，存储，转发等消息处理；</li>
<li>Storm集群：与OtherApp处于同一级别，采用拉的方式消费队列中的数据；</li>
</ul>
<h1 id="JMS消息服务"><a href="#JMS消息服务" class="headerlink" title="JMS消息服务"></a>JMS消息服务</h1><p>讲消息队列就不得不提JMS 。JMS（Java Message Service,Java消息服务）API是一个消息服务的标准/规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<p>在EJB架构中，有消息bean可以无缝的与JM消息服务集成。在J2EE架构模式中，有消息服务者模式，用于实现消息与应用直接的解耦。</p>
<h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><p>在JMS标准中，有两种消息模型P2P（Point to Point）,Publish/Subscribe(Pub/Sub)。</p>
<h3 id="P2P模式"><a href="#P2P模式" class="headerlink" title="P2P模式"></a>P2P模式</h3><p><img src="assets/551ee6d17950db4686585aeac79d5250" alt="img"></p>
<p>​                                        P2P模式<br>P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p>
<p>P2P的特点</p>
<ul>
<li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li>
<li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</li>
<li>接收者在成功接收消息之后需向队列应答成功</li>
</ul>
<p>如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式。</p>
<h3 id="Pub-Sub模式"><a href="#Pub-Sub模式" class="headerlink" title="Pub/Sub模式"></a>Pub/Sub模式</h3><p><img src="assets/59688c1ea076e912a31f3b08cc25880f" alt="img"></p>
<p>​                                        Pub/Sub模式<br>包含三个角色：主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p>
<p>Pub/Sub的特点</p>
<ul>
<li>每个消息可以有多个消费者</li>
<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li>
<li>为了消费消息，订阅者必须保持运行的状态。</li>
</ul>
<p>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</p>
<p>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。</p>
<h2 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h2><p>在JMS中，消息的产生和消费都是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。</p>
<ol>
<li>同步<br>订阅者或接收者通过receive方法来接收消息，receive方法在接收到消息之前（或超时之前）将一直阻塞；</li>
<li>异步<br>订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。</li>
</ol>
<p>JNDI：Java命名和目录接口,是一种标准的Java命名系统接口。可以在网络上查找和访问服务。通过指定一个资源名称，该名称对应于数据库或命名服务中的一个记录，同时返回资源连接建立所必须的信息。</p>
<p>JNDI在JMS中起到查找和访问发送目标或消息来源的作用。</p>
<h2 id="JMS编程模型"><a href="#JMS编程模型" class="headerlink" title="JMS编程模型"></a>JMS编程模型</h2><h3 id="1-ConnectionFactory"><a href="#1-ConnectionFactory" class="headerlink" title="1. ConnectionFactory"></a>1. ConnectionFactory</h3><p>创建Connection对象的工厂，针对两种不同的JMS消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。</p>
<h3 id="2-Destination"><a href="#2-Destination" class="headerlink" title="2. Destination"></a>2. Destination</h3><p>Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。</p>
<p>所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。</p>
<h3 id="3-Connection"><a href="#3-Connection" class="headerlink" title="3. Connection"></a>3. Connection</h3><p>Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP Socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。</p>
<h3 id="4-Session"><a href="#4-Session" class="headerlink" title="4. Session"></a>4. Session</h3><p>Session是操作消息的接口。可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分QueueSession和TopicSession。</p>
<h3 id="5-消息的生产者"><a href="#5-消息的生产者" class="headerlink" title="5. 消息的生产者"></a>5. 消息的生产者</h3><p>消息生产者由Session创建，并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。</p>
<h3 id="6-消息消费者"><a href="#6-消息消费者" class="headerlink" title="6. 消息消费者"></a>6. 消息消费者</h3><p>消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。</p>
<h3 id="7-MessageListener"><a href="#7-MessageListener" class="headerlink" title="7. MessageListener"></a>7. MessageListener</h3><p>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。EJB中的MDB（Message-Driven Bean）就是一种MessageListener。</p>
<p>深入学习JMS对掌握JAVA架构、EJB架构有很好的帮助，消息中间件也是大型分布式系统必须的组件。本次分享主要做全局性介绍，具体的深入需要大家学习，实践，总结，领会。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://juejin.im/entry/590c2d9061ff4b006239098e" target="_blank" rel="noopener">消息队列技术介绍</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/17/"><i class="fa fa-angle-left" aria-label="Página anterior"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/19/"><i class="fa fa-angle-right" aria-label="Página siguiente"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">219</span>
          <span class="site-state-item-name">entradas</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categorías</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
</div>
  <div class="powered-by">Creado mediante <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Tema – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  











  
  <script>
    function showTime(Counter) {
      var entries = [];
      var $visitors = $('.leancloud_visitors');

      $visitors.each(function() {
        entries.push( $(this).attr('id').trim() );
      });

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url: { '$in': entries } }) })
        .done(function({ results }) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if (countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function ({ responseJSON }) {
          console.log(`LeanCloud Counter Error: ${responseJSON.code} ${responseJSON.error}`);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
                'X-LC-Key': 'uTVcNIWdMCGpicrhTKygpKXi',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
            if ($('.post-title-link').length >= 1) {
              showTime(Counter);
            }
          
        });
    });
  </script>
























    
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
    appKey: 'uTVcNIWdMCGpicrhTKygpKXi',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn'
  });
</script>


</body>
</html>
