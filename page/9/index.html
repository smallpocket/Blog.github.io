<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: 'OZTK1BY156',
      apiKey: '',
      indexName: 'BlogIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copiar',
      copy_success: 'Copiado',
      copy_failure: 'Copiar falló'
    }
  };
</script>

  <meta name="description" content="To be awesome">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="To be awesome">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="To be awesome">
  <link rel="canonical" href="http://yoursite.com/page/9/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Cambiar a barra de navegación">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Inicio</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>Sobre mi</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Etiquetas</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categorías</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archivo</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>Calendario</a>

  </li>
    </ul>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/17/Java/设计模式/设计模式：模板方法模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/17/Java/设计模式/设计模式：模板方法模式/" class="post-title-link" itemprop="url">设计模式：模板方法模式</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-04-17 23:48:38" itemprop="dateCreated datePublished" datetime="2019-04-17T23:48:38+08:00">2019-04-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-29 08:55:23" itemprop="dateModified" datetime="2019-07-29T08:55:23+08:00">2019-07-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/04/17/Java/设计模式/设计模式：模板方法模式/" class="post-meta-item leancloud_visitors" data-flag-title="设计模式：模板方法模式">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/04/17/Java/设计模式/设计模式：模板方法模式/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/17/Java/设计模式/设计模式：模板方法模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>当多个类当中存在共同或相似的算法，因此有一些重复的代码块（方法）时，因此在这些类当中就有着重复的代码。</p>
<h2 id="为什么要用（作用）"><a href="#为什么要用（作用）" class="headerlink" title="为什么要用（作用）"></a>为什么要用（作用）</h2><ul>
<li>封装算法块，使得子类可以在任何时候都可以将自己挂接进运算里。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤</p>
</blockquote>
<p><strong><em>模板方法</em></strong></p>
<p>骨架prepareRecipe()，步骤即是算法内部的方法。</p>
<p>步骤延迟到子类中，即内部的一些抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineBeverage</span></span>&#123;</span><br><span class="line">    <span class="comment">//prepareRecipe()是一个模板方法</span></span><br><span class="line">    <span class="comment">//是用来制作咖啡因饮料的算法</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addConiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addConiments</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板方法原因：</p>
<ul>
<li>是一个方法</li>
<li>用做一个算法的模板，在模板当中，算法的每一个步骤都被一个方法代表了。</li>
</ul>
<p>一些方法由超类处理，即这个类，例如boilWater()</p>
<p>而另一些方法由子类处理，这些方法加上abstract标识，如addConiments()</p>
<h3 id="分类，各个分类是什么"><a href="#分类，各个分类是什么" class="headerlink" title="分类，各个分类是什么"></a>分类，各个分类是什么</h3><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="优缺"><a href="#优缺" class="headerlink" title="优缺"></a>优缺</h3><ul>
<li>算法存在与模板方法类当中，拥有算法并保护算法，并且容易修改。专注于算法本身</li>
<li>模板方法对于子类而言可以将代码的复用最大化。</li>
<li>提供了算法框架，新增添的类型可以容易加入</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板方法的模板类，作为基类，子类必须事先其操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模板方法，final避免子类改变算法顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义算法步骤，每个步骤由一个方法代表</span></span><br><span class="line">        primitiveOperation1();</span><br><span class="line">        primitiveOperation2();</span><br><span class="line">        concreteOperation1();</span><br><span class="line">        hook();</span><br><span class="line">        <span class="comment">//利用钩子做判断影响算法流程</span></span><br><span class="line">        <span class="comment">//if(hook())&#123;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//子类需要事先的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">primitiveOperation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">primitiveOperation2</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//由超类进行的实现</span></span><br><span class="line">    <span class="comment">//算法的默认流程</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">concreteOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//一个空的方法，作为钩子，子类视情况决定是否覆盖。</span></span><br><span class="line">    <span class="comment">//子类有能力在算法的不同点进行挂钩</span></span><br><span class="line">    <span class="comment">//当然也可以不是空的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>钩子</em></strong></p>
<ul>
<li>钩子可以让子类实现算法中可选的部分</li>
<li>钩子对子类实现并不重要时可以忽略</li>
<li>钩子可以让子类能够有机会对模板方法中某些即将发生的步骤做出反应</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="与其他的区别"><a href="#与其他的区别" class="headerlink" title="与其他的区别"></a>与其他的区别</h4><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>UML类图</p>
<p><img src="assets/1559632429677.png" alt="1559632429677"></p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="使用Lambda"><a href="#使用Lambda" class="headerlink" title="使用Lambda"></a>使用Lambda</h3><h2 id="反省总结"><a href="#反省总结" class="headerlink" title="反省总结"></a>反省总结</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/17/Java/设计模式/设计模式：命令模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/17/Java/设计模式/设计模式：命令模式/" class="post-title-link" itemprop="url">设计模式：命令模式</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-04-17 23:48:27" itemprop="dateCreated datePublished" datetime="2019-04-17T23:48:27+08:00">2019-04-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-17 18:28:12" itemprop="dateModified" datetime="2019-07-17T18:28:12+08:00">2019-07-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/04/17/Java/设计模式/设计模式：命令模式/" class="post-meta-item leancloud_visitors" data-flag-title="设计模式：命令模式">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/04/17/Java/设计模式/设计模式：命令模式/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/17/Java/设计模式/设计模式：命令模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接收者的任何信息。</p>
<h3 id="问题案例"><a href="#问题案例" class="headerlink" title="问题案例"></a>问题案例</h3><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ul>
<li>将“发出请求的对象与“接收与执行这些请求的对象”分离开</li>
<li>解耦对象间通过命令对象来沟通，命令对象封装了接受者和一个或一组动作</li>
</ul>
<h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><ul>
<li><p>当有一个遥控器，它需要控制电灯、车门的开关。它不应该去了解电灯开关的具体细节，只需要控制它打开即可</p>
<ul>
<li><p>差的设计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slot1 ==light)</span><br><span class="line">	light.on();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (slot1 == hottub)</span><br><span class="line">	hottub.jetsOn();</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令模式：</p>
<ul>
<li>遥控器是命令的调用者。而启用电灯、开启车门是一项命令。</li>
<li>对于遥控器来讲，执行命令即可，至于命令是什么，是可以随意更换的。是开启电灯、车门不需要关心</li>
<li>命令对象中绑定着接受者，对于开启电灯来讲，具体传递到哪一个电灯，需要绑定到命令中</li>
</ul>
</li>
</ul>
</li>
<li><p>以餐厅考虑。</p>
<ul>
<li>顾客点餐，在中间涉及到了：顾客、餐单、服务员、厨师</li>
<li>服务员只需要知道这是一份餐单即可，即使餐单更换了也没有影响。服务员不会去关心餐单的信息，只需要接受，然后送给柜台即可。</li>
<li>厨师不需要与服务员交互，只需要获取提交过来的餐单即可。</li>
<li>即实现解耦合</li>
</ul>
</li>
</ul>
<h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>命令模式：将”请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。</p>
</blockquote>
<p>别名：动作、<strong>事务</strong></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="assets/1555662094742.png" alt="1555662094742"></p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><h3 id="协作-1"><a href="#协作-1" class="headerlink" title="协作"></a>协作</h3><ul>
<li>类关系</li>
<li>逻辑关系</li>
</ul>
<h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><h1 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h1><h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><h2 id="效果（优缺）"><a href="#效果（优缺）" class="headerlink" title="效果（优缺）"></a>效果（优缺）</h2><p>为什么接受者一定存在， 命令对象不直接执行execute</p>
<ul>
<li>尽量设计“傻瓜”命令对象，只懂得调用一个接受者的一个行为。这样解耦程度最高。</li>
<li>可以将接受者作为参数传递给命令。实现多种接受者</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>通过命令对象实现方法，而调用者通过执行命令对象，从而进行动作</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul>
<li>定义一个命令对象的接口</li>
<li>定义一个实现类，实现接口</li>
<li>在方法调用类当中，将接口与实现类绑定</li>
<li>需要调用方法时，只需要执行命令接口的方法，则无论是哪一个实现类，都可以实现它的方法。</li>
</ul>
<h3 id="案例1-1"><a href="#案例1-1" class="headerlink" title="案例1"></a>案例1</h3><p>#### </p>
<p><strong>command接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Heper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span> Command 命令接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/19 15:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Receiver接收者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Heper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span> 接受者 Receiver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/19 15:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"on"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>命令对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义了动作与接收者之间的绑定关系</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Heper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/19 15:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Light light;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入实体，以让命令进行控制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发出请求，执行动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Invoker调用者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Heper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span> 调用者 Invoker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/19 15:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRemoteControl</span> </span>&#123;</span><br><span class="line">    Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRemoteControl</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command com)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buttonWasPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Client</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Heper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span> 客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/19 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControlTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遥控器，作为命令的调用者</span></span><br><span class="line">        SimpleRemoteControl simpleRemoteControl = <span class="keyword">new</span> SimpleRemoteControl();</span><br><span class="line">        <span class="comment">//创建请求的接受者</span></span><br><span class="line">        Light light = <span class="keyword">new</span> Light();</span><br><span class="line">        <span class="comment">//创建命令</span></span><br><span class="line">        LightCommand lightCommand = <span class="keyword">new</span> LightCommand(light);</span><br><span class="line">        <span class="comment">//命令传递给调用者</span></span><br><span class="line">        simpleRemoteControl.setCommand(lightCommand);</span><br><span class="line">        <span class="comment">//调用者执行</span></span><br><span class="line">        simpleRemoteControl.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>命令模式的更多特性：队列请求</p>
<p>命令可以将运算块打包，然后将它传来传去。命令对象可以在不同的线程中调用。因此衍生了一些应用：日程安排、线程池、工作队列等。</p>
<p><strong>工作队列</strong>：一端添加命令，另一端是线程，从队列当中取出命令，然后调用execute方法</p>
<p><strong>日志请求：</strong>某些应用需要我们将过去的动作都记录在日志中，并在系统死机后，重新调用这些动作恢复到之前的状态。通过新增两个方法store和load即可实现</p>
<h2 id="反省总结"><a href="#反省总结" class="headerlink" title="反省总结"></a>反省总结</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/16/数据库/Redis：分布式锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/16/数据库/Redis：分布式锁/" class="post-title-link" itemprop="url">Redis：分布式锁</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-04-16 23:18:37" itemprop="dateCreated datePublished" datetime="2019-04-16T23:18:37+08:00">2019-04-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-05-10 17:28:43" itemprop="dateModified" datetime="2019-05-10T17:28:43+08:00">2019-05-10</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/04/16/数据库/Redis：分布式锁/" class="post-meta-item leancloud_visitors" data-flag-title="Redis：分布式锁">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/04/16/数据库/Redis：分布式锁/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/16/数据库/Redis：分布式锁/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="Redis分布式锁简单实现"><a href="#Redis分布式锁简单实现" class="headerlink" title="Redis分布式锁简单实现"></a>Redis分布式锁简单实现</h1><p>熟悉Redis的同学那么肯定对setNx(set if not exist)方法不陌生，如果不存在则更新，其可以很好的用来实现我们的分布式锁。对于某个资源加锁我们只需要</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setNx resourceName value</span><br></pre></td></tr></table></figure>

<p>这里有个问题，加锁了之后如果机器宕机那么这个锁就不会得到释放所以会加入过期时间，加入过期时间需要和setNx同一个原子操作，在Redis2.8之前我们需要使用Lua脚本达到我们的目的，但是redis2.8之后redis支持nx和ex操作是同一原子操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> resourceName <span class="keyword">value</span> ex <span class="number">5</span> nx</span><br></pre></td></tr></table></figure>

<h1 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h1><p>Javaer都知道Jedis，Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。Redission也是Redis的客户端，相比于Jedis功能简单。Jedis简单使用阻塞的I/O和redis交互，Redission通过Netty支持非阻塞I/O。Jedis最新版本2.9.0是2016年的快3年了没有更新，而Redission最新版本是2018.10月更新。</p>
<p>Redission封装了锁的实现，其继承了java.util.concurrent.locks.Lock的接口，让我们像操作我们的本地Lock一样去操作Redission的Lock，下面介绍一下其如何实现分布式锁。</p>
<p><img src="assets/16652989862ce5af" alt="img"></p>
<p>Redission不仅提供了Java自带的一些方法(lock,tryLock)，还提供了异步加锁，对于异步编程更加方便。 由于内部源码较多，就不贴源码了，这里用文字叙述来分析他是如何加锁的，这里分析一下tryLock方法:</p>
<ol>
<li><p>尝试加锁:首先会尝试进行加锁，由于保证操作是原子性，那么就只能使用lua脚本，相关的lua脚本如下： </p>
<p><img src="assets/166529eb8139751a" alt="img">可以看见他并没有使用我们的sexNx来进行操作，而是使用的hash结构，我们的每一个需要锁定的资源都可以看做是一个HashMap，锁定资源的节点信息是Key,锁定次数是value。通过这种方式可以很好的实现可重入的效果，只需要对value进行加1操作，就能进行可重入锁。当然这里也可以用之前我们说的本地计数进行优化。</p>
</li>
<li><p>如果尝试加锁失败，判断是否超时，如果超时则返回false。</p>
</li>
<li><p>如果加锁失败之后，没有超时，那么需要在名字为redisson_lock__channel+lockName的channel上进行订阅，用于订阅解锁消息，然后一直阻塞直到超时，或者有解锁消息。</p>
</li>
<li><p>重试步骤1，2，3，直到最后获取到锁，或者某一步获取锁超时。</p>
</li>
</ol>
<p>对于我们的unlock方法比较简单也是通过lua脚本进行解锁，如果是可重入锁，只是减1。如果是非加锁线程解锁，那么解锁失败。 </p>
<p><img src="assets/16652acd8c664482" alt="img"></p>
<p>Redission还有公平锁的实现，对于公平锁其利用了list结构和hashset结构分别用来保存我们排队的节点，和我们节点的过期时间，用这两个数据结构帮助我们实现公平锁，这里就不展开介绍了，有兴趣可以参考源码。</p>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><img src="assets/16730ecd592f41e3" alt="img"></p>
<h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><p>现在某个客户端要加锁。如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。<strong>这里注意</strong>，仅仅只是选择一台机器！这点很关键！紧接着，就会发送一段lua脚本到redis上，那段lua脚本如下所示：</p>
<p><img src="assets/166529eb8139751a" alt="img"></p>
<p>LUA脚本：保证复杂业务逻辑执行的<strong>原子性</strong>。</p>
<ul>
<li><p><strong>KEYS[1]</strong>代表的是你加锁的那个key，比如说：RLock lock = redisson.getLock(“myLock”);这里你自己设置了加锁的那个锁key就是“myLock”。</p>
</li>
<li><p><strong>ARGV[1]</strong>代表的就是锁key的默认生存时间，默认30秒。<strong>ARGV[2]</strong>代表的是加锁的客户端的ID，类似于下面这样：8743c9c0-0795-4907-87fd-6c719a6b4586:1</p>
</li>
<li><p>第一段if判断语句，就是用“<strong>exists myLock</strong>”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。如何加锁呢？很简单，<strong>用下面的命令</strong>：hset myLock 8743c9c0-0795-4907-87fd-6c719a6b4586:1 1，通过这个命令设置一个hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myLock:&#123;</span><br><span class="line">    &quot;8743c9c0-0795-4907-87fd-6c719a6b4586:1&quot; : 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁key完成了加锁。接着会执行“<strong>pexpire myLock 30000</strong>”命令，设置myLock这个锁key的<strong>生存时间是30秒</strong>。好了，到此为止，ok，加锁完成了。</p>
</li>
</ul>
<h3 id="释放锁机制"><a href="#释放锁机制" class="headerlink" title="释放锁机制"></a>释放锁机制</h3><p>如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：<strong>“del myLock”命令</strong>，从redis里删除这个key。然后呢，另外的客户端2就可以尝试完成加锁了。这就是所谓的<strong>分布式锁的开源Redisson框架的实现机制。</strong></p>
<p>一般我们在生产系统中，可以用Redisson框架提供的这个类库来基于redis进行分布式锁的加锁与释放锁。</p>
<h3 id="锁互斥机制"><a href="#锁互斥机制" class="headerlink" title="锁互斥机制"></a>锁互斥机制</h3><p>那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？很简单，第一个if判断会执行“<strong>exists myLock</strong>”，发现myLock这个锁key已经存在了。接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。</p>
<p>所以，客户端2会获取到<strong>pttl myLock</strong>返回的一个数字，这个数字代表了myLock这个锁key的<strong>剩余生存时间。</strong>比如还剩15000毫秒的生存时间。此时客户端2会进入一个while循环，不停的尝试加锁。</p>
<h3 id="watch-dog自动延期机制"><a href="#watch-dog自动延期机制" class="headerlink" title="watch dog自动延期机制"></a>watch dog自动延期机制</h3><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p>
<p>简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，<strong>他是一个后台线程，会每隔10秒检查一下</strong>，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p>
<h3 id="可重入加锁机制"><a href="#可重入加锁机制" class="headerlink" title="可重入加锁机制"></a>可重入加锁机制</h3><p>那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？</p>
<p>这时我们来分析一下上面那段lua脚本。<strong>第一个if判断肯定不成立</strong>，“exists myLock”会显示锁key已经存在了。<strong>第二个if判断会成立</strong>，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“8743c9c0-0795-4907-87fd-6c719a6b4586:1”</p>
<p>此时就会执行可重入加锁的逻辑，他会用：</p>
<p>incrby myLock 8743c9c0-0795-4907-87fd-6c71a6b4586:1 1  ，通过这个命令，对客户端1的加锁次数，累加1。此时myLock数据结构变为下面这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myLock:&#123;</span><br><span class="line">    <span class="string">"8743c9c0-0795-4907-87fd-6c719a6b4586:1"</span> : <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家看到了吧，那个myLock的hash数据结构中的那个客户端ID，就对应着加锁的次数</p>
<h3 id="释放锁机制-1"><a href="#释放锁机制-1" class="headerlink" title="释放锁机制"></a>释放锁机制</h3><p>如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：<strong>“del myLock”命令</strong>，从redis里删除这个key。然后呢，另外的客户端2就可以尝试完成加锁了。这就是所谓的<strong>分布式锁的开源Redisson框架的实现机制。</strong></p>
<p>一般我们在生产系统中，可以用Redisson框架提供的这个类库来基于redis进行分布式锁的加锁与释放锁。</p>
<h3 id="上述Redis分布式锁的缺点"><a href="#上述Redis分布式锁的缺点" class="headerlink" title="上述Redis分布式锁的缺点"></a>上述Redis分布式锁的缺点</h3><p>其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master slave实例。但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。</p>
<p>接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。此时就会导致多个客户端对一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题，<strong>导致各种脏数据的产生</strong>。</p>
<p>所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布式锁的最大缺陷：<strong>在redis master实例宕机的时候，可能导致多个客户端同时完成加锁</strong>。</p>
<h1 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h1><p>我们想象一个这样的场景当机器A申请到一把锁之后，如果Redis主宕机了，这个时候从机并没有同步到这一把锁，那么机器B再次申请的时候就会再次申请到这把锁，为了解决这个问题Redis作者提出了RedLock红锁的算法,在Redission中也对RedLock进行了实现。</p>
<p><img src="assets/16652bd95e11a8b3" alt="img"></p>
<p>通过上面的代码，我们需要实现多个Redis集群，然后进行红锁的加锁，解锁。具体的步骤如下:</p>
<ol>
<li>首先生成多个Redis集群的Rlock，并将其构造成RedLock。</li>
<li>依次循环对三个集群进行加锁，加锁的过程和5.2里面一致。</li>
<li>如果循环加锁的过程中加锁失败，那么需要判断加锁失败的次数是否超出了最大值，这里的最大值是根据集群的个数，比如三个那么只允许失败一个，五个的话只允许失败两个，要保证多数成功。</li>
<li>加锁的过程中需要判断是否加锁超时，有可能我们设置加锁只能用3ms，第一个集群加锁已经消耗了3ms了。那么也算加锁失败。</li>
<li>3，4步里面加锁失败的话，那么就会进行解锁操作，解锁会对所有的集群在请求一次解锁。</li>
</ol>
<p>可以看见RedLock基本原理是利用多个Redis集群，用多数的集群加锁成功，减少Redis某个集群出故障，造成分布式锁出现问题的概率。</p>
<h1 id="Redis小结"><a href="#Redis小结" class="headerlink" title="Redis小结"></a>Redis小结</h1><ul>
<li>优点:对于Redis实现简单，性能对比ZK和Mysql较好。如果不需要特别复杂的要求，那么自己就可以利用setNx进行实现，如果自己需要复杂的需求的话那么可以利用或者借鉴Redission。对于一些要求比较严格的场景来说的话可以使用RedLock。</li>
<li>缺点:需要维护Redis集群，如果要实现RedLock那么需要维护更多的集群。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://juejin.im/post/5bbb0d8df265da0abd3533a5#heading-18" target="_blank" rel="noopener">再有人问你分布式锁，这篇文章扔给他</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/15/Java/框架/分布式：分布式锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/15/Java/框架/分布式：分布式锁/" class="post-title-link" itemprop="url">分布式：分布式锁</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-04-15 23:26:44" itemprop="dateCreated datePublished" datetime="2019-04-15T23:26:44+08:00">2019-04-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-05-10 17:09:50" itemprop="dateModified" datetime="2019-05-10T17:09:50+08:00">2019-05-10</time>
              </span>
            
          

          
            <span id="/2019/04/15/Java/框架/分布式：分布式锁/" class="post-meta-item leancloud_visitors" data-flag-title="分布式：分布式锁">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/04/15/Java/框架/分布式：分布式锁/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/15/Java/框架/分布式：分布式锁/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h2><ul>
<li><p>效率：使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。</p>
</li>
<li><p>正确性：加分布式锁同样可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。</p>
</li>
</ul>
<h2 id="分布式锁的一些特点"><a href="#分布式锁的一些特点" class="headerlink" title="分布式锁的一些特点"></a>分布式锁的一些特点</h2><p>当我们确定了在不同节点上需要分布式锁，那么我们需要了解分布式锁到底应该有哪些特点:</p>
<ul>
<li>互斥性：和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。</li>
<li>可重入性：同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</li>
<li>锁超时：和本地锁一样支持锁超时，防止死锁。</li>
<li>高效，高可用：加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。</li>
<li>支持阻塞和非阻塞：和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。</li>
<li>支持公平锁和非公平锁(可选)：公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。</li>
</ul>
<h2 id="常见分布式锁"><a href="#常见分布式锁" class="headerlink" title="常见分布式锁"></a>常见分布式锁</h2><p>一般实现分布式锁的方式</p>
<ul>
<li>MySQL</li>
<li>ZK</li>
<li>Redis</li>
<li>自研分布式锁，谷歌的Chubby</li>
</ul>
<h1 id="MySQL分布式锁"><a href="#MySQL分布式锁" class="headerlink" title="MySQL分布式锁"></a>MySQL分布式锁</h1><p>InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持对分布式事务的实现。</p>
<ul>
<li>分布式事务：允许多个独立的事务资源参与到一个全局的事务中。</li>
<li>事务资源：通常是关系型数据库系统，页可以是其他类型的资源。</li>
<li>全局事务要求在其中的所有参与的事务要么都提交，要么都回滚。</li>
</ul>
<p>实现分布式事务，InnoDB存储引擎的事务隔离级别必须为Serializable</p>
<p>XA事务允许不同数据库键的分布式事务，如MySQL、oracle数据库，只要参与全局事务中的每个节点都支持XA事务。</p>
<p>XA事务由一个或多个资源管理器、一个事务管理器以及一个应用程序组成。</p>
<ul>
<li>资源管理器：提供访问事务资源的方法，通常一个数据库就是一个资源管理器</li>
<li>事务管理器：协调参与全局事务中的各个事务，需要和参与全局事务的所有资源管理器进行通信</li>
<li>应用程序：定义事务的边界，指定全局事务中的操作。</li>
</ul>
<p><em>分布式事务的实现</em></p>
<ul>
<li>采用两段式提交的方式</li>
<li>第一阶段：所有参与全局事务的节点都开始准备，告诉事务管理器它们准备好提交了</li>
<li>第二阶段：事务管理器告诉资源管理器执行ROLLBACK或COMMIT。</li>
<li>与本地事务不同的是，分布式事务要多一次prepare工作，待收到所有节点的同意信息后，再进行commit或者rollback</li>
</ul>
<h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><p>Java的JTA可以很好的支持MySQL的分布式事务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyXid</span> <span class="keyword">implements</span> <span class="title">Xid</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> formatId;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span> gtrid[];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span> bqual[];</span><br><span class="line">    <span class="comment">//get方法</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XaDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MysqlXADataSource <span class="title">getDataSource</span><span class="params">(String connStr, String user, String pwd)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            MysqlXADataSource ds = <span class="keyword">new</span> MysqlXADataSource();</span><br><span class="line">            ds.setUrl(connStr);</span><br><span class="line">            ds.setUser(user);</span><br><span class="line">            ds.setPassword(pwd);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> ds;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        String connStr1 = <span class="string">"jdbc:mysql://192.168.0.1:3306/test"</span>;</span><br><span class="line">        String connStr2 = <span class="string">"jdbc:mysql://192.168.0.2:3306/test"</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从不同数据库获取数据库数据源</span></span><br><span class="line">            MysqlXADataSource ds1 = getDataSource(connStr1, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">            MysqlXADataSource ds2 = getDataSource(connStr2, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//数据库1获取连接</span></span><br><span class="line">            XAConnection xaConnection1 = ds1.getXAConnection();</span><br><span class="line">            XAResource xaResource1 = xaConnection1.getXAResource();</span><br><span class="line">            Connection connection1 = xaConnection1.getConnection();</span><br><span class="line">            Statement statement1 = connection1.createStatement();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//数据库2获取连接</span></span><br><span class="line">            XAConnection xaConnection2 = ds2.getXAConnection();</span><br><span class="line">            XAResource xaResource2 = xaConnection2.getXAResource();</span><br><span class="line">            Connection connection2 = xaConnection2.getConnection();</span><br><span class="line">            Statement statement2 = connection2.createStatement();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//创建事务分支的xid</span></span><br><span class="line">            Xid xid1 = <span class="keyword">new</span> MysqlXid(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">0x01</span> &#125;, <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">0x02</span> &#125;, <span class="number">100</span>);</span><br><span class="line">            Xid xid2 = <span class="keyword">new</span> MysqlXid(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">0x011</span> &#125;, <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">0x012</span> &#125;, <span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//事务分支1关联分支事务sql语句</span></span><br><span class="line">                xaResource1.start(xid1, XAResource.TMNOFLAGS);</span><br><span class="line">                <span class="keyword">int</span> update1Result = statement1.executeUpdate(<span class="string">"update account_from set money=money - 50 where id=1"</span>);</span><br><span class="line">                xaResource1.end(xid1, XAResource.TMSUCCESS);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">//事务分支2关联分支事务sql语句</span></span><br><span class="line">                xaResource2.start(xid2, XAResource.TMNOFLAGS);</span><br><span class="line">                <span class="keyword">int</span> update2Result = statement2.executeUpdate(<span class="string">"update account_to set money= money + 50 where id=1"</span>);</span><br><span class="line">                xaResource2.end(xid2, XAResource.TMSUCCESS);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 两阶段提交协议第一阶段</span></span><br><span class="line">                <span class="keyword">int</span> ret1 = xaResource1.prepare(xid1);</span><br><span class="line">                <span class="keyword">int</span> ret2 = xaResource2.prepare(xid2);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 两阶段提交协议第二阶段</span></span><br><span class="line">                <span class="keyword">if</span> (XAResource.XA_OK == ret1 &amp;&amp; XAResource.XA_OK == ret2) &#123;</span><br><span class="line">                    xaResource1.commit(xid1, <span class="keyword">false</span>);</span><br><span class="line">                    xaResource2.commit(xid2, <span class="keyword">false</span>);</span><br><span class="line"> </span><br><span class="line">                    System.out.println(<span class="string">"reslut1:"</span> + update1Result + <span class="string">", result2:"</span> + update2Result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部XA事务"><a href="#内部XA事务" class="headerlink" title="内部XA事务"></a>内部XA事务</h3><ul>
<li>之前的分布式事务时外部事务，即资源管理器是MySQL数据库本身</li>
<li>另一种分布式事务在存储引擎与插件间，或者存在于存储引擎与存储引擎间，称为内部XA事务。</li>
</ul>
<p>常见的为binlog与InnoDB存储引擎间。</p>
<h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h1 id="分布式锁的安全问题"><a href="#分布式锁的安全问题" class="headerlink" title="分布式锁的安全问题"></a>分布式锁的安全问题</h1><p>上面我们介绍过红锁，但是Martin Kleppmann认为其依然不安全。有关于Martin反驳的几点，我认为其实不仅仅局限于RedLock,前面说的算法基本都有这个问题，下面我们来讨论一下这些问题:</p>
<ul>
<li><p>长时间的GC pause:熟悉Java的同学肯定对GC不陌生，在GC的时候会发生STW(stop-the-world),例如CMS垃圾回收器，他会有两个阶段进行STW防止引用继续进行变化。那么有可能会出现下面图(引用至Martin反驳Redlock的文章)中这个情况： </p>
<p><img src="assets/16653450d45a2a96" alt="img"></p>
<p> client1获取了锁并且设置了锁的超时时间，但是client1之后出现了STW，这个STW时间比较长，导致分布式锁进行了释放，client2获取到了锁，这个时候client1恢复了锁，那么就会出现client1，2同时获取到锁，这个时候分布式锁不安全问题就出现了。这个其实不仅仅局限于RedLock,对于我们的ZK,Mysql一样的有同样的问题。</p>
</li>
<li><p>时钟发生跳跃:对于Redis服务器如果其时间发生了向跳跃，那么肯定会影响我们锁的过期时间，那么我们的锁过期时间就不是我们预期的了，也会出现client1和client2获取到同一把锁，那么也会出现不安全，这个对于Mysql也会出现。但是ZK由于没有设置过期时间，那么发生跳跃也不会受影响。</p>
</li>
<li><p>长时间的网络I/O:这个问题和我们的GC的STW很像，也就是我们这个获取了锁之后我们进行网络调用，其调用时间由可能比我们锁的过期时间都还长，那么也会出现不安全的问题，这个Mysql也会有，ZK也不会出现这个问题。</p>
</li>
</ul>
<p>对于这三个问题，在网上包括Redis作者在内发起了很多讨论。</p>
<h2 id="GC的STW"><a href="#GC的STW" class="headerlink" title="GC的STW"></a>GC的STW</h2><p>对于这个问题可以看见基本所有的都会出现问题，Martin给出了一个解法，对于ZK这种他会生成一个自增的序列，那么我们真正进行对资源操作的时候，需要判断当前序列是否是最新，有点类似于我们乐观锁。当然这个解法Redis作者进行了反驳，你既然都能生成一个自增的序列了那么你完全不需要加锁了，也就是可以按照类似于Mysql乐观锁的解法去做。</p>
<p>我自己认为这种解法增加了复杂性，当我们对资源操作的时候需要增加判断序列号是否是最新，无论用什么判断方法都会增加复杂度，后面会介绍谷歌的Chubby提出了一个更好的方案。</p>
<h2 id="时钟发生跳跃"><a href="#时钟发生跳跃" class="headerlink" title="时钟发生跳跃"></a>时钟发生跳跃</h2><p>Martin觉得RedLock不安全很大的原因也是因为时钟的跳跃，因为锁过期强依赖于时间，但是ZK不需要依赖时间，依赖每个节点的Session。Redis作者也给出了解答:对于时间跳跃分为人为调整和NTP自动调整。</p>
<ul>
<li>人为调整:人为调整影响的那么完全可以人为不调整，这个是处于可控的。</li>
<li>NTP自动调整:这个可以通过一定的优化，把跳跃时间控制的可控范围内，虽然会跳跃，但是是完全可以接受的。</li>
</ul>
<h2 id="长时间的网络I-O"><a href="#长时间的网络I-O" class="headerlink" title="长时间的网络I/O"></a>长时间的网络I/O</h2><p>这一块不是他们讨论的重点，我自己觉得，对于这个问题的优化可以控制网络调用的超时时间，把所有网络调用的超时时间相加，那么我们锁过期时间其实应该大于这个时间，当然也可以通过优化网络调用比如串行改成并行，异步化等。可以参考我的两个文章: <a href="https://juejin.im/post/5b9861d15188255c581a92a0" target="_blank" rel="noopener">并行化-你的高并发大杀器</a>，<a href="https://juejin.im/post/5b4cd263e51d4519846971e0" target="_blank" rel="noopener">异步化-你的高并发大杀器</a></p>
<h2 id="Chubby的一些优化"><a href="#Chubby的一些优化" class="headerlink" title="Chubby的一些优化"></a>Chubby的一些优化</h2><p>大家搜索ZK的时候，会发现他们都写了ZK是Chubby的开源实现，Chubby内部工作原理和ZK类似。但是Chubby的定位是分布式锁和ZK有点不同。Chubby也是使用上面自增序列的方案用来解决分布式不安全的问题，但是他提供了多种校验方法:</p>
<ul>
<li>CheckSequencer()：调用Chubby的API检查此时这个序列号是否有效。</li>
<li>访问资源服务器检查，判断当前资源服务器最新的序列号和我们的序列号的大小。</li>
<li>lock-delay:为了防止我们校验的逻辑入侵我们的资源服务器，其提供了一种方法当客户端失联的时候，并不会立即释放锁，而是在一定的时间内(默认1min)阻止其他客户端拿去这个锁，那么也就是给予了一定的buffer等待STW恢复，而我们的GC的STW时间如果比1min还长那么你应该检查你的程序，而不是怀疑你的分布式锁了。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://juejin.im/post/5bbb0d8df265da0abd3533a5" target="_blank" rel="noopener">再有人问你分布式锁，这篇文章扔给他</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/OS/计算机操作系统：死锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/14/OS/计算机操作系统：死锁/" class="post-title-link" itemprop="url">计算机操作系统：死锁</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-04-14 20:50:48 / Modificado por: 20:51:43" itemprop="dateCreated datePublished" datetime="2019-04-14T20:50:48+08:00">2019-04-14</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/04/14/OS/计算机操作系统：死锁/" class="post-meta-item leancloud_visitors" data-flag-title="计算机操作系统：死锁">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/04/14/OS/计算机操作系统：死锁/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/14/OS/计算机操作系统：死锁/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>进程间由于共享资源所导致的一种无限期等待的情况</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>由于竞争资源或者通信关系，两个或者更多线程在执行中出现，永远相互等待只能由其他进程引发的事件</p>
<p><strong>进程访问资源的流程</strong></p>
<ul>
<li>资源类型 <ul>
<li>CPU执行时间、内存空间、IO设备等</li>
</ul>
</li>
<li>每类资源R有W个实例</li>
<li>进程访问资源的流程<ul>
<li>请求/获取</li>
<li>使用/占用</li>
<li>释放</li>
</ul>
</li>
</ul>
<p><strong>资源分类</strong></p>
<ul>
<li>可重用资源<ul>
<li>资源不能被删除，且任何时刻只能有一个进程使用</li>
<li>进程释放资源后，其他进程可重用</li>
<li>可重用资源示例<ul>
<li>硬件：处理器、IO、主和副存储器、设备等</li>
<li>软件：文件、数据库、信号量等数据结构</li>
</ul>
</li>
<li>可能出现死锁<ul>
<li>一个进程占用一部分资源并请求其他资源</li>
</ul>
</li>
</ul>
</li>
<li>消耗资源<ul>
<li>资源创建和销毁</li>
<li>销毁资源示例：<ul>
<li>在IO缓冲区的中断、信号、消息等</li>
</ul>
</li>
<li>可能出现死锁<ul>
<li>进程间相互等待接收对方的消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>资源分配图</strong></p>
<p>描述资源和进程间的分配和占用关系的有向图</p>
<ul>
<li>两类定点<ul>
<li>系统中的所有进程P</li>
<li>系统中的所有资源R</li>
</ul>
</li>
<li>两类有向边<ul>
<li>资源请求边P-&gt;R</li>
<li>资源分配边R-&gt;P</li>
</ul>
</li>
</ul>
<p>存在死锁的分配图：</p>
<p><img src="assets/1551948669788.png" alt="1551948669788"></p>
<p><strong>出现死锁的必要条件</strong></p>
<ul>
<li>互斥：任何时刻只能有一个进程使用一个资源实例</li>
<li>持有并等待：进程保持至少一个资源，并正在等待获取其他进程持有的资源</li>
<li>非抢占：资源只能再进程使用后自愿释放</li>
<li>循环等待：存在等待进程集合，形成循环</li>
</ul>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>类似于消防系统</p>
<ul>
<li>死锁预防<ul>
<li>确保系统永远不会进入死锁状态</li>
<li>资源利用效率可能较低</li>
</ul>
</li>
<li>死锁避免<ul>
<li>使用前进行判断，只允许不会出现死锁的进程请求资源</li>
</ul>
</li>
<li>死锁检测和恢复<ul>
<li>在检测到运行系统进入死锁状态后，进行恢复</li>
</ul>
</li>
<li>由应用进程处理死锁<ul>
<li>通常操作系统忽略死锁的存在</li>
</ul>
</li>
</ul>
<p><strong>死锁预防</strong></p>
<p>预防是采用某种策略，限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的必要条件</p>
<ul>
<li>互斥：把互斥的共享资源封装成可同时访问</li>
<li>持有并等待：<ul>
<li>进程请求资源时，要求它不能持有任何其他资源</li>
<li>仅允许进程在开始执行时，一次请求所有需要的资源</li>
<li>资源利用率低</li>
</ul>
</li>
<li>非抢占：<ul>
<li>如进程请求不能立即分配的资源，则释放已占有资源</li>
<li>只有能同时获得所有需要资源时，才执行分配操作</li>
</ul>
</li>
<li>循环等待：对资源排序，要求进程按顺序请求资源</li>
</ul>
<p><strong>死锁避免</strong></p>
<ul>
<li>利用额外的先验信息，在分配资源时判断是否会出现死锁，只在不会死锁时分配资源<ul>
<li>要求进程声明需要的资源的最大数目</li>
<li>限定提供与分配的资源数量，确保满足进程的最大需求</li>
<li>动态检查资源分配状态，确保不会出现环路等待<ul>
<li>系统资源分配的安全状态</li>
<li>进行执行的安全序列</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>一种死锁避免的方法，以银行借贷分配策略为基础，判断并保证系统处于安全状态</p>
<p>问题模型：</p>
<p><img src="assets/1551949424265.png" alt="1551949424265"></p>
<p>数据结构</p>
<p><img src="assets/1551949511055.png" alt="1551949511055"></p>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><ul>
<li>允许系统进入死锁状态</li>
<li>维护系统的资源分配图</li>
<li>定期调用死锁检测算法来搜索图红是非存在死锁</li>
<li>出现死锁使用死锁恢复机制</li>
</ul>
<p><img src="assets/1551949623989.png" alt="1551949623989"></p>
<p>死锁检测算法的使用</p>
<ul>
<li>检测的时间和周期选择依据<ul>
<li>死锁多久可能会发生</li>
<li>多少进程需要被回滚</li>
</ul>
</li>
<li>资源图可能有多个循环<ul>
<li>难于分辨造成死锁的关键进程</li>
</ul>
</li>
</ul>
<h2 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h2><p>进程终止</p>
<ul>
<li>终止所有的死锁进程</li>
<li>一次只终止一个进程直到死锁消除</li>
<li>终止进程的顺序应该是<ul>
<li>进程的优先级</li>
<li>进程已运行时间以及还需运行时间</li>
<li>进程已占有资源</li>
<li>进程完成需要的资源</li>
<li>终止进程数目</li>
<li>进程是交互还是批处理</li>
</ul>
</li>
</ul>
<p>资源抢占</p>
<ul>
<li>选择被抢占进程<ul>
<li>最小成本目标</li>
</ul>
</li>
<li>进程回退<ul>
<li>返回到一些安全状态，重启进程到安全状态</li>
</ul>
</li>
<li>可能出现饥饿<ul>
<li>同一进程可能一直被抢占</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/11/Java/base/Java并发：线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/11/Java/base/Java并发：线程池/" class="post-title-link" itemprop="url">Java并发：线程池</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-04-11 21:51:00" itemprop="dateCreated datePublished" datetime="2019-04-11T21:51:00+08:00">2019-04-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-05-13 14:18:59" itemprop="dateModified" datetime="2019-05-13T14:18:59+08:00">2019-05-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/04/11/Java/base/Java并发：线程池/" class="post-meta-item leancloud_visitors" data-flag-title="Java并发：线程池">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/04/11/Java/base/Java并发：线程池/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Java/base/Java并发：线程池/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="为什么要用"><a href="#为什么要用" class="headerlink" title="为什么要用"></a>为什么要用</h2><p>new Thread弊端</p>
<ul>
<li>每次新建对象，性能差</li>
<li>线程缺乏统一管理，可能无限新建线程，相互竞争，有可能占用过多系统资源导致死机或OOM</li>
<li>缺少更多功能，如更多执行、定期执行、线程中断</li>
</ul>
<p>线程池好处</p>
<ul>
<li>重用存在的线程，减少对象创建、消亡的开销</li>
<li>可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞</li>
<li>提供定时执行、定期执行、单线程、并发控制等功能</li>
</ul>
<h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>线程池是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销</p>
<p>线程池包括四个<strong>基本组成部分</strong></p>
<ul>
<li>线程管理器：用于创建并管理线程池，包括创建线程、销毁线程池、添加新任务</li>
<li>工作线程：线程池中线程，在没有任务时处于等待状态，可以循环地执行任务</li>
<li>任务接口：每个任务必须实现的接口，以供工作线程调度任务的执行，主要规定了任务的入口，任务执行完成的收尾工作，任务的执行状态等。</li>
<li>任务队列：用于存放没有处理的任务，提供一种缓冲机制。</li>
</ul>
<h3 id="Executor框架接口"><a href="#Executor框架接口" class="headerlink" title="Executor框架接口"></a>Executor框架接口</h3><ul>
<li>Executors.newCachedThreadPool<ul>
<li>可以缓存的线程池</li>
<li>如果线程超出处理需要，则回收空闲线程</li>
</ul>
</li>
<li>Executors.newFixedThreadPool<ul>
<li>创建定长线程池</li>
</ul>
</li>
<li>Executors.newScheduledThreadPool<ul>
<li>创建定长线程池，支持定时与周期任务执行</li>
</ul>
</li>
<li>Executors.newSingleThreadExecutor<ul>
<li>单线程化，按照每种规则执行</li>
</ul>
</li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>线程池ThreadPoolExcutor</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>corePoolSize：核心线程数量</li>
<li>maxmumPoolSize：线程最大线程数<ul>
<li>当核心线程都在工作，且阻塞队列满，且线程数目小于最大线程数，则创建新线程</li>
<li>如果线程数目等于最大线程数，通过拒绝策略来处理新到来的任务</li>
</ul>
</li>
<li>workQueue：阻塞队列，存储等待执行的任务<ul>
<li>直接切换</li>
<li>无界队列，基于链表，创建的最大线程即核心线程数目</li>
<li>有界队列，创建的最大线程数目为最大线程数</li>
</ul>
</li>
<li>keepAliveTime：线程没有任务执行时最多保持多久时间终止</li>
<li>unit：时间单位</li>
<li>threadFactory：线程工厂，创建线程</li>
<li>rejectHandler：拒绝处理任务时的策略<ul>
<li>直接抛出异常，默认</li>
<li>用调用者所在的线程执行任务</li>
<li>丢弃队列中最靠前的任务</li>
<li>直接丢弃这个任务</li>
</ul>
</li>
</ul>
<p>降低系统资源消耗：较大队列容量，较小线程池容量</p>
<p>线程数目增加，则CPU利用率会提高，如果线程数目过大，则并发量过大，线程调度存在消耗</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>execute<ul>
<li>提交任务，交给线程池执行</li>
</ul>
</li>
<li>submit<ul>
<li>提交任务，能够返回执行结果</li>
</ul>
</li>
<li>shutdown<ul>
<li>关闭线程池，等待任务都执行完</li>
</ul>
</li>
<li>shutdownNow<ul>
<li>关闭线程池，不等待任务执行完</li>
</ul>
</li>
<li>getTaskCount<ul>
<li>线程池已执行和未执行的任务总数</li>
</ul>
</li>
<li>getCompletedTaskCount<ul>
<li>已完成的任务数</li>
</ul>
</li>
<li>getPoolSize<ul>
<li>线程池当前的线程数量</li>
</ul>
</li>
<li>getActiveCount<ul>
<li>当前线程池当中正在执行任务的线程数量</li>
</ul>
</li>
</ul>
<h2 id="线程池实例的状态"><a href="#线程池实例的状态" class="headerlink" title="线程池实例的状态"></a>线程池实例的状态</h2><ul>
<li>running<ul>
<li>能接受新提交的任务，并能处理阻塞队列的任务</li>
</ul>
</li>
<li>shutdown<ul>
<li>关闭状态，不能接受新提交的任务，但能处理阻塞队列的任务</li>
</ul>
</li>
<li>stop<ul>
<li>不能接受新提交的任务，也不能处理阻塞队列的任务</li>
<li>会中断正在处理任务的线程</li>
</ul>
</li>
<li>tidying<ul>
<li>如果所有任务都已经中止</li>
</ul>
</li>
<li>terminated</li>
</ul>
<p><img src="assets/1551616609267.png" alt="1551616609267"></p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><ul>
<li>CPU密集型任务，需要尽量压榨CPU，参考值设置为NCPU（CPU数量）+1</li>
<li>IO密集型任务，参照值设置为2*NCPU</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/11/Java/base/Java并发：目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/11/Java/base/Java并发：目录/" class="post-title-link" itemprop="url">Java并发：目录</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-04-11 21:50:42" itemprop="dateCreated datePublished" datetime="2019-04-11T21:50:42+08:00">2019-04-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-31 15:32:24" itemprop="dateModified" datetime="2019-07-31T15:32:24+08:00">2019-07-31</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/04/11/Java/base/Java并发：目录/" class="post-meta-item leancloud_visitors" data-flag-title="Java并发：目录">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/04/11/Java/base/Java并发：目录/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Java/base/Java并发：目录/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          Java并发编程的知识目录
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/04/11/Java/base/Java并发：目录/">
                Leer más &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/11/Java/base/Java并发：JMM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/11/Java/base/Java并发：JMM/" class="post-title-link" itemprop="url">Java并发：JMM</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-04-11 21:50:21" itemprop="dateCreated datePublished" datetime="2019-04-11T21:50:21+08:00">2019-04-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-31 15:16:16" itemprop="dateModified" datetime="2019-07-31T15:16:16+08:00">2019-07-31</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/04/11/Java/base/Java并发：JMM/" class="post-meta-item leancloud_visitors" data-flag-title="Java并发：JMM">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/04/11/Java/base/Java并发：JMM/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Java/base/Java并发：JMM/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="JMM基础"><a href="#JMM基础" class="headerlink" title="JMM基础"></a>JMM基础</h1><p>内存模型：在特定的操作协议(应该时指缓存一致性协议把)下，对特定内存或高速缓存进行读写访问地过程抽象</p>
<p>Java内存模型(<strong>JMM</strong>)试图屏蔽各种硬件和OS间的内存访问差异，以实现Java程序在各种平台下都能达到一致的内存访问效果。</p>
<p>Java内存模型是围绕着在并发过程中如何处理<strong>原子性</strong>、<strong>可见性</strong>和<strong>有序性</strong>而建立的</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>JMM规范了java虚拟机与计算机内存如何协同工作，规定了一个线程如何和何时能看到其他线程修改过的共享变量的值，以及在必须时如何同步地访问共享变量</p>
<p>在JMM中，<strong>堆区域</strong>是线程间会共享的数据(<strong>实例字段、静态字段、构成数组对象的元素等</strong>)，Java内存模型的主要目标时定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p>
<p>并且为了获得较好的执行性能，JMM<strong>没有限制执行引擎使用CPU的特定寄存器或缓存</strong>来和主内存进行交互，也<strong>没有限制即时编译器进行调整代码执行顺序</strong>这类优化措施</p>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>JMM当中，所有变量都必须存储在主内存当中，每条线程还有自己的工作内存，线程中的工作内存保存了被该线程使用到的变量的<strong>主内存副本拷贝</strong>。当线程中对对象的引用，引用了在堆上的对象，调用了对象的方法，访问了对象的数据，这个时候他们拥有的是对象成员变量的私有拷贝。</p>
<p>而线程对变量的所有修改都必须在工作内存中进行，不能直接读写主内存中的变量，不同的线程间也无法直接访问对方工作内存中的变量，即线程间的变量值传递均需要通过主内存来完成。</p>
<p><strong><em>Java内存区域的堆栈</em></strong></p>
<p>工作内存、主内存与Java堆栈不是一个层次的<strong>内存划分</strong>，即它们没有直接关联。</p>
<p>若非要对应的话，则主内存主要对应与Java堆内的对象实例数据部分，而工作内存主要对应虚拟机栈内的部分区域。</p>
<p><img src="assets/1551253396237.png" alt="1551253396237"></p>
<p><strong>CPU寄存器</strong>CPU registers，访问缓存的速度最快，其次是高速缓存。它们都属于<strong>线程的本地内存</strong></p>
<p><img src="assets/1551253669203.png" alt="1551253669203"></p>
<p><img src="assets/1551253796357.png" alt="1551253796357"></p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节。</p>
<p>Java内存模型定义了8种操作，并且虚拟机实现时必须保证每一种操作都是原子的，不可再分的(long和double的load、store、read、write在某些平台上允许例外)</p>
<ul>
<li>lock锁定：作用于主内存的变量，把一个变量标识为一条线程独占状态</li>
<li>unlock解锁：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li>read读取：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后load动作使用</li>
<li>load载入：作用于工作内存的变量，把read操作从主内存得到的变量值放入工作内存的<strong>变量副本</strong>中</li>
<li>use使用：作用于工作内存的变量，把工作内存的一个变量值传递给<strong>执行引擎</strong>（线程）</li>
<li>assign赋值：作用于工作内存的变量，把一个从执行引擎接收到的值赋值给工作内存的变量</li>
<li>store存储：作用于工作内存的变量，把工作内存的一个变量的值传递到主内存中，以便随后的write操作</li>
<li>write写入：作用于主内存的变量，把store操作从工作内存中一个变量的值传送到主内存的变量中</li>
</ul>
<p><img src="D:/ABlog/source/_posts/Java/base/assets/1551254279492.png" alt="1551254279492"></p>
<p>而具体操作间的顺序是有一定的规则的，较为简单的即happens-before原则判断</p>
<p><strong><em>同步规则</em></strong></p>
<ul>
<li>不允许read、load与store、write操作单一出现，但是不必连续执行，中间可以插入其他指令</li>
<li>不允许一个线程丢弃掉它最近的assign操作，必须将变化同步给主内存</li>
<li>不允许一个线程无原因地（没有assign操作）将数据同步给主内存。</li>
<li>一个新的变量只能从主内存中诞生，不允许在工作内存直接使用一个未初始化（load或assign）的变量，即在use与store前，必须先assign</li>
<li>一个变量在同一时刻只允许一个线程进行lock，lock可以被同一线程执行多次。</li>
<li>如果一个变量执行了lock操作，将清空工作内存中次变量的值，在执行引擎使用这个变量前需要重新load或assign操作初始化变量</li>
<li>如果一个变量没有lock，则不允许unlock操作，也不能unlock其他线程lock的变量</li>
<li>对变量unlock前，必须先将变量同步到主内存</li>
</ul>
<p><strong><em>long和double型变量的特殊规则</em></strong></p>
<p>对于64位数据类型，允许虚拟机将没有被volatile修饰的64位数据的读写操作划分位两次32位的操作来进行，允许虚拟机实现选择可以不保证64位数据类型的load、store、read、write这4个操作的原子性。即long和double的<strong>非原子性协定</strong></p>
<p>如果多个线程共享一个未声明为volatile的long或double类型的变量并且同时进行读取和修改，那么线程可能读到一个既非原值也非其他线程修改值的代表了半个变量的数值（<strong>商用JVM不会出现</strong>，因为虚拟机选择将其实现了原子操作）。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>JDK5开始，Java使用新的JSR-133内存模型，JSR-133使用happens-before的概念来阐述操作之间的内存可见性</p>
<p>如果两个操作的执行次序无法从happens before推导出来，<strong>则JVM可以对它进行随意的重排序。</strong></p>
<p><strong>概述</strong></p>
<p>在JMM中，<strong>如果一个操作执行的结果需要对另一个操作可见</strong>，那么这两个操作之间<strong>必须要存在</strong>happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p>
<p><img src="D:/ABlog/source/_posts/Java/base/assets/1555058673645.png" alt="1555058673645"></p>
<p><strong>happens-before规则</strong></p>
<ul>
<li><strong>程序次序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<ul>
<li>虽然由于指令重排序，即使先行发生也可能再时间上后发生，但是在一个线程中无法感知到这一点，因此并没有关系</li>
<li>衡量并发安全问题时不要受到时间顺序的干扰，一切以先行发生原则为准。</li>
</ul>
</li>
</ul>
<p><img src="assets/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" alt="img"></p>
<ul>
<li><strong>锁定操作</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作</li>
</ul>
<p><img src="assets/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" alt="img"></p>
<ul>
<li><strong>volatile变量规则</strong>：对一个变量的写操作先行发生于后面对于这个变量的读操作</li>
</ul>
<p><img src="assets/942f33c9-8ad9-4987-836f-007de4c21de0.png" alt="img"></p>
<ul>
<li><strong>传递规则</strong>；如果操作A先行发生于操作B，而操作B又先行发生于操作C，则操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start（）方法先行发生于此线程的每一个动作</li>
</ul>
<p><img src="assets/6270c216-7ec0-4db7-94de-0003bce37cd2.png" alt="img"></p>
<ul>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测</li>
</ul>
<p><img src="assets/233f8d89-31d7-413f-9c02-042f19c46ba1.png" alt="img"></p>
<ul>
<li>对象终结规则：一个对象的初始化完成先行发生于它的finalize（）方法的开始</li>
</ul>
<p><strong>优点</strong></p>
<p>happens-before规则避免Java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法</p>
<h3 id="JMM的抽象结构"><a href="#JMM的抽象结构" class="headerlink" title="JMM的抽象结构"></a>JMM的抽象结构</h3><ul>
<li>Java中，所有实例域、静态域和数组元素都存放在堆内存中，堆内存在线程间共享。即共享变量</li>
<li>局部变量和异常处理器参数不会在线程间共享，不会有内存可见性问题，不受内存模型影响。</li>
</ul>
<p>Java线程间通信由JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。JMM定义了线程和主内存间的抽象关系。</p>
<p>JMM通过控制主内存与每个线程的本地内存间的交互，为程序员提供内存可见性保证。</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="从源代码到指令序列的重排序"><a href="#从源代码到指令序列的重排序" class="headerlink" title="从源代码到指令序列的重排序"></a>从源代码到指令序列的重排序</h3><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p>
<ul>
<li>编译器重排序：编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>处理器重排序：<ul>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
</li>
</ul>
<p>对于Java源代码到最终执行的指令序列，会经历三种重排序，可能导致内存可见性问题：</p>
<p><img src="D:/ABlog/source/_posts/Java/base/assets/1555057714237.png" alt="1555057714237"></p>
<p>JMM属于语言级别的内存模型，确保在不同的编译器和处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，保证一致性的内存可见性。</p>
<ul>
<li>对于编译器，JMM的编译器重排序规则会禁止<strong>特定类型</strong>的编译器重排序</li>
<li>对于处理器重排序。JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，禁止特定类型的处理器重排序</li>
</ul>
<h2 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h2><p>现代处理器的写缓冲区：</p>
<ul>
<li>临时保存向内存写入的数据。</li>
<li>优点：保证指令流水线的持续运行，避免由于处理器停顿下来等待向内存写入数据而产生的延迟。以批处理方式刷新写缓冲区，合并对同一内存地址的多次写，减少对内存总线的占用</li>
<li>缺点：写缓冲区只对其所在处理器可见。对内存操作的执行顺序产生重要影响。导致处理器对内存的读、写操作的执行顺序，不一定与内存实际发生的读、写顺序一致</li>
</ul>
<p>示例：在并行执行下</p>
<p><img src="assets/1555058346281.png" alt="1555058346281"></p>
<p>现代处理器都会允许对写-读操作重排序</p>
<p><img src="assets/1555058415256.png" alt="1555058415256"></p>
<h3 id="内存屏障指令"><a href="#内存屏障指令" class="headerlink" title="内存屏障指令"></a>内存屏障指令</h3><p>对于只有一个CPU访问内存时，并不需要内存屏障。但是如果有两个或更多个CPU访问同一块内存，并且其中有一个正在观测另一个，就需要内存屏障保证一致性。</p>
<p>为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序</p>
<p><img src="assets/1555058476394.png" alt="1555058476394"></p>
<ul>
<li>StoreLoad Barriers<ul>
<li>全能型屏障，具有其他3个屏障的效果。现代处理器大多数支持该屏障</li>
<li>开销很高，要把写缓冲区的数据全部刷新到内存中</li>
</ul>
</li>
</ul>
<h2 id="三个特性"><a href="#三个特性" class="headerlink" title="三个特性"></a>三个特性</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><strong>数据类型级别</strong>：Java内存模型直接保证的原子性变量操作包括read、load、assign、use、store、write。大致可以认为基本数据类型的访问读写时具备原子性的。</p>
<p><strong>synchronized</strong>：若应用场景需要一个更大范围的原子性保证，则提供了lock和unlock来满足这种需求，虽然虚拟机未将lock、unlock操作开放给用户使用，但提供了更高层次的<strong>字节码指令</strong><code>monitorenter</code>和<code>monitorexit</code>来隐式使用这两个操作，而反映到Java代码中即<code>synchronized</code>，即<code>synchronized</code>块间操作具备原子性</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</p>
<p>JMM是提供在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式实现可见性的。</p>
<ul>
<li>volatile的特殊规则保证了新值能够立即同步到主内存，并且每次使用前立即从主内存刷新</li>
<li>synchronized是由“对一个变量执行unlock操作前，必须先把此变量同步回主内存中”这条规则获得的</li>
<li>final字段在构造器中一旦初始化完成，并且构造器没有将this引用传递出去(this引用逃逸可能让其他线程访问到初始化了一半的对象)，那再其他线程中就能看到final字段的值。</li>
</ul>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p><strong>线程内表现为串行的语义</strong>：如果在本线程内观察，所有的操作都是有序的。</p>
<p><strong>指令重排序与工作内存与主内存同步延迟</strong>：如果在一个线程中观察另一个线程，所有操作都是无序的。</p>
<p>Java提供volatile与synchronized保证线程间操作的有序性</p>
<ul>
<li>volatile本身禁止指令重排序的语义</li>
<li>synchronized是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的。这决定了持有同一个锁的两个同步块只能串行进入。</li>
</ul>
<h1 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h1><p>顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照。</p>
<h2 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h2><p>当程序未正确同步时，就可能存在数据竞争。</p>
<p>数据竞争：在一个线程中写一个变量，在另一个线程中读一个编程，而且写和读没有通过同步来排序。</p>
<p><strong>JMM对正确同步的多线程程序的内存一致性做了如下保证</strong></p>
<p>如果程序是正确同步的，程序的执行将具有顺序一致性（Sequentially Consistent）——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。</p>
<h2 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h2><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性。</p>
<ul>
<li>一个线程中的所有操作必须按照程序的顺序来执行</li>
<li>不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见</li>
</ul>
<p>而在JMM当中<strong>是没有这个保证的</strong></p>
<ul>
<li>未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。<ul>
<li>比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；</li>
<li>从其他线程的角度来观察，会认为这个写操作根本没有被当前线程执行。</li>
<li>只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其他线程看到的操作执行顺序将不一致。</li>
</ul>
</li>
</ul>
<h2 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h2><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        	<span class="keyword">int</span> i = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据JMM规范，该程序的执行结果将与程序在顺序一致性模型中的执行结果相同。</p>
<ul>
<li>JMM中，临界区内的代码可以重排序（但是临界区的代码不能逸出到临界区外，那样会破坏监视器的语义），JMM会在退出、进入临界区这两个时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图</li>
<li>虽然线程A在临界区做了重排序，但由于监视器互斥执行的特性。线程B无法观察到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</li>
</ul>
<h2 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h2><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null，False），JMM保证线程读操作读取到的值不会无中生有（Out Of Thin Air）的冒出来。为了实现最小安全性，JVM在堆上分配对象时，首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部会同步这两个操作）。因此，在已清零的内存空间（Pre-zeroed Memory）分配对象时，域的默认初始化已经完成了。</p>
<h1 id="final域的内存语义"><a href="#final域的内存语义" class="headerlink" title="final域的内存语义"></a>final域的内存语义</h1><h1 id="happens-before-1"><a href="#happens-before-1" class="headerlink" title="happens-before"></a>happens-before</h1><h1 id="双重检查锁定与延迟初始化"><a href="#双重检查锁定与延迟初始化" class="headerlink" title="双重检查锁定与延迟初始化"></a>双重检查锁定与延迟初始化</h1><h1 id="JMM综述"><a href="#JMM综述" class="headerlink" title="JMM综述"></a>JMM综述</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/11/系统架构/架构：大型网站架构演化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/11/系统架构/架构：大型网站架构演化/" class="post-title-link" itemprop="url">架构：大型网站架构演化</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-04-11 20:23:19" itemprop="dateCreated datePublished" datetime="2019-04-11T20:23:19+08:00">2019-04-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-22 12:22:15" itemprop="dateModified" datetime="2019-07-22T12:22:15+08:00">2019-07-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/04/11/系统架构/架构：大型网站架构演化/" class="post-meta-item leancloud_visitors" data-flag-title="架构：大型网站架构演化">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/04/11/系统架构/架构：大型网站架构演化/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/系统架构/架构：大型网站架构演化/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>如何打造一个高性能、高可用、易扩展、可伸缩且安全的网站。</p>
<p>如何让网站随应用所需灵活变动</p>
<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p>
<p><img src="assets/1561193987325.png" alt="1561193987325"></p>
<h3 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a>单一应用架构</h3><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<p>当用户访问量提高时</p>
<h3 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h3><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<h3 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h3><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<h3 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h3><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h1 id="大型网站软件系统的特点"><a href="#大型网站软件系统的特点" class="headerlink" title="大型网站软件系统的特点"></a>大型网站软件系统的特点</h1><p>与传统企业应用系统相比</p>
<ul>
<li>高并发、大流量<ul>
<li>需要面对高并发用户，大流量访问</li>
</ul>
</li>
<li>高可用<ul>
<li>系统7*24小时不间断服务，大型网站的宕机事件会成为新闻焦点</li>
</ul>
</li>
<li>海量数据<ul>
<li>需要存储、管理海量数据，需要使用大量服务器</li>
</ul>
</li>
<li>用户分布广泛，网络情况复杂<ul>
<li>需要为全球用户提供服务，各地网络情况千差万别</li>
<li>国内，各个运营商网络互通难的问题</li>
<li>中美光缆的数次故障，需要一些对国外用户依赖大的网站考虑建立海外数据中心</li>
</ul>
</li>
<li>安全环境恶劣<ul>
<li>互联网的开放型，容易受到攻击</li>
</ul>
</li>
<li>需求快速变更，发布频繁</li>
<li>渐进式发展<ul>
<li>从一个小网站渐进的发展过来</li>
</ul>
</li>
</ul>
<h1 id="大型网站架构演化发展历程"><a href="#大型网站架构演化发展历程" class="headerlink" title="大型网站架构演化发展历程"></a>大型网站架构演化发展历程</h1><p>任何简单的业务一旦需要处理数以P计的数据和面对数以亿计的用户，问题就会很棘手。大型网站架构主要解决这类问题</p>
<h2 id="初始阶段的网站架构"><a href="#初始阶段的网站架构" class="headerlink" title="初始阶段的网站架构"></a>初始阶段的网站架构</h2><ul>
<li>一台服务器即可</li>
<li>应用程序、数据库、文件等所有资源都在一台服务器上。</li>
</ul>
<p><img src="assets/1554990959181.png" alt="1554990959181"></p>
<h2 id="应用服务与数据服务分离"><a href="#应用服务与数据服务分离" class="headerlink" title="应用服务与数据服务分离"></a>应用服务与数据服务分离</h2><p><strong>问题</strong></p>
<ul>
<li>一台服务逐渐不能满足需求，越来越多的用户导致性能越来越差，越来越多的数据导致存储空间不足</li>
</ul>
<p><strong>解决方案</strong>：将数据和应用分离</p>
<p>三台服务器：</p>
<ul>
<li>应用服务器：需要处理大量业务逻辑，需要更强CPU</li>
<li>数据库服务器：快速磁盘检索和数据缓存，因此需要更快的磁盘和更大的内存</li>
<li>文件服务器：存储大量用户上传的文件，需要更大的硬盘</li>
</ul>
<p><img src="assets/1563719826873.png" alt="1563719826873"></p>
<p>不同的服务器承担不同的服务角色，网站的并发处理能力、数据存储空间得到很大改善</p>
<h2 id="使用缓存改善网站性能"><a href="#使用缓存改善网站性能" class="headerlink" title="使用缓存改善网站性能"></a>使用缓存改善网站性能</h2><p><strong>问题</strong></p>
<ul>
<li>数据库压力太大导致访问延迟，进而影响整个系统的性能</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>网站的访问特点</strong>：二八定律，80%的业务访问集中在20%的数据上</li>
<li>将频繁访问的数据缓存在内存当中</li>
</ul>
<p>缓存分类：</p>
<ul>
<li>本地缓存，缓存在应用服务器上<ul>
<li>速度更快</li>
<li>受内存限制，并与应用程序争夺内存</li>
</ul>
</li>
<li>远程缓存，缓存在专门的分布式缓存服务器上<ul>
<li>理论上不受内存限制</li>
</ul>
</li>
</ul>
<p><img src="assets/1554991453473.png" alt="1554991453473"></p>
<h2 id="使用应用服务器集群改善网站的并发处理能力"><a href="#使用应用服务器集群改善网站的并发处理能力" class="headerlink" title="使用应用服务器集群改善网站的并发处理能力"></a>使用应用服务器集群改善网站的并发处理能力</h2><p><strong>问题</strong></p>
<ul>
<li>单一应用服务器能够处理的请求连接有限，在网站访问高峰期，应用服务器成为瓶颈</li>
</ul>
<p><strong>解决方案：</strong></p>
<p>增加服务器分担压力，并可以以此方式不断提升系统性能。实现系统的可伸缩性。</p>
<p><img src="assets/1555049101516.png" alt="1555049101516"></p>
<p><strong>负载均衡调度服务器</strong>：将来自用户的访问请求分发到应用服务器集群的任何一台服务器中，若有更多的用户，则在集群中增加更多的服务器，使应用服务器的负载压力不再成为整个网站的瓶颈</p>
<h2 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h2><p><strong>问题</strong>：</p>
<ul>
<li>数据库负载压力过高<ul>
<li>即使使用缓存后，绝大部分数据访问都可以不通过数据库就能完成</li>
<li>但依然有一部分读操作（缓存访问不命中、缓存过期）和全部的写操作需要访问数据库。会导致数据库负载压力过高</li>
</ul>
</li>
</ul>
<p><strong>解决方案</strong>：</p>
<p>配置数据库的主从关系，将一台数据库服务器上的数据更新同步到另一台服务器上，实现读写分离。</p>
<p>应用服务器在写数据时，访问主数据库，主数据库通过主从复制将数据更新同步到从数据库，当应用服务器读数据时，就可以通过从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常使用专门的数据访问模块，使数据库读写分离对应用透明</p>
<p><img src="assets/1555049383697.png" alt="1555049383697"></p>
<h2 id="使用反向代理和CDN加速网站响应"><a href="#使用反向代理和CDN加速网站响应" class="headerlink" title="使用反向代理和CDN加速网站响应"></a>使用反向代理和CDN加速网站响应</h2><p><strong>问题：</strong></p>
<ul>
<li>复杂的网络环境，导致不同地区的用户访问网站速度差别极大</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>加快网络响应速度，提高用户体验</li>
<li>反向代理与CDN加速<ul>
<li>原理为：利用缓存</li>
<li>CDN：部署在网络提供商的机房，使得用户在请求网站服务时，可以从距离自己最近的网络提供方机房获得数据</li>
<li>反向代理：部署在网站的中心机房，当用户请求到达中心时，首先访问反向代理服务器，如果反向代理服务器缓存着用户请求的数据，就直接返回给用户</li>
</ul>
</li>
<li>通过缓存数据，也减轻了后端服务器的负载压力</li>
</ul>
<p><img src="assets/1555049588729.png" alt="1555049588729"></p>
<h2 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h2><p><strong>问题：</strong></p>
<ul>
<li>任何强大的单一服务器都无法满足持续增长的业务需求</li>
<li>数据库服务器与文件服务器无法支持</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>分布式数据库与分布式文件<ul>
<li>分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大时才使用</li>
<li>常见手段为业务分库，不同业务的数据库部署在不同服务器上</li>
</ul>
</li>
</ul>
<p><img src="assets/1555049722498.png" alt="1555049722498"></p>
<h2 id="使用NoSQL和搜索引擎"><a href="#使用NoSQL和搜索引擎" class="headerlink" title="使用NoSQL和搜索引擎"></a>使用NoSQL和搜索引擎</h2><p><strong>问题：</strong></p>
<ul>
<li>网站业务复杂，对数据存储和检索的需求越来越复杂，需要采用一些非关系数据库（NoSQL）以及非数据库查询技术（搜索）</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>NoSQL与搜索引擎都是源自互联网的技术手段，对于可伸缩的分布式特性有更好地支持</li>
<li>应用服务器通过一个统一的数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦</li>
</ul>
<p><img src="assets/1555049803999.png" alt="1555049803999"></p>
<h2 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h2><p><strong>问题：</strong></p>
<p><strong>解决方案：</strong></p>
<ul>
<li>分而治之，将整个网站业务分为不同的产品线</li>
<li>将一个网站拆分为许多不同的应用，每个应用独立部署维护。<ul>
<li>应用间通过超链接建立关系。</li>
<li>也可以通过消息队列进行数据分发</li>
<li>最多的是通过访问同一个数据存储系统来构成一个关联的完整系统</li>
</ul>
</li>
</ul>
<p><img src="assets/1555050083322.png" alt="1555050083322"></p>
<h2 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h2><p><strong>问题：</strong></p>
<ul>
<li>随着业务拆分越来越小，存储系统越来越大，应用系统的复杂性指数级增大，部署维护越来越困难</li>
<li>所有应用都要与数据库系统相连接，数万台服务器中，连接的数目是服务器^2，导致数据库资源不足，拒绝服务</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>将每一个应用系统需要执行的相同业务操作提取出来独立部署</li>
<li>由这些可复用的业务连接数据库，提供公共的业务服务。</li>
<li>应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作</li>
</ul>
<p><img src="assets/1555050317233.png" alt="1555050317233"></p>
<h2 id="云计算平台"><a href="#云计算平台" class="headerlink" title="云计算平台"></a>云计算平台</h2><p>当大型网站架构解决了海量数据管理和高并发事务的处理，就可以将这些解决方案应用到网站自身以外的业务上，即建设云计算平台，将计算作为一种基础资源出售。</p>
<h1 id="大型网站架构演化的价值观"><a href="#大型网站架构演化的价值观" class="headerlink" title="大型网站架构演化的价值观"></a>大型网站架构演化的价值观</h1><p>网站的价值在于它能够为用户提供什么样的价值，在于能做什么，而不是怎么做的</p>
<p>因此在小网站上追求架构是舍本逐末的，需要做的就是为用户提供更好的服务创造价值</p>
<p><strong>核心价值观：随网站所需灵活应对</strong></p>
<p>核心价值是随着小型网站业务的逐步发展，慢慢演化为一个大型网站</p>
<p><strong>驱动大型网站技术发展的主要力量：网站的业务发展</strong></p>
<p>创新的业务发展模式对网站架构逐步提出了更高的要求，才使得创新的网站架构得以发展成熟。</p>
<p>业务成就了技术，后努力提高技术回馈业务</p>
<h1 id="网站架构设计的误区"><a href="#网站架构设计的误区" class="headerlink" title="网站架构设计的误区"></a>网站架构设计的误区</h1><p><strong>一味追求大公司的解决方案</strong></p>
<p><strong>为了技术而技术</strong></p>
<p>网站技术是为业务而存在的，除此毫无意义。</p>
<p>在技术选型和架构设计中，脱离网站业务发展的实际，一味追求技术，会使得架构之路越走越难</p>
<p><strong>企图用技术解决所有问题</strong></p>
<p>12306的故障问题</p>
<ul>
<li>真正的问题是在于业务架构<ul>
<li>在几亿中国人一票难求的情况下进行窗口售票模式在网上售票（0点后出售若干天后的车票）</li>
<li>是一种促销秒杀</li>
</ul>
</li>
<li>进行分时段售票、排队机制等，控制并发访问的量</li>
</ul>
<p>技术是解决业务问题，业务手段也可以解决业务问题</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>利用云计算资源，便可以对所需要的一切技术资源：计算、存储、网络都可以按需购买，线性伸缩</li>
<li>因此亲身经历架构演化之路的人会越来越少。架构师更应该对这个过程深刻了解，理解成熟的网站架构技术方案的来龙去脉和历史渊源，才能在技术选型和架构决策时有的放矢，直击要害</li>
</ul>
<h1 id="大型网站架构模式"><a href="#大型网站架构模式" class="headerlink" title="大型网站架构模式"></a>大型网站架构模式</h1><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>分层是最常见的一种架构模式，将系统在横向维度上切分成几个部分，每个部分负责一部分相对比较单一的职责，然后通过上层对下层的依赖和调用组成一个完整的系统。</p>
<table>
<thead>
<tr>
<th>应用层</th>
<th>负责具体业务和视图展示，如网站首页以及搜索输入和结果展示</th>
</tr>
</thead>
<tbody><tr>
<td>服务层</td>
<td>为应用层提供服务支持，如用户管理服务、购物车服务等</td>
</tr>
<tr>
<td>数据层</td>
<td>提供数据存储访问服务，如数据库、缓存、文件等</td>
</tr>
</tbody></table>
<p>各层之间具有一定的独立性，只要维持调用接口不变，各层可以根据具体问题独立发展演化，而不需要其它层做出调整</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/11/Java/base/Java并发：并发机制的底层原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heper">
      <meta itemprop="description" content="To be awesome">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/11/Java/base/Java并发：并发机制的底层原理/" class="post-title-link" itemprop="url">Java并发：并发机制的底层原理</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Publicado el</span>
              

              
                
              

              <time title="Creado por: 2019-04-11 16:04:48" itemprop="dateCreated datePublished" datetime="2019-04-11T16:04:48+08:00">2019-04-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Editado el</span>
                
                <time title="Modificado por: 2019-07-31 13:15:59" itemprop="dateModified" datetime="2019-07-31T13:15:59+08:00">2019-07-31</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">En</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/04/11/Java/base/Java并发：并发机制的底层原理/" class="post-meta-item leancloud_visitors" data-flag-title="Java并发：并发机制的底层原理">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Visitas: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comentarios: </span>
    
  
    <a href="/2019/04/11/Java/base/Java并发：并发机制的底层原理/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/11/Java/base/Java并发：并发机制的底层原理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="并发机制的底层原理"><a href="#并发机制的底层原理" class="headerlink" title="并发机制的底层原理"></a>并发机制的底层原理</h1><p>Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上执行，Java中所使用的并发机制依赖于JVM的实现和CPU的指令。</p>
<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>定义</strong></p>
<p>Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<p><strong>特性</strong></p>
<ul>
<li>轻量级synchronized<ul>
<li>在使用恰当情况下，比synchronized的使用和执行成本更低。它不会引起线程的上下文切换与调度</li>
</ul>
</li>
<li>保证共享变量的<strong>可见性</strong><ul>
<li>可见性：当一个线程修改一个共享变量的值，另外一个线程能读到这个修改的值</li>
</ul>
</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="CPU术语"><a href="#CPU术语" class="headerlink" title="CPU术语"></a>CPU术语</h3><p><img src="assets/1554972512576.png" alt="1554972512576"></p>
<h3 id="volatile如何保证可见性"><a href="#volatile如何保证可见性" class="headerlink" title="volatile如何保证可见性"></a>volatile如何保证可见性</h3><p>在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时，CPU会做什么事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java代码：</span></span><br><span class="line"><span class="keyword">volatile</span> instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="comment">//汇编代码</span></span><br><span class="line"><span class="number">0x01a3de1d</span>: movb $<span class="number">0</span>×<span class="number">0</span>,<span class="number">0</span>×<span class="number">1104800</span>(%esi);</span><br><span class="line"><span class="number">0x01a3de24</span>: lock addl $<span class="number">0</span>×<span class="number">0</span>,(%esp);<span class="comment">//由于volatile而多出</span></span><br></pre></td></tr></table></figure>

<p>Lock前缀的指令在多核处理器下会引发了两件事情</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
<h4 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h4><ul>
<li>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。</li>
<li>如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，</li>
<li>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过<strong>嗅探在总线上传播的数据来检查自己缓存的值是不是过期了</strong>，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</li>
</ul>
<h4 id="volatile的两条实现原则"><a href="#volatile的两条实现原则" class="headerlink" title="volatile的两条实现原则"></a>volatile的两条实现原则</h4><h5 id="处理器缓存回写到内存。"><a href="#处理器缓存回写到内存。" class="headerlink" title="处理器缓存回写到内存。"></a>处理器缓存回写到内存。</h5><ul>
<li><p>Lock前缀指令会引起处理器缓存回写到内存。</p>
<ul>
<li>Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。<ul>
<li>处理器可以独占任何共享内存 ：因为它会锁住总线，导致其他CPU不能访问总线，不能访问总线就意味着不能访问系统内存。</li>
</ul>
</li>
<li>在8.1.4节有详细说明锁定操作对处理器缓存的影响，对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“<strong>缓存锁定</strong>”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。</li>
</ul>
</li>
</ul>
<h5 id="缓存无效。"><a href="#缓存无效。" class="headerlink" title="缓存无效。"></a>缓存无效。</h5><ul>
<li><p>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</p>
<ul>
<li>IA-32处理器和Intel 64处理器使用<strong>MESI（修改、独占、共享、无效）控制协议</strong>去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。</li>
<li>处理器使用<strong>嗅探技术</strong>保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。例如，在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</li>
</ul>
</li>
</ul>
<h4 id="嗅探技术"><a href="#嗅探技术" class="headerlink" title="嗅探技术"></a>嗅探技术</h4><p>这是一个跟踪每个缓存行的状态的缓存子系统。该系统使用一个称为 <em>“总线动态监视”</em> 或者称为<em>“总线嗅探”</em> 的技术来监视在系统总线上发生的所有事务，以检测缓存中的某个地址上何时发生了读取或写入操作。</p>
<p>当这个缓存子系统在系统总线上检测到对缓存中加载的内存区域进行的读取操作时，它会将该缓存行的状态更改为 <strong>“shared”</strong>。如果它检测到对该地址的写入操作时，会将缓存行的状态更改为 <strong>“invalid”</strong>。</p>
<p>该缓存子系统想知道，当该系统在监视系统总线时，系统是否在其缓存中包含数据的惟一副本。如果数据由它自己的 CPU 进行了更新，那么这个缓存子系统会将缓存行的状态从 <strong>“exclusive”</strong> 更改为 <strong>“modified”</strong>。如果该缓存子系统检测到另一个处理器对该地址的读取，它会阻止访问，更新系统内存中的数据，然后允许该处理的访问继续进行。它还允许将该缓存行的状态标记为 <strong>shared</strong>。</p>
<h2 id="volatile使用优化"><a href="#volatile使用优化" class="headerlink" title="volatile使用优化"></a>volatile使用优化</h2><h3 id="追加字节"><a href="#追加字节" class="headerlink" title="追加字节"></a>追加字节</h3><p>著名的Java并发编程大师Doug lea在JDK 7的并发包里新增一个队列集合类Linked-TransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。LinkedTransferQueue的代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 队列中的头部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"><span class="comment">/** 队列中的尾部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedAtomicReference</span> &lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span> <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 使用很多4个字节的引用追加到64个字节</span></span><br><span class="line">	Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;</span><br><span class="line">	PaddedAtomicReference(T r) &#123;</span><br><span class="line">		<span class="keyword">super</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span> &lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p><strong>追加字节能优化性能？</strong></p>
<p>这种方式看起来很神奇，但如果深入理解处理器架构就能理解其中的奥秘。让我们先来看看LinkedTransferQueue这个类，它使用一个内部类类型来定义队列的头节点（head）和尾节点（tail），而这个内部类PaddedAtomicReference相对于父类AtomicReference只做了一件事情，就是将共享变量追加到64字节。我们可以来计算下，一个对象的引用占4个字节，它追加了15个变量（共占60个字节），再加上父类的value变量，一共64个字节。</p>
<p><strong>为什么追加64字节能够提高并发编程的效率呢？</strong></p>
<ul>
<li>因为对于英特尔酷睿i7、酷睿、Atom和NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，<strong>不支持部分填充缓存行</strong>。</li>
<li>这意味着，如果队列的头节点和尾节点都不足64字节的话，<strong>处理器会将它们都读到同一个高速缓存行中</strong>，在多处理器下每个处理器都会缓存同样的头、尾节点，<strong>当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点</strong>，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。</li>
<li>Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，<strong>使头、尾节点在修改时不会互相锁定。</strong></li>
</ul>
<p><strong>那么是不是在使用volatile变量时都应该追加到64字节呢？</strong></p>
<p>不是的。在两种场景下不应该使用这种方式。</p>
<ul>
<li><p>缓存行非64字节宽的处理器。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。</p>
</li>
<li><p>共享变量不会被频繁地写。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</p>
</li>
</ul>
<p><strong>Java7下可能不生效</strong></p>
<p>不过这种追加字节的方式在Java 7下可能不生效，因为Java 7变得更加智慧，它会淘汰或重新排列无用字段，需要使用其他追加字节的方式。除了volatile，Java并发编程中应用较多的是synchronized，下面一起来看一下。</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>某些情况下，volatile的同步机制的性能确实要优于锁(synchronized、JUC)等，但是虚拟机对锁实行了许多消除和优化，使得我们很难量化认为volatile比synchronized快多少。</p>
<p>如果volatile与自己比较，则volatile读操作的性能消耗与普通变量几乎没有什么差别。而写操作会慢一些，因为它需要在本地代码中插入很多内存屏障指令保证不会乱序执行。</p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>在volatile与锁之间选择的唯一依据仅仅是volatile的语义能否满足场景的需求</p>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>重量级锁，在Java SE1.6后进行了各种优化，显得并没有那么重了。</p>
<p>Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。</p>
<h2 id="实现原理与应用"><a href="#实现原理与应用" class="headerlink" title="实现原理与应用"></a>实现原理与应用</h2><p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁</p>
<ul>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。  </li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象。</li>
</ul>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。那么锁到底存在哪里呢？锁里面会存储什么信息呢？</p>
<ul>
<li>锁存放在Java对象头当中</li>
</ul>
<h3 id="synchronized在JVM当中的实现原理"><a href="#synchronized在JVM当中的实现原理" class="headerlink" title="synchronized在JVM当中的实现原理"></a>synchronized在JVM当中的实现原理</h3><p>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。</p>
<ul>
<li>代码块同步是使用monitorenter和monitorexit指令实现的<ul>
<li>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。</li>
<li>任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</li>
</ul>
</li>
<li>而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。</li>
</ul>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit。</p>
<p><strong>Java对象头</strong></p>
<p><img src="assets/1554975016754.png" alt="1554975016754"></p>
<p><strong>Mark Word</strong>32位机默认存储结构</p>
<p><img src="assets/1554975039230.png" alt="1554975039230"></p>
<p>结构随着锁标志位变化而变化</p>
<p><img src="assets/1554975085461.png" alt="1554975085461"></p>
<p>Mark Word <strong>64位机</strong>，大小64bit</p>
<p><img src="assets/1554975120307.png" alt="1554975120307"></p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”</p>
<p>锁的四种状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。随着竞争情况逐渐升级。</p>
<p>锁只可升级不可降级</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>HotSpot [1] 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<ul>
<li>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。<ul>
<li>如果测试成功，表示线程已经获得了锁。</li>
<li>如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：<ul>
<li>如果没有设置，则使用CAS竞争锁；</li>
<li>如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a><strong>偏向锁的撤销</strong></h4><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p>
<ul>
<li>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。</li>
<li>它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。<ul>
<li>如果线程不处于活动状态，则将对象头设置成无锁状态；</li>
<li>如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</li>
</ul>
</li>
</ul>
<p>图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p>
<p><img src="assets/1554976198265.png" alt="1554976198265"></p>
<h4 id="关闭偏向锁"><a href="#关闭偏向锁" class="headerlink" title="关闭偏向锁"></a>关闭偏向锁</h4><p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活。</p>
<ul>
<li>如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。</li>
<li>如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</li>
</ul>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>加锁</strong></p>
<ul>
<li>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。</li>
<li>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。<ul>
<li>如果成功，当前线程获得锁</li>
<li>如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋来获取锁。</strong></li>
</ul>
</li>
</ul>
<p><strong>解锁</strong></p>
<ul>
<li><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，</p>
<ul>
<li><p>如果成功，则表示没有竞争发生。</p>
</li>
<li><p>如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>
</li>
</ul>
</li>
</ul>
<p>图中是两个线程同时争夺锁，导致锁膨胀的流程图。</p>
<p><img src="assets/1554976291901.png" alt="1554976291901"></p>
<p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h2 id="锁优缺点对比"><a href="#锁优缺点对比" class="headerlink" title="锁优缺点对比"></a>锁优缺点对比</h2><p><img src="assets/1554976411243.png" alt="1554976411243"></p>
<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。在多处理器上实现原子操作就变得有点复杂。</p>
<p>让我们一起来聊一聊在Intel处理器和Java里是如何实现原子操作的。</p>
<h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="CPU术语定义"><a href="#CPU术语定义" class="headerlink" title="CPU术语定义"></a>CPU术语定义</h3><p><img src="assets/1554976466843.png" alt="1554976466843"></p>
<h3 id="CPU如何实现原子操作"><a href="#CPU如何实现原子操作" class="headerlink" title="CPU如何实现原子操作"></a>CPU如何实现原子操作</h3><p>32位IA-32处理器使用<strong>基于对缓存加锁</strong>或<strong>总线加锁</strong>的方式来实现多处理器之间的原子操作。</p>
<ul>
<li>首先处理器会自动保证基本的内存操作的原子性。<ul>
<li>处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的</li>
</ul>
</li>
<li>但是复杂的内存操作处理器是不能自动保证其原子性的<ul>
<li>比如跨总线宽度、跨多个缓存行和跨页表的访问。</li>
</ul>
</li>
</ul>
<h4 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h4><p>所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p>
<p>保证了CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p>
<p><strong>缺陷：</strong></p>
<p>但总线锁定<strong>把CPU和内存之间的通信</strong>锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p>
<h4 id="缓存锁"><a href="#缓存锁" class="headerlink" title="缓存锁"></a>缓存锁</h4><p>在同一时刻，我们只需保证对某个内存地址的操作是原子性即可</p>
<p><strong>概述</strong></p>
<p>所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong>，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
<p><strong>有两种情况下处理器不会使用缓存锁定</strong></p>
<ul>
<li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。</li>
<li>有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</li>
</ul>
<p>针对以上两个机制，我们通过Intel处理器提供了很多Lock前缀的指令来实现。例如，位测试和修改指令：BTS、BTR、BTC；交换指令XADD、CMPXCHG，以及其他一些操作数和逻辑指令（如ADD、OR）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。</p>
<h2 id="Java原子操作"><a href="#Java原子操作" class="headerlink" title="Java原子操作"></a>Java原子操作</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁机制有：偏向锁、轻量级锁和互斥锁</p>
<p>除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>基于处理器提供的CMPXCHG指令实现的</p>
<p>Atomic包下的很多类支持原子操作</p>
<p><strong>问题</strong></p>
<ul>
<li>ABA问题<ul>
<li>使用版本号解决</li>
<li>AtomicStampedReference可解决</li>
</ul>
</li>
<li>循环时间长开销大<ul>
<li>自旋的执行开销</li>
<li>如果JVM支持pause指令，会有一定的效率提升<ul>
<li>它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零</li>
<li>它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。</li>
</ul>
</li>
</ul>
</li>
<li>只能保证一个共享变量的原子操作<ul>
<li>AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="Página anterior"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="Página siguiente"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="Heper">
  <p class="site-author-name" itemprop="name">Heper</p>
  <div class="site-description motion-element" itemprop="description">To be awesome</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">219</span>
          <span class="site-state-item-name">entradas</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categorías</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heper</span>
</div>
  <div class="powered-by">Creado mediante <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Tema – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  











  
  <script>
    function showTime(Counter) {
      var entries = [];
      var $visitors = $('.leancloud_visitors');

      $visitors.each(function() {
        entries.push( $(this).attr('id').trim() );
      });

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url: { '$in': entries } }) })
        .done(function({ results }) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if (countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function ({ responseJSON }) {
          console.log(`LeanCloud Counter Error: ${responseJSON.code} ${responseJSON.error}`);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
                'X-LC-Key': 'uTVcNIWdMCGpicrhTKygpKXi',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
            if ($('.post-title-link').length >= 1) {
              showTime(Counter);
            }
          
        });
    });
  </script>
























    
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'rNE6CB58iechI12zCD4oeVtM-gzGzoHsz',
    appKey: 'uTVcNIWdMCGpicrhTKygpKXi',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn'
  });
</script>


</body>
</html>
